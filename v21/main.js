import {
  BidiModule,
  CdkDrag,
  CdkDragHandle,
  CdkDropList,
  CdkFixedSizeVirtualScroll,
  CdkScrollable,
  CdkVirtualForOf,
  CdkVirtualScrollViewport,
  Directionality,
  DragDropModule,
  GanttDomService,
  GanttDragContainer,
  NgxGanttBarComponent,
  Platform,
  ScrollDirection,
  ScrollDispatcher,
  ScrollingModule,
  ViewportRuler,
  _CdkPrivateStyleLoader,
  _IdGenerator,
  _getEventTarget,
  _getFocusedElementPierceShadowDom,
  _getShadowRoot,
  isFakeMousedownFromScreenReader,
  isFakeTouchstartFromScreenReader,
  passiveListenerOptions,
  supportsScrollBehavior
} from "./chunk-XO4YAWWX.js";
import {
  NgxGanttRangeComponent
} from "./chunk-ARV2EPQ5.js";
import {
  ANIMATION_MODULE_TYPE,
  APP_BOOTSTRAP_LISTENER,
  APP_ID,
  APP_INITIALIZER,
  ApplicationModule,
  ApplicationRef,
  AsyncPipe,
  Attribute,
  BehaviorSubject,
  CSP_NONCE,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  CommonModule,
  Compiler,
  Component,
  ComponentFactoryResolver$1,
  Console,
  ContentChild,
  ContentChildren,
  DOCUMENT,
  DatePipe,
  DecimalPipe,
  DestroyRef,
  Directive,
  DomAdapter,
  EMPTY,
  ENVIRONMENT_INITIALIZER,
  ElementRef,
  EmptyError,
  EnvironmentInjector,
  ErrorHandler,
  EventEmitter,
  GANTT_GLOBAL_CONFIG,
  GANTT_UPPER_TOKEN,
  GanttConfigService,
  GanttDate,
  GanttI18nLocale,
  GanttItemType,
  GanttItemUpper,
  GanttLinkLineType,
  GanttLinkType,
  GanttUpper,
  GanttView,
  GanttViewTick,
  GanttViewType,
  HashLocationStrategy,
  Host,
  HostAttributeToken,
  HostBinding,
  HostListener,
  INJECTOR_SCOPE,
  INTERNAL_APPLICATION_ERROR_HANDLER,
  IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
  Inject,
  Injectable,
  InjectionToken,
  Injector,
  Input,
  KeyValueDiffers,
  LOCATION_INITIALIZED,
  Location,
  LocationStrategy,
  NgClass,
  NgComponentOutlet,
  NgModule,
  NgModuleFactory,
  NgModuleFactory$1,
  NgModuleRef$1,
  NgStyle,
  NgTemplateOutlet,
  NgZone,
  Observable,
  Optional,
  Output,
  PERIOD_TICK_TOP,
  PLATFORM_BROWSER_ID,
  PLATFORM_ID,
  PLATFORM_INITIALIZER,
  PathLocationStrategy,
  PendingTasks,
  PendingTasksInternal,
  Pipe,
  PlatformLocation,
  PlatformNavigation,
  Renderer2,
  RendererFactory2,
  RendererStyleFlags2,
  ReplaySubject,
  ResourceImpl,
  RuntimeError,
  SecurityContext,
  Self,
  SkipSelf,
  SlicePipe,
  Subject,
  Subscription,
  TESTABILITY,
  TESTABILITY_GETTER,
  TZDate,
  TemplateRef,
  Testability,
  TracingService,
  UNIT_TICK_TOP,
  ViewChild,
  ViewChildren,
  ViewContainerRef,
  ViewEncapsulation,
  ViewportScroller,
  XSS_SECURITY_URL,
  XhrFactory,
  __decorate,
  __metadata,
  __param,
  _global,
  _isNumberValue,
  _sanitizeHtml,
  _sanitizeUrl,
  addDays,
  addHours,
  addMinutes,
  addMonths,
  addQuarters,
  addSeconds,
  addWeeks,
  addYears,
  afterEveryRender,
  afterNextRender,
  allLeavingAnimations,
  allowSanitizationBypassAndThrow,
  assertInInjectionContext,
  assertNotInReactiveContext,
  auditTime,
  booleanAttribute,
  buildFormatLongFn,
  buildLocalizeFn,
  buildMatchFn,
  buildMatchPatternFn,
  bypassSanitizationTrustHtml,
  bypassSanitizationTrustResourceUrl,
  bypassSanitizationTrustScript,
  bypassSanitizationTrustStyle,
  bypassSanitizationTrustUrl,
  catchError,
  coerceArray,
  coerceBooleanProperty,
  coerceCssPixelValue,
  coerceElement,
  coerceNumberProperty,
  combineLatest,
  computed,
  concat,
  concatMap,
  constructFrom,
  constructNow,
  contentChild,
  contentChildren,
  createComponent,
  createEnvironmentInjector,
  createPlatformFactory,
  de,
  debounceTime,
  defaultConfig,
  defer,
  delay,
  differenceInCalendarDays,
  differenceInCalendarQuarters,
  differenceInCalendarYears,
  differenceInDays,
  differenceInHours,
  differenceInMilliseconds,
  differenceInMinutes,
  distinctUntilChanged,
  eachDayOfInterval,
  effect,
  enUS,
  enableProdMode,
  encapsulateResourceError,
  endOfDay,
  endOfMonth,
  endOfQuarter,
  endOfWeek,
  endOfYear,
  exhaustMap,
  filter,
  finalize,
  first,
  forkJoin,
  format,
  formatDate,
  formatRuntimeError,
  forwardRef,
  from,
  fromEvent,
  fromUnixTime,
  getDOM,
  getDaysInMonth,
  getDefaultOptions,
  getOutputDestroyRef,
  getQuarter,
  getRoundingMethod,
  getUnixTime,
  getWeek,
  i18nLocaleProvides,
  inject,
  input,
  isDevMode,
  isInjectable,
  isNgModule,
  isNumber,
  isObservable,
  isPlatformBrowser,
  isPromise,
  isSameDay,
  isSameWeek,
  isSignal,
  isStandalone,
  isSubscribable,
  isToday,
  isValid,
  isWeekend,
  keyBy,
  linkedSignal,
  makeEnvironmentProviders,
  map,
  mapTo,
  merge,
  mergeAll,
  mergeMap,
  model,
  normalizeDates,
  numberAttribute,
  of,
  output,
  parseCookieValue,
  performanceMarkFeature,
  pipe,
  platformCore,
  provideAppInitializer,
  provideZonelessChangeDetection,
  recursiveItems,
  reflectComponentType,
  registerLocaleData,
  registerView,
  runInInjectionContext,
  setClassMetadata,
  setClassMetadataAsync,
  setDefaultOptions,
  setDocument,
  setRootDomAdapter,
  share,
  shareReplay,
  signal,
  skip,
  startOfDay,
  startOfHour,
  startOfISOWeek,
  startOfMinute,
  startOfMonth,
  startOfQuarter,
  startOfWeek,
  startOfYear,
  startWith,
  switchMap,
  take,
  takeLast,
  takeUntil,
  takeWhile,
  tap,
  throttleTime,
  throwError,
  timer,
  toDate,
  todayBorderRadius,
  todayHeight,
  todayWidth,
  uniqBy,
  untracked,
  unwrapSafeValue,
  viewChild,
  ɵsetClassDebugInfo,
  ɵɵHostDirectivesFeature,
  ɵɵInheritDefinitionFeature,
  ɵɵNgOnChangesFeature,
  ɵɵProvidersFeature,
  ɵɵadvance,
  ɵɵattribute,
  ɵɵclassMap,
  ɵɵclassProp,
  ɵɵcomponentInstance,
  ɵɵconditional,
  ɵɵconditionalBranchCreate,
  ɵɵconditionalCreate,
  ɵɵcontentQuery,
  ɵɵcontentQuerySignal,
  ɵɵdeclareLet,
  ɵɵdefer,
  ɵɵdeferOnViewport,
  ɵɵdefineComponent,
  ɵɵdefineDirective,
  ɵɵdefineInjectable,
  ɵɵdefineInjector,
  ɵɵdefineNgModule,
  ɵɵdefinePipe,
  ɵɵdirectiveInject,
  ɵɵdomElement,
  ɵɵdomElementContainerEnd,
  ɵɵdomElementContainerStart,
  ɵɵdomElementEnd,
  ɵɵdomElementStart,
  ɵɵdomListener,
  ɵɵdomProperty,
  ɵɵdomTemplate,
  ɵɵelement,
  ɵɵelementContainer,
  ɵɵelementContainerEnd,
  ɵɵelementContainerStart,
  ɵɵelementEnd,
  ɵɵelementStart,
  ɵɵgetCurrentView,
  ɵɵgetInheritedFactory,
  ɵɵinject,
  ɵɵinjectAttribute,
  ɵɵinterpolate,
  ɵɵinterpolate1,
  ɵɵinterpolate2,
  ɵɵinterpolate3,
  ɵɵinterpolate5,
  ɵɵinvalidFactory,
  ɵɵlistener,
  ɵɵloadQuery,
  ɵɵnamespaceSVG,
  ɵɵnextContext,
  ɵɵpipe,
  ɵɵpipeBind1,
  ɵɵpipeBind2,
  ɵɵpipeBind3,
  ɵɵprojection,
  ɵɵprojectionDef,
  ɵɵproperty,
  ɵɵpureFunction0,
  ɵɵpureFunction1,
  ɵɵpureFunction2,
  ɵɵpureFunction3,
  ɵɵpureFunction4,
  ɵɵqueryAdvance,
  ɵɵqueryRefresh,
  ɵɵreadContextLet,
  ɵɵreference,
  ɵɵrepeater,
  ɵɵrepeaterCreate,
  ɵɵrepeaterTrackByIdentity,
  ɵɵrepeaterTrackByIndex,
  ɵɵresetView,
  ɵɵresolveWindow,
  ɵɵrestoreView,
  ɵɵsanitizeHtml,
  ɵɵsanitizeStyle,
  ɵɵsanitizeUrl,
  ɵɵsanitizeUrlOrResourceUrl,
  ɵɵstoreLet,
  ɵɵstyleMap,
  ɵɵstyleProp,
  ɵɵsyntheticHostListener,
  ɵɵsyntheticHostProperty,
  ɵɵtemplate,
  ɵɵtemplateRefExtractor,
  ɵɵtext,
  ɵɵtextInterpolate,
  ɵɵtextInterpolate1,
  ɵɵtextInterpolate2,
  ɵɵtwoWayBindingSet,
  ɵɵtwoWayListener,
  ɵɵtwoWayProperty,
  ɵɵviewQuery,
  ɵɵviewQuerySignal
} from "./chunk-AWOQS22U.js";
import {
  __async,
  __export,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-7GOANPIK.js";

// node_modules/@angular/forms/fesm2022/forms.mjs
var BaseControlValueAccessor = class _BaseControlValueAccessor {
  _renderer;
  _elementRef;
  onChange = (_) => {
  };
  onTouched = () => {
  };
  constructor(_renderer, _elementRef) {
    this._renderer = _renderer;
    this._elementRef = _elementRef;
  }
  setProperty(key, value) {
    this._renderer.setProperty(this._elementRef.nativeElement, key, value);
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  setDisabledState(isDisabled) {
    this.setProperty("disabled", isDisabled);
  }
  static \u0275fac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _BaseControlValueAccessor
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{
    type: Directive
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }], null);
})();
var BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275BuiltInControlValueAccessor_BaseFactory;
    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275BuiltInControlValueAccessor_BaseFactory || (\u0275BuiltInControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _BuiltInControlValueAccessor,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{
    type: Directive
  }], null, null);
})();
var NG_VALUE_ACCESSOR = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "NgValueAccessor" : "");
var CHECKBOX_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => CheckboxControlValueAccessor),
  multi: true
};
var CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    this.setProperty("checked", value);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275CheckboxControlValueAccessor_BaseFactory;
    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275CheckboxControlValueAccessor_BaseFactory || (\u0275CheckboxControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CheckboxControlValueAccessor,
    selectors: [["input", "type", "checkbox", "formControlName", ""], ["input", "type", "checkbox", "formControl", ""], ["input", "type", "checkbox", "ngModel", ""]],
    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.checked);
        })("blur", function CheckboxControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]",
      host: {
        "(change)": "onChange($any($event.target).checked)",
        "(blur)": "onTouched()"
      },
      providers: [CHECKBOX_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var DEFAULT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => DefaultValueAccessor),
  multi: true
};
function _isAndroid() {
  const userAgent = getDOM() ? getDOM().getUserAgent() : "";
  return /android (\d+)/.test(userAgent.toLowerCase());
}
var COMPOSITION_BUFFER_MODE = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "CompositionEventMode" : "");
var DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {
  _compositionMode;
  _composing = false;
  constructor(renderer, elementRef, _compositionMode) {
    super(renderer, elementRef);
    this._compositionMode = _compositionMode;
    if (this._compositionMode == null) {
      this._compositionMode = !_isAndroid();
    }
  }
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  _handleInput(value) {
    if (!this._compositionMode || this._compositionMode && !this._composing) {
      this.onChange(value);
    }
  }
  _compositionStart() {
    this._composing = true;
  }
  _compositionEnd(value) {
    this._composing = false;
    this._compositionMode && this.onChange(value);
  }
  static \u0275fac = function DefaultValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _DefaultValueAccessor,
    selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]],
    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function DefaultValueAccessor_input_HostBindingHandler($event) {
          return ctx._handleInput($event.target.value);
        })("blur", function DefaultValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        })("compositionstart", function DefaultValueAccessor_compositionstart_HostBindingHandler() {
          return ctx._compositionStart();
        })("compositionend", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {
          return ctx._compositionEnd($event.target.value);
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]",
      host: {
        "(input)": "_handleInput($any($event.target).value)",
        "(blur)": "onTouched()",
        "(compositionstart)": "_compositionStart()",
        "(compositionend)": "_compositionEnd($any($event.target).value)"
      },
      providers: [DEFAULT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [COMPOSITION_BUFFER_MODE]
    }]
  }], null);
})();
function isEmptyInputValue(value) {
  return value == null || lengthOrSize(value) === 0;
}
function lengthOrSize(value) {
  if (value == null) {
    return null;
  } else if (Array.isArray(value) || typeof value === "string") {
    return value.length;
  } else if (value instanceof Set) {
    return value.size;
  }
  return null;
}
var NG_VALIDATORS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "NgValidators" : "");
var NG_ASYNC_VALIDATORS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "NgAsyncValidators" : "");
var EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
function minValidator(min) {
  return (control) => {
    if (control.value == null || min == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value < min ? {
      "min": {
        "min": min,
        "actual": control.value
      }
    } : null;
  };
}
function maxValidator(max) {
  return (control) => {
    if (control.value == null || max == null) {
      return null;
    }
    const value = parseFloat(control.value);
    return !isNaN(value) && value > max ? {
      "max": {
        "max": max,
        "actual": control.value
      }
    } : null;
  };
}
function requiredValidator(control) {
  return isEmptyInputValue(control.value) ? {
    "required": true
  } : null;
}
function requiredTrueValidator(control) {
  return control.value === true ? null : {
    "required": true
  };
}
function emailValidator(control) {
  if (isEmptyInputValue(control.value)) {
    return null;
  }
  return EMAIL_REGEXP.test(control.value) ? null : {
    "email": true
  };
}
function minLengthValidator(minLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length === null || length === 0) {
      return null;
    }
    return length < minLength ? {
      "minlength": {
        "requiredLength": minLength,
        "actualLength": length
      }
    } : null;
  };
}
function maxLengthValidator(maxLength) {
  return (control) => {
    const length = control.value?.length ?? lengthOrSize(control.value);
    if (length !== null && length > maxLength) {
      return {
        "maxlength": {
          "requiredLength": maxLength,
          "actualLength": length
        }
      };
    }
    return null;
  };
}
function patternValidator(pattern) {
  if (!pattern) return nullValidator;
  let regex;
  let regexStr;
  if (typeof pattern === "string") {
    regexStr = "";
    if (pattern.charAt(0) !== "^") regexStr += "^";
    regexStr += pattern;
    if (pattern.charAt(pattern.length - 1) !== "$") regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern.toString();
    regex = pattern;
  }
  return (control) => {
    if (isEmptyInputValue(control.value)) {
      return null;
    }
    const value = control.value;
    return regex.test(value) ? null : {
      "pattern": {
        "requiredPattern": regexStr,
        "actualValue": value
      }
    };
  };
}
function nullValidator(control) {
  return null;
}
function isPresent(o) {
  return o != null;
}
function toObservable(value) {
  const obs = isPromise(value) ? from(value) : value;
  if ((typeof ngDevMode === "undefined" || ngDevMode) && !isSubscribable(obs)) {
    let errorMessage = `Expected async validator to return Promise or Observable.`;
    if (typeof value === "object") {
      errorMessage += " Are you using a synchronous validator where an async validator is expected?";
    }
    throw new RuntimeError(-1101, errorMessage);
  }
  return obs;
}
function mergeErrors(arrayOfErrors) {
  let res = {};
  arrayOfErrors.forEach((errors) => {
    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;
  });
  return Object.keys(res).length === 0 ? null : res;
}
function executeValidators(control, validators) {
  return validators.map((validator) => validator(control));
}
function isValidatorFn(validator) {
  return !validator.validate;
}
function normalizeValidators(validators) {
  return validators.map((validator) => {
    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);
  });
}
function compose(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    return mergeErrors(executeValidators(control, presentValidators));
  };
}
function composeValidators(validators) {
  return validators != null ? compose(normalizeValidators(validators)) : null;
}
function composeAsync(validators) {
  if (!validators) return null;
  const presentValidators = validators.filter(isPresent);
  if (presentValidators.length == 0) return null;
  return function(control) {
    const observables = executeValidators(control, presentValidators).map(toObservable);
    return forkJoin(observables).pipe(map(mergeErrors));
  };
}
function composeAsyncValidators(validators) {
  return validators != null ? composeAsync(normalizeValidators(validators)) : null;
}
function mergeValidators(controlValidators, dirValidator) {
  if (controlValidators === null) return [dirValidator];
  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];
}
function getControlValidators(control) {
  return control._rawValidators;
}
function getControlAsyncValidators(control) {
  return control._rawAsyncValidators;
}
function makeValidatorsArray(validators) {
  if (!validators) return [];
  return Array.isArray(validators) ? validators : [validators];
}
function hasValidator(validators, validator) {
  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;
}
function addValidators(validators, currentValidators) {
  const current = makeValidatorsArray(currentValidators);
  const validatorsToAdd = makeValidatorsArray(validators);
  validatorsToAdd.forEach((v) => {
    if (!hasValidator(current, v)) {
      current.push(v);
    }
  });
  return current;
}
function removeValidators(validators, currentValidators) {
  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));
}
var AbstractControlDirective = class {
  get value() {
    return this.control ? this.control.value : null;
  }
  get valid() {
    return this.control ? this.control.valid : null;
  }
  get invalid() {
    return this.control ? this.control.invalid : null;
  }
  get pending() {
    return this.control ? this.control.pending : null;
  }
  get disabled() {
    return this.control ? this.control.disabled : null;
  }
  get enabled() {
    return this.control ? this.control.enabled : null;
  }
  get errors() {
    return this.control ? this.control.errors : null;
  }
  get pristine() {
    return this.control ? this.control.pristine : null;
  }
  get dirty() {
    return this.control ? this.control.dirty : null;
  }
  get touched() {
    return this.control ? this.control.touched : null;
  }
  get status() {
    return this.control ? this.control.status : null;
  }
  get untouched() {
    return this.control ? this.control.untouched : null;
  }
  get statusChanges() {
    return this.control ? this.control.statusChanges : null;
  }
  get valueChanges() {
    return this.control ? this.control.valueChanges : null;
  }
  get path() {
    return null;
  }
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators = [];
  _rawAsyncValidators = [];
  _setValidators(validators) {
    this._rawValidators = validators || [];
    this._composedValidatorFn = composeValidators(this._rawValidators);
  }
  _setAsyncValidators(validators) {
    this._rawAsyncValidators = validators || [];
    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);
  }
  get validator() {
    return this._composedValidatorFn || null;
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn || null;
  }
  _onDestroyCallbacks = [];
  _registerOnDestroy(fn) {
    this._onDestroyCallbacks.push(fn);
  }
  _invokeOnDestroyCallbacks() {
    this._onDestroyCallbacks.forEach((fn) => fn());
    this._onDestroyCallbacks = [];
  }
  reset(value = void 0) {
    if (this.control) this.control.reset(value);
  }
  hasError(errorCode, path) {
    return this.control ? this.control.hasError(errorCode, path) : false;
  }
  getError(errorCode, path) {
    return this.control ? this.control.getError(errorCode, path) : null;
  }
};
var ControlContainer = class extends AbstractControlDirective {
  name;
  get formDirective() {
    return null;
  }
  get path() {
    return null;
  }
};
var NgControl = class extends AbstractControlDirective {
  _parent = null;
  name = null;
  valueAccessor = null;
};
var AbstractControlStatus = class {
  _cd;
  constructor(cd) {
    this._cd = cd;
  }
  get isTouched() {
    this._cd?.control?._touched?.();
    return !!this._cd?.control?.touched;
  }
  get isUntouched() {
    return !!this._cd?.control?.untouched;
  }
  get isPristine() {
    this._cd?.control?._pristine?.();
    return !!this._cd?.control?.pristine;
  }
  get isDirty() {
    return !!this._cd?.control?.dirty;
  }
  get isValid() {
    this._cd?.control?._status?.();
    return !!this._cd?.control?.valid;
  }
  get isInvalid() {
    return !!this._cd?.control?.invalid;
  }
  get isPending() {
    return !!this._cd?.control?.pending;
  }
  get isSubmitted() {
    this._cd?._submitted?.();
    return !!this._cd?.submitted;
  }
};
var ngControlStatusHost = {
  "[class.ng-untouched]": "isUntouched",
  "[class.ng-touched]": "isTouched",
  "[class.ng-pristine]": "isPristine",
  "[class.ng-dirty]": "isDirty",
  "[class.ng-valid]": "isValid",
  "[class.ng-invalid]": "isInvalid",
  "[class.ng-pending]": "isPending"
};
var NgControlStatus = class _NgControlStatus extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static \u0275fac = function NgControlStatus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatus)(\u0275\u0275directiveInject(NgControl, 2));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgControlStatus,
    selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]],
    hostVars: 14,
    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending);
      }
    },
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatus, [{
    type: Directive,
    args: [{
      selector: "[formControlName],[ngModel],[formControl]",
      host: ngControlStatusHost,
      standalone: false
    }]
  }], () => [{
    type: NgControl,
    decorators: [{
      type: Self
    }]
  }], null);
})();
var NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {
  constructor(cd) {
    super(cd);
  }
  static \u0275fac = function NgControlStatusGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgControlStatusGroup)(\u0275\u0275directiveInject(ControlContainer, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgControlStatusGroup,
    selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["", "formArray", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]],
    hostVars: 16,
    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("ng-untouched", ctx.isUntouched)("ng-touched", ctx.isTouched)("ng-pristine", ctx.isPristine)("ng-dirty", ctx.isDirty)("ng-valid", ctx.isValid)("ng-invalid", ctx.isInvalid)("ng-pending", ctx.isPending)("ng-submitted", ctx.isSubmitted);
      }
    },
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{
    type: Directive,
    args: [{
      selector: "[formGroupName],[formArrayName],[ngModelGroup],[formGroup],[formArray],form:not([ngNoForm]),[ngForm]",
      host: __spreadProps(__spreadValues({}, ngControlStatusHost), {
        "[class.ng-submitted]": "isSubmitted"
      }),
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }]
  }], null);
})();
var formControlNameExample = `
  <div [formGroup]="myGroup">
    <input formControlName="firstName">
  </div>

  In your class:

  this.myGroup = new FormGroup({
      firstName: new FormControl()
  });`;
var formGroupNameExample = `
  <div [formGroup]="myGroup">
      <div formGroupName="person">
        <input formControlName="firstName">
      </div>
  </div>

  In your class:

  this.myGroup = new FormGroup({
      person: new FormGroup({ firstName: new FormControl() })
  });`;
var formArrayNameExample = `
  <div [formGroup]="myGroup">
    <div formArrayName="cities">
      <div *ngFor="let city of cityArray.controls; index as i">
        <input [formControlName]="i">
      </div>
    </div>
  </div>

  In your class:

  this.cityArray = new FormArray([new FormControl('SF')]);
  this.myGroup = new FormGroup({
    cities: this.cityArray
  });`;
var ngModelGroupExample = `
  <form>
      <div ngModelGroup="person">
        <input [(ngModel)]="person.name" name="firstName">
      </div>
  </form>`;
var ngModelWithFormGroupExample = `
  <div [formGroup]="myGroup">
      <input formControlName="firstName">
      <input [(ngModel)]="showMoreControls" [ngModelOptions]="{standalone: true}">
  </div>
`;
function controlParentException(nameOrIndex) {
  return new RuntimeError(1050, `formControlName must be used with a parent formGroup or formArray directive. You'll want to add a formGroup/formArray
      directive and pass it an existing FormGroup/FormArray instance (you can create one in your class).

      ${describeFormControl(nameOrIndex)}

    Example:

    ${formControlNameExample}`);
}
function describeFormControl(nameOrIndex) {
  if (nameOrIndex == null || nameOrIndex === "") {
    return "";
  }
  const valueType = typeof nameOrIndex === "string" ? "name" : "index";
  return `Affected Form Control ${valueType}: "${nameOrIndex}"`;
}
function ngModelGroupException() {
  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents
      that also have a "form" prefix: formGroupName, formArrayName, or formGroup.

      Option 1:  Update the parent to be formGroupName (reactive form strategy)

      ${formGroupNameExample}

      Option 2: Use ngModel instead of formControlName (template-driven strategy)

      ${ngModelGroupExample}`);
}
function missingFormException() {
  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.

      Example:

      ${formControlNameExample}`);
}
function groupParentException() {
  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup
    directive and pass it an existing FormGroup instance (you can create one in your class).

    Example:

    ${formGroupNameExample}`);
}
function arrayParentException() {
  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup
      directive and pass it an existing FormGroup instance (you can create one in your class).

      Example:

      ${formArrayNameExample}`);
}
var disabledAttrWarning = `
  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true
  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for
  you. We recommend using this approach to avoid 'changed after checked' errors.

  Example:
  // Specify the \`disabled\` property at control creation time:
  form = new FormGroup({
    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),
    last: new FormControl('Drew', Validators.required)
  });

  // Controls can also be enabled/disabled after creation:
  form.get('first')?.enable();
  form.get('last')?.disable();
`;
var asyncValidatorsDroppedWithOptsWarning = `
  It looks like you're constructing using a FormControl with both an options argument and an
  async validators argument. Mixing these arguments will cause your async validators to be dropped.
  You should either put all your validators in the options object, or in separate validators
  arguments. For example:

  // Using validators arguments
  fc = new FormControl(42, Validators.required, myAsyncValidator);

  // Using AbstractControlOptions
  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});

  // Do NOT mix them: async validators will be dropped!
  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);
`;
function ngModelWarning(directiveName) {
  return `
  It looks like you're using ngModel on the same form field as ${directiveName}.
  Support for using the ngModel input property and ngModelChange event with
  reactive form directives has been deprecated in Angular v6 and will be removed
  in a future version of Angular.

  For more information on this, see our API docs here:
  https://angular.io/api/forms/${directiveName === "formControl" ? "FormControlDirective" : "FormControlName"}#use-with-ngmodel
  `;
}
function describeKey(isFormGroup, key) {
  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;
}
function noControlsError(isFormGroup) {
  return `
    There are no form controls registered with this ${isFormGroup ? "group" : "array"} yet. If you're using ngModel,
    you may want to check next tick (e.g. use setTimeout).
  `;
}
function missingControlError(isFormGroup, key) {
  return `Cannot find form control ${describeKey(isFormGroup, key)}`;
}
function missingControlValueError(isFormGroup, key) {
  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;
}
var VALID = "VALID";
var INVALID = "INVALID";
var PENDING = "PENDING";
var DISABLED = "DISABLED";
var ControlEvent = class {
};
var ValueChangeEvent = class extends ControlEvent {
  value;
  source;
  constructor(value, source) {
    super();
    this.value = value;
    this.source = source;
  }
};
var PristineChangeEvent = class extends ControlEvent {
  pristine;
  source;
  constructor(pristine, source) {
    super();
    this.pristine = pristine;
    this.source = source;
  }
};
var TouchedChangeEvent = class extends ControlEvent {
  touched;
  source;
  constructor(touched, source) {
    super();
    this.touched = touched;
    this.source = source;
  }
};
var StatusChangeEvent = class extends ControlEvent {
  status;
  source;
  constructor(status, source) {
    super();
    this.status = status;
    this.source = source;
  }
};
var FormSubmittedEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
var FormResetEvent = class extends ControlEvent {
  source;
  constructor(source) {
    super();
    this.source = source;
  }
};
function pickValidators(validatorOrOpts) {
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;
}
function coerceToValidator(validator) {
  return Array.isArray(validator) ? composeValidators(validator) : validator || null;
}
function pickAsyncValidators(asyncValidator, validatorOrOpts) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (isOptionsObj(validatorOrOpts) && asyncValidator) {
      console.warn(asyncValidatorsDroppedWithOptsWarning);
    }
  }
  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;
}
function coerceToAsyncValidator(asyncValidator) {
  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;
}
function isOptionsObj(validatorOrOpts) {
  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === "object";
}
function assertControlPresent(parent, isGroup, key) {
  const controls = parent.controls;
  const collection = isGroup ? Object.keys(controls) : controls;
  if (!collection.length) {
    throw new RuntimeError(1e3, typeof ngDevMode === "undefined" || ngDevMode ? noControlsError(isGroup) : "");
  }
  if (!controls[key]) {
    throw new RuntimeError(1001, typeof ngDevMode === "undefined" || ngDevMode ? missingControlError(isGroup, key) : "");
  }
}
function assertAllValuesPresent(control, isGroup, value) {
  control._forEachChild((_, key) => {
    if (value[key] === void 0) {
      throw new RuntimeError(1002, typeof ngDevMode === "undefined" || ngDevMode ? missingControlValueError(isGroup, key) : "");
    }
  });
}
var AbstractControl = class {
  _pendingDirty = false;
  _hasOwnPendingAsyncValidator = null;
  _pendingTouched = false;
  _onCollectionChange = () => {
  };
  _updateOn;
  _parent = null;
  _asyncValidationSubscription;
  _composedValidatorFn;
  _composedAsyncValidatorFn;
  _rawValidators;
  _rawAsyncValidators;
  value;
  constructor(validators, asyncValidators) {
    this._assignValidators(validators);
    this._assignAsyncValidators(asyncValidators);
  }
  get validator() {
    return this._composedValidatorFn;
  }
  set validator(validatorFn) {
    this._rawValidators = this._composedValidatorFn = validatorFn;
  }
  get asyncValidator() {
    return this._composedAsyncValidatorFn;
  }
  set asyncValidator(asyncValidatorFn) {
    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;
  }
  get parent() {
    return this._parent;
  }
  get status() {
    return untracked(this.statusReactive);
  }
  set status(v) {
    untracked(() => this.statusReactive.set(v));
  }
  _status = computed(() => this.statusReactive(), ...ngDevMode ? [{
    debugName: "_status"
  }] : []);
  statusReactive = signal(void 0, ...ngDevMode ? [{
    debugName: "statusReactive"
  }] : []);
  get valid() {
    return this.status === VALID;
  }
  get invalid() {
    return this.status === INVALID;
  }
  get pending() {
    return this.status == PENDING;
  }
  get disabled() {
    return this.status === DISABLED;
  }
  get enabled() {
    return this.status !== DISABLED;
  }
  errors;
  get pristine() {
    return untracked(this.pristineReactive);
  }
  set pristine(v) {
    untracked(() => this.pristineReactive.set(v));
  }
  _pristine = computed(() => this.pristineReactive(), ...ngDevMode ? [{
    debugName: "_pristine"
  }] : []);
  pristineReactive = signal(true, ...ngDevMode ? [{
    debugName: "pristineReactive"
  }] : []);
  get dirty() {
    return !this.pristine;
  }
  get touched() {
    return untracked(this.touchedReactive);
  }
  set touched(v) {
    untracked(() => this.touchedReactive.set(v));
  }
  _touched = computed(() => this.touchedReactive(), ...ngDevMode ? [{
    debugName: "_touched"
  }] : []);
  touchedReactive = signal(false, ...ngDevMode ? [{
    debugName: "touchedReactive"
  }] : []);
  get untouched() {
    return !this.touched;
  }
  _events = new Subject();
  events = this._events.asObservable();
  valueChanges;
  statusChanges;
  get updateOn() {
    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change";
  }
  setValidators(validators) {
    this._assignValidators(validators);
  }
  setAsyncValidators(validators) {
    this._assignAsyncValidators(validators);
  }
  addValidators(validators) {
    this.setValidators(addValidators(validators, this._rawValidators));
  }
  addAsyncValidators(validators) {
    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));
  }
  removeValidators(validators) {
    this.setValidators(removeValidators(validators, this._rawValidators));
  }
  removeAsyncValidators(validators) {
    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));
  }
  hasValidator(validator) {
    return hasValidator(this._rawValidators, validator);
  }
  hasAsyncValidator(validator) {
    return hasValidator(this._rawAsyncValidators, validator);
  }
  clearValidators() {
    this.validator = null;
  }
  clearAsyncValidators() {
    this.asyncValidator = null;
  }
  markAsTouched(opts = {}) {
    const changed = this.touched === false;
    this.touched = true;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(true, sourceControl));
    }
  }
  markAllAsDirty(opts = {}) {
    this.markAsDirty({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsDirty(opts));
  }
  markAllAsTouched(opts = {}) {
    this.markAsTouched({
      onlySelf: true,
      emitEvent: opts.emitEvent,
      sourceControl: this
    });
    this._forEachChild((control) => control.markAllAsTouched(opts));
  }
  markAsUntouched(opts = {}) {
    const changed = this.touched === true;
    this.touched = false;
    this._pendingTouched = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsUntouched({
        onlySelf: true,
        emitEvent: opts.emitEvent,
        sourceControl
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new TouchedChangeEvent(false, sourceControl));
    }
  }
  markAsDirty(opts = {}) {
    const changed = this.pristine === true;
    this.pristine = false;
    const sourceControl = opts.sourceControl ?? this;
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(false, sourceControl));
    }
  }
  markAsPristine(opts = {}) {
    const changed = this.pristine === false;
    this.pristine = true;
    this._pendingDirty = false;
    const sourceControl = opts.sourceControl ?? this;
    this._forEachChild((control) => {
      control.markAsPristine({
        onlySelf: true,
        emitEvent: opts.emitEvent
      });
    });
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, sourceControl);
    }
    if (changed && opts.emitEvent !== false) {
      this._events.next(new PristineChangeEvent(true, sourceControl));
    }
  }
  markAsPending(opts = {}) {
    this.status = PENDING;
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  disable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = DISABLED;
    this.errors = null;
    this._forEachChild((control) => {
      control.disable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this._updateValue();
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(true));
  }
  enable(opts = {}) {
    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);
    this.status = VALID;
    this._forEachChild((control) => {
      control.enable(__spreadProps(__spreadValues({}, opts), {
        onlySelf: true
      }));
    });
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {
      skipPristineCheck
    }), this);
    this._onDisabledChange.forEach((changeFn) => changeFn(false));
  }
  _updateAncestors(opts, sourceControl) {
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(opts);
      if (!opts.skipPristineCheck) {
        this._parent._updatePristine({}, sourceControl);
      }
      this._parent._updateTouched({}, sourceControl);
    }
  }
  setParent(parent) {
    this._parent = parent;
  }
  getRawValue() {
    return this.value;
  }
  updateValueAndValidity(opts = {}) {
    this._setInitialStatus();
    this._updateValue();
    if (this.enabled) {
      const shouldHaveEmitted = this._cancelExistingSubscription();
      this.errors = this._runValidator();
      this.status = this._calculateStatus();
      if (this.status === VALID || this.status === PENDING) {
        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);
      }
    }
    const sourceControl = opts.sourceControl ?? this;
    if (opts.emitEvent !== false) {
      this._events.next(new ValueChangeEvent(this.value, sourceControl));
      this._events.next(new StatusChangeEvent(this.status, sourceControl));
      this.valueChanges.emit(this.value);
      this.statusChanges.emit(this.status);
    }
    if (this._parent && !opts.onlySelf) {
      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {
        sourceControl
      }));
    }
  }
  _updateTreeValidity(opts = {
    emitEvent: true
  }) {
    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: opts.emitEvent
    });
  }
  _setInitialStatus() {
    this.status = this._allControlsDisabled() ? DISABLED : VALID;
  }
  _runValidator() {
    return this.validator ? this.validator(this) : null;
  }
  _runAsyncValidator(shouldHaveEmitted, emitEvent) {
    if (this.asyncValidator) {
      this.status = PENDING;
      this._hasOwnPendingAsyncValidator = {
        emitEvent: emitEvent !== false,
        shouldHaveEmitted: shouldHaveEmitted !== false
      };
      const obs = toObservable(this.asyncValidator(this));
      this._asyncValidationSubscription = obs.subscribe((errors) => {
        this._hasOwnPendingAsyncValidator = null;
        this.setErrors(errors, {
          emitEvent,
          shouldHaveEmitted
        });
      });
    }
  }
  _cancelExistingSubscription() {
    if (this._asyncValidationSubscription) {
      this._asyncValidationSubscription.unsubscribe();
      const shouldHaveEmitted = (this._hasOwnPendingAsyncValidator?.emitEvent || this._hasOwnPendingAsyncValidator?.shouldHaveEmitted) ?? false;
      this._hasOwnPendingAsyncValidator = null;
      return shouldHaveEmitted;
    }
    return false;
  }
  setErrors(errors, opts = {}) {
    this.errors = errors;
    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);
  }
  get(path) {
    let currPath = path;
    if (currPath == null) return null;
    if (!Array.isArray(currPath)) currPath = currPath.split(".");
    if (currPath.length === 0) return null;
    return currPath.reduce((control, name) => control && control._find(name), this);
  }
  getError(errorCode, path) {
    const control = path ? this.get(path) : this;
    return control && control.errors ? control.errors[errorCode] : null;
  }
  hasError(errorCode, path) {
    return !!this.getError(errorCode, path);
  }
  get root() {
    let x = this;
    while (x._parent) {
      x = x._parent;
    }
    return x;
  }
  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {
    this.status = this._calculateStatus();
    if (emitEvent) {
      this.statusChanges.emit(this.status);
    }
    if (emitEvent || shouldHaveEmitted) {
      this._events.next(new StatusChangeEvent(this.status, changedControl));
    }
    if (this._parent) {
      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);
    }
  }
  _initObservables() {
    this.valueChanges = new EventEmitter();
    this.statusChanges = new EventEmitter();
  }
  _calculateStatus() {
    if (this._allControlsDisabled()) return DISABLED;
    if (this.errors) return INVALID;
    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;
    if (this._anyControlsHaveStatus(INVALID)) return INVALID;
    return VALID;
  }
  _anyControlsHaveStatus(status) {
    return this._anyControls((control) => control.status === status);
  }
  _anyControlsDirty() {
    return this._anyControls((control) => control.dirty);
  }
  _anyControlsTouched() {
    return this._anyControls((control) => control.touched);
  }
  _updatePristine(opts, changedControl) {
    const newPristine = !this._anyControlsDirty();
    const changed = this.pristine !== newPristine;
    this.pristine = newPristine;
    if (this._parent && !opts.onlySelf) {
      this._parent._updatePristine(opts, changedControl);
    }
    if (changed) {
      this._events.next(new PristineChangeEvent(this.pristine, changedControl));
    }
  }
  _updateTouched(opts = {}, changedControl) {
    this.touched = this._anyControlsTouched();
    this._events.next(new TouchedChangeEvent(this.touched, changedControl));
    if (this._parent && !opts.onlySelf) {
      this._parent._updateTouched(opts, changedControl);
    }
  }
  _onDisabledChange = [];
  _registerOnCollectionChange(fn) {
    this._onCollectionChange = fn;
  }
  _setUpdateStrategy(opts) {
    if (isOptionsObj(opts) && opts.updateOn != null) {
      this._updateOn = opts.updateOn;
    }
  }
  _parentMarkedDirty(onlySelf) {
    const parentDirty = this._parent && this._parent.dirty;
    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();
  }
  _find(name) {
    return null;
  }
  _assignValidators(validators) {
    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedValidatorFn = coerceToValidator(this._rawValidators);
  }
  _assignAsyncValidators(validators) {
    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;
    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);
  }
};
var FormGroup = class extends AbstractControl {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    (typeof ngDevMode === "undefined" || ngDevMode) && validateFormGroupControls(controls);
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  registerControl(name, control) {
    if (this.controls[name]) return this.controls[name];
    this.controls[name] = control;
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
    return control;
  }
  addControl(name, control, options = {}) {
    this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  removeControl(name, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  setControl(name, control, options = {}) {
    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {
    });
    delete this.controls[name];
    if (control) this.registerControl(name, control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  contains(controlName) {
    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;
  }
  setValue(value, options = {}) {
    assertAllValuesPresent(this, true, value);
    Object.keys(value).forEach((name) => {
      assertControlPresent(this, true, name);
      this.controls[name].setValue(value[name], {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    if (value == null) return;
    Object.keys(value).forEach((name) => {
      const control = this.controls[name];
      if (control) {
        control.patchValue(value[name], {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  reset(value = {}, options = {}) {
    this._forEachChild((control, name) => {
      control.reset(value ? value[name] : null, __spreadProps(__spreadValues({}, options), {
        onlySelf: true
      }));
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  getRawValue() {
    return this._reduceChildren({}, (acc, control, name) => {
      acc[name] = control.getRawValue();
      return acc;
    });
  }
  _syncPendingControls() {
    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {
      return child._syncPendingControls() ? true : updated;
    });
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  _forEachChild(cb) {
    Object.keys(this.controls).forEach((key) => {
      const control = this.controls[key];
      control && cb(control, key);
    });
  }
  _setUpControls() {
    this._forEachChild((control) => {
      control.setParent(this);
      control._registerOnCollectionChange(this._onCollectionChange);
    });
  }
  _updateValue() {
    this.value = this._reduceValue();
  }
  _anyControls(condition) {
    for (const [controlName, control] of Object.entries(this.controls)) {
      if (this.contains(controlName) && condition(control)) {
        return true;
      }
    }
    return false;
  }
  _reduceValue() {
    let acc = {};
    return this._reduceChildren(acc, (acc2, control, name) => {
      if (control.enabled || this.disabled) {
        acc2[name] = control.value;
      }
      return acc2;
    });
  }
  _reduceChildren(initValue, fn) {
    let res = initValue;
    this._forEachChild((control, name) => {
      res = fn(res, control, name);
    });
    return res;
  }
  _allControlsDisabled() {
    for (const controlName of Object.keys(this.controls)) {
      if (this.controls[controlName].enabled) {
        return false;
      }
    }
    return Object.keys(this.controls).length > 0 || this.disabled;
  }
  _find(name) {
    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;
  }
};
function validateFormGroupControls(controls) {
  const invalidKeys = Object.keys(controls).filter((key) => key.includes("."));
  if (invalidKeys.length > 0) {
    console.warn(`FormGroup keys cannot include \`.\`, please replace the keys for: ${invalidKeys.join(",")}.`);
  }
}
var FormRecord = class extends FormGroup {
};
var CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "CallSetDisabledState" : "", {
  factory: () => setDisabledStateDefault
});
var setDisabledStateDefault = "always";
function controlPath(name, parent) {
  return [...parent.path, name];
}
function setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!control) _throwError(dir, "Cannot find control with");
    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);
  }
  setUpValidators(control, dir);
  dir.valueAccessor.writeValue(control.value);
  if (control.disabled || callSetDisabledState === "always") {
    dir.valueAccessor.setDisabledState?.(control.disabled);
  }
  setUpViewChangePipeline(control, dir);
  setUpModelChangePipeline(control, dir);
  setUpBlurPipeline(control, dir);
  setUpDisabledChangeHandler(control, dir);
}
function cleanUpControl(control, dir, validateControlPresenceOnChange = true) {
  const noop4 = () => {
    if (validateControlPresenceOnChange && (typeof ngDevMode === "undefined" || ngDevMode)) {
      _noControlError(dir);
    }
  };
  if (dir.valueAccessor) {
    dir.valueAccessor.registerOnChange(noop4);
    dir.valueAccessor.registerOnTouched(noop4);
  }
  cleanUpValidators(control, dir);
  if (control) {
    dir._invokeOnDestroyCallbacks();
    control._registerOnCollectionChange(() => {
    });
  }
}
function registerOnValidatorChange(validators, onChange) {
  validators.forEach((validator) => {
    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);
  });
}
function setUpDisabledChangeHandler(control, dir) {
  if (dir.valueAccessor.setDisabledState) {
    const onDisabledChange = (isDisabled) => {
      dir.valueAccessor.setDisabledState(isDisabled);
    };
    control.registerOnDisabledChange(onDisabledChange);
    dir._registerOnDestroy(() => {
      control._unregisterOnDisabledChange(onDisabledChange);
    });
  }
}
function setUpValidators(control, dir) {
  const validators = getControlValidators(control);
  if (dir.validator !== null) {
    control.setValidators(mergeValidators(validators, dir.validator));
  } else if (typeof validators === "function") {
    control.setValidators([validators]);
  }
  const asyncValidators = getControlAsyncValidators(control);
  if (dir.asyncValidator !== null) {
    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));
  } else if (typeof asyncValidators === "function") {
    control.setAsyncValidators([asyncValidators]);
  }
  const onValidatorChange = () => control.updateValueAndValidity();
  registerOnValidatorChange(dir._rawValidators, onValidatorChange);
  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);
}
function cleanUpValidators(control, dir) {
  let isControlUpdated = false;
  if (control !== null) {
    if (dir.validator !== null) {
      const validators = getControlValidators(control);
      if (Array.isArray(validators) && validators.length > 0) {
        const updatedValidators = validators.filter((validator) => validator !== dir.validator);
        if (updatedValidators.length !== validators.length) {
          isControlUpdated = true;
          control.setValidators(updatedValidators);
        }
      }
    }
    if (dir.asyncValidator !== null) {
      const asyncValidators = getControlAsyncValidators(control);
      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {
        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);
        if (updatedAsyncValidators.length !== asyncValidators.length) {
          isControlUpdated = true;
          control.setAsyncValidators(updatedAsyncValidators);
        }
      }
    }
  }
  const noop4 = () => {
  };
  registerOnValidatorChange(dir._rawValidators, noop4);
  registerOnValidatorChange(dir._rawAsyncValidators, noop4);
  return isControlUpdated;
}
function setUpViewChangePipeline(control, dir) {
  dir.valueAccessor.registerOnChange((newValue) => {
    control._pendingValue = newValue;
    control._pendingChange = true;
    control._pendingDirty = true;
    if (control.updateOn === "change") updateControl(control, dir);
  });
}
function setUpBlurPipeline(control, dir) {
  dir.valueAccessor.registerOnTouched(() => {
    control._pendingTouched = true;
    if (control.updateOn === "blur" && control._pendingChange) updateControl(control, dir);
    if (control.updateOn !== "submit") control.markAsTouched();
  });
}
function updateControl(control, dir) {
  if (control._pendingDirty) control.markAsDirty();
  control.setValue(control._pendingValue, {
    emitModelToViewChange: false
  });
  dir.viewToModelUpdate(control._pendingValue);
  control._pendingChange = false;
}
function setUpModelChangePipeline(control, dir) {
  const onChange = (newValue, emitModelEvent) => {
    dir.valueAccessor.writeValue(newValue);
    if (emitModelEvent) dir.viewToModelUpdate(newValue);
  };
  control.registerOnChange(onChange);
  dir._registerOnDestroy(() => {
    control._unregisterOnChange(onChange);
  });
}
function setUpFormContainer(control, dir) {
  if (control == null && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "Cannot find control with");
  setUpValidators(control, dir);
}
function cleanUpFormContainer(control, dir) {
  return cleanUpValidators(control, dir);
}
function _noControlError(dir) {
  return _throwError(dir, "There is no FormControl instance attached to form control element with");
}
function _throwError(dir, message) {
  const messageEnd = _describeControlLocation(dir);
  throw new Error(`${message} ${messageEnd}`);
}
function _describeControlLocation(dir) {
  const path = dir.path;
  if (path && path.length > 1) return `path: '${path.join(" -> ")}'`;
  if (path?.[0]) return `name: '${path}'`;
  return "unspecified name attribute";
}
function _throwMissingValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);
}
function _throwInvalidValueAccessorError(dir) {
  const loc = _describeControlLocation(dir);
  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \`NG_VALUE_ACCESSOR\` token is configured as a \`multi: true\` provider.`);
}
function isPropertyUpdated(changes, viewModel) {
  if (!changes.hasOwnProperty("model")) return false;
  const change = changes["model"];
  if (change.isFirstChange()) return true;
  return !Object.is(viewModel, change.currentValue);
}
function isBuiltInAccessor(valueAccessor) {
  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;
}
function syncPendingControls(form, directives) {
  form._syncPendingControls();
  directives.forEach((dir) => {
    const control = dir.control;
    if (control.updateOn === "submit" && control._pendingChange) {
      dir.viewToModelUpdate(control._pendingValue);
      control._pendingChange = false;
    }
  });
}
function selectValueAccessor(dir, valueAccessors) {
  if (!valueAccessors) return null;
  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === "undefined" || ngDevMode)) _throwInvalidValueAccessorError(dir);
  let defaultAccessor = void 0;
  let builtinAccessor = void 0;
  let customAccessor = void 0;
  valueAccessors.forEach((v) => {
    if (v.constructor === DefaultValueAccessor) {
      defaultAccessor = v;
    } else if (isBuiltInAccessor(v)) {
      if (builtinAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one built-in value accessor matches form control with");
      builtinAccessor = v;
    } else {
      if (customAccessor && (typeof ngDevMode === "undefined" || ngDevMode)) _throwError(dir, "More than one custom value accessor matches form control with");
      customAccessor = v;
    }
  });
  if (customAccessor) return customAccessor;
  if (builtinAccessor) return builtinAccessor;
  if (defaultAccessor) return defaultAccessor;
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    _throwError(dir, "No valid value accessor for form control with");
  }
  return null;
}
function removeListItem$1(list2, el) {
  const index2 = list2.indexOf(el);
  if (index2 > -1) list2.splice(index2, 1);
}
function _ngModelWarning(name, type, instance, warningConfig) {
  if (warningConfig === "never") return;
  if ((warningConfig === null || warningConfig === "once") && !type._ngModelWarningSentOnce || warningConfig === "always" && !instance._ngModelWarningSent) {
    console.warn(ngModelWarning(name));
    type._ngModelWarningSentOnce = true;
    instance._ngModelWarningSent = true;
  }
}
var formDirectiveProvider$2 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgForm)
};
var resolvedPromise$1 = (() => Promise.resolve())();
var NgForm = class _NgForm extends ControlContainer {
  callSetDisabledState;
  get submitted() {
    return untracked(this.submittedReactive);
  }
  _submitted = computed(() => this.submittedReactive(), ...ngDevMode ? [{
    debugName: "_submitted"
  }] : []);
  submittedReactive = signal(false, ...ngDevMode ? [{
    debugName: "submittedReactive"
  }] : []);
  _directives = /* @__PURE__ */ new Set();
  form;
  ngSubmit = new EventEmitter();
  options;
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));
  }
  ngAfterViewInit() {
    this._setUpdateStrategy();
  }
  get formDirective() {
    return this;
  }
  get control() {
    return this.form;
  }
  get path() {
    return [];
  }
  get controls() {
    return this.form.controls;
  }
  addControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      dir.control = container.registerControl(dir.name, dir.control);
      setUpControl(dir.control, dir, this.callSetDisabledState);
      dir.control.updateValueAndValidity({
        emitEvent: false
      });
      this._directives.add(dir);
    });
  }
  getControl(dir) {
    return this.form.get(dir.path);
  }
  removeControl(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
      this._directives.delete(dir);
    });
  }
  addFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      const group2 = new FormGroup({});
      setUpFormContainer(group2, dir);
      container.registerControl(dir.name, group2);
      group2.updateValueAndValidity({
        emitEvent: false
      });
    });
  }
  removeFormGroup(dir) {
    resolvedPromise$1.then(() => {
      const container = this._findContainer(dir.path);
      if (container) {
        container.removeControl(dir.name);
      }
    });
  }
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  updateModel(dir, value) {
    resolvedPromise$1.then(() => {
      const ctrl = this.form.get(dir.path);
      ctrl.setValue(value);
    });
  }
  setValue(value) {
    this.control.setValue(value);
  }
  onSubmit($event) {
    this.submittedReactive.set(true);
    syncPendingControls(this.form, this._directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  onReset() {
    this.resetForm();
  }
  resetForm(value = void 0) {
    this.form.reset(value);
    this.submittedReactive.set(false);
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.form._updateOn = this.options.updateOn;
    }
  }
  _findContainer(path) {
    path.pop();
    return path.length ? this.form.get(path) : this.form;
  }
  static \u0275fac = function NgForm_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgForm)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgForm,
    selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", "", 3, "formArray", ""], ["ng-form"], ["", "ngForm", ""]],
    hostBindings: function NgForm_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("submit", function NgForm_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function NgForm_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      options: [0, "ngFormOptions", "options"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$2]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgForm, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([formGroup]):not([formArray]),ng-form,[ngForm]",
      providers: [formDirectiveProvider$2],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      outputs: ["ngSubmit"],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    options: [{
      type: Input,
      args: ["ngFormOptions"]
    }]
  });
})();
function removeListItem(list2, el) {
  const index2 = list2.indexOf(el);
  if (index2 > -1) list2.splice(index2, 1);
}
function isFormControlState(formState) {
  return typeof formState === "object" && formState !== null && Object.keys(formState).length === 2 && "value" in formState && "disabled" in formState;
}
var FormControl = class FormControl2 extends AbstractControl {
  defaultValue = null;
  _onChange = [];
  _pendingValue;
  _pendingChange = false;
  constructor(formState = null, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this._applyFormState(formState);
    this._setUpdateStrategy(validatorOrOpts);
    this._initObservables();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {
      if (isFormControlState(formState)) {
        this.defaultValue = formState.value;
      } else {
        this.defaultValue = formState;
      }
    }
  }
  setValue(value, options = {}) {
    this.value = this._pendingValue = value;
    if (this._onChange.length && options.emitModelToViewChange !== false) {
      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));
    }
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    this.setValue(value, options);
  }
  reset(formState = this.defaultValue, options = {}) {
    this._applyFormState(formState);
    this.markAsPristine(options);
    this.markAsUntouched(options);
    this.setValue(this.value, options);
    if (options.overwriteDefaultValue) {
      this.defaultValue = this.value;
    }
    this._pendingChange = false;
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  _updateValue() {
  }
  _anyControls(condition) {
    return false;
  }
  _allControlsDisabled() {
    return this.disabled;
  }
  registerOnChange(fn) {
    this._onChange.push(fn);
  }
  _unregisterOnChange(fn) {
    removeListItem(this._onChange, fn);
  }
  registerOnDisabledChange(fn) {
    this._onDisabledChange.push(fn);
  }
  _unregisterOnDisabledChange(fn) {
    removeListItem(this._onDisabledChange, fn);
  }
  _forEachChild(cb) {
  }
  _syncPendingControls() {
    if (this.updateOn === "submit") {
      if (this._pendingDirty) this.markAsDirty();
      if (this._pendingTouched) this.markAsTouched();
      if (this._pendingChange) {
        this.setValue(this._pendingValue, {
          onlySelf: true,
          emitModelToViewChange: false
        });
        return true;
      }
    }
    return false;
  }
  _applyFormState(formState) {
    if (isFormControlState(formState)) {
      this.value = this._pendingValue = formState.value;
      formState.disabled ? this.disable({
        onlySelf: true,
        emitEvent: false
      }) : this.enable({
        onlySelf: true,
        emitEvent: false
      });
    } else {
      this.value = this._pendingValue = formState;
    }
  }
};
var isFormControl = (control) => control instanceof FormControl;
var AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {
  _parent;
  ngOnInit() {
    this._checkParentType();
    this.formDirective.addFormGroup(this);
  }
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeFormGroup(this);
    }
  }
  get control() {
    return this.formDirective.getFormGroup(this);
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _checkParentType() {
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275AbstractFormGroupDirective_BaseFactory;
    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {
      return (\u0275AbstractFormGroupDirective_BaseFactory || (\u0275AbstractFormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _AbstractFormGroupDirective,
    standalone: false,
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{
    type: Directive,
    args: [{
      standalone: false
    }]
  }], null, null);
})();
function modelParentException() {
  return new RuntimeError(1350, `
    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using
    formGroup's partner directive "formControlName" instead.  Example:

    ${formControlNameExample}

    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:

    Example:

    ${ngModelWithFormGroupExample}`);
}
function formGroupNameException() {
  return new RuntimeError(1351, `
    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.

    Option 1: Use formControlName instead of ngModel (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):

    ${ngModelGroupExample}`);
}
function missingNameException() {
  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form
    control must be defined as 'standalone' in ngModelOptions.

    Example 1: <input [(ngModel)]="person.firstName" name="first">
    Example 2: <input [(ngModel)]="person.firstName" [ngModelOptions]="{standalone: true}">`);
}
function modelGroupParentException() {
  return new RuntimeError(1353, `
    ngModelGroup cannot be used with a parent formGroup directive.

    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):

    ${formGroupNameExample}

    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):

    ${ngModelGroupExample}`);
}
var modelGroupProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => NgModelGroup)
};
var NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {
  name = "";
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  _checkParentType() {
    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw modelGroupParentException();
    }
  }
  static \u0275fac = function NgModelGroup_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModelGroup)(\u0275\u0275directiveInject(ControlContainer, 5), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgModelGroup,
    selectors: [["", "ngModelGroup", ""]],
    inputs: {
      name: [0, "ngModelGroup", "name"]
    },
    exportAs: ["ngModelGroup"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([modelGroupProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModelGroup, [{
    type: Directive,
    args: [{
      selector: "[ngModelGroup]",
      providers: [modelGroupProvider],
      exportAs: "ngModelGroup",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["ngModelGroup"]
    }]
  });
})();
var formControlBinding$1 = {
  provide: NgControl,
  useExisting: forwardRef(() => NgModel)
};
var resolvedPromise = (() => Promise.resolve())();
var NgModel = class _NgModel extends NgControl {
  _changeDetectorRef;
  callSetDisabledState;
  control = new FormControl();
  static ngAcceptInputType_isDisabled;
  _registered = false;
  viewModel;
  name = "";
  isDisabled;
  model;
  options;
  update = new EventEmitter();
  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {
    super();
    this._changeDetectorRef = _changeDetectorRef;
    this.callSetDisabledState = callSetDisabledState;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    this._checkForErrors();
    if (!this._registered || "name" in changes) {
      if (this._registered) {
        this._checkName();
        if (this.formDirective) {
          const oldName = changes["name"].previousValue;
          this.formDirective.removeControl({
            name: oldName,
            path: this._getPath(oldName)
          });
        }
      }
      this._setUpControl();
    }
    if ("isDisabled" in changes) {
      this._updateDisabled(changes);
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      this._updateValue(this.model);
      this.viewModel = this.model;
    }
  }
  ngOnDestroy() {
    this.formDirective && this.formDirective.removeControl(this);
  }
  get path() {
    return this._getPath(this.name);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _setUpControl() {
    this._setUpdateStrategy();
    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);
    this._registered = true;
  }
  _setUpdateStrategy() {
    if (this.options && this.options.updateOn != null) {
      this.control._updateOn = this.options.updateOn;
    }
  }
  _isStandalone() {
    return !this._parent || !!(this.options && this.options.standalone);
  }
  _setUpStandalone() {
    setUpControl(this.control, this, this.callSetDisabledState);
    this.control.updateValueAndValidity({
      emitEvent: false
    });
  }
  _checkForErrors() {
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._isStandalone()) {
      checkParentType$1(this._parent);
    }
    this._checkName();
  }
  _checkName() {
    if (this.options && this.options.name) this.name = this.options.name;
    if (!this._isStandalone() && !this.name && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingNameException();
    }
  }
  _updateValue(value) {
    resolvedPromise.then(() => {
      this.control.setValue(value, {
        emitViewToModelChange: false
      });
      this._changeDetectorRef?.markForCheck();
    });
  }
  _updateDisabled(changes) {
    const disabledValue = changes["isDisabled"].currentValue;
    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);
    resolvedPromise.then(() => {
      if (isDisabled && !this.control.disabled) {
        this.control.disable();
      } else if (!isDisabled && this.control.disabled) {
        this.control.enable();
      }
      this._changeDetectorRef?.markForCheck();
    });
  }
  _getPath(controlName) {
    return this._parent ? controlPath(controlName, this._parent) : [controlName];
  }
  static \u0275fac = function NgModel_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgModel)(\u0275\u0275directiveInject(ControlContainer, 9), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(ChangeDetectorRef, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgModel,
    selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]],
    inputs: {
      name: "name",
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"],
      options: [0, "ngModelOptions", "options"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngModel"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formControlBinding$1]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgModel, [{
    type: Directive,
    args: [{
      selector: "[ngModel]:not([formControlName]):not([formControl])",
      providers: [formControlBinding$1],
      exportAs: "ngModel",
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: ChangeDetectorRef,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [ChangeDetectorRef]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    name: [{
      type: Input
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    options: [{
      type: Input,
      args: ["ngModelOptions"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType$1(parent) {
  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {
    throw formGroupNameException();
  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {
    throw modelParentException();
  }
}
var \u0275NgNoValidate = class _\u0275NgNoValidate {
  static \u0275fac = function \u0275NgNoValidate_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275NgNoValidate)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _\u0275NgNoValidate,
    selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]],
    hostAttrs: ["novalidate", ""],
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgNoValidate, [{
    type: Directive,
    args: [{
      selector: "form:not([ngNoForm]):not([ngNativeValidate])",
      host: {
        "novalidate": ""
      },
      standalone: false
    }]
  }], null, null);
})();
var NUMBER_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => NumberValueAccessor),
  multi: true
};
var NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    const normalizedValue = value == null ? "" : value;
    this.setProperty("value", normalizedValue);
  }
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275NumberValueAccessor_BaseFactory;
    return function NumberValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275NumberValueAccessor_BaseFactory || (\u0275NumberValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NumberValueAccessor,
    selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]],
    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("input", function NumberValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function NumberValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]",
      host: {
        "(input)": "onChange($any($event.target).value)",
        "(blur)": "onTouched()"
      },
      providers: [NUMBER_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var RADIO_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RadioControlValueAccessor),
  multi: true
};
function throwNameError() {
  throw new RuntimeError(1202, `
      If you define both a name and a formControlName attribute on your radio button, their values
      must match. Ex: <input type="radio" formControlName="food" name="food">
    `);
}
var RadioControlRegistry = class _RadioControlRegistry {
  _accessors = [];
  add(control, accessor) {
    this._accessors.push([control, accessor]);
  }
  remove(accessor) {
    for (let i = this._accessors.length - 1; i >= 0; --i) {
      if (this._accessors[i][1] === accessor) {
        this._accessors.splice(i, 1);
        return;
      }
    }
  }
  select(accessor) {
    this._accessors.forEach((c) => {
      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {
        c[1].fireUncheck(accessor.value);
      }
    });
  }
  _isSameGroup(controlPair, accessor) {
    if (!controlPair[0].control) return false;
    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;
  }
  static \u0275fac = function RadioControlRegistry_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlRegistry)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RadioControlRegistry,
    factory: _RadioControlRegistry.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {
  _registry;
  _injector;
  _state;
  _control;
  _fn;
  setDisabledStateFired = false;
  onChange = () => {
  };
  name;
  formControlName;
  value;
  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {
    optional: true
  }) ?? setDisabledStateDefault;
  constructor(renderer, elementRef, _registry, _injector) {
    super(renderer, elementRef);
    this._registry = _registry;
    this._injector = _injector;
  }
  ngOnInit() {
    this._control = this._injector.get(NgControl);
    this._checkName();
    this._registry.add(this._control, this);
  }
  ngOnDestroy() {
    this._registry.remove(this);
  }
  writeValue(value) {
    this._state = value === this.value;
    this.setProperty("checked", this._state);
  }
  registerOnChange(fn) {
    this._fn = fn;
    this.onChange = () => {
      fn(this.value);
      this._registry.select(this);
    };
  }
  setDisabledState(isDisabled) {
    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === "whenDisabledForLegacyCode") {
      this.setProperty("disabled", isDisabled);
    }
    this.setDisabledStateFired = true;
  }
  fireUncheck(value) {
    this.writeValue(value);
  }
  _checkName() {
    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throwNameError();
    }
    if (!this.name && this.formControlName) this.name = this.formControlName;
  }
  static \u0275fac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RadioControlValueAccessor)(\u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(RadioControlRegistry), \u0275\u0275directiveInject(Injector));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RadioControlValueAccessor,
    selectors: [["input", "type", "radio", "formControlName", ""], ["input", "type", "radio", "formControl", ""], ["input", "type", "radio", "ngModel", ""]],
    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function RadioControlValueAccessor_change_HostBindingHandler() {
          return ctx.onChange();
        })("blur", function RadioControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      name: "name",
      formControlName: "formControlName",
      value: "value"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]",
      host: {
        "(change)": "onChange()",
        "(blur)": "onTouched()"
      },
      providers: [RADIO_VALUE_ACCESSOR],
      standalone: false
    }]
  }], () => [{
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: RadioControlRegistry
  }, {
    type: Injector
  }], {
    name: [{
      type: Input
    }],
    formControlName: [{
      type: Input
    }],
    value: [{
      type: Input
    }]
  });
})();
var RANGE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => RangeValueAccessor),
  multi: true
};
var RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {
  writeValue(value) {
    this.setProperty("value", parseFloat(value));
  }
  registerOnChange(fn) {
    this.onChange = (value) => {
      fn(value == "" ? null : parseFloat(value));
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275RangeValueAccessor_BaseFactory;
    return function RangeValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275RangeValueAccessor_BaseFactory || (\u0275RangeValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RangeValueAccessor,
    selectors: [["input", "type", "range", "formControlName", ""], ["input", "type", "range", "formControl", ""], ["input", "type", "range", "ngModel", ""]],
    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function RangeValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("input", function RangeValueAccessor_input_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function RangeValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{
    type: Directive,
    args: [{
      selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]",
      host: {
        "(change)": "onChange($any($event.target).value)",
        "(input)": "onChange($any($event.target).value)",
        "(blur)": "onTouched()"
      },
      providers: [RANGE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, null);
})();
var FormArray = class extends AbstractControl {
  constructor(controls, validatorOrOpts, asyncValidator) {
    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));
    this.controls = controls;
    this._initObservables();
    this._setUpdateStrategy(validatorOrOpts);
    this._setUpControls();
    this.updateValueAndValidity({
      onlySelf: true,
      emitEvent: !!this.asyncValidator
    });
  }
  controls;
  at(index2) {
    return this.controls[this._adjustIndex(index2)];
  }
  push(control, options = {}) {
    if (Array.isArray(control)) {
      control.forEach((ctrl) => {
        this.controls.push(ctrl);
        this._registerControl(ctrl);
      });
    } else {
      this.controls.push(control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  insert(index2, control, options = {}) {
    this.controls.splice(index2, 0, control);
    this._registerControl(control);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  removeAt(index2, options = {}) {
    let adjustedIndex = this._adjustIndex(index2);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  setControl(index2, control, options = {}) {
    let adjustedIndex = this._adjustIndex(index2);
    if (adjustedIndex < 0) adjustedIndex = 0;
    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {
    });
    this.controls.splice(adjustedIndex, 1);
    if (control) {
      this.controls.splice(adjustedIndex, 0, control);
      this._registerControl(control);
    }
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
    this._onCollectionChange();
  }
  get length() {
    return this.controls.length;
  }
  setValue(value, options = {}) {
    assertAllValuesPresent(this, false, value);
    value.forEach((newValue, index2) => {
      assertControlPresent(this, false, index2);
      this.at(index2).setValue(newValue, {
        onlySelf: true,
        emitEvent: options.emitEvent
      });
    });
    this.updateValueAndValidity(options);
  }
  patchValue(value, options = {}) {
    if (value == null) return;
    value.forEach((newValue, index2) => {
      if (this.at(index2)) {
        this.at(index2).patchValue(newValue, {
          onlySelf: true,
          emitEvent: options.emitEvent
        });
      }
    });
    this.updateValueAndValidity(options);
  }
  reset(value = [], options = {}) {
    this._forEachChild((control, index2) => {
      control.reset(value[index2], __spreadProps(__spreadValues({}, options), {
        onlySelf: true
      }));
    });
    this._updatePristine(options, this);
    this._updateTouched(options, this);
    this.updateValueAndValidity(options);
    if (options?.emitEvent !== false) {
      this._events.next(new FormResetEvent(this));
    }
  }
  getRawValue() {
    return this.controls.map((control) => control.getRawValue());
  }
  clear(options = {}) {
    if (this.controls.length < 1) return;
    this._forEachChild((control) => control._registerOnCollectionChange(() => {
    }));
    this.controls.splice(0);
    this.updateValueAndValidity({
      emitEvent: options.emitEvent
    });
  }
  _adjustIndex(index2) {
    return index2 < 0 ? index2 + this.length : index2;
  }
  _syncPendingControls() {
    let subtreeUpdated = this.controls.reduce((updated, child) => {
      return child._syncPendingControls() ? true : updated;
    }, false);
    if (subtreeUpdated) this.updateValueAndValidity({
      onlySelf: true
    });
    return subtreeUpdated;
  }
  _forEachChild(cb) {
    this.controls.forEach((control, index2) => {
      cb(control, index2);
    });
  }
  _updateValue() {
    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);
  }
  _anyControls(condition) {
    return this.controls.some((control) => control.enabled && condition(control));
  }
  _setUpControls() {
    this._forEachChild((control) => this._registerControl(control));
  }
  _allControlsDisabled() {
    for (const control of this.controls) {
      if (control.enabled) return false;
    }
    return this.controls.length > 0 || this.disabled;
  }
  _registerControl(control) {
    control.setParent(this);
    control._registerOnCollectionChange(this._onCollectionChange);
  }
  _find(name) {
    return this.at(name) ?? null;
  }
};
var AbstractFormDirective = class _AbstractFormDirective extends ControlContainer {
  callSetDisabledState;
  get submitted() {
    return untracked(this._submittedReactive);
  }
  set submitted(value) {
    this._submittedReactive.set(value);
  }
  _submitted = computed(() => this._submittedReactive(), ...ngDevMode ? [{
    debugName: "_submitted"
  }] : []);
  _submittedReactive = signal(false, ...ngDevMode ? [{
    debugName: "_submittedReactive"
  }] : []);
  _oldForm;
  _onCollectionChange = () => this._updateDomValue();
  directives = [];
  constructor(validators, asyncValidators, callSetDisabledState) {
    super();
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  ngOnChanges(changes) {
    this.onChanges(changes);
  }
  ngOnDestroy() {
    this.onDestroy();
  }
  onChanges(changes) {
    this._checkFormPresent();
    if (changes.hasOwnProperty("form")) {
      this._updateValidators();
      this._updateDomValue();
      this._updateRegistrations();
      this._oldForm = this.form;
    }
  }
  onDestroy() {
    if (this.form) {
      cleanUpValidators(this.form, this);
      if (this.form._onCollectionChange === this._onCollectionChange) {
        this.form._registerOnCollectionChange(() => {
        });
      }
    }
  }
  get formDirective() {
    return this;
  }
  get path() {
    return [];
  }
  addControl(dir) {
    const ctrl = this.form.get(dir.path);
    setUpControl(ctrl, dir, this.callSetDisabledState);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
    this.directives.push(dir);
    return ctrl;
  }
  getControl(dir) {
    return this.form.get(dir.path);
  }
  removeControl(dir) {
    cleanUpControl(dir.control || null, dir, false);
    removeListItem$1(this.directives, dir);
  }
  addFormGroup(dir) {
    this._setUpFormContainer(dir);
  }
  removeFormGroup(dir) {
    this._cleanUpFormContainer(dir);
  }
  getFormGroup(dir) {
    return this.form.get(dir.path);
  }
  getFormArray(dir) {
    return this.form.get(dir.path);
  }
  addFormArray(dir) {
    this._setUpFormContainer(dir);
  }
  removeFormArray(dir) {
    this._cleanUpFormContainer(dir);
  }
  updateModel(dir, value) {
    const ctrl = this.form.get(dir.path);
    ctrl.setValue(value);
  }
  onReset() {
    this.resetForm();
  }
  resetForm(value = void 0, options = {}) {
    this.form.reset(value, options);
    this._submittedReactive.set(false);
  }
  onSubmit($event) {
    this.submitted = true;
    syncPendingControls(this.form, this.directives);
    this.ngSubmit.emit($event);
    this.form._events.next(new FormSubmittedEvent(this.control));
    return $event?.target?.method === "dialog";
  }
  _updateDomValue() {
    this.directives.forEach((dir) => {
      const oldCtrl = dir.control;
      const newCtrl = this.form.get(dir.path);
      if (oldCtrl !== newCtrl) {
        cleanUpControl(oldCtrl || null, dir);
        if (isFormControl(newCtrl)) {
          setUpControl(newCtrl, dir, this.callSetDisabledState);
          dir.control = newCtrl;
        }
      }
    });
    this.form._updateTreeValidity({
      emitEvent: false
    });
  }
  _setUpFormContainer(dir) {
    const ctrl = this.form.get(dir.path);
    setUpFormContainer(ctrl, dir);
    ctrl.updateValueAndValidity({
      emitEvent: false
    });
  }
  _cleanUpFormContainer(dir) {
    if (this.form) {
      const ctrl = this.form.get(dir.path);
      if (ctrl) {
        const isControlUpdated = cleanUpFormContainer(ctrl, dir);
        if (isControlUpdated) {
          ctrl.updateValueAndValidity({
            emitEvent: false
          });
        }
      }
    }
  }
  _updateRegistrations() {
    this.form._registerOnCollectionChange(this._onCollectionChange);
    if (this._oldForm) {
      this._oldForm._registerOnCollectionChange(() => {
      });
    }
  }
  _updateValidators() {
    setUpValidators(this.form, this);
    if (this._oldForm) {
      cleanUpValidators(this._oldForm, this);
    }
  }
  _checkFormPresent() {
    if (!this.form && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw missingFormException();
    }
  }
  static \u0275fac = function AbstractFormDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractFormDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _AbstractFormDirective,
    features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractFormDirective, [{
    type: Directive
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], null);
})();
var formDirectiveProvider$1 = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayDirective)
};
var FormArrayDirective = class _FormArrayDirective extends AbstractFormDirective {
  form = null;
  ngSubmit = new EventEmitter();
  get control() {
    return this.form;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275FormArrayDirective_BaseFactory;
    return function FormArrayDirective_Factory(__ngFactoryType__) {
      return (\u0275FormArrayDirective_BaseFactory || (\u0275FormArrayDirective_BaseFactory = \u0275\u0275getInheritedFactory(_FormArrayDirective)))(__ngFactoryType__ || _FormArrayDirective);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormArrayDirective,
    selectors: [["", "formArray", ""]],
    hostBindings: function FormArrayDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("submit", function FormArrayDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormArrayDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formArray", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formDirectiveProvider$1]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayDirective, [{
    type: Directive,
    args: [{
      selector: "[formArray]",
      providers: [formDirectiveProvider$1],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], null, {
    form: [{
      type: Input,
      args: ["formArray"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "NgModelWithFormControlWarning" : "");
var formControlBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlDirective)
};
var FormControlDirective = class _FormControlDirective extends NgControl {
  _ngModelWarningConfig;
  callSetDisabledState;
  viewModel;
  form;
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  model;
  update = new EventEmitter();
  static _ngModelWarningSentOnce = false;
  _ngModelWarningSent = false;
  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this.callSetDisabledState = callSetDisabledState;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    if (this._isControlChanged(changes)) {
      const previousForm = changes["form"].previousValue;
      if (previousForm) {
        cleanUpControl(previousForm, this, false);
      }
      setUpControl(this.form, this, this.callSetDisabledState);
      this.form.updateValueAndValidity({
        emitEvent: false
      });
    }
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControl", _FormControlDirective, this, this._ngModelWarningConfig);
      }
      this.form.setValue(this.model);
      this.viewModel = this.model;
    }
  }
  ngOnDestroy() {
    if (this.form) {
      cleanUpControl(this.form, this, false);
    }
  }
  get path() {
    return [];
  }
  get control() {
    return this.form;
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  _isControlChanged(changes) {
    return changes.hasOwnProperty("form");
  }
  static \u0275fac = function FormControlDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlDirective)(\u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \u0275\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormControlDirective,
    selectors: [["", "formControl", ""]],
    inputs: {
      form: [0, "formControl", "form"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formControlBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlDirective, [{
    type: Directive,
    args: [{
      selector: "[formControl]",
      providers: [formControlBinding],
      exportAs: "ngForm",
      standalone: false
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [CALL_SET_DISABLED_STATE]
    }]
  }], {
    form: [{
      type: Input,
      args: ["formControl"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
var formGroupNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupName)
};
var FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  _checkParentType() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw groupParentException();
    }
  }
  static \u0275fac = function FormGroupName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormGroupName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormGroupName,
    selectors: [["", "formGroupName", ""]],
    inputs: {
      name: [0, "formGroupName", "name"]
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formGroupNameProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupName, [{
    type: Directive,
    args: [{
      selector: "[formGroupName]",
      providers: [formGroupNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formGroupName"]
    }]
  });
})();
var formArrayNameProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormArrayName)
};
var FormArrayName = class _FormArrayName extends ControlContainer {
  _parent;
  name = null;
  constructor(parent, validators, asyncValidators) {
    super();
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
  }
  ngOnInit() {
    if (hasInvalidParent(this._parent) && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw arrayParentException();
    }
    this.formDirective.addFormArray(this);
  }
  ngOnDestroy() {
    this.formDirective?.removeFormArray(this);
  }
  get control() {
    return this.formDirective.getFormArray(this);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  static \u0275fac = function FormArrayName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormArrayName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormArrayName,
    selectors: [["", "formArrayName", ""]],
    inputs: {
      name: [0, "formArrayName", "name"]
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formArrayNameProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormArrayName, [{
    type: Directive,
    args: [{
      selector: "[formArrayName]",
      providers: [formArrayNameProvider],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formArrayName"]
    }]
  });
})();
function hasInvalidParent(parent) {
  return !(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName);
}
var controlNameBinding = {
  provide: NgControl,
  useExisting: forwardRef(() => FormControlName)
};
var FormControlName = class _FormControlName extends NgControl {
  _ngModelWarningConfig;
  _added = false;
  viewModel;
  control;
  name = null;
  set isDisabled(isDisabled) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.warn(disabledAttrWarning);
    }
  }
  model;
  update = new EventEmitter();
  static _ngModelWarningSentOnce = false;
  _ngModelWarningSent = false;
  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {
    super();
    this._ngModelWarningConfig = _ngModelWarningConfig;
    this._parent = parent;
    this._setValidators(validators);
    this._setAsyncValidators(asyncValidators);
    this.valueAccessor = selectValueAccessor(this, valueAccessors);
  }
  ngOnChanges(changes) {
    if (!this._added) this._setUpControl();
    if (isPropertyUpdated(changes, this.viewModel)) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        _ngModelWarning("formControlName", _FormControlName, this, this._ngModelWarningConfig);
      }
      this.viewModel = this.model;
      this.formDirective.updateModel(this, this.model);
    }
  }
  ngOnDestroy() {
    if (this.formDirective) {
      this.formDirective.removeControl(this);
    }
  }
  viewToModelUpdate(newValue) {
    this.viewModel = newValue;
    this.update.emit(newValue);
  }
  get path() {
    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);
  }
  get formDirective() {
    return this._parent ? this._parent.formDirective : null;
  }
  _setUpControl() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkParentType(this._parent, this.name);
    }
    this.control = this.formDirective.addControl(this);
    this._added = true;
  }
  static \u0275fac = function FormControlName_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormControlName)(\u0275\u0275directiveInject(ControlContainer, 13), \u0275\u0275directiveInject(NG_VALIDATORS, 10), \u0275\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \u0275\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \u0275\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormControlName,
    selectors: [["", "formControlName", ""]],
    inputs: {
      name: [0, "formControlName", "name"],
      isDisabled: [0, "disabled", "isDisabled"],
      model: [0, "ngModel", "model"]
    },
    outputs: {
      update: "ngModelChange"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([controlNameBinding]), \u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormControlName, [{
    type: Directive,
    args: [{
      selector: "[formControlName]",
      providers: [controlNameBinding],
      standalone: false
    }]
  }], () => [{
    type: ControlContainer,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }, {
      type: SkipSelf
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_ASYNC_VALIDATORS]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Self
    }, {
      type: Inject,
      args: [NG_VALUE_ACCESSOR]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]
    }]
  }], {
    name: [{
      type: Input,
      args: ["formControlName"]
    }],
    isDisabled: [{
      type: Input,
      args: ["disabled"]
    }],
    model: [{
      type: Input,
      args: ["ngModel"]
    }],
    update: [{
      type: Output,
      args: ["ngModelChange"]
    }]
  });
})();
function checkParentType(parent, name) {
  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {
    throw ngModelGroupException();
  } else if (!(parent instanceof FormGroupName) && !(parent instanceof AbstractFormDirective) && !(parent instanceof FormArrayName)) {
    throw controlParentException(name);
  }
}
var formDirectiveProvider = {
  provide: ControlContainer,
  useExisting: forwardRef(() => FormGroupDirective)
};
var FormGroupDirective = class _FormGroupDirective extends AbstractFormDirective {
  form = null;
  ngSubmit = new EventEmitter();
  get control() {
    return this.form;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275FormGroupDirective_BaseFactory;
    return function FormGroupDirective_Factory(__ngFactoryType__) {
      return (\u0275FormGroupDirective_BaseFactory || (\u0275FormGroupDirective_BaseFactory = \u0275\u0275getInheritedFactory(_FormGroupDirective)))(__ngFactoryType__ || _FormGroupDirective);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _FormGroupDirective,
    selectors: [["", "formGroup", ""]],
    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("submit", function FormGroupDirective_submit_HostBindingHandler($event) {
          return ctx.onSubmit($event);
        })("reset", function FormGroupDirective_reset_HostBindingHandler() {
          return ctx.onReset();
        });
      }
    },
    inputs: {
      form: [0, "formGroup", "form"]
    },
    outputs: {
      ngSubmit: "ngSubmit"
    },
    exportAs: ["ngForm"],
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([formDirectiveProvider]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormGroupDirective, [{
    type: Directive,
    args: [{
      selector: "[formGroup]",
      providers: [formDirectiveProvider],
      host: {
        "(submit)": "onSubmit($event)",
        "(reset)": "onReset()"
      },
      exportAs: "ngForm",
      standalone: false
    }]
  }], null, {
    form: [{
      type: Input,
      args: ["formGroup"]
    }],
    ngSubmit: [{
      type: Output
    }]
  });
})();
var SELECT_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectControlValueAccessor),
  multi: true
};
function _buildValueString$1(id, value) {
  if (id == null) return `${value}`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId$1(valueString) {
  return valueString.split(":")[0];
}
var SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {
  value;
  _optionMap = /* @__PURE__ */ new Map();
  _idCounter = 0;
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  appRefInjector = inject(ApplicationRef).injector;
  destroyRef = inject(DestroyRef);
  cdr = inject(ChangeDetectorRef);
  _queuedWrite = false;
  _writeValueAfterRender() {
    if (this._queuedWrite || this.appRefInjector.destroyed) {
      return;
    }
    this._queuedWrite = true;
    afterNextRender({
      write: () => {
        if (this.destroyRef.destroyed) {
          return;
        }
        this._queuedWrite = false;
        this.writeValue(this.value);
      }
    }, {
      injector: this.appRefInjector
    });
  }
  writeValue(value) {
    this.cdr.markForCheck();
    this.value = value;
    const id = this._getOptionId(value);
    const valueString = _buildValueString$1(id, value);
    this.setProperty("value", valueString);
  }
  registerOnChange(fn) {
    this.onChange = (valueString) => {
      this.value = this._getOptionValue(valueString);
      fn(this.value);
    };
  }
  _registerOption() {
    return (this._idCounter++).toString();
  }
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id), value)) return id;
    }
    return null;
  }
  _getOptionValue(valueString) {
    const id = _extractId$1(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SelectControlValueAccessor_BaseFactory;
    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275SelectControlValueAccessor_BaseFactory || (\u0275SelectControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _SelectControlValueAccessor,
    selectors: [["select", "formControlName", "", 3, "multiple", ""], ["select", "formControl", "", 3, "multiple", ""], ["select", "ngModel", "", 3, "multiple", ""]],
    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function SelectControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target.value);
        })("blur", function SelectControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]",
      host: {
        "(change)": "onChange($any($event.target).value)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var NgSelectOption = class _NgSelectOption {
  _element;
  _renderer;
  _select;
  id;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) this.id = this._select._registerOption();
  }
  set ngValue(value) {
    if (this._select == null) return;
    this._select._optionMap.set(this.id, value);
    this._setElementValue(_buildValueString$1(this.id, value));
    this._select._writeValueAfterRender();
  }
  set value(value) {
    this._setElementValue(value);
    if (this._select) this._select._writeValueAfterRender();
  }
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select._writeValueAfterRender();
    }
  }
  static \u0275fac = function NgSelectOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NgSelectOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectControlValueAccessor, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _NgSelectOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgSelectOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
var SELECT_MULTIPLE_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),
  multi: true
};
function _buildValueString(id, value) {
  if (id == null) return `${value}`;
  if (typeof value === "string") value = `'${value}'`;
  if (value && typeof value === "object") value = "Object";
  return `${id}: ${value}`.slice(0, 50);
}
function _extractId(valueString) {
  return valueString.split(":")[0];
}
var SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {
  value;
  _optionMap = /* @__PURE__ */ new Map();
  _idCounter = 0;
  set compareWith(fn) {
    if (typeof fn !== "function" && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);
    }
    this._compareWith = fn;
  }
  _compareWith = Object.is;
  writeValue(value) {
    this.value = value;
    let optionSelectedStateSetter;
    if (Array.isArray(value)) {
      const ids = value.map((v) => this._getOptionId(v));
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(ids.indexOf(o.toString()) > -1);
      };
    } else {
      optionSelectedStateSetter = (opt, o) => {
        opt._setSelected(false);
      };
    }
    this._optionMap.forEach(optionSelectedStateSetter);
  }
  registerOnChange(fn) {
    this.onChange = (element) => {
      const selected = [];
      const selectedOptions = element.selectedOptions;
      if (selectedOptions !== void 0) {
        const options = selectedOptions;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          const val = this._getOptionValue(opt.value);
          selected.push(val);
        }
      } else {
        const options = element.options;
        for (let i = 0; i < options.length; i++) {
          const opt = options[i];
          if (opt.selected) {
            const val = this._getOptionValue(opt.value);
            selected.push(val);
          }
        }
      }
      this.value = selected;
      fn(selected);
    };
  }
  _registerOption(value) {
    const id = (this._idCounter++).toString();
    this._optionMap.set(id, value);
    return id;
  }
  _getOptionId(value) {
    for (const id of this._optionMap.keys()) {
      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;
    }
    return null;
  }
  _getOptionValue(valueString) {
    const id = _extractId(valueString);
    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275SelectMultipleControlValueAccessor_BaseFactory;
    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {
      return (\u0275SelectMultipleControlValueAccessor_BaseFactory || (\u0275SelectMultipleControlValueAccessor_BaseFactory = \u0275\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _SelectMultipleControlValueAccessor,
    selectors: [["select", "multiple", "", "formControlName", ""], ["select", "multiple", "", "formControl", ""], ["select", "multiple", "", "ngModel", ""]],
    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("change", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {
          return ctx.onChange($event.target);
        })("blur", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {
          return ctx.onTouched();
        });
      }
    },
    inputs: {
      compareWith: "compareWith"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{
    type: Directive,
    args: [{
      selector: "select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]",
      host: {
        "(change)": "onChange($event.target)",
        "(blur)": "onTouched()"
      },
      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],
      standalone: false
    }]
  }], null, {
    compareWith: [{
      type: Input
    }]
  });
})();
var \u0275NgSelectMultipleOption = class _\u0275NgSelectMultipleOption {
  _element;
  _renderer;
  _select;
  id;
  _value;
  constructor(_element, _renderer, _select) {
    this._element = _element;
    this._renderer = _renderer;
    this._select = _select;
    if (this._select) {
      this.id = this._select._registerOption(this);
    }
  }
  set ngValue(value) {
    if (this._select == null) return;
    this._value = value;
    this._setElementValue(_buildValueString(this.id, value));
    this._select.writeValue(this._select.value);
  }
  set value(value) {
    if (this._select) {
      this._value = value;
      this._setElementValue(_buildValueString(this.id, value));
      this._select.writeValue(this._select.value);
    } else {
      this._setElementValue(value);
    }
  }
  _setElementValue(value) {
    this._renderer.setProperty(this._element.nativeElement, "value", value);
  }
  _setSelected(selected) {
    this._renderer.setProperty(this._element.nativeElement, "selected", selected);
  }
  ngOnDestroy() {
    if (this._select) {
      this._select._optionMap.delete(this.id);
      this._select.writeValue(this._select.value);
    }
  }
  static \u0275fac = function \u0275NgSelectMultipleOption_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275NgSelectMultipleOption)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(SelectMultipleControlValueAccessor, 9));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _\u0275NgSelectMultipleOption,
    selectors: [["option"]],
    inputs: {
      ngValue: "ngValue",
      value: "value"
    },
    standalone: false
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275NgSelectMultipleOption, [{
    type: Directive,
    args: [{
      selector: "option",
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: SelectMultipleControlValueAccessor,
    decorators: [{
      type: Optional
    }, {
      type: Host
    }]
  }], {
    ngValue: [{
      type: Input,
      args: ["ngValue"]
    }],
    value: [{
      type: Input,
      args: ["value"]
    }]
  });
})();
function toInteger(value) {
  return typeof value === "number" ? value : parseInt(value, 10);
}
function toFloat(value) {
  return typeof value === "number" ? value : parseFloat(value);
}
var AbstractValidatorDirective = class _AbstractValidatorDirective {
  _validator = nullValidator;
  _onChange;
  _enabled;
  ngOnChanges(changes) {
    if (this.inputName in changes) {
      const input2 = this.normalizeInput(changes[this.inputName].currentValue);
      this._enabled = this.enabled(input2);
      this._validator = this._enabled ? this.createValidator(input2) : nullValidator;
      if (this._onChange) {
        this._onChange();
      }
    }
  }
  validate(control) {
    return this._validator(control);
  }
  registerOnValidatorChange(fn) {
    this._onChange = fn;
  }
  enabled(input2) {
    return input2 != null;
  }
  static \u0275fac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AbstractValidatorDirective)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _AbstractValidatorDirective,
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{
    type: Directive
  }], null, null);
})();
var MAX_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxValidator),
  multi: true
};
var MaxValidator = class _MaxValidator extends AbstractValidatorDirective {
  max;
  inputName = "max";
  normalizeInput = (input2) => toFloat(input2);
  createValidator = (max) => maxValidator(max);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MaxValidator_BaseFactory;
    return function MaxValidator_Factory(__ngFactoryType__) {
      return (\u0275MaxValidator_BaseFactory || (\u0275MaxValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MaxValidator,
    selectors: [["input", "type", "number", "max", "", "formControlName", ""], ["input", "type", "number", "max", "", "formControl", ""], ["input", "type", "number", "max", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("max", ctx._enabled ? ctx.max : null);
      }
    },
    inputs: {
      max: "max"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MAX_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]",
      providers: [MAX_VALIDATOR],
      host: {
        "[attr.max]": "_enabled ? max : null"
      },
      standalone: false
    }]
  }], null, {
    max: [{
      type: Input
    }]
  });
})();
var MIN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinValidator),
  multi: true
};
var MinValidator = class _MinValidator extends AbstractValidatorDirective {
  min;
  inputName = "min";
  normalizeInput = (input2) => toFloat(input2);
  createValidator = (min) => minValidator(min);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MinValidator_BaseFactory;
    return function MinValidator_Factory(__ngFactoryType__) {
      return (\u0275MinValidator_BaseFactory || (\u0275MinValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MinValidator,
    selectors: [["input", "type", "number", "min", "", "formControlName", ""], ["input", "type", "number", "min", "", "formControl", ""], ["input", "type", "number", "min", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("min", ctx._enabled ? ctx.min : null);
      }
    },
    inputs: {
      min: "min"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MIN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]",
      providers: [MIN_VALIDATOR],
      host: {
        "[attr.min]": "_enabled ? min : null"
      },
      standalone: false
    }]
  }], null, {
    min: [{
      type: Input
    }]
  });
})();
var REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RequiredValidator),
  multi: true
};
var CHECKBOX_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => CheckboxRequiredValidator),
  multi: true
};
var RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {
  required;
  inputName = "required";
  normalizeInput = booleanAttribute;
  createValidator = (input2) => requiredValidator;
  enabled(input2) {
    return input2;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275RequiredValidator_BaseFactory;
    return function RequiredValidator_Factory(__ngFactoryType__) {
      return (\u0275RequiredValidator_BaseFactory || (\u0275RequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RequiredValidator,
    selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]],
    hostVars: 1,
    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("required", ctx._enabled ? "" : null);
      }
    },
    inputs: {
      required: "required"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RequiredValidator, [{
    type: Directive,
    args: [{
      selector: ":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]",
      providers: [REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, {
    required: [{
      type: Input
    }]
  });
})();
var CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {
  createValidator = (input2) => requiredTrueValidator;
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275CheckboxRequiredValidator_BaseFactory;
    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {
      return (\u0275CheckboxRequiredValidator_BaseFactory || (\u0275CheckboxRequiredValidator_BaseFactory = \u0275\u0275getInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CheckboxRequiredValidator,
    selectors: [["input", "type", "checkbox", "required", "", "formControlName", ""], ["input", "type", "checkbox", "required", "", "formControl", ""], ["input", "type", "checkbox", "required", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("required", ctx._enabled ? "" : null);
      }
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]",
      providers: [CHECKBOX_REQUIRED_VALIDATOR],
      host: {
        "[attr.required]": '_enabled ? "" : null'
      },
      standalone: false
    }]
  }], null, null);
})();
var EMAIL_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => EmailValidator),
  multi: true
};
var EmailValidator = class _EmailValidator extends AbstractValidatorDirective {
  email;
  inputName = "email";
  normalizeInput = booleanAttribute;
  createValidator = (input2) => emailValidator;
  enabled(input2) {
    return input2;
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275EmailValidator_BaseFactory;
    return function EmailValidator_Factory(__ngFactoryType__) {
      return (\u0275EmailValidator_BaseFactory || (\u0275EmailValidator_BaseFactory = \u0275\u0275getInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _EmailValidator,
    selectors: [["", "email", "", "formControlName", ""], ["", "email", "", "formControl", ""], ["", "email", "", "ngModel", ""]],
    inputs: {
      email: "email"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([EMAIL_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EmailValidator, [{
    type: Directive,
    args: [{
      selector: "[email][formControlName],[email][formControl],[email][ngModel]",
      providers: [EMAIL_VALIDATOR],
      standalone: false
    }]
  }], null, {
    email: [{
      type: Input
    }]
  });
})();
var MIN_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MinLengthValidator),
  multi: true
};
var MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {
  minlength;
  inputName = "minlength";
  normalizeInput = (input2) => toInteger(input2);
  createValidator = (minlength) => minLengthValidator(minlength);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MinLengthValidator_BaseFactory;
    return function MinLengthValidator_Factory(__ngFactoryType__) {
      return (\u0275MinLengthValidator_BaseFactory || (\u0275MinLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MinLengthValidator,
    selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("minlength", ctx._enabled ? ctx.minlength : null);
      }
    },
    inputs: {
      minlength: "minlength"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MinLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[minlength][formControlName],[minlength][formControl],[minlength][ngModel]",
      providers: [MIN_LENGTH_VALIDATOR],
      host: {
        "[attr.minlength]": "_enabled ? minlength : null"
      },
      standalone: false
    }]
  }], null, {
    minlength: [{
      type: Input
    }]
  });
})();
var MAX_LENGTH_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => MaxLengthValidator),
  multi: true
};
var MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {
  maxlength;
  inputName = "maxlength";
  normalizeInput = (input2) => toInteger(input2);
  createValidator = (maxlength) => maxLengthValidator(maxlength);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275MaxLengthValidator_BaseFactory;
    return function MaxLengthValidator_Factory(__ngFactoryType__) {
      return (\u0275MaxLengthValidator_BaseFactory || (\u0275MaxLengthValidator_BaseFactory = \u0275\u0275getInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _MaxLengthValidator,
    selectors: [["", "maxlength", "", "formControlName", ""], ["", "maxlength", "", "formControl", ""], ["", "maxlength", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("maxlength", ctx._enabled ? ctx.maxlength : null);
      }
    },
    inputs: {
      maxlength: "maxlength"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{
    type: Directive,
    args: [{
      selector: "[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]",
      providers: [MAX_LENGTH_VALIDATOR],
      host: {
        "[attr.maxlength]": "_enabled ? maxlength : null"
      },
      standalone: false
    }]
  }], null, {
    maxlength: [{
      type: Input
    }]
  });
})();
var PATTERN_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => PatternValidator),
  multi: true
};
var PatternValidator = class _PatternValidator extends AbstractValidatorDirective {
  pattern;
  inputName = "pattern";
  normalizeInput = (input2) => input2;
  createValidator = (input2) => patternValidator(input2);
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275PatternValidator_BaseFactory;
    return function PatternValidator_Factory(__ngFactoryType__) {
      return (\u0275PatternValidator_BaseFactory || (\u0275PatternValidator_BaseFactory = \u0275\u0275getInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);
    };
  })();
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _PatternValidator,
    selectors: [["", "pattern", "", "formControlName", ""], ["", "pattern", "", "formControl", ""], ["", "pattern", "", "ngModel", ""]],
    hostVars: 1,
    hostBindings: function PatternValidator_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275attribute("pattern", ctx._enabled ? ctx.pattern : null);
      }
    },
    inputs: {
      pattern: "pattern"
    },
    standalone: false,
    features: [\u0275\u0275ProvidersFeature([PATTERN_VALIDATOR]), \u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PatternValidator, [{
    type: Directive,
    args: [{
      selector: "[pattern][formControlName],[pattern][formControl],[pattern][ngModel]",
      providers: [PATTERN_VALIDATOR],
      host: {
        "[attr.pattern]": "_enabled ? pattern : null"
      },
      standalone: false
    }]
  }], null, {
    pattern: [{
      type: Input
    }]
  });
})();
var SHARED_FORM_DIRECTIVES = [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];
var TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];
var REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName];
var \u0275InternalFormsSharedModule = class _\u0275InternalFormsSharedModule {
  static \u0275fac = function \u0275InternalFormsSharedModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275InternalFormsSharedModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _\u0275InternalFormsSharedModule,
    declarations: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator],
    exports: [\u0275NgNoValidate, NgSelectOption, \u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275InternalFormsSharedModule, [{
    type: NgModule,
    args: [{
      declarations: SHARED_FORM_DIRECTIVES,
      exports: SHARED_FORM_DIRECTIVES
    }]
  }], null, null);
})();
function isAbstractControlOptions(options) {
  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);
}
var FormBuilder = class _FormBuilder {
  useNonNullable = false;
  get nonNullable() {
    const nnfb = new _FormBuilder();
    nnfb.useNonNullable = true;
    return nnfb;
  }
  group(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    let newOptions = {};
    if (isAbstractControlOptions(options)) {
      newOptions = options;
    } else if (options !== null) {
      newOptions.validators = options.validator;
      newOptions.asyncValidators = options.asyncValidator;
    }
    return new FormGroup(reducedControls, newOptions);
  }
  record(controls, options = null) {
    const reducedControls = this._reduceControls(controls);
    return new FormRecord(reducedControls, options);
  }
  control(formState, validatorOrOpts, asyncValidator) {
    let newOptions = {};
    if (!this.useNonNullable) {
      return new FormControl(formState, validatorOrOpts, asyncValidator);
    }
    if (isAbstractControlOptions(validatorOrOpts)) {
      newOptions = validatorOrOpts;
    } else {
      newOptions.validators = validatorOrOpts;
      newOptions.asyncValidators = asyncValidator;
    }
    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {
      nonNullable: true
    }));
  }
  array(controls, validatorOrOpts, asyncValidator) {
    const createdControls = controls.map((c) => this._createControl(c));
    return new FormArray(createdControls, validatorOrOpts, asyncValidator);
  }
  _reduceControls(controls) {
    const createdControls = {};
    Object.keys(controls).forEach((controlName) => {
      createdControls[controlName] = this._createControl(controls[controlName]);
    });
    return createdControls;
  }
  _createControl(controls) {
    if (controls instanceof FormControl) {
      return controls;
    } else if (controls instanceof AbstractControl) {
      return controls;
    } else if (Array.isArray(controls)) {
      const value = controls[0];
      const validator = controls.length > 1 ? controls[1] : null;
      const asyncValidator = controls.length > 2 ? controls[2] : null;
      return this.control(value, validator, asyncValidator);
    } else {
      return this.control(controls);
    }
  }
  static \u0275fac = function FormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FormBuilder,
    factory: _FormBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NonNullableFormBuilder = class _NonNullableFormBuilder {
  static \u0275fac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NonNullableFormBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NonNullableFormBuilder,
    factory: () => (() => inject(FormBuilder).nonNullable)(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(FormBuilder).nonNullable
    }]
  }], null, null);
})();
var UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {
  group(controlsConfig, options = null) {
    return super.group(controlsConfig, options);
  }
  control(formState, validatorOrOpts, asyncValidator) {
    return super.control(formState, validatorOrOpts, asyncValidator);
  }
  array(controlsConfig, validatorOrOpts, asyncValidator) {
    return super.array(controlsConfig, validatorOrOpts, asyncValidator);
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275UntypedFormBuilder_BaseFactory;
    return function UntypedFormBuilder_Factory(__ngFactoryType__) {
      return (\u0275UntypedFormBuilder_BaseFactory || (\u0275UntypedFormBuilder_BaseFactory = \u0275\u0275getInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UntypedFormBuilder,
    factory: _UntypedFormBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var FormsModule = class _FormsModule {
  static withConfig(opts) {
    return {
      ngModule: _FormsModule,
      providers: [{
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static \u0275fac = function FormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FormsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _FormsModule,
    declarations: [NgModel, NgModelGroup, NgForm],
    exports: [\u0275InternalFormsSharedModule, NgModel, NgModelGroup, NgForm]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [\u0275InternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FormsModule, [{
    type: NgModule,
    args: [{
      declarations: TEMPLATE_DRIVEN_DIRECTIVES,
      exports: [\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();
var ReactiveFormsModule = class _ReactiveFormsModule {
  static withConfig(opts) {
    return {
      ngModule: _ReactiveFormsModule,
      providers: [{
        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,
        useValue: opts.warnOnNgModelWithFormControl ?? "always"
      }, {
        provide: CALL_SET_DISABLED_STATE,
        useValue: opts.callSetDisabledState ?? setDisabledStateDefault
      }]
    };
  }
  static \u0275fac = function ReactiveFormsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ReactiveFormsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ReactiveFormsModule,
    declarations: [FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName],
    exports: [\u0275InternalFormsSharedModule, FormControlDirective, FormGroupDirective, FormArrayDirective, FormControlName, FormGroupName, FormArrayName]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [\u0275InternalFormsSharedModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{
    type: NgModule,
    args: [{
      declarations: [REACTIVE_DRIVEN_DIRECTIVES],
      exports: [\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]
    }]
  }], null, null);
})();

// node_modules/@tethys/cdk/fesm2022/tethys-cdk-dom.mjs
var AbstractElementRenderer = class {
  constructor() {
    this.renderer = inject(Renderer2);
    this.classNames = [];
  }
  get safeElement() {
    if (!this.element) {
      throw new Error(`Element is null, should call setElement method for ElementRenderer before update dom.`);
    }
    return this.element;
  }
  updateClass(classNames) {
    if (this.classNames) {
      this.classNames.forEach((className) => {
        if (classNames.indexOf(className) < 0) {
          this.removeClass(className);
        }
      });
    }
    const newClasses = [];
    classNames.forEach((className) => {
      if (className) {
        newClasses.push(className);
        if (this.classNames.indexOf(className) < 0) {
          this.addClass(className);
        }
      }
    });
    this.classNames = newClasses;
    return this;
  }
  updateClassByMap(classMap) {
    const newClasses = [];
    for (const key in classMap) {
      if (classMap.hasOwnProperty(key) && classMap[key]) {
        newClasses.push(key);
      }
    }
    this.updateClass(newClasses);
  }
  addClass(className) {
    this.renderer.addClass(this.safeElement, className);
    return this;
  }
  removeClass(className) {
    this.renderer.removeClass(this.safeElement, className);
    return this;
  }
  setStyle(style2, value, flags) {
    this.renderer.setStyle(this.safeElement, style2, value, flags);
    return this;
  }
};
var HostRenderer = class _HostRenderer extends AbstractElementRenderer {
  constructor() {
    super(...arguments);
    this.elementRef = inject(ElementRef);
  }
  get element() {
    return this.elementRef.nativeElement;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275HostRenderer_BaseFactory;
      return function HostRenderer_Factory(__ngFactoryType__) {
        return (\u0275HostRenderer_BaseFactory || (\u0275HostRenderer_BaseFactory = \u0275\u0275getInheritedFactory(_HostRenderer)))(__ngFactoryType__ || _HostRenderer);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _HostRenderer,
      factory: _HostRenderer.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HostRenderer, [{
    type: Injectable
  }], null, null);
})();
function useHostRenderer() {
  return new HostRenderer();
}
function useStealthViewRenderer(templateRefInput) {
  const injector = inject(Injector);
  const applicationRef = inject(ApplicationRef);
  const destroyRef = inject(DestroyRef);
  let embeddedViewRef;
  destroyRef.onDestroy(() => {
    if (embeddedViewRef) {
      embeddedViewRef.destroy();
      applicationRef.detachView(embeddedViewRef);
    }
  });
  const result = {
    get rootNodes() {
      if (!embeddedViewRef) {
        const templateRef = isSignal(templateRefInput) ? templateRefInput() : templateRefInput;
        embeddedViewRef = templateRef.createEmbeddedView({}, injector);
        applicationRef.attachView(embeddedViewRef);
      }
      return embeddedViewRef.rootNodes;
    }
  };
  return result;
}
var ThyStealthView = class _ThyStealthView {
  get rootNodes() {
    return this.stealthViewBehavior.rootNodes;
  }
  constructor() {
    this.templateRef = inject(TemplateRef);
    this.stealthViewBehavior = useStealthViewRenderer(this.templateRef);
  }
  static {
    this.\u0275fac = function ThyStealthView_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyStealthView)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyStealthView,
      selectors: [["ng-template", "thyStealthView", ""]],
      exportAs: ["thyStealthView"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyStealthView, [{
    type: Directive,
    args: [{
      selector: "ng-template[thyStealthView]",
      exportAs: "thyStealthView"
    }]
  }], () => [], null);
})();

// node_modules/@angular/common/fesm2022/_module-chunk.mjs
var HttpHeaders = class _HttpHeaders {
  headers;
  normalizedNames = /* @__PURE__ */ new Map();
  lazyInit;
  lazyUpdate = null;
  constructor(headers) {
    if (!headers) {
      this.headers = /* @__PURE__ */ new Map();
    } else if (typeof headers === "string") {
      this.lazyInit = () => {
        this.headers = /* @__PURE__ */ new Map();
        headers.split("\n").forEach((line) => {
          const index2 = line.indexOf(":");
          if (index2 > 0) {
            const name = line.slice(0, index2);
            const value = line.slice(index2 + 1).trim();
            this.addHeaderEntry(name, value);
          }
        });
      };
    } else if (typeof Headers !== "undefined" && headers instanceof Headers) {
      this.headers = /* @__PURE__ */ new Map();
      headers.forEach((value, name) => {
        this.addHeaderEntry(name, value);
      });
    } else {
      this.lazyInit = () => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          assertValidHeaders(headers);
        }
        this.headers = /* @__PURE__ */ new Map();
        Object.entries(headers).forEach(([name, values]) => {
          this.setHeaderEntries(name, values);
        });
      };
    }
  }
  has(name) {
    this.init();
    return this.headers.has(name.toLowerCase());
  }
  get(name) {
    this.init();
    const values = this.headers.get(name.toLowerCase());
    return values && values.length > 0 ? values[0] : null;
  }
  keys() {
    this.init();
    return Array.from(this.normalizedNames.values());
  }
  getAll(name) {
    this.init();
    return this.headers.get(name.toLowerCase()) || null;
  }
  append(name, value) {
    return this.clone({
      name,
      value,
      op: "a"
    });
  }
  set(name, value) {
    return this.clone({
      name,
      value,
      op: "s"
    });
  }
  delete(name, value) {
    return this.clone({
      name,
      value,
      op: "d"
    });
  }
  maybeSetNormalizedName(name, lcName) {
    if (!this.normalizedNames.has(lcName)) {
      this.normalizedNames.set(lcName, name);
    }
  }
  init() {
    if (!!this.lazyInit) {
      if (this.lazyInit instanceof _HttpHeaders) {
        this.copyFrom(this.lazyInit);
      } else {
        this.lazyInit();
      }
      this.lazyInit = null;
      if (!!this.lazyUpdate) {
        this.lazyUpdate.forEach((update) => this.applyUpdate(update));
        this.lazyUpdate = null;
      }
    }
  }
  copyFrom(other) {
    other.init();
    Array.from(other.headers.keys()).forEach((key) => {
      this.headers.set(key, other.headers.get(key));
      this.normalizedNames.set(key, other.normalizedNames.get(key));
    });
  }
  clone(update) {
    const clone = new _HttpHeaders();
    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
    return clone;
  }
  applyUpdate(update) {
    const key = update.name.toLowerCase();
    switch (update.op) {
      case "a":
      case "s":
        let value = update.value;
        if (typeof value === "string") {
          value = [value];
        }
        if (value.length === 0) {
          return;
        }
        this.maybeSetNormalizedName(update.name, key);
        const base = (update.op === "a" ? this.headers.get(key) : void 0) || [];
        base.push(...value);
        this.headers.set(key, base);
        break;
      case "d":
        const toDelete = update.value;
        if (!toDelete) {
          this.headers.delete(key);
          this.normalizedNames.delete(key);
        } else {
          let existing = this.headers.get(key);
          if (!existing) {
            return;
          }
          existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);
          if (existing.length === 0) {
            this.headers.delete(key);
            this.normalizedNames.delete(key);
          } else {
            this.headers.set(key, existing);
          }
        }
        break;
    }
  }
  addHeaderEntry(name, value) {
    const key = name.toLowerCase();
    this.maybeSetNormalizedName(name, key);
    if (this.headers.has(key)) {
      this.headers.get(key).push(value);
    } else {
      this.headers.set(key, [value]);
    }
  }
  setHeaderEntries(name, values) {
    const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());
    const key = name.toLowerCase();
    this.headers.set(key, headerValues);
    this.maybeSetNormalizedName(name, key);
  }
  forEach(fn) {
    this.init();
    Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));
  }
};
function assertValidHeaders(headers) {
  for (const [key, value] of Object.entries(headers)) {
    if (!(typeof value === "string" || typeof value === "number") && !Array.isArray(value)) {
      throw new Error(`Unexpected value of the \`${key}\` header provided. Expecting either a string, a number or an array, but got: \`${value}\`.`);
    }
  }
}
var HttpContext = class {
  map = /* @__PURE__ */ new Map();
  set(token, value) {
    this.map.set(token, value);
    return this;
  }
  get(token) {
    if (!this.map.has(token)) {
      this.map.set(token, token.defaultValue());
    }
    return this.map.get(token);
  }
  delete(token) {
    this.map.delete(token);
    return this;
  }
  has(token) {
    return this.map.has(token);
  }
  keys() {
    return this.map.keys();
  }
};
var HttpUrlEncodingCodec = class {
  encodeKey(key) {
    return standardEncoding(key);
  }
  encodeValue(value) {
    return standardEncoding(value);
  }
  decodeKey(key) {
    return decodeURIComponent(key);
  }
  decodeValue(value) {
    return decodeURIComponent(value);
  }
};
function paramParser(rawParams, codec) {
  const map2 = /* @__PURE__ */ new Map();
  if (rawParams.length > 0) {
    const params = rawParams.replace(/^\?/, "").split("&");
    params.forEach((param) => {
      const eqIdx = param.indexOf("=");
      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), ""] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];
      const list2 = map2.get(key) || [];
      list2.push(val);
      map2.set(key, list2);
    });
  }
  return map2;
}
var STANDARD_ENCODING_REGEX = /%(\d[a-f0-9])/gi;
var STANDARD_ENCODING_REPLACEMENTS = {
  "40": "@",
  "3A": ":",
  "24": "$",
  "2C": ",",
  "3B": ";",
  "3D": "=",
  "3F": "?",
  "2F": "/"
};
function standardEncoding(v) {
  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);
}
function valueToString(value) {
  return `${value}`;
}
var HttpParams = class _HttpParams {
  map;
  encoder;
  updates = null;
  cloneFrom = null;
  constructor(options = {}) {
    this.encoder = options.encoder || new HttpUrlEncodingCodec();
    if (options.fromString) {
      if (options.fromObject) {
        throw new RuntimeError(2805, ngDevMode && "Cannot specify both fromString and fromObject.");
      }
      this.map = paramParser(options.fromString, this.encoder);
    } else if (!!options.fromObject) {
      this.map = /* @__PURE__ */ new Map();
      Object.keys(options.fromObject).forEach((key) => {
        const value = options.fromObject[key];
        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];
        this.map.set(key, values);
      });
    } else {
      this.map = null;
    }
  }
  has(param) {
    this.init();
    return this.map.has(param);
  }
  get(param) {
    this.init();
    const res = this.map.get(param);
    return !!res ? res[0] : null;
  }
  getAll(param) {
    this.init();
    return this.map.get(param) || null;
  }
  keys() {
    this.init();
    return Array.from(this.map.keys());
  }
  append(param, value) {
    return this.clone({
      param,
      value,
      op: "a"
    });
  }
  appendAll(params) {
    const updates = [];
    Object.keys(params).forEach((param) => {
      const value = params[param];
      if (Array.isArray(value)) {
        value.forEach((_value) => {
          updates.push({
            param,
            value: _value,
            op: "a"
          });
        });
      } else {
        updates.push({
          param,
          value,
          op: "a"
        });
      }
    });
    return this.clone(updates);
  }
  set(param, value) {
    return this.clone({
      param,
      value,
      op: "s"
    });
  }
  delete(param, value) {
    return this.clone({
      param,
      value,
      op: "d"
    });
  }
  toString() {
    this.init();
    return this.keys().map((key) => {
      const eKey = this.encoder.encodeKey(key);
      return this.map.get(key).map((value) => eKey + "=" + this.encoder.encodeValue(value)).join("&");
    }).filter((param) => param !== "").join("&");
  }
  clone(update) {
    const clone = new _HttpParams({
      encoder: this.encoder
    });
    clone.cloneFrom = this.cloneFrom || this;
    clone.updates = (this.updates || []).concat(update);
    return clone;
  }
  init() {
    if (this.map === null) {
      this.map = /* @__PURE__ */ new Map();
    }
    if (this.cloneFrom !== null) {
      this.cloneFrom.init();
      this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));
      this.updates.forEach((update) => {
        switch (update.op) {
          case "a":
          case "s":
            const base = (update.op === "a" ? this.map.get(update.param) : void 0) || [];
            base.push(valueToString(update.value));
            this.map.set(update.param, base);
            break;
          case "d":
            if (update.value !== void 0) {
              let base2 = this.map.get(update.param) || [];
              const idx = base2.indexOf(valueToString(update.value));
              if (idx !== -1) {
                base2.splice(idx, 1);
              }
              if (base2.length > 0) {
                this.map.set(update.param, base2);
              } else {
                this.map.delete(update.param);
              }
            } else {
              this.map.delete(update.param);
              break;
            }
        }
      });
      this.cloneFrom = this.updates = null;
    }
  }
};
function mightHaveBody(method) {
  switch (method) {
    case "DELETE":
    case "GET":
    case "HEAD":
    case "OPTIONS":
    case "JSONP":
      return false;
    default:
      return true;
  }
}
function isArrayBuffer(value) {
  return typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer;
}
function isBlob(value) {
  return typeof Blob !== "undefined" && value instanceof Blob;
}
function isFormData(value) {
  return typeof FormData !== "undefined" && value instanceof FormData;
}
function isUrlSearchParams(value) {
  return typeof URLSearchParams !== "undefined" && value instanceof URLSearchParams;
}
var CONTENT_TYPE_HEADER = "Content-Type";
var ACCEPT_HEADER = "Accept";
var TEXT_CONTENT_TYPE = "text/plain";
var JSON_CONTENT_TYPE = "application/json";
var ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;
var HttpRequest = class _HttpRequest {
  url;
  body = null;
  headers;
  context;
  reportProgress = false;
  withCredentials = false;
  credentials;
  keepalive = false;
  cache;
  priority;
  mode;
  redirect;
  referrer;
  integrity;
  referrerPolicy;
  responseType = "json";
  method;
  params;
  urlWithParams;
  transferCache;
  timeout;
  constructor(method, url, third, fourth) {
    this.url = url;
    this.method = method.toUpperCase();
    let options;
    if (mightHaveBody(this.method) || !!fourth) {
      this.body = third !== void 0 ? third : null;
      options = fourth;
    } else {
      options = third;
    }
    if (options) {
      this.reportProgress = !!options.reportProgress;
      this.withCredentials = !!options.withCredentials;
      this.keepalive = !!options.keepalive;
      if (!!options.responseType) {
        this.responseType = options.responseType;
      }
      if (options.headers) {
        this.headers = options.headers;
      }
      if (options.context) {
        this.context = options.context;
      }
      if (options.params) {
        this.params = options.params;
      }
      if (options.priority) {
        this.priority = options.priority;
      }
      if (options.cache) {
        this.cache = options.cache;
      }
      if (options.credentials) {
        this.credentials = options.credentials;
      }
      if (typeof options.timeout === "number") {
        if (options.timeout < 1 || !Number.isInteger(options.timeout)) {
          throw new RuntimeError(2822, ngDevMode ? "`timeout` must be a positive integer value" : "");
        }
        this.timeout = options.timeout;
      }
      if (options.mode) {
        this.mode = options.mode;
      }
      if (options.redirect) {
        this.redirect = options.redirect;
      }
      if (options.integrity) {
        this.integrity = options.integrity;
      }
      if (options.referrer) {
        this.referrer = options.referrer;
      }
      if (options.referrerPolicy) {
        this.referrerPolicy = options.referrerPolicy;
      }
      this.transferCache = options.transferCache;
    }
    this.headers ??= new HttpHeaders();
    this.context ??= new HttpContext();
    if (!this.params) {
      this.params = new HttpParams();
      this.urlWithParams = url;
    } else {
      const params = this.params.toString();
      if (params.length === 0) {
        this.urlWithParams = url;
      } else {
        const qIdx = url.indexOf("?");
        const sep = qIdx === -1 ? "?" : qIdx < url.length - 1 ? "&" : "";
        this.urlWithParams = url + sep + params;
      }
    }
  }
  serializeBody() {
    if (this.body === null) {
      return null;
    }
    if (typeof this.body === "string" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {
      return this.body;
    }
    if (this.body instanceof HttpParams) {
      return this.body.toString();
    }
    if (typeof this.body === "object" || typeof this.body === "boolean" || Array.isArray(this.body)) {
      return JSON.stringify(this.body);
    }
    return this.body.toString();
  }
  detectContentTypeHeader() {
    if (this.body === null) {
      return null;
    }
    if (isFormData(this.body)) {
      return null;
    }
    if (isBlob(this.body)) {
      return this.body.type || null;
    }
    if (isArrayBuffer(this.body)) {
      return null;
    }
    if (typeof this.body === "string") {
      return TEXT_CONTENT_TYPE;
    }
    if (this.body instanceof HttpParams) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    }
    if (typeof this.body === "object" || typeof this.body === "number" || typeof this.body === "boolean") {
      return JSON_CONTENT_TYPE;
    }
    return null;
  }
  clone(update = {}) {
    const method = update.method || this.method;
    const url = update.url || this.url;
    const responseType = update.responseType || this.responseType;
    const keepalive = update.keepalive ?? this.keepalive;
    const priority = update.priority || this.priority;
    const cache = update.cache || this.cache;
    const mode = update.mode || this.mode;
    const redirect = update.redirect || this.redirect;
    const credentials = update.credentials || this.credentials;
    const referrer = update.referrer || this.referrer;
    const integrity = update.integrity || this.integrity;
    const referrerPolicy = update.referrerPolicy || this.referrerPolicy;
    const transferCache = update.transferCache ?? this.transferCache;
    const timeout = update.timeout ?? this.timeout;
    const body = update.body !== void 0 ? update.body : this.body;
    const withCredentials = update.withCredentials ?? this.withCredentials;
    const reportProgress = update.reportProgress ?? this.reportProgress;
    let headers = update.headers || this.headers;
    let params = update.params || this.params;
    const context = update.context ?? this.context;
    if (update.setHeaders !== void 0) {
      headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);
    }
    if (update.setParams) {
      params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);
    }
    return new _HttpRequest(method, url, body, {
      params,
      headers,
      context,
      reportProgress,
      responseType,
      withCredentials,
      transferCache,
      keepalive,
      cache,
      priority,
      timeout,
      mode,
      redirect,
      credentials,
      referrer,
      integrity,
      referrerPolicy
    });
  }
};
var HttpEventType;
(function(HttpEventType2) {
  HttpEventType2[HttpEventType2["Sent"] = 0] = "Sent";
  HttpEventType2[HttpEventType2["UploadProgress"] = 1] = "UploadProgress";
  HttpEventType2[HttpEventType2["ResponseHeader"] = 2] = "ResponseHeader";
  HttpEventType2[HttpEventType2["DownloadProgress"] = 3] = "DownloadProgress";
  HttpEventType2[HttpEventType2["Response"] = 4] = "Response";
  HttpEventType2[HttpEventType2["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
var HttpResponseBase = class {
  headers;
  status;
  statusText;
  url;
  ok;
  type;
  redirected;
  responseType;
  constructor(init, defaultStatus = 200, defaultStatusText = "OK") {
    this.headers = init.headers || new HttpHeaders();
    this.status = init.status !== void 0 ? init.status : defaultStatus;
    this.statusText = init.statusText || defaultStatusText;
    this.url = init.url || null;
    this.redirected = init.redirected;
    this.responseType = init.responseType;
    this.ok = this.status >= 200 && this.status < 300;
  }
};
var HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {
  constructor(init = {}) {
    super(init);
  }
  type = HttpEventType.ResponseHeader;
  clone(update = {}) {
    return new _HttpHeaderResponse({
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0
    });
  }
};
var HttpResponse = class _HttpResponse extends HttpResponseBase {
  body;
  constructor(init = {}) {
    super(init);
    this.body = init.body !== void 0 ? init.body : null;
  }
  type = HttpEventType.Response;
  clone(update = {}) {
    return new _HttpResponse({
      body: update.body !== void 0 ? update.body : this.body,
      headers: update.headers || this.headers,
      status: update.status !== void 0 ? update.status : this.status,
      statusText: update.statusText || this.statusText,
      url: update.url || this.url || void 0,
      redirected: update.redirected ?? this.redirected,
      responseType: update.responseType ?? this.responseType
    });
  }
};
var HttpErrorResponse = class extends HttpResponseBase {
  name = "HttpErrorResponse";
  message;
  error;
  ok = false;
  constructor(init) {
    super(init, 0, "Unknown Error");
    if (this.status >= 200 && this.status < 300) {
      this.message = `Http failure during parsing for ${init.url || "(unknown url)"}`;
    } else {
      this.message = `Http failure response for ${init.url || "(unknown url)"}: ${init.status} ${init.statusText}`;
    }
    this.error = init.error || null;
  }
};
var HTTP_STATUS_CODE_OK = 200;
var HTTP_STATUS_CODE_NO_CONTENT = 204;
var HttpStatusCode;
(function(HttpStatusCode2) {
  HttpStatusCode2[HttpStatusCode2["Continue"] = 100] = "Continue";
  HttpStatusCode2[HttpStatusCode2["SwitchingProtocols"] = 101] = "SwitchingProtocols";
  HttpStatusCode2[HttpStatusCode2["Processing"] = 102] = "Processing";
  HttpStatusCode2[HttpStatusCode2["EarlyHints"] = 103] = "EarlyHints";
  HttpStatusCode2[HttpStatusCode2["Ok"] = 200] = "Ok";
  HttpStatusCode2[HttpStatusCode2["Created"] = 201] = "Created";
  HttpStatusCode2[HttpStatusCode2["Accepted"] = 202] = "Accepted";
  HttpStatusCode2[HttpStatusCode2["NonAuthoritativeInformation"] = 203] = "NonAuthoritativeInformation";
  HttpStatusCode2[HttpStatusCode2["NoContent"] = 204] = "NoContent";
  HttpStatusCode2[HttpStatusCode2["ResetContent"] = 205] = "ResetContent";
  HttpStatusCode2[HttpStatusCode2["PartialContent"] = 206] = "PartialContent";
  HttpStatusCode2[HttpStatusCode2["MultiStatus"] = 207] = "MultiStatus";
  HttpStatusCode2[HttpStatusCode2["AlreadyReported"] = 208] = "AlreadyReported";
  HttpStatusCode2[HttpStatusCode2["ImUsed"] = 226] = "ImUsed";
  HttpStatusCode2[HttpStatusCode2["MultipleChoices"] = 300] = "MultipleChoices";
  HttpStatusCode2[HttpStatusCode2["MovedPermanently"] = 301] = "MovedPermanently";
  HttpStatusCode2[HttpStatusCode2["Found"] = 302] = "Found";
  HttpStatusCode2[HttpStatusCode2["SeeOther"] = 303] = "SeeOther";
  HttpStatusCode2[HttpStatusCode2["NotModified"] = 304] = "NotModified";
  HttpStatusCode2[HttpStatusCode2["UseProxy"] = 305] = "UseProxy";
  HttpStatusCode2[HttpStatusCode2["Unused"] = 306] = "Unused";
  HttpStatusCode2[HttpStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
  HttpStatusCode2[HttpStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
  HttpStatusCode2[HttpStatusCode2["BadRequest"] = 400] = "BadRequest";
  HttpStatusCode2[HttpStatusCode2["Unauthorized"] = 401] = "Unauthorized";
  HttpStatusCode2[HttpStatusCode2["PaymentRequired"] = 402] = "PaymentRequired";
  HttpStatusCode2[HttpStatusCode2["Forbidden"] = 403] = "Forbidden";
  HttpStatusCode2[HttpStatusCode2["NotFound"] = 404] = "NotFound";
  HttpStatusCode2[HttpStatusCode2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
  HttpStatusCode2[HttpStatusCode2["NotAcceptable"] = 406] = "NotAcceptable";
  HttpStatusCode2[HttpStatusCode2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
  HttpStatusCode2[HttpStatusCode2["RequestTimeout"] = 408] = "RequestTimeout";
  HttpStatusCode2[HttpStatusCode2["Conflict"] = 409] = "Conflict";
  HttpStatusCode2[HttpStatusCode2["Gone"] = 410] = "Gone";
  HttpStatusCode2[HttpStatusCode2["LengthRequired"] = 411] = "LengthRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionFailed"] = 412] = "PreconditionFailed";
  HttpStatusCode2[HttpStatusCode2["PayloadTooLarge"] = 413] = "PayloadTooLarge";
  HttpStatusCode2[HttpStatusCode2["UriTooLong"] = 414] = "UriTooLong";
  HttpStatusCode2[HttpStatusCode2["UnsupportedMediaType"] = 415] = "UnsupportedMediaType";
  HttpStatusCode2[HttpStatusCode2["RangeNotSatisfiable"] = 416] = "RangeNotSatisfiable";
  HttpStatusCode2[HttpStatusCode2["ExpectationFailed"] = 417] = "ExpectationFailed";
  HttpStatusCode2[HttpStatusCode2["ImATeapot"] = 418] = "ImATeapot";
  HttpStatusCode2[HttpStatusCode2["MisdirectedRequest"] = 421] = "MisdirectedRequest";
  HttpStatusCode2[HttpStatusCode2["UnprocessableEntity"] = 422] = "UnprocessableEntity";
  HttpStatusCode2[HttpStatusCode2["Locked"] = 423] = "Locked";
  HttpStatusCode2[HttpStatusCode2["FailedDependency"] = 424] = "FailedDependency";
  HttpStatusCode2[HttpStatusCode2["TooEarly"] = 425] = "TooEarly";
  HttpStatusCode2[HttpStatusCode2["UpgradeRequired"] = 426] = "UpgradeRequired";
  HttpStatusCode2[HttpStatusCode2["PreconditionRequired"] = 428] = "PreconditionRequired";
  HttpStatusCode2[HttpStatusCode2["TooManyRequests"] = 429] = "TooManyRequests";
  HttpStatusCode2[HttpStatusCode2["RequestHeaderFieldsTooLarge"] = 431] = "RequestHeaderFieldsTooLarge";
  HttpStatusCode2[HttpStatusCode2["UnavailableForLegalReasons"] = 451] = "UnavailableForLegalReasons";
  HttpStatusCode2[HttpStatusCode2["InternalServerError"] = 500] = "InternalServerError";
  HttpStatusCode2[HttpStatusCode2["NotImplemented"] = 501] = "NotImplemented";
  HttpStatusCode2[HttpStatusCode2["BadGateway"] = 502] = "BadGateway";
  HttpStatusCode2[HttpStatusCode2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
  HttpStatusCode2[HttpStatusCode2["GatewayTimeout"] = 504] = "GatewayTimeout";
  HttpStatusCode2[HttpStatusCode2["HttpVersionNotSupported"] = 505] = "HttpVersionNotSupported";
  HttpStatusCode2[HttpStatusCode2["VariantAlsoNegotiates"] = 506] = "VariantAlsoNegotiates";
  HttpStatusCode2[HttpStatusCode2["InsufficientStorage"] = 507] = "InsufficientStorage";
  HttpStatusCode2[HttpStatusCode2["LoopDetected"] = 508] = "LoopDetected";
  HttpStatusCode2[HttpStatusCode2["NotExtended"] = 510] = "NotExtended";
  HttpStatusCode2[HttpStatusCode2["NetworkAuthenticationRequired"] = 511] = "NetworkAuthenticationRequired";
})(HttpStatusCode || (HttpStatusCode = {}));
var XSSI_PREFIX$1 = /^\)\]\}',?\n/;
var FETCH_BACKEND = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "FETCH_BACKEND" : "");
var FetchBackend = class _FetchBackend {
  fetchImpl = inject(FetchFactory, {
    optional: true
  })?.fetch ?? ((...args) => globalThis.fetch(...args));
  ngZone = inject(NgZone);
  destroyRef = inject(DestroyRef);
  handle(request) {
    return new Observable((observer) => {
      const aborter = new AbortController();
      this.doRequest(request, aborter.signal, observer).then(noop, (error) => observer.error(new HttpErrorResponse({
        error
      })));
      let timeoutId;
      if (request.timeout) {
        timeoutId = this.ngZone.runOutsideAngular(() => setTimeout(() => {
          if (!aborter.signal.aborted) {
            aborter.abort(new DOMException("signal timed out", "TimeoutError"));
          }
        }, request.timeout));
      }
      return () => {
        if (timeoutId !== void 0) {
          clearTimeout(timeoutId);
        }
        aborter.abort();
      };
    });
  }
  doRequest(request, signal2, observer) {
    return __async(this, null, function* () {
      const init = this.createRequestInit(request);
      let response;
      try {
        const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({
          signal: signal2
        }, init)));
        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);
        observer.next({
          type: HttpEventType.Sent
        });
        response = yield fetchPromise;
      } catch (error) {
        observer.error(new HttpErrorResponse({
          error,
          status: error.status ?? 0,
          statusText: error.statusText,
          url: request.urlWithParams,
          headers: error.headers
        }));
        return;
      }
      const headers = new HttpHeaders(response.headers);
      const statusText = response.statusText;
      const url = response.url || request.urlWithParams;
      let status = response.status;
      let body = null;
      if (request.reportProgress) {
        observer.next(new HttpHeaderResponse({
          headers,
          status,
          statusText,
          url
        }));
      }
      if (response.body) {
        const contentLength = response.headers.get("content-length");
        const chunks = [];
        const reader = response.body.getReader();
        let receivedLength = 0;
        let decoder;
        let partialText;
        const reqZone = typeof Zone !== "undefined" && Zone.current;
        let canceled = false;
        yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {
          while (true) {
            if (this.destroyRef.destroyed) {
              yield reader.cancel();
              canceled = true;
              break;
            }
            const {
              done,
              value
            } = yield reader.read();
            if (done) {
              break;
            }
            chunks.push(value);
            receivedLength += value.length;
            if (request.reportProgress) {
              partialText = request.responseType === "text" ? (partialText ?? "") + (decoder ??= new TextDecoder()).decode(value, {
                stream: true
              }) : void 0;
              const reportProgress = () => observer.next({
                type: HttpEventType.DownloadProgress,
                total: contentLength ? +contentLength : void 0,
                loaded: receivedLength,
                partialText
              });
              reqZone ? reqZone.run(reportProgress) : reportProgress();
            }
          }
        }));
        if (canceled) {
          observer.complete();
          return;
        }
        const chunksAll = this.concatChunks(chunks, receivedLength);
        try {
          const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? "";
          body = this.parseBody(request, chunksAll, contentType, status);
        } catch (error) {
          observer.error(new HttpErrorResponse({
            error,
            headers: new HttpHeaders(response.headers),
            status: response.status,
            statusText: response.statusText,
            url: response.url || request.urlWithParams
          }));
          return;
        }
      }
      if (status === 0) {
        status = body ? HTTP_STATUS_CODE_OK : 0;
      }
      const ok = status >= 200 && status < 300;
      const redirected = response.redirected;
      const responseType = response.type;
      if (ok) {
        observer.next(new HttpResponse({
          body,
          headers,
          status,
          statusText,
          url,
          redirected,
          responseType
        }));
        observer.complete();
      } else {
        observer.error(new HttpErrorResponse({
          error: body,
          headers,
          status,
          statusText,
          url,
          redirected,
          responseType
        }));
      }
    });
  }
  parseBody(request, binContent, contentType, status) {
    switch (request.responseType) {
      case "json":
        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, "");
        if (text === "") {
          return null;
        }
        try {
          return JSON.parse(text);
        } catch (e) {
          if (status < 200 || status >= 300) {
            return text;
          }
          throw e;
        }
      case "text":
        return new TextDecoder().decode(binContent);
      case "blob":
        return new Blob([binContent], {
          type: contentType
        });
      case "arraybuffer":
        return binContent.buffer;
    }
  }
  createRequestInit(req) {
    const headers = {};
    let credentials;
    credentials = req.credentials;
    if (req.withCredentials) {
      (typeof ngDevMode === "undefined" || ngDevMode) && warningOptionsMessage(req);
      credentials = "include";
    }
    req.headers.forEach((name, values) => headers[name] = values.join(","));
    if (!req.headers.has(ACCEPT_HEADER)) {
      headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;
    }
    if (!req.headers.has(CONTENT_TYPE_HEADER)) {
      const detectedType = req.detectContentTypeHeader();
      if (detectedType !== null) {
        headers[CONTENT_TYPE_HEADER] = detectedType;
      }
    }
    return {
      body: req.serializeBody(),
      method: req.method,
      headers,
      credentials,
      keepalive: req.keepalive,
      cache: req.cache,
      priority: req.priority,
      mode: req.mode,
      redirect: req.redirect,
      referrer: req.referrer,
      integrity: req.integrity,
      referrerPolicy: req.referrerPolicy
    };
  }
  concatChunks(chunks, totalLength) {
    const chunksAll = new Uint8Array(totalLength);
    let position = 0;
    for (const chunk of chunks) {
      chunksAll.set(chunk, position);
      position += chunk.length;
    }
    return chunksAll;
  }
  static \u0275fac = function FetchBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FetchBackend)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FetchBackend,
    factory: _FetchBackend.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FetchBackend, [{
    type: Injectable
  }], null, null);
})();
var FetchFactory = class {
};
function noop() {
}
function warningOptionsMessage(req) {
  if (req.credentials && req.withCredentials) {
    console.warn(formatRuntimeError(2819, `Angular detected that a \`HttpClient\` request has both \`withCredentials: true\` and \`credentials: '${req.credentials}'\` options. The \`withCredentials\` option is overriding the explicit \`credentials\` setting to 'include'. Consider removing \`withCredentials\` and using \`credentials: '${req.credentials}'\` directly for clarity.`));
  }
}
function silenceSuperfluousUnhandledPromiseRejection(promise) {
  promise.then(noop, noop);
}
var XSSI_PREFIX = /^\)\]\}',?\n/;
function validateXhrCompatibility(req) {
  const unsupportedOptions = [{
    property: "keepalive",
    errorCode: 2813
  }, {
    property: "cache",
    errorCode: 2814
  }, {
    property: "priority",
    errorCode: 2815
  }, {
    property: "mode",
    errorCode: 2816
  }, {
    property: "redirect",
    errorCode: 2817
  }, {
    property: "credentials",
    errorCode: 2818
  }, {
    property: "integrity",
    errorCode: 2820
  }, {
    property: "referrer",
    errorCode: 2821
  }, {
    property: "referrerPolicy",
    errorCode: 2823
  }];
  for (const {
    property,
    errorCode
  } of unsupportedOptions) {
    if (req[property]) {
      console.warn(formatRuntimeError(errorCode, `Angular detected that a \`HttpClient\` request with the \`${property}\` option was sent using XHR, which does not support it. To use the \`${property}\` option, enable Fetch API support by passing \`withFetch()\` as an argument to \`provideHttpClient()\`.`));
    }
  }
}
var HttpXhrBackend = class _HttpXhrBackend {
  xhrFactory;
  tracingService = inject(TracingService, {
    optional: true
  });
  constructor(xhrFactory) {
    this.xhrFactory = xhrFactory;
  }
  maybePropagateTrace(fn) {
    return this.tracingService?.propagate ? this.tracingService.propagate(fn) : fn;
  }
  handle(req) {
    if (req.method === "JSONP") {
      throw new RuntimeError(-2800, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \`withJsonpSupport()\` call (if \`provideHttpClient()\` is used) or import the \`HttpClientJsonpModule\` in the root NgModule.`);
    }
    ngDevMode && validateXhrCompatibility(req);
    const xhrFactory = this.xhrFactory;
    const source = false ? from(xhrFactory.\u0275loadImpl()) : of(null);
    return source.pipe(switchMap(() => {
      return new Observable((observer) => {
        const xhr = xhrFactory.build();
        xhr.open(req.method, req.urlWithParams);
        if (req.withCredentials) {
          xhr.withCredentials = true;
        }
        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(",")));
        if (!req.headers.has(ACCEPT_HEADER)) {
          xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);
        }
        if (!req.headers.has(CONTENT_TYPE_HEADER)) {
          const detectedType = req.detectContentTypeHeader();
          if (detectedType !== null) {
            xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);
          }
        }
        if (req.timeout) {
          xhr.timeout = req.timeout;
        }
        if (req.responseType) {
          const responseType = req.responseType.toLowerCase();
          xhr.responseType = responseType !== "json" ? responseType : "text";
        }
        const reqBody = req.serializeBody();
        let headerResponse = null;
        const partialFromXhr = () => {
          if (headerResponse !== null) {
            return headerResponse;
          }
          const statusText = xhr.statusText || "OK";
          const headers = new HttpHeaders(xhr.getAllResponseHeaders());
          const url = xhr.responseURL || req.url;
          headerResponse = new HttpHeaderResponse({
            headers,
            status: xhr.status,
            statusText,
            url
          });
          return headerResponse;
        };
        const onLoad = this.maybePropagateTrace(() => {
          let {
            headers,
            status,
            statusText,
            url
          } = partialFromXhr();
          let body = null;
          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {
            body = typeof xhr.response === "undefined" ? xhr.responseText : xhr.response;
          }
          if (status === 0) {
            status = !!body ? HTTP_STATUS_CODE_OK : 0;
          }
          let ok = status >= 200 && status < 300;
          if (req.responseType === "json" && typeof body === "string") {
            const originalBody = body;
            body = body.replace(XSSI_PREFIX, "");
            try {
              body = body !== "" ? JSON.parse(body) : null;
            } catch (error) {
              body = originalBody;
              if (ok) {
                ok = false;
                body = {
                  error,
                  text: body
                };
              }
            }
          }
          if (ok) {
            observer.next(new HttpResponse({
              body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
            observer.complete();
          } else {
            observer.error(new HttpErrorResponse({
              error: body,
              headers,
              status,
              statusText,
              url: url || void 0
            }));
          }
        });
        const onError = this.maybePropagateTrace((error) => {
          const {
            url
          } = partialFromXhr();
          const res = new HttpErrorResponse({
            error,
            status: xhr.status || 0,
            statusText: xhr.statusText || "Unknown Error",
            url: url || void 0
          });
          observer.error(res);
        });
        let onTimeout = onError;
        if (req.timeout) {
          onTimeout = this.maybePropagateTrace((_) => {
            const {
              url
            } = partialFromXhr();
            const res = new HttpErrorResponse({
              error: new DOMException("Request timed out", "TimeoutError"),
              status: xhr.status || 0,
              statusText: xhr.statusText || "Request timeout",
              url: url || void 0
            });
            observer.error(res);
          });
        }
        let sentHeaders = false;
        const onDownProgress = this.maybePropagateTrace((event) => {
          if (!sentHeaders) {
            observer.next(partialFromXhr());
            sentHeaders = true;
          }
          let progressEvent = {
            type: HttpEventType.DownloadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progressEvent.total = event.total;
          }
          if (req.responseType === "text" && !!xhr.responseText) {
            progressEvent.partialText = xhr.responseText;
          }
          observer.next(progressEvent);
        });
        const onUpProgress = this.maybePropagateTrace((event) => {
          let progress = {
            type: HttpEventType.UploadProgress,
            loaded: event.loaded
          };
          if (event.lengthComputable) {
            progress.total = event.total;
          }
          observer.next(progress);
        });
        xhr.addEventListener("load", onLoad);
        xhr.addEventListener("error", onError);
        xhr.addEventListener("timeout", onTimeout);
        xhr.addEventListener("abort", onError);
        if (req.reportProgress) {
          xhr.addEventListener("progress", onDownProgress);
          if (reqBody !== null && xhr.upload) {
            xhr.upload.addEventListener("progress", onUpProgress);
          }
        }
        xhr.send(reqBody);
        observer.next({
          type: HttpEventType.Sent
        });
        return () => {
          xhr.removeEventListener("error", onError);
          xhr.removeEventListener("abort", onError);
          xhr.removeEventListener("load", onLoad);
          xhr.removeEventListener("timeout", onTimeout);
          if (req.reportProgress) {
            xhr.removeEventListener("progress", onDownProgress);
            if (reqBody !== null && xhr.upload) {
              xhr.upload.removeEventListener("progress", onUpProgress);
            }
          }
          if (xhr.readyState !== xhr.DONE) {
            xhr.abort();
          }
        };
      });
    }));
  }
  static \u0275fac = function HttpXhrBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXhrBackend)(\u0275\u0275inject(XhrFactory));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXhrBackend,
    factory: _HttpXhrBackend.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: XhrFactory
  }], null);
})();
function interceptorChainEndFn(req, finalHandlerFn) {
  return finalHandlerFn(req);
}
function adaptLegacyInterceptorToChain(chainTailFn, interceptor) {
  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {
    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)
  });
}
function chainedInterceptorFn(chainTailFn, interceptorFn, injector) {
  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));
}
var HTTP_INTERCEPTORS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "HTTP_INTERCEPTORS" : "");
var HTTP_INTERCEPTOR_FNS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "HTTP_INTERCEPTOR_FNS" : "", {
  factory: () => []
});
var HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "HTTP_ROOT_INTERCEPTOR_FNS" : "");
var REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "REQUESTS_CONTRIBUTE_TO_STABILITY" : "", {
  factory: () => true
});
function legacyInterceptorFnFactory() {
  let chain = null;
  return (req, handler) => {
    if (chain === null) {
      const interceptors = inject(HTTP_INTERCEPTORS, {
        optional: true
      }) ?? [];
      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);
    }
    const pendingTasks = inject(PendingTasks);
    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
    if (contributeToStability) {
      const removeTask = pendingTasks.add();
      return chain(req, handler).pipe(finalize(removeTask));
    } else {
      return chain(req, handler);
    }
  };
}
var HttpBackend = class _HttpBackend {
  static \u0275fac = function HttpBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpBackend)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpBackend,
    factory: function HttpBackend_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _HttpBackend)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(HttpXhrBackend);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpBackend, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: HttpXhrBackend
    }]
  }], null, null);
})();
var fetchBackendWarningDisplayed = false;
var HttpInterceptorHandler = class _HttpInterceptorHandler {
  backend;
  injector;
  chain = null;
  pendingTasks = inject(PendingTasks);
  contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);
  constructor(backend, injector) {
    this.backend = backend;
    this.injector = injector;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !fetchBackendWarningDisplayed) {
      const isTestingBackend = this.backend.isTestingBackend;
      if (false) {
        fetchBackendWarningDisplayed = true;
        injector.get(Console).warn(formatRuntimeError(2801, "Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application."));
      }
    }
  }
  handle(initialRequest) {
    if (this.chain === null) {
      const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));
      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);
    }
    if (this.contributeToStability) {
      const removeTask = this.pendingTasks.add();
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(removeTask));
    } else {
      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));
    }
  }
  static \u0275fac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpInterceptorHandler)(\u0275\u0275inject(HttpBackend), \u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpInterceptorHandler,
    factory: _HttpInterceptorHandler.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpBackend
  }, {
    type: EnvironmentInjector
  }], null);
})();
var HttpHandler = class _HttpHandler {
  static \u0275fac = function HttpHandler_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpHandler)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpHandler,
    factory: function HttpHandler_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _HttpHandler)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(HttpInterceptorHandler);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpHandler, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: HttpInterceptorHandler
    }]
  }], null, null);
})();
function addBody(options, body) {
  return {
    body,
    headers: options.headers,
    context: options.context,
    observe: options.observe,
    params: options.params,
    reportProgress: options.reportProgress,
    responseType: options.responseType,
    withCredentials: options.withCredentials,
    credentials: options.credentials,
    transferCache: options.transferCache,
    timeout: options.timeout,
    keepalive: options.keepalive,
    priority: options.priority,
    cache: options.cache,
    mode: options.mode,
    redirect: options.redirect,
    integrity: options.integrity,
    referrer: options.referrer,
    referrerPolicy: options.referrerPolicy
  };
}
var HttpClient = class _HttpClient {
  handler;
  constructor(handler) {
    this.handler = handler;
  }
  request(first2, url, options = {}) {
    let req;
    if (first2 instanceof HttpRequest) {
      req = first2;
    } else {
      let headers = void 0;
      if (options.headers instanceof HttpHeaders) {
        headers = options.headers;
      } else {
        headers = new HttpHeaders(options.headers);
      }
      let params = void 0;
      if (!!options.params) {
        if (options.params instanceof HttpParams) {
          params = options.params;
        } else {
          params = new HttpParams({
            fromObject: options.params
          });
        }
      }
      req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {
        headers,
        context: options.context,
        params,
        reportProgress: options.reportProgress,
        responseType: options.responseType || "json",
        withCredentials: options.withCredentials,
        transferCache: options.transferCache,
        keepalive: options.keepalive,
        priority: options.priority,
        cache: options.cache,
        mode: options.mode,
        redirect: options.redirect,
        credentials: options.credentials,
        referrer: options.referrer,
        referrerPolicy: options.referrerPolicy,
        integrity: options.integrity,
        timeout: options.timeout
      });
    }
    const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));
    if (first2 instanceof HttpRequest || options.observe === "events") {
      return events$;
    }
    const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));
    switch (options.observe || "body") {
      case "body":
        switch (req.responseType) {
          case "arraybuffer":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                throw new RuntimeError(2806, ngDevMode && "Response is not an ArrayBuffer.");
              }
              return res.body;
            }));
          case "blob":
            return res$.pipe(map((res) => {
              if (res.body !== null && !(res.body instanceof Blob)) {
                throw new RuntimeError(2807, ngDevMode && "Response is not a Blob.");
              }
              return res.body;
            }));
          case "text":
            return res$.pipe(map((res) => {
              if (res.body !== null && typeof res.body !== "string") {
                throw new RuntimeError(2808, ngDevMode && "Response is not a string.");
              }
              return res.body;
            }));
          case "json":
          default:
            return res$.pipe(map((res) => res.body));
        }
      case "response":
        return res$;
      default:
        throw new RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);
    }
  }
  delete(url, options = {}) {
    return this.request("DELETE", url, options);
  }
  get(url, options = {}) {
    return this.request("GET", url, options);
  }
  head(url, options = {}) {
    return this.request("HEAD", url, options);
  }
  jsonp(url, callbackParam) {
    return this.request("JSONP", url, {
      params: new HttpParams().append(callbackParam, "JSONP_CALLBACK"),
      observe: "body",
      responseType: "json"
    });
  }
  options(url, options = {}) {
    return this.request("OPTIONS", url, options);
  }
  patch(url, body, options = {}) {
    return this.request("PATCH", url, addBody(options, body));
  }
  post(url, body, options = {}) {
    return this.request("POST", url, addBody(options, body));
  }
  put(url, body, options = {}) {
    return this.request("PUT", url, addBody(options, body));
  }
  static \u0275fac = function HttpClient_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClient)(\u0275\u0275inject(HttpHandler));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpClient,
    factory: _HttpClient.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClient, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: HttpHandler
  }], null);
})();
var nextRequestId = 0;
var foreignDocument;
var JSONP_ERR_NO_CALLBACK = "JSONP injected script did not invoke callback.";
var JSONP_ERR_WRONG_METHOD = "JSONP requests must use JSONP request method.";
var JSONP_ERR_WRONG_RESPONSE_TYPE = "JSONP requests must use Json response type.";
var JSONP_ERR_HEADERS_NOT_SUPPORTED = "JSONP requests do not support headers.";
var JsonpCallbackContext = class {
};
function jsonpCallbackContext() {
  if (typeof window === "object") {
    return window;
  }
  return {};
}
var JsonpClientBackend = class _JsonpClientBackend {
  callbackMap;
  document;
  resolvedPromise = Promise.resolve();
  constructor(callbackMap, document2) {
    this.callbackMap = callbackMap;
    this.document = document2;
  }
  nextCallback() {
    return `ng_jsonp_callback_${nextRequestId++}`;
  }
  handle(req) {
    if (req.method !== "JSONP") {
      throw new RuntimeError(2810, ngDevMode && JSONP_ERR_WRONG_METHOD);
    } else if (req.responseType !== "json") {
      throw new RuntimeError(2811, ngDevMode && JSONP_ERR_WRONG_RESPONSE_TYPE);
    }
    if (req.headers.keys().length > 0) {
      throw new RuntimeError(2812, ngDevMode && JSONP_ERR_HEADERS_NOT_SUPPORTED);
    }
    return new Observable((observer) => {
      const callback = this.nextCallback();
      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);
      const node = this.document.createElement("script");
      node.src = url;
      let body = null;
      let finished = false;
      this.callbackMap[callback] = (data) => {
        delete this.callbackMap[callback];
        body = data;
        finished = true;
      };
      const cleanup = () => {
        node.removeEventListener("load", onLoad);
        node.removeEventListener("error", onError);
        node.remove();
        delete this.callbackMap[callback];
      };
      const onLoad = () => {
        this.resolvedPromise.then(() => {
          cleanup();
          if (!finished) {
            observer.error(new HttpErrorResponse({
              url,
              status: 0,
              statusText: "JSONP Error",
              error: new Error(JSONP_ERR_NO_CALLBACK)
            }));
            return;
          }
          observer.next(new HttpResponse({
            body,
            status: HTTP_STATUS_CODE_OK,
            statusText: "OK",
            url
          }));
          observer.complete();
        });
      };
      const onError = (error) => {
        cleanup();
        observer.error(new HttpErrorResponse({
          error,
          status: 0,
          statusText: "JSONP Error",
          url
        }));
      };
      node.addEventListener("load", onLoad);
      node.addEventListener("error", onError);
      this.document.body.appendChild(node);
      observer.next({
        type: HttpEventType.Sent
      });
      return () => {
        if (!finished) {
          this.removeListeners(node);
        }
        cleanup();
      };
    });
  }
  removeListeners(script) {
    foreignDocument ??= this.document.implementation.createHTMLDocument();
    foreignDocument.adoptNode(script);
  }
  static \u0275fac = function JsonpClientBackend_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _JsonpClientBackend)(\u0275\u0275inject(JsonpCallbackContext), \u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _JsonpClientBackend,
    factory: _JsonpClientBackend.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{
    type: Injectable
  }], () => [{
    type: JsonpCallbackContext
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
function jsonpInterceptorFn(req, next) {
  if (req.method === "JSONP") {
    return inject(JsonpClientBackend).handle(req);
  }
  return next(req);
}
var JsonpInterceptor = class _JsonpInterceptor {
  injector;
  constructor(injector) {
    this.injector = injector;
  }
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static \u0275fac = function JsonpInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _JsonpInterceptor)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _JsonpInterceptor,
    factory: _JsonpInterceptor.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{
    type: Injectable
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var XSRF_ENABLED = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "XSRF_ENABLED" : "", {
  factory: () => true
});
var XSRF_DEFAULT_COOKIE_NAME = "XSRF-TOKEN";
var XSRF_COOKIE_NAME = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "XSRF_COOKIE_NAME" : "", {
  factory: () => XSRF_DEFAULT_COOKIE_NAME
});
var XSRF_DEFAULT_HEADER_NAME = "X-XSRF-TOKEN";
var XSRF_HEADER_NAME = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "XSRF_HEADER_NAME" : "", {
  providedIn: "root",
  factory: () => XSRF_DEFAULT_HEADER_NAME
});
var HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {
  cookieName = inject(XSRF_COOKIE_NAME);
  doc = inject(DOCUMENT);
  lastCookieString = "";
  lastToken = null;
  parseCount = 0;
  getToken() {
    if (false) {
      return null;
    }
    const cookieString = this.doc.cookie || "";
    if (cookieString !== this.lastCookieString) {
      this.parseCount++;
      this.lastToken = parseCookieValue(cookieString, this.cookieName);
      this.lastCookieString = cookieString;
    }
    return this.lastToken;
  }
  static \u0275fac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXsrfCookieExtractor,
    factory: _HttpXsrfCookieExtractor.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var HttpXsrfTokenExtractor = class _HttpXsrfTokenExtractor {
  static \u0275fac = function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXsrfTokenExtractor)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXsrfTokenExtractor,
    factory: function HttpXsrfTokenExtractor_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _HttpXsrfTokenExtractor)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(HttpXsrfCookieExtractor);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfTokenExtractor, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: HttpXsrfCookieExtractor
    }]
  }], null, null);
})();
function xsrfInterceptorFn(req, next) {
  if (!inject(XSRF_ENABLED) || req.method === "GET" || req.method === "HEAD") {
    return next(req);
  }
  try {
    const locationHref = inject(PlatformLocation).href;
    const {
      origin: locationOrigin
    } = new URL(locationHref);
    const {
      origin: requestOrigin
    } = new URL(req.url, locationOrigin);
    if (locationOrigin !== requestOrigin) {
      return next(req);
    }
  } catch {
    return next(req);
  }
  const token = inject(HttpXsrfTokenExtractor).getToken();
  const headerName = inject(XSRF_HEADER_NAME);
  if (token != null && !req.headers.has(headerName)) {
    req = req.clone({
      headers: req.headers.set(headerName, token)
    });
  }
  return next(req);
}
var HttpXsrfInterceptor = class _HttpXsrfInterceptor {
  injector = inject(EnvironmentInjector);
  intercept(initialRequest, next) {
    return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));
  }
  static \u0275fac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpXsrfInterceptor)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HttpXsrfInterceptor,
    factory: _HttpXsrfInterceptor.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{
    type: Injectable
  }], null, null);
})();
var HttpFeatureKind;
(function(HttpFeatureKind2) {
  HttpFeatureKind2[HttpFeatureKind2["Interceptors"] = 0] = "Interceptors";
  HttpFeatureKind2[HttpFeatureKind2["LegacyInterceptors"] = 1] = "LegacyInterceptors";
  HttpFeatureKind2[HttpFeatureKind2["CustomXsrfConfiguration"] = 2] = "CustomXsrfConfiguration";
  HttpFeatureKind2[HttpFeatureKind2["NoXsrfProtection"] = 3] = "NoXsrfProtection";
  HttpFeatureKind2[HttpFeatureKind2["JsonpSupport"] = 4] = "JsonpSupport";
  HttpFeatureKind2[HttpFeatureKind2["RequestsMadeViaParent"] = 5] = "RequestsMadeViaParent";
  HttpFeatureKind2[HttpFeatureKind2["Fetch"] = 6] = "Fetch";
})(HttpFeatureKind || (HttpFeatureKind = {}));
function makeHttpFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
function provideHttpClient(...features) {
  if (ngDevMode) {
    const featureKinds = new Set(features.map((f) => f.\u0275kind));
    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {
      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : "");
    }
  }
  const providers = [HttpClient, HttpInterceptorHandler, {
    provide: HttpHandler,
    useExisting: HttpInterceptorHandler
  }, {
    provide: HttpBackend,
    useFactory: () => {
      return inject(FETCH_BACKEND, {
        optional: true
      }) ?? inject(HttpXhrBackend);
    }
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: xsrfInterceptorFn,
    multi: true
  }];
  for (const feature of features) {
    providers.push(...feature.\u0275providers);
  }
  return makeEnvironmentProviders(providers);
}
var LEGACY_INTERCEPTOR_FN = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "LEGACY_INTERCEPTOR_FN" : "");
function withInterceptorsFromDi() {
  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{
    provide: LEGACY_INTERCEPTOR_FN,
    useFactory: legacyInterceptorFnFactory
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useExisting: LEGACY_INTERCEPTOR_FN,
    multi: true
  }]);
}
function withXsrfConfiguration({
  cookieName,
  headerName
}) {
  const providers = [];
  if (cookieName !== void 0) {
    providers.push({
      provide: XSRF_COOKIE_NAME,
      useValue: cookieName
    });
  }
  if (headerName !== void 0) {
    providers.push({
      provide: XSRF_HEADER_NAME,
      useValue: headerName
    });
  }
  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);
}
function withNoXsrfProtection() {
  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{
    provide: XSRF_ENABLED,
    useValue: false
  }]);
}
function withJsonpSupport() {
  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {
    provide: JsonpCallbackContext,
    useFactory: jsonpCallbackContext
  }, {
    provide: HTTP_INTERCEPTOR_FNS,
    useValue: jsonpInterceptorFn,
    multi: true
  }]);
}
var HttpClientXsrfModule = class _HttpClientXsrfModule {
  static disable() {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: [withNoXsrfProtection().\u0275providers]
    };
  }
  static withOptions(options = {}) {
    return {
      ngModule: _HttpClientXsrfModule,
      providers: withXsrfConfiguration(options).\u0275providers
    };
  }
  static \u0275fac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientXsrfModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientXsrfModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [HttpXsrfInterceptor, {
      provide: HTTP_INTERCEPTORS,
      useExisting: HttpXsrfInterceptor,
      multi: true
    }, {
      provide: HttpXsrfTokenExtractor,
      useClass: HttpXsrfCookieExtractor
    }, withXsrfConfiguration({
      cookieName: XSRF_DEFAULT_COOKIE_NAME,
      headerName: XSRF_DEFAULT_HEADER_NAME
    }).\u0275providers, {
      provide: XSRF_ENABLED,
      useValue: true
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{
    type: NgModule,
    args: [{
      providers: [HttpXsrfInterceptor, {
        provide: HTTP_INTERCEPTORS,
        useExisting: HttpXsrfInterceptor,
        multi: true
      }, {
        provide: HttpXsrfTokenExtractor,
        useClass: HttpXsrfCookieExtractor
      }, withXsrfConfiguration({
        cookieName: XSRF_DEFAULT_COOKIE_NAME,
        headerName: XSRF_DEFAULT_HEADER_NAME
      }).\u0275providers, {
        provide: XSRF_ENABLED,
        useValue: true
      }]
    }]
  }], null, null);
})();
var HttpClientModule = class _HttpClientModule {
  static \u0275fac = function HttpClientModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [provideHttpClient(withInterceptorsFromDi())]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientModule, [{
    type: NgModule,
    args: [{
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
var HttpClientJsonpModule = class _HttpClientJsonpModule {
  static \u0275fac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HttpClientJsonpModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HttpClientJsonpModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [withJsonpSupport().\u0275providers]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{
    type: NgModule,
    args: [{
      providers: [withJsonpSupport().\u0275providers]
    }]
  }], null, null);
})();

// node_modules/@angular/common/fesm2022/http.mjs
var httpResource = (() => {
  const jsonFn = makeHttpResourceFn("json");
  jsonFn.arrayBuffer = makeHttpResourceFn("arraybuffer");
  jsonFn.blob = makeHttpResourceFn("blob");
  jsonFn.text = makeHttpResourceFn("text");
  return jsonFn;
})();
function makeHttpResourceFn(responseType) {
  return function httpResource2(request, options) {
    if (ngDevMode && !options?.injector) {
      assertInInjectionContext(httpResource2);
    }
    const injector = options?.injector ?? inject(Injector);
    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.debugName, options?.parse, options?.equal);
  };
}
function normalizeRequest(request, responseType) {
  let unwrappedRequest = typeof request === "function" ? request() : request;
  if (unwrappedRequest === void 0) {
    return void 0;
  } else if (typeof unwrappedRequest === "string") {
    unwrappedRequest = {
      url: unwrappedRequest
    };
  }
  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);
  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({
    fromObject: unwrappedRequest.params
  });
  return new HttpRequest(unwrappedRequest.method ?? "GET", unwrappedRequest.url, unwrappedRequest.body ?? null, {
    headers,
    params,
    reportProgress: unwrappedRequest.reportProgress,
    withCredentials: unwrappedRequest.withCredentials,
    keepalive: unwrappedRequest.keepalive,
    cache: unwrappedRequest.cache,
    priority: unwrappedRequest.priority,
    mode: unwrappedRequest.mode,
    redirect: unwrappedRequest.redirect,
    responseType,
    context: unwrappedRequest.context,
    transferCache: unwrappedRequest.transferCache,
    credentials: unwrappedRequest.credentials,
    referrer: unwrappedRequest.referrer,
    referrerPolicy: unwrappedRequest.referrerPolicy,
    integrity: unwrappedRequest.integrity,
    timeout: unwrappedRequest.timeout
  });
}
var HttpResourceImpl = class extends ResourceImpl {
  client;
  _headers = linkedSignal(__spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "_headers"
  } : {}), {
    source: this.extRequest,
    computation: () => void 0
  }));
  _progress = linkedSignal(__spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "_progress"
  } : {}), {
    source: this.extRequest,
    computation: () => void 0
  }));
  _statusCode = linkedSignal(__spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "_statusCode"
  } : {}), {
    source: this.extRequest,
    computation: () => void 0
  }));
  headers = computed(() => this.status() === "resolved" || this.status() === "error" ? this._headers() : void 0, ...ngDevMode ? [{
    debugName: "headers"
  }] : []);
  progress = this._progress.asReadonly();
  statusCode = this._statusCode.asReadonly();
  constructor(injector, request, defaultValue, debugName, parse, equal) {
    super(request, ({
      params: request2,
      abortSignal
    }) => {
      let sub;
      const onAbort = () => sub.unsubscribe();
      abortSignal.addEventListener("abort", onAbort);
      const stream = signal({
        value: void 0
      }, ...ngDevMode ? [{
        debugName: "stream"
      }] : []);
      let resolve;
      const promise = new Promise((r) => resolve = r);
      const send = (value) => {
        stream.set(value);
        resolve?.(stream);
        resolve = void 0;
      };
      sub = this.client.request(request2).subscribe({
        next: (event) => {
          switch (event.type) {
            case HttpEventType.Response:
              this._headers.set(event.headers);
              this._statusCode.set(event.status);
              try {
                send({
                  value: parse ? parse(event.body) : event.body
                });
              } catch (error) {
                send({
                  error: encapsulateResourceError(error)
                });
              }
              break;
            case HttpEventType.DownloadProgress:
              this._progress.set(event);
              break;
          }
        },
        error: (error) => {
          if (error instanceof HttpErrorResponse) {
            this._headers.set(error.headers);
            this._statusCode.set(error.status);
          }
          send({
            error
          });
          abortSignal.removeEventListener("abort", onAbort);
        },
        complete: () => {
          if (resolve) {
            send({
              error: new RuntimeError(991, ngDevMode && "Resource completed before producing a value")
            });
          }
          abortSignal.removeEventListener("abort", onAbort);
        }
      });
      return promise;
    }, defaultValue, equal, debugName, injector);
    this.client = injector.get(HttpClient);
  }
  set(value) {
    super.set(value);
    this._headers.set(void 0);
    this._progress.set(void 0);
    this._statusCode.set(void 0);
  }
};
var HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "HTTP_TRANSFER_CACHE_ORIGIN_MAP" : "");
var CACHE_OPTIONS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "HTTP_TRANSFER_STATE_CACHE_OPTIONS" : "");

// node_modules/@angular/platform-browser/fesm2022/_dom_renderer-chunk.mjs
var EventManagerPlugin = class {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  manager;
};
var DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return true;
  }
  addEventListener(element, eventName, handler, options) {
    element.addEventListener(eventName, handler, options);
    return () => this.removeEventListener(element, eventName, handler, options);
  }
  removeEventListener(target, eventName, callback, options) {
    return target.removeEventListener(eventName, callback, options);
  }
  static \u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomEventsPlugin)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomEventsPlugin,
    factory: _DomEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var EVENT_MANAGER_PLUGINS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "EventManagerPlugins" : "");
var EventManager = class _EventManager {
  _zone;
  _plugins;
  _eventNameToPlugin = /* @__PURE__ */ new Map();
  constructor(plugins, _zone) {
    this._zone = _zone;
    plugins.forEach((plugin) => {
      plugin.manager = this;
    });
    const otherPlugins = plugins.filter((p) => !(p instanceof DomEventsPlugin));
    this._plugins = otherPlugins.slice().reverse();
    const domEventPlugin = plugins.find((p) => p instanceof DomEventsPlugin);
    if (domEventPlugin) {
      this._plugins.push(domEventPlugin);
    }
  }
  addEventListener(element, eventName, handler, options) {
    const plugin = this._findPluginFor(eventName);
    return plugin.addEventListener(element, eventName, handler, options);
  }
  getZone() {
    return this._zone;
  }
  _findPluginFor(eventName) {
    let plugin = this._eventNameToPlugin.get(eventName);
    if (plugin) {
      return plugin;
    }
    const plugins = this._plugins;
    plugin = plugins.find((plugin2) => plugin2.supports(eventName));
    if (!plugin) {
      throw new RuntimeError(5101, (typeof ngDevMode === "undefined" || ngDevMode) && `No event manager plugin found for event ${eventName}`);
    }
    this._eventNameToPlugin.set(eventName, plugin);
    return plugin;
  }
  static \u0275fac = function EventManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _EventManager)(\u0275\u0275inject(EVENT_MANAGER_PLUGINS), \u0275\u0275inject(NgZone));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _EventManager,
    factory: _EventManager.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(EventManager, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [EVENT_MANAGER_PLUGINS]
    }]
  }, {
    type: NgZone
  }], null);
})();
var APP_ID_ATTRIBUTE_NAME = "ng-app-id";
function removeElements(elements) {
  for (const element of elements) {
    element.remove();
  }
}
function createStyleElement(style2, doc) {
  const styleElement = doc.createElement("style");
  styleElement.textContent = style2;
  return styleElement;
}
function addServerStyles(doc, appId, inline, external2) {
  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}="${appId}"],link[${APP_ID_ATTRIBUTE_NAME}="${appId}"]`);
  if (elements) {
    for (const styleElement of elements) {
      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);
      if (styleElement instanceof HTMLLinkElement) {
        external2.set(styleElement.href.slice(styleElement.href.lastIndexOf("/") + 1), {
          usage: 0,
          elements: [styleElement]
        });
      } else if (styleElement.textContent) {
        inline.set(styleElement.textContent, {
          usage: 0,
          elements: [styleElement]
        });
      }
    }
  }
}
function createLinkElement(url, doc) {
  const linkElement = doc.createElement("link");
  linkElement.setAttribute("rel", "stylesheet");
  linkElement.setAttribute("href", url);
  return linkElement;
}
var SharedStylesHost = class _SharedStylesHost {
  doc;
  appId;
  nonce;
  inline = /* @__PURE__ */ new Map();
  external = /* @__PURE__ */ new Map();
  hosts = /* @__PURE__ */ new Set();
  constructor(doc, appId, nonce, platformId = {}) {
    this.doc = doc;
    this.appId = appId;
    this.nonce = nonce;
    addServerStyles(doc, appId, this.inline, this.external);
    this.hosts.add(doc.head);
  }
  addStyles(styles, urls) {
    for (const value of styles) {
      this.addUsage(value, this.inline, createStyleElement);
    }
    urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));
  }
  removeStyles(styles, urls) {
    for (const value of styles) {
      this.removeUsage(value, this.inline);
    }
    urls?.forEach((value) => this.removeUsage(value, this.external));
  }
  addUsage(value, usages, creator) {
    const record2 = usages.get(value);
    if (record2) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && record2.usage === 0) {
        record2.elements.forEach((element) => element.setAttribute("ng-style-reused", ""));
      }
      record2.usage++;
    } else {
      usages.set(value, {
        usage: 1,
        elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc)))
      });
    }
  }
  removeUsage(value, usages) {
    const record2 = usages.get(value);
    if (record2) {
      record2.usage--;
      if (record2.usage <= 0) {
        removeElements(record2.elements);
        usages.delete(value);
      }
    }
  }
  ngOnDestroy() {
    for (const [, {
      elements
    }] of [...this.inline, ...this.external]) {
      removeElements(elements);
    }
    this.hosts.clear();
  }
  addHost(hostNode) {
    this.hosts.add(hostNode);
    for (const [style2, {
      elements
    }] of this.inline) {
      elements.push(this.addElement(hostNode, createStyleElement(style2, this.doc)));
    }
    for (const [url, {
      elements
    }] of this.external) {
      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));
    }
  }
  removeHost(hostNode) {
    this.hosts.delete(hostNode);
  }
  addElement(host, element) {
    if (this.nonce) {
      element.setAttribute("nonce", this.nonce);
    }
    if (false) {
      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);
    }
    return host.appendChild(element);
  }
  static \u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _SharedStylesHost)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(APP_ID), \u0275\u0275inject(CSP_NONCE, 8), \u0275\u0275inject(PLATFORM_ID));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _SharedStylesHost,
    factory: _SharedStylesHost.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SharedStylesHost, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }, {
      type: Optional
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [PLATFORM_ID]
    }]
  }], null);
})();
var NAMESPACE_URIS = {
  "svg": "http://www.w3.org/2000/svg",
  "xhtml": "http://www.w3.org/1999/xhtml",
  "xlink": "http://www.w3.org/1999/xlink",
  "xml": "http://www.w3.org/XML/1998/namespace",
  "xmlns": "http://www.w3.org/2000/xmlns/",
  "math": "http://www.w3.org/1998/Math/MathML"
};
var COMPONENT_REGEX = /%COMP%/g;
var SOURCEMAP_URL_REGEXP = /\/\*#\s*sourceMappingURL=(.+?)\s*\*\//;
var PROTOCOL_REGEXP = /^https?:/;
var COMPONENT_VARIABLE = "%COMP%";
var HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;
var CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;
var REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;
var REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "RemoveStylesOnCompDestroy" : "", {
  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT
});
function shimContentAttribute(componentShortId) {
  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimHostAttribute(componentShortId) {
  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);
}
function shimStylesContent(compId, styles) {
  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));
}
function addBaseHrefToCssSourceMap(baseHref, styles) {
  if (!baseHref) {
    return styles;
  }
  const absoluteBaseHrefUrl = new URL(baseHref, "http://localhost");
  return styles.map((cssContent) => {
    if (!cssContent.includes("sourceMappingURL=")) {
      return cssContent;
    }
    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {
      if (sourceMapUrl[0] === "/" || sourceMapUrl.startsWith("data:") || PROTOCOL_REGEXP.test(sourceMapUrl)) {
        return `/*# sourceMappingURL=${sourceMapUrl} */`;
      }
      const {
        pathname: resolvedSourceMapUrl
      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);
      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;
    });
  });
}
var DomRendererFactory2 = class _DomRendererFactory2 {
  eventManager;
  sharedStylesHost;
  appId;
  removeStylesOnCompDestroy;
  doc;
  ngZone;
  nonce;
  tracingService;
  rendererByCompId = /* @__PURE__ */ new Map();
  defaultRenderer;
  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, ngZone, nonce = null, tracingService = null) {
    this.eventManager = eventManager;
    this.sharedStylesHost = sharedStylesHost;
    this.appId = appId;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    this.doc = doc;
    this.ngZone = ngZone;
    this.nonce = nonce;
    this.tracingService = tracingService;
    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.tracingService);
  }
  createRenderer(element, type) {
    if (!element || !type) {
      return this.defaultRenderer;
    }
    if (false) {
      type = __spreadProps(__spreadValues({}, type), {
        encapsulation: ViewEncapsulation.Emulated
      });
    }
    const renderer = this.getOrCreateRenderer(element, type);
    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {
      renderer.applyToHost(element);
    } else if (renderer instanceof NoneEncapsulationDomRenderer) {
      renderer.applyStyles();
    }
    return renderer;
  }
  getOrCreateRenderer(element, type) {
    const rendererByCompId = this.rendererByCompId;
    let renderer = rendererByCompId.get(type.id);
    if (!renderer) {
      const doc = this.doc;
      const ngZone = this.ngZone;
      const eventManager = this.eventManager;
      const sharedStylesHost = this.sharedStylesHost;
      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;
      const tracingService = this.tracingService;
      switch (type.encapsulation) {
        case ViewEncapsulation.Emulated:
          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, tracingService);
          break;
        case ViewEncapsulation.ShadowDom:
          return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, tracingService, sharedStylesHost);
        case ViewEncapsulation.ExperimentalIsolatedShadowDom:
          return new ShadowDomRenderer(eventManager, element, type, doc, ngZone, this.nonce, tracingService);
        default:
          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, tracingService);
          break;
      }
      rendererByCompId.set(type.id, renderer);
    }
    return renderer;
  }
  ngOnDestroy() {
    this.rendererByCompId.clear();
  }
  componentReplaced(componentId) {
    this.rendererByCompId.delete(componentId);
  }
  static \u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomRendererFactory2)(\u0275\u0275inject(EventManager), \u0275\u0275inject(SharedStylesHost), \u0275\u0275inject(APP_ID), \u0275\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(NgZone), \u0275\u0275inject(CSP_NONCE), \u0275\u0275inject(TracingService, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomRendererFactory2,
    factory: _DomRendererFactory2.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{
    type: Injectable
  }], () => [{
    type: EventManager
  }, {
    type: SharedStylesHost
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [APP_ID]
    }]
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]
    }]
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: NgZone
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CSP_NONCE]
    }]
  }, {
    type: TracingService,
    decorators: [{
      type: Inject,
      args: [TracingService]
    }, {
      type: Optional
    }]
  }], null);
})();
var DefaultDomRenderer2 = class {
  eventManager;
  doc;
  ngZone;
  tracingService;
  data = /* @__PURE__ */ Object.create(null);
  throwOnSyntheticProps = true;
  constructor(eventManager, doc, ngZone, tracingService) {
    this.eventManager = eventManager;
    this.doc = doc;
    this.ngZone = ngZone;
    this.tracingService = tracingService;
  }
  destroy() {
  }
  destroyNode = null;
  createElement(name, namespace) {
    if (namespace) {
      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);
    }
    return this.doc.createElement(name);
  }
  createComment(value) {
    return this.doc.createComment(value);
  }
  createText(value) {
    return this.doc.createTextNode(value);
  }
  appendChild(parent, newChild) {
    const targetParent = isTemplateNode(parent) ? parent.content : parent;
    targetParent.appendChild(newChild);
  }
  insertBefore(parent, newChild, refChild) {
    if (parent) {
      const targetParent = isTemplateNode(parent) ? parent.content : parent;
      targetParent.insertBefore(newChild, refChild);
    }
  }
  removeChild(_parent, oldChild) {
    oldChild.remove();
  }
  selectRootElement(selectorOrNode, preserveContent) {
    let el = typeof selectorOrNode === "string" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;
    if (!el) {
      throw new RuntimeError(-5104, (typeof ngDevMode === "undefined" || ngDevMode) && `The selector "${selectorOrNode}" did not match any elements`);
    }
    if (!preserveContent) {
      el.textContent = "";
    }
    return el;
  }
  parentNode(node) {
    return node.parentNode;
  }
  nextSibling(node) {
    return node.nextSibling;
  }
  setAttribute(el, name, value, namespace) {
    if (namespace) {
      name = namespace + ":" + name;
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.setAttributeNS(namespaceUri, name, value);
      } else {
        el.setAttribute(name, value);
      }
    } else {
      el.setAttribute(name, value);
    }
  }
  removeAttribute(el, name, namespace) {
    if (namespace) {
      const namespaceUri = NAMESPACE_URIS[namespace];
      if (namespaceUri) {
        el.removeAttributeNS(namespaceUri, name);
      } else {
        el.removeAttribute(`${namespace}:${name}`);
      }
    } else {
      el.removeAttribute(name);
    }
  }
  addClass(el, name) {
    el.classList.add(name);
  }
  removeClass(el, name) {
    el.classList.remove(name);
  }
  setStyle(el, style2, value, flags) {
    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {
      el.style.setProperty(style2, value, flags & RendererStyleFlags2.Important ? "important" : "");
    } else {
      el.style[style2] = value;
    }
  }
  removeStyle(el, style2, flags) {
    if (flags & RendererStyleFlags2.DashCase) {
      el.style.removeProperty(style2);
    } else {
      el.style[style2] = "";
    }
  }
  setProperty(el, name, value) {
    if (el == null) {
      return;
    }
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, "property");
    el[name] = value;
  }
  setValue(node, value) {
    node.nodeValue = value;
  }
  listen(target, event, callback, options) {
    (typeof ngDevMode === "undefined" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, "listener");
    if (typeof target === "string") {
      target = getDOM().getGlobalEventTarget(this.doc, target);
      if (!target) {
        throw new RuntimeError(5102, (typeof ngDevMode === "undefined" || ngDevMode) && `Unsupported event target ${target} for event ${event}`);
      }
    }
    let wrappedCallback = this.decoratePreventDefault(callback);
    if (this.tracingService?.wrapEventListener) {
      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);
    }
    return this.eventManager.addEventListener(target, event, wrappedCallback, options);
  }
  decoratePreventDefault(eventHandler) {
    return (event) => {
      if (event === "__ngUnwrap__") {
        return eventHandler;
      }
      const allowDefaultBehavior = false ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);
      if (allowDefaultBehavior === false) {
        event.preventDefault();
      }
      return void 0;
    };
  }
};
var AT_CHARCODE = (() => "@".charCodeAt(0))();
function checkNoSyntheticProp(name, nameKind) {
  if (name.charCodeAt(0) === AT_CHARCODE) {
    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:
  - Make sure \`provideAnimationsAsync()\`, \`provideAnimations()\` or \`provideNoopAnimations()\` call was added to a list of providers used to bootstrap an application.
  - There is a corresponding animation configuration named \`${name}\` defined in the \`animations\` field of the \`@Component\` decorator (see https://angular.dev/api/core/Component#animations).`);
  }
}
function isTemplateNode(node) {
  return node.tagName === "TEMPLATE" && node.content !== void 0;
}
var ShadowDomRenderer = class extends DefaultDomRenderer2 {
  hostEl;
  sharedStylesHost;
  shadowRoot;
  constructor(eventManager, hostEl, component, doc, ngZone, nonce, tracingService, sharedStylesHost) {
    super(eventManager, doc, ngZone, tracingService);
    this.hostEl = hostEl;
    this.sharedStylesHost = sharedStylesHost;
    this.shadowRoot = hostEl.attachShadow({
      mode: "open"
    });
    if (this.sharedStylesHost) {
      this.sharedStylesHost.addHost(this.shadowRoot);
    }
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = getDOM().getBaseHref(doc) ?? "";
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    styles = shimStylesContent(component.id, styles);
    for (const style2 of styles) {
      const styleEl = document.createElement("style");
      if (nonce) {
        styleEl.setAttribute("nonce", nonce);
      }
      styleEl.textContent = style2;
      this.shadowRoot.appendChild(styleEl);
    }
    const styleUrls = component.getExternalStyles?.();
    if (styleUrls) {
      for (const styleUrl of styleUrls) {
        const linkEl = createLinkElement(styleUrl, doc);
        if (nonce) {
          linkEl.setAttribute("nonce", nonce);
        }
        this.shadowRoot.appendChild(linkEl);
      }
    }
  }
  nodeOrShadowRoot(node) {
    return node === this.hostEl ? this.shadowRoot : node;
  }
  appendChild(parent, newChild) {
    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);
  }
  insertBefore(parent, newChild, refChild) {
    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);
  }
  removeChild(_parent, oldChild) {
    return super.removeChild(null, oldChild);
  }
  parentNode(node) {
    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));
  }
  destroy() {
    if (this.sharedStylesHost) {
      this.sharedStylesHost.removeHost(this.shadowRoot);
    }
  }
};
var NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {
  sharedStylesHost;
  removeStylesOnCompDestroy;
  styles;
  styleUrls;
  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, tracingService, compId) {
    super(eventManager, doc, ngZone, tracingService);
    this.sharedStylesHost = sharedStylesHost;
    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;
    let styles = component.styles;
    if (ngDevMode) {
      const baseHref = getDOM().getBaseHref(doc) ?? "";
      styles = addBaseHrefToCssSourceMap(baseHref, styles);
    }
    this.styles = compId ? shimStylesContent(compId, styles) : styles;
    this.styleUrls = component.getExternalStyles?.(compId);
  }
  applyStyles() {
    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);
  }
  destroy() {
    if (!this.removeStylesOnCompDestroy) {
      return;
    }
    if (allLeavingAnimations.size === 0) {
      this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);
    }
  }
};
var EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {
  contentAttr;
  hostAttr;
  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, tracingService) {
    const compId = appId + "-" + component.id;
    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, tracingService, compId);
    this.contentAttr = shimContentAttribute(compId);
    this.hostAttr = shimHostAttribute(compId);
  }
  applyToHost(element) {
    this.applyStyles();
    this.setAttribute(element, this.hostAttr, "");
  }
  createElement(parent, name) {
    const el = super.createElement(parent, name);
    super.setAttribute(el, this.contentAttr, "");
    return el;
  }
};

// node_modules/@angular/platform-browser/fesm2022/_browser-chunk.mjs
var BrowserDomAdapter = class _BrowserDomAdapter extends DomAdapter {
  supportsDOMEvents = true;
  static makeCurrent() {
    setRootDomAdapter(new _BrowserDomAdapter());
  }
  onAndCancel(el, evt, listener, options) {
    el.addEventListener(evt, listener, options);
    return () => {
      el.removeEventListener(evt, listener, options);
    };
  }
  dispatchEvent(el, evt) {
    el.dispatchEvent(evt);
  }
  remove(node) {
    node.remove();
  }
  createElement(tagName, doc) {
    doc = doc || this.getDefaultDocument();
    return doc.createElement(tagName);
  }
  createHtmlDocument() {
    return document.implementation.createHTMLDocument("fakeTitle");
  }
  getDefaultDocument() {
    return document;
  }
  isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
  }
  isShadowRoot(node) {
    return node instanceof DocumentFragment;
  }
  getGlobalEventTarget(doc, target) {
    if (target === "window") {
      return window;
    }
    if (target === "document") {
      return doc;
    }
    if (target === "body") {
      return doc.body;
    }
    return null;
  }
  getBaseHref(doc) {
    const href = getBaseElementHref();
    return href == null ? null : relativePath(href);
  }
  resetBaseElement() {
    baseElement = null;
  }
  getUserAgent() {
    return window.navigator.userAgent;
  }
  getCookie(name) {
    return parseCookieValue(document.cookie, name);
  }
};
var baseElement = null;
function getBaseElementHref() {
  baseElement = baseElement || document.head.querySelector("base");
  return baseElement ? baseElement.getAttribute("href") : null;
}
function relativePath(url) {
  return new URL(url, document.baseURI).pathname;
}
var BrowserGetTestability = class {
  addToWindow(registry) {
    _global["getAngularTestability"] = (elem, findInAncestors = true) => {
      const testability = registry.findTestabilityInTree(elem, findInAncestors);
      if (testability == null) {
        throw new RuntimeError(5103, (typeof ngDevMode === "undefined" || ngDevMode) && "Could not find testability for element.");
      }
      return testability;
    };
    _global["getAllAngularTestabilities"] = () => registry.getAllTestabilities();
    _global["getAllAngularRootElements"] = () => registry.getAllRootElements();
    const whenAllStable = (callback) => {
      const testabilities = _global["getAllAngularTestabilities"]();
      let count = testabilities.length;
      const decrement = function() {
        count--;
        if (count == 0) {
          callback();
        }
      };
      testabilities.forEach((testability) => {
        testability.whenStable(decrement);
      });
    };
    if (!_global["frameworkStabilizers"]) {
      _global["frameworkStabilizers"] = [];
    }
    _global["frameworkStabilizers"].push(whenAllStable);
  }
  findTestabilityInTree(registry, elem, findInAncestors) {
    if (elem == null) {
      return null;
    }
    const t = registry.getTestability(elem);
    if (t != null) {
      return t;
    } else if (!findInAncestors) {
      return null;
    }
    if (getDOM().isShadowRoot(elem)) {
      return this.findTestabilityInTree(registry, elem.host, true);
    }
    return this.findTestabilityInTree(registry, elem.parentElement, true);
  }
};
var BrowserXhr = class _BrowserXhr {
  build() {
    return new XMLHttpRequest();
  }
  static \u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserXhr)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserXhr,
    factory: _BrowserXhr.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserXhr, [{
    type: Injectable
  }], null, null);
})();
var MODIFIER_KEYS = ["alt", "control", "meta", "shift"];
var _keyMap = {
  "\b": "Backspace",
  "	": "Tab",
  "\x7F": "Delete",
  "\x1B": "Escape",
  "Del": "Delete",
  "Esc": "Escape",
  "Left": "ArrowLeft",
  "Right": "ArrowRight",
  "Up": "ArrowUp",
  "Down": "ArrowDown",
  "Menu": "ContextMenu",
  "Scroll": "ScrollLock",
  "Win": "OS"
};
var MODIFIER_KEY_GETTERS = {
  "alt": (event) => event.altKey,
  "control": (event) => event.ctrlKey,
  "meta": (event) => event.metaKey,
  "shift": (event) => event.shiftKey
};
var KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {
  constructor(doc) {
    super(doc);
  }
  supports(eventName) {
    return _KeyEventsPlugin.parseEventName(eventName) != null;
  }
  addEventListener(element, eventName, handler, options) {
    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);
    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent["fullKey"], handler, this.manager.getZone());
    return this.manager.getZone().runOutsideAngular(() => {
      return getDOM().onAndCancel(element, parsedEvent["domEventName"], outsideHandler, options);
    });
  }
  static parseEventName(eventName) {
    const parts = eventName.toLowerCase().split(".");
    const domEventName = parts.shift();
    if (parts.length === 0 || !(domEventName === "keydown" || domEventName === "keyup")) {
      return null;
    }
    const key = _KeyEventsPlugin._normalizeKey(parts.pop());
    let fullKey = "";
    let codeIX = parts.indexOf("code");
    if (codeIX > -1) {
      parts.splice(codeIX, 1);
      fullKey = "code.";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      const index2 = parts.indexOf(modifierName);
      if (index2 > -1) {
        parts.splice(index2, 1);
        fullKey += modifierName + ".";
      }
    });
    fullKey += key;
    if (parts.length != 0 || key.length === 0) {
      return null;
    }
    const result = {};
    result["domEventName"] = domEventName;
    result["fullKey"] = fullKey;
    return result;
  }
  static matchEventFullKeyCode(event, fullKeyCode) {
    let keycode = _keyMap[event.key] || event.key;
    let key = "";
    if (fullKeyCode.indexOf("code.") > -1) {
      keycode = event.code;
      key = "code.";
    }
    if (keycode == null || !keycode) return false;
    keycode = keycode.toLowerCase();
    if (keycode === " ") {
      keycode = "space";
    } else if (keycode === ".") {
      keycode = "dot";
    }
    MODIFIER_KEYS.forEach((modifierName) => {
      if (modifierName !== keycode) {
        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];
        if (modifierGetter(event)) {
          key += modifierName + ".";
        }
      }
    });
    key += keycode;
    return key === fullKeyCode;
  }
  static eventCallback(fullKey, handler, zone) {
    return (event) => {
      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {
        zone.runGuarded(() => handler(event));
      }
    };
  }
  static _normalizeKey(keyName) {
    return keyName === "esc" ? "escape" : keyName;
  }
  static \u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _KeyEventsPlugin)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _KeyEventsPlugin,
    factory: _KeyEventsPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
function initDomAdapter() {
  BrowserDomAdapter.makeCurrent();
}
function errorHandler() {
  return new ErrorHandler();
}
function _document() {
  setDocument(document);
  return document;
}
var INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
  provide: PLATFORM_ID,
  useValue: PLATFORM_BROWSER_ID
}, {
  provide: PLATFORM_INITIALIZER,
  useValue: initDomAdapter,
  multi: true
}, {
  provide: DOCUMENT,
  useFactory: _document
}];
var platformBrowser = createPlatformFactory(platformCore, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS);
var BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "BrowserModule Providers Marker" : "");
var TESTABILITY_PROVIDERS = [{
  provide: TESTABILITY_GETTER,
  useClass: BrowserGetTestability
}, {
  provide: TESTABILITY,
  useClass: Testability
}, {
  provide: Testability,
  useClass: Testability
}];
var BROWSER_MODULE_PROVIDERS = [{
  provide: INJECTOR_SCOPE,
  useValue: "root"
}, {
  provide: ErrorHandler,
  useFactory: errorHandler
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: DomEventsPlugin,
  multi: true
}, {
  provide: EVENT_MANAGER_PLUGINS,
  useClass: KeyEventsPlugin,
  multi: true
}, DomRendererFactory2, SharedStylesHost, EventManager, {
  provide: RendererFactory2,
  useExisting: DomRendererFactory2
}, {
  provide: XhrFactory,
  useClass: BrowserXhr
}, typeof ngDevMode === "undefined" || ngDevMode ? {
  provide: BROWSER_MODULE_PROVIDERS_MARKER,
  useValue: true
} : []];
var BrowserModule = class _BrowserModule {
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const providersAlreadyPresent = inject(BROWSER_MODULE_PROVIDERS_MARKER, {
        optional: true,
        skipSelf: true
      });
      if (providersAlreadyPresent) {
        throw new RuntimeError(5100, `Providers from the \`BrowserModule\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \`CommonModule\` instead.`);
      }
    }
  }
  static \u0275fac = function BrowserModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserModule,
    exports: [CommonModule, ApplicationModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
    imports: [CommonModule, ApplicationModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserModule, [{
    type: NgModule,
    args: [{
      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],
      exports: [CommonModule, ApplicationModule]
    }]
  }], () => [], null);
})();

// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs
var Meta = class _Meta {
  _doc;
  _dom;
  constructor(_doc) {
    this._doc = _doc;
    this._dom = getDOM();
  }
  addTag(tag, forceCreation = false) {
    if (!tag) return null;
    return this._getOrCreateElement(tag, forceCreation);
  }
  addTags(tags, forceCreation = false) {
    if (!tags) return [];
    return tags.reduce((result, tag) => {
      if (tag) {
        result.push(this._getOrCreateElement(tag, forceCreation));
      }
      return result;
    }, []);
  }
  getTag(attrSelector) {
    if (!attrSelector) return null;
    return this._doc.querySelector(`meta[${attrSelector}]`) || null;
  }
  getTags(attrSelector) {
    if (!attrSelector) return [];
    const list2 = this._doc.querySelectorAll(`meta[${attrSelector}]`);
    return list2 ? [].slice.call(list2) : [];
  }
  updateTag(tag, selector) {
    if (!tag) return null;
    selector = selector || this._parseSelector(tag);
    const meta = this.getTag(selector);
    if (meta) {
      return this._setMetaElementAttributes(tag, meta);
    }
    return this._getOrCreateElement(tag, true);
  }
  removeTag(attrSelector) {
    this.removeTagElement(this.getTag(attrSelector));
  }
  removeTagElement(meta) {
    if (meta) {
      this._dom.remove(meta);
    }
  }
  _getOrCreateElement(meta, forceCreation = false) {
    if (!forceCreation) {
      const selector = this._parseSelector(meta);
      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];
      if (elem !== void 0) return elem;
    }
    const element = this._dom.createElement("meta");
    this._setMetaElementAttributes(meta, element);
    const head = this._doc.getElementsByTagName("head")[0];
    head.appendChild(element);
    return element;
  }
  _setMetaElementAttributes(tag, el) {
    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));
    return el;
  }
  _parseSelector(tag) {
    const attr = tag.name ? "name" : "property";
    return `${attr}="${tag[attr]}"`;
  }
  _containsAttributes(tag, elem) {
    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);
  }
  _getMetaKeyMap(prop) {
    return META_KEYS_MAP[prop] || prop;
  }
  static \u0275fac = function Meta_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Meta)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Meta,
    factory: _Meta.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Meta, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var META_KEYS_MAP = {
  httpEquiv: "http-equiv"
};
var Title = class _Title {
  _doc;
  constructor(_doc) {
    this._doc = _doc;
  }
  getTitle() {
    return this._doc.title;
  }
  setTitle(newTitle) {
    this._doc.title = newTitle || "";
  }
  static \u0275fac = function Title_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Title)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Title,
    factory: _Title.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Title, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var EVENT_NAMES = {
  "pan": true,
  "panstart": true,
  "panmove": true,
  "panend": true,
  "pancancel": true,
  "panleft": true,
  "panright": true,
  "panup": true,
  "pandown": true,
  "pinch": true,
  "pinchstart": true,
  "pinchmove": true,
  "pinchend": true,
  "pinchcancel": true,
  "pinchin": true,
  "pinchout": true,
  "press": true,
  "pressup": true,
  "rotate": true,
  "rotatestart": true,
  "rotatemove": true,
  "rotateend": true,
  "rotatecancel": true,
  "swipe": true,
  "swipeleft": true,
  "swiperight": true,
  "swipeup": true,
  "swipedown": true,
  "tap": true,
  "doubletap": true
};
var HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerGestureConfig" : "");
var HAMMER_LOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "HammerLoader" : "");
var HammerGestureConfig = class _HammerGestureConfig {
  events = [];
  overrides = {};
  options;
  buildHammer(element) {
    const mc = new Hammer(element, this.options);
    mc.get("pinch").set({
      enable: true
    });
    mc.get("rotate").set({
      enable: true
    });
    for (const eventName in this.overrides) {
      mc.get(eventName).set(this.overrides[eventName]);
    }
    return mc;
  }
  static \u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGestureConfig)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGestureConfig,
    factory: _HammerGestureConfig.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{
    type: Injectable
  }], null, null);
})();
var HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {
  _config;
  _injector;
  loader;
  _loaderPromise = null;
  constructor(doc, _config, _injector, loader) {
    super(doc);
    this._config = _config;
    this._injector = _injector;
    this.loader = loader;
  }
  supports(eventName) {
    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {
      return false;
    }
    if (!window.Hammer && !this.loader) {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        const _console = this._injector.get(Console);
        _console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);
      }
      return false;
    }
    return true;
  }
  addEventListener(element, eventName, handler) {
    const zone = this.manager.getZone();
    eventName = eventName.toLowerCase();
    if (!window.Hammer && this.loader) {
      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());
      let cancelRegistration = false;
      let deregister = () => {
        cancelRegistration = true;
      };
      zone.runOutsideAngular(() => this._loaderPromise.then(() => {
        if (!window.Hammer) {
          if (typeof ngDevMode === "undefined" || ngDevMode) {
            const _console = this._injector.get(Console);
            _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);
          }
          deregister = () => {
          };
          return;
        }
        if (!cancelRegistration) {
          deregister = this.addEventListener(element, eventName, handler);
        }
      }).catch(() => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          const _console = this._injector.get(Console);
          _console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`);
        }
        deregister = () => {
        };
      }));
      return () => {
        deregister();
      };
    }
    return zone.runOutsideAngular(() => {
      const mc = this._config.buildHammer(element);
      const callback = function(eventObj) {
        zone.runGuarded(function() {
          handler(eventObj);
        });
      };
      mc.on(eventName, callback);
      return () => {
        mc.off(eventName, callback);
        if (typeof mc.destroy === "function") {
          mc.destroy();
        }
      };
    });
  }
  isCustomEvent(eventName) {
    return this._config.events.indexOf(eventName) > -1;
  }
  static \u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerGesturesPlugin)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(HAMMER_GESTURE_CONFIG), \u0275\u0275inject(Injector), \u0275\u0275inject(HAMMER_LOADER, 8));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HammerGesturesPlugin,
    factory: _HammerGesturesPlugin.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{
    type: Injectable
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: HammerGestureConfig,
    decorators: [{
      type: Inject,
      args: [HAMMER_GESTURE_CONFIG]
    }]
  }, {
    type: Injector
  }, {
    type: void 0,
    decorators: [{
      type: Optional
    }, {
      type: Inject,
      args: [HAMMER_LOADER]
    }]
  }], null);
})();
var HammerModule = class _HammerModule {
  static \u0275fac = function HammerModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HammerModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _HammerModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [{
      provide: EVENT_MANAGER_PLUGINS,
      useClass: HammerGesturesPlugin,
      multi: true,
      deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
    }, {
      provide: HAMMER_GESTURE_CONFIG,
      useClass: HammerGestureConfig
    }]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HammerModule, [{
    type: NgModule,
    args: [{
      providers: [{
        provide: EVENT_MANAGER_PLUGINS,
        useClass: HammerGesturesPlugin,
        multi: true,
        deps: [DOCUMENT, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]
      }, {
        provide: HAMMER_GESTURE_CONFIG,
        useClass: HammerGestureConfig
      }]
    }]
  }], null, null);
})();
var DomSanitizer = class _DomSanitizer {
  static \u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizer,
    factory: function DomSanitizer_Factory(__ngFactoryType__) {
      let __ngConditionalFactory__ = null;
      if (__ngFactoryType__) {
        __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();
      } else {
        __ngConditionalFactory__ = \u0275\u0275inject(DomSanitizerImpl);
      }
      return __ngConditionalFactory__;
    },
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useExisting: forwardRef(() => DomSanitizerImpl)
    }]
  }], null, null);
})();
var DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {
  _doc;
  constructor(_doc) {
    super();
    this._doc = _doc;
  }
  sanitize(ctx, value) {
    if (value == null) return null;
    switch (ctx) {
      case SecurityContext.NONE:
        return value;
      case SecurityContext.HTML:
        if (allowSanitizationBypassAndThrow(value, "HTML")) {
          return unwrapSafeValue(value);
        }
        return _sanitizeHtml(this._doc, String(value)).toString();
      case SecurityContext.STYLE:
        if (allowSanitizationBypassAndThrow(value, "Style")) {
          return unwrapSafeValue(value);
        }
        return value;
      case SecurityContext.SCRIPT:
        if (allowSanitizationBypassAndThrow(value, "Script")) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5200, (typeof ngDevMode === "undefined" || ngDevMode) && "unsafe value used in a script context");
      case SecurityContext.URL:
        if (allowSanitizationBypassAndThrow(value, "URL")) {
          return unwrapSafeValue(value);
        }
        return _sanitizeUrl(String(value));
      case SecurityContext.RESOURCE_URL:
        if (allowSanitizationBypassAndThrow(value, "ResourceURL")) {
          return unwrapSafeValue(value);
        }
        throw new RuntimeError(5201, (typeof ngDevMode === "undefined" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);
      default:
        throw new RuntimeError(5202, (typeof ngDevMode === "undefined" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);
    }
  }
  bypassSecurityTrustHtml(value) {
    return bypassSanitizationTrustHtml(value);
  }
  bypassSecurityTrustStyle(value) {
    return bypassSanitizationTrustStyle(value);
  }
  bypassSecurityTrustScript(value) {
    return bypassSanitizationTrustScript(value);
  }
  bypassSecurityTrustUrl(value) {
    return bypassSanitizationTrustUrl(value);
  }
  bypassSecurityTrustResourceUrl(value) {
    return bypassSanitizationTrustResourceUrl(value);
  }
  static \u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DomSanitizerImpl)(\u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DomSanitizerImpl,
    factory: _DomSanitizerImpl.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var HydrationFeatureKind;
(function(HydrationFeatureKind2) {
  HydrationFeatureKind2[HydrationFeatureKind2["NoHttpTransferCache"] = 0] = "NoHttpTransferCache";
  HydrationFeatureKind2[HydrationFeatureKind2["HttpTransferCacheOptions"] = 1] = "HttpTransferCacheOptions";
  HydrationFeatureKind2[HydrationFeatureKind2["I18nSupport"] = 2] = "I18nSupport";
  HydrationFeatureKind2[HydrationFeatureKind2["EventReplay"] = 3] = "EventReplay";
  HydrationFeatureKind2[HydrationFeatureKind2["IncrementalHydration"] = 4] = "IncrementalHydration";
})(HydrationFeatureKind || (HydrationFeatureKind = {}));

// node_modules/date-fns/differenceInCalendarMonths.js
function differenceInCalendarMonths(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  const yearsDiff = laterDate_.getFullYear() - earlierDate_.getFullYear();
  const monthsDiff = laterDate_.getMonth() - earlierDate_.getMonth();
  return yearsDiff * 12 + monthsDiff;
}

// node_modules/date-fns/differenceInSeconds.js
function differenceInSeconds(laterDate, earlierDate, options) {
  const diff = differenceInMilliseconds(laterDate, earlierDate) / 1e3;
  return getRoundingMethod(options?.roundingMethod)(diff);
}

// node_modules/date-fns/differenceInWeeks.js
function differenceInWeeks(laterDate, earlierDate, options) {
  const diff = differenceInDays(laterDate, earlierDate, options) / 7;
  return getRoundingMethod(options?.roundingMethod)(diff);
}

// node_modules/date-fns/endOfISOWeek.js
function endOfISOWeek(date, options) {
  return endOfWeek(date, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
}

// node_modules/date-fns/setDay.js
function setDay(date, day, options) {
  const defaultOptions = getDefaultOptions();
  const weekStartsOn = options?.weekStartsOn ?? options?.locale?.options?.weekStartsOn ?? defaultOptions.weekStartsOn ?? defaultOptions.locale?.options?.weekStartsOn ?? 0;
  const date_ = toDate(date, options?.in);
  const currentDay = date_.getDay();
  const remainder = day % 7;
  const dayIndex = (remainder + 7) % 7;
  const delta = 7 - weekStartsOn;
  const diff = day < 0 || day > 6 ? day - (currentDay + delta) % 7 : (dayIndex + delta) % 7 - (currentDay + delta) % 7;
  return addDays(date_, diff, options);
}

// node_modules/date-fns/isSameHour.js
function isSameHour(dateLeft, dateRight, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options?.in,
    dateLeft,
    dateRight
  );
  return +startOfHour(dateLeft_) === +startOfHour(dateRight_);
}

// node_modules/date-fns/isSameMinute.js
function isSameMinute(laterDate, earlierDate) {
  return +startOfMinute(laterDate) === +startOfMinute(earlierDate);
}

// node_modules/date-fns/isSameMonth.js
function isSameMonth(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear() && laterDate_.getMonth() === earlierDate_.getMonth();
}

// node_modules/date-fns/isSameQuarter.js
function isSameQuarter(laterDate, earlierDate, options) {
  const [dateLeft_, dateRight_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return +startOfQuarter(dateLeft_) === +startOfQuarter(dateRight_);
}

// node_modules/date-fns/startOfSecond.js
function startOfSecond(date, options) {
  const date_ = toDate(date, options?.in);
  date_.setMilliseconds(0);
  return date_;
}

// node_modules/date-fns/isSameSecond.js
function isSameSecond(laterDate, earlierDate) {
  return +startOfSecond(laterDate) === +startOfSecond(earlierDate);
}

// node_modules/date-fns/isSameYear.js
function isSameYear(laterDate, earlierDate, options) {
  const [laterDate_, earlierDate_] = normalizeDates(
    options?.in,
    laterDate,
    earlierDate
  );
  return laterDate_.getFullYear() === earlierDate_.getFullYear();
}

// node_modules/date-fns/isTomorrow.js
function isTomorrow(date, options) {
  return isSameDay(
    date,
    addDays(constructNow(options?.in || date), 1),
    options
  );
}

// node_modules/date-fns/subDays.js
function subDays(date, amount, options) {
  return addDays(date, -amount, options);
}

// node_modules/date-fns/setMonth.js
function setMonth(date, month, options) {
  const _date = toDate(date, options?.in);
  const year = _date.getFullYear();
  const day = _date.getDate();
  const midMonth = constructFrom(options?.in || date, 0);
  midMonth.setFullYear(year, month, 15);
  midMonth.setHours(0, 0, 0, 0);
  const daysInMonth = getDaysInMonth(midMonth);
  _date.setMonth(month, Math.min(day, daysInMonth));
  return _date;
}

// node_modules/date-fns/setHours.js
function setHours(date, hours, options) {
  const _date = toDate(date, options?.in);
  _date.setHours(hours);
  return _date;
}

// node_modules/date-fns/setMinutes.js
function setMinutes(date, minutes, options) {
  const date_ = toDate(date, options?.in);
  date_.setMinutes(minutes);
  return date_;
}

// node_modules/date-fns/setQuarter.js
function setQuarter(date, quarter, options) {
  const date_ = toDate(date, options?.in);
  const oldQuarter = Math.trunc(date_.getMonth() / 3) + 1;
  const diff = quarter - oldQuarter;
  return setMonth(date_, date_.getMonth() + diff * 3);
}

// node_modules/date-fns/setSeconds.js
function setSeconds(date, seconds, options) {
  const _date = toDate(date, options?.in);
  _date.setSeconds(seconds);
  return _date;
}

// node_modules/date-fns/setYear.js
function setYear(date, year, options) {
  const date_ = toDate(date, options?.in);
  if (isNaN(+date_)) return constructFrom(options?.in || date, NaN);
  date_.setFullYear(year);
  return date_;
}

// node_modules/date-fns/subWeeks.js
function subWeeks(date, amount, options) {
  return addWeeks(date, -amount, options);
}

// node_modules/date-fns/locale/ja/_lib/formatDistance.js
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "1\u79D2\u672A\u6E80",
    other: "{{count}}\u79D2\u672A\u6E80",
    oneWithSuffix: "\u7D041\u79D2",
    otherWithSuffix: "\u7D04{{count}}\u79D2"
  },
  xSeconds: {
    one: "1\u79D2",
    other: "{{count}}\u79D2"
  },
  halfAMinute: "30\u79D2",
  lessThanXMinutes: {
    one: "1\u5206\u672A\u6E80",
    other: "{{count}}\u5206\u672A\u6E80",
    oneWithSuffix: "\u7D041\u5206",
    otherWithSuffix: "\u7D04{{count}}\u5206"
  },
  xMinutes: {
    one: "1\u5206",
    other: "{{count}}\u5206"
  },
  aboutXHours: {
    one: "\u7D041\u6642\u9593",
    other: "\u7D04{{count}}\u6642\u9593"
  },
  xHours: {
    one: "1\u6642\u9593",
    other: "{{count}}\u6642\u9593"
  },
  xDays: {
    one: "1\u65E5",
    other: "{{count}}\u65E5"
  },
  aboutXWeeks: {
    one: "\u7D041\u9031\u9593",
    other: "\u7D04{{count}}\u9031\u9593"
  },
  xWeeks: {
    one: "1\u9031\u9593",
    other: "{{count}}\u9031\u9593"
  },
  aboutXMonths: {
    one: "\u7D041\u304B\u6708",
    other: "\u7D04{{count}}\u304B\u6708"
  },
  xMonths: {
    one: "1\u304B\u6708",
    other: "{{count}}\u304B\u6708"
  },
  aboutXYears: {
    one: "\u7D041\u5E74",
    other: "\u7D04{{count}}\u5E74"
  },
  xYears: {
    one: "1\u5E74",
    other: "{{count}}\u5E74"
  },
  overXYears: {
    one: "1\u5E74\u4EE5\u4E0A",
    other: "{{count}}\u5E74\u4EE5\u4E0A"
  },
  almostXYears: {
    one: "1\u5E74\u8FD1\u304F",
    other: "{{count}}\u5E74\u8FD1\u304F"
  }
};
var formatDistance = (token, count, options) => {
  options = options || {};
  let result;
  const tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    if (options.addSuffix && tokenValue.oneWithSuffix) {
      result = tokenValue.oneWithSuffix;
    } else {
      result = tokenValue.one;
    }
  } else {
    if (options.addSuffix && tokenValue.otherWithSuffix) {
      result = tokenValue.otherWithSuffix.replace("{{count}}", String(count));
    } else {
      result = tokenValue.other.replace("{{count}}", String(count));
    }
  }
  if (options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5F8C";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};

// node_modules/date-fns/locale/ja/_lib/formatLong.js
var dateFormats = {
  full: "y\u5E74M\u6708d\u65E5EEEE",
  long: "y\u5E74M\u6708d\u65E5",
  medium: "y/MM/dd",
  short: "y/MM/dd"
};
var timeFormats = {
  full: "H\u6642mm\u5206ss\u79D2 zzzz",
  long: "H:mm:ss z",
  medium: "H:mm:ss",
  short: "H:mm"
};
var dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/ja/_lib/formatRelative.js
var formatRelativeLocale = {
  lastWeek: "\u5148\u9031\u306Eeeee\u306Ep",
  yesterday: "\u6628\u65E5\u306Ep",
  today: "\u4ECA\u65E5\u306Ep",
  tomorrow: "\u660E\u65E5\u306Ep",
  nextWeek: "\u7FCC\u9031\u306Eeeee\u306Ep",
  other: "P"
};
var formatRelative = (token, _date, _baseDate, _options) => {
  return formatRelativeLocale[token];
};

// node_modules/date-fns/locale/ja/_lib/localize.js
var eraValues = {
  narrow: ["BC", "AC"],
  abbreviated: ["\u7D00\u5143\u524D", "\u897F\u66A6"],
  wide: ["\u7D00\u5143\u524D", "\u897F\u66A6"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["\u7B2C1\u56DB\u534A\u671F", "\u7B2C2\u56DB\u534A\u671F", "\u7B2C3\u56DB\u534A\u671F", "\u7B2C4\u56DB\u534A\u671F"]
};
var monthValues = {
  narrow: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
  abbreviated: [
    "1\u6708",
    "2\u6708",
    "3\u6708",
    "4\u6708",
    "5\u6708",
    "6\u6708",
    "7\u6708",
    "8\u6708",
    "9\u6708",
    "10\u6708",
    "11\u6708",
    "12\u6708"
  ],
  wide: [
    "1\u6708",
    "2\u6708",
    "3\u6708",
    "4\u6708",
    "5\u6708",
    "6\u6708",
    "7\u6708",
    "8\u6708",
    "9\u6708",
    "10\u6708",
    "11\u6708",
    "12\u6708"
  ]
};
var dayValues = {
  narrow: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
  short: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
  abbreviated: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"],
  wide: ["\u65E5\u66DC\u65E5", "\u6708\u66DC\u65E5", "\u706B\u66DC\u65E5", "\u6C34\u66DC\u65E5", "\u6728\u66DC\u65E5", "\u91D1\u66DC\u65E5", "\u571F\u66DC\u65E5"]
};
var dayPeriodValues = {
  narrow: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  },
  abbreviated: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  },
  wide: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  },
  abbreviated: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  },
  wide: {
    am: "\u5348\u524D",
    pm: "\u5348\u5F8C",
    midnight: "\u6DF1\u591C",
    noon: "\u6B63\u5348",
    morning: "\u671D",
    afternoon: "\u5348\u5F8C",
    evening: "\u591C",
    night: "\u6DF1\u591C"
  }
};
var ordinalNumber = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  const unit = String(options?.unit);
  switch (unit) {
    case "year":
      return `${number}\u5E74`;
    case "quarter":
      return `\u7B2C${number}\u56DB\u534A\u671F`;
    case "month":
      return `${number}\u6708`;
    case "week":
      return `\u7B2C${number}\u9031`;
    case "date":
      return `${number}\u65E5`;
    case "hour":
      return `${number}\u6642`;
    case "minute":
      return `${number}\u5206`;
    case "second":
      return `${number}\u79D2`;
    default:
      return `${number}`;
  }
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: (quarter) => Number(quarter) - 1
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/ja/_lib/match.js
var matchOrdinalNumberPattern = /^第?\d+(年|四半期|月|週|日|時|分|秒)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(B\.?C\.?|A\.?D\.?)/i,
  abbreviated: /^(紀元[前後]|西暦)/i,
  wide: /^(紀元[前後]|西暦)/i
};
var parseEraPatterns = {
  narrow: [/^B/i, /^A/i],
  any: [/^(紀元前)/i, /^(西暦|紀元後)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^Q[1234]/i,
  wide: /^第[1234一二三四１２３４]四半期/i
};
var parseQuarterPatterns = {
  any: [/(1|一|１)/i, /(2|二|２)/i, /(3|三|３)/i, /(4|四|４)/i]
};
var matchMonthPatterns = {
  narrow: /^([123456789]|1[012])/,
  abbreviated: /^([123456789]|1[012])月/i,
  wide: /^([123456789]|1[012])月/i
};
var parseMonthPatterns = {
  any: [
    /^1\D/,
    /^2/,
    /^3/,
    /^4/,
    /^5/,
    /^6/,
    /^7/,
    /^8/,
    /^9/,
    /^10/,
    /^11/,
    /^12/
  ]
};
var matchDayPatterns = {
  narrow: /^[日月火水木金土]/,
  short: /^[日月火水木金土]/,
  abbreviated: /^[日月火水木金土]/,
  wide: /^[日月火水木金土]曜日/
};
var parseDayPatterns = {
  any: [/^日/, /^月/, /^火/, /^水/, /^木/, /^金/, /^土/]
};
var matchDayPeriodPatterns = {
  any: /^(AM|PM|午前|午後|正午|深夜|真夜中|夜|朝)/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^(A|午前)/i,
    pm: /^(P|午後)/i,
    midnight: /^深夜|真夜中/i,
    noon: /^正午/i,
    morning: /^朝/i,
    afternoon: /^午後/i,
    evening: /^夜/i,
    night: /^深夜/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/ja.js
var ja = {
  code: "ja",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};

// node_modules/date-fns/locale/zh-CN/_lib/formatDistance.js
var formatDistanceLocale2 = {
  lessThanXSeconds: {
    one: "\u4E0D\u5230 1 \u79D2",
    other: "\u4E0D\u5230 {{count}} \u79D2"
  },
  xSeconds: {
    one: "1 \u79D2",
    other: "{{count}} \u79D2"
  },
  halfAMinute: "\u534A\u5206\u949F",
  lessThanXMinutes: {
    one: "\u4E0D\u5230 1 \u5206\u949F",
    other: "\u4E0D\u5230 {{count}} \u5206\u949F"
  },
  xMinutes: {
    one: "1 \u5206\u949F",
    other: "{{count}} \u5206\u949F"
  },
  xHours: {
    one: "1 \u5C0F\u65F6",
    other: "{{count}} \u5C0F\u65F6"
  },
  aboutXHours: {
    one: "\u5927\u7EA6 1 \u5C0F\u65F6",
    other: "\u5927\u7EA6 {{count}} \u5C0F\u65F6"
  },
  xDays: {
    one: "1 \u5929",
    other: "{{count}} \u5929"
  },
  aboutXWeeks: {
    one: "\u5927\u7EA6 1 \u4E2A\u661F\u671F",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u661F\u671F"
  },
  xWeeks: {
    one: "1 \u4E2A\u661F\u671F",
    other: "{{count}} \u4E2A\u661F\u671F"
  },
  aboutXMonths: {
    one: "\u5927\u7EA6 1 \u4E2A\u6708",
    other: "\u5927\u7EA6 {{count}} \u4E2A\u6708"
  },
  xMonths: {
    one: "1 \u4E2A\u6708",
    other: "{{count}} \u4E2A\u6708"
  },
  aboutXYears: {
    one: "\u5927\u7EA6 1 \u5E74",
    other: "\u5927\u7EA6 {{count}} \u5E74"
  },
  xYears: {
    one: "1 \u5E74",
    other: "{{count}} \u5E74"
  },
  overXYears: {
    one: "\u8D85\u8FC7 1 \u5E74",
    other: "\u8D85\u8FC7 {{count}} \u5E74"
  },
  almostXYears: {
    one: "\u5C06\u8FD1 1 \u5E74",
    other: "\u5C06\u8FD1 {{count}} \u5E74"
  }
};
var formatDistance2 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale2[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5185";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};

// node_modules/date-fns/locale/zh-CN/_lib/formatLong.js
var dateFormats2 = {
  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
  long: "y'\u5E74'M'\u6708'd'\u65E5'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats2 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats2 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong2 = {
  date: buildFormatLongFn({
    formats: dateFormats2,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats2,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats2,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/zh-CN/_lib/formatRelative.js
function checkWeek(date, baseDate, options) {
  const baseFormat = "eeee p";
  if (isSameWeek(date, baseDate, options)) {
    return baseFormat;
  } else if (date.getTime() > baseDate.getTime()) {
    return "'\u4E0B\u4E2A'" + baseFormat;
  }
  return "'\u4E0A\u4E2A'" + baseFormat;
}
var formatRelativeLocale2 = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'\u6628\u5929' p",
  today: "'\u4ECA\u5929' p",
  tomorrow: "'\u660E\u5929' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
};
var formatRelative2 = (token, date, baseDate, options) => {
  const format4 = formatRelativeLocale2[token];
  if (typeof format4 === "function") {
    return format4(date, baseDate, options);
  }
  return format4;
};

// node_modules/date-fns/locale/zh-CN/_lib/localize.js
var eraValues2 = {
  narrow: ["\u524D", "\u516C\u5143"],
  abbreviated: ["\u524D", "\u516C\u5143"],
  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
};
var quarterValues2 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["\u7B2C\u4E00\u5B63", "\u7B2C\u4E8C\u5B63", "\u7B2C\u4E09\u5B63", "\u7B2C\u56DB\u5B63"],
  wide: ["\u7B2C\u4E00\u5B63\u5EA6", "\u7B2C\u4E8C\u5B63\u5EA6", "\u7B2C\u4E09\u5B63\u5EA6", "\u7B2C\u56DB\u5B63\u5EA6"]
};
var monthValues2 = {
  narrow: [
    "\u4E00",
    "\u4E8C",
    "\u4E09",
    "\u56DB",
    "\u4E94",
    "\u516D",
    "\u4E03",
    "\u516B",
    "\u4E5D",
    "\u5341",
    "\u5341\u4E00",
    "\u5341\u4E8C"
  ],
  abbreviated: [
    "1\u6708",
    "2\u6708",
    "3\u6708",
    "4\u6708",
    "5\u6708",
    "6\u6708",
    "7\u6708",
    "8\u6708",
    "9\u6708",
    "10\u6708",
    "11\u6708",
    "12\u6708"
  ],
  wide: [
    "\u4E00\u6708",
    "\u4E8C\u6708",
    "\u4E09\u6708",
    "\u56DB\u6708",
    "\u4E94\u6708",
    "\u516D\u6708",
    "\u4E03\u6708",
    "\u516B\u6708",
    "\u4E5D\u6708",
    "\u5341\u6708",
    "\u5341\u4E00\u6708",
    "\u5341\u4E8C\u6708"
  ]
};
var dayValues2 = {
  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  abbreviated: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"],
  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
};
var dayPeriodValues2 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var formattingDayPeriodValues2 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u95F4"
  }
};
var ordinalNumber2 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number.toString() + "\u65E5";
    case "hour":
      return number.toString() + "\u65F6";
    case "minute":
      return number.toString() + "\u5206";
    case "second":
      return number.toString() + "\u79D2";
    default:
      return "\u7B2C " + number.toString();
  }
};
var localize2 = {
  ordinalNumber: ordinalNumber2,
  era: buildLocalizeFn({
    values: eraValues2,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues2,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues2,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues2,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues2,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues2,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/zh-CN/_lib/match.js
var matchOrdinalNumberPattern2 = /^(第\s*)?\d+(日|时|分|秒)?/i;
var parseOrdinalNumberPattern2 = /\d+/i;
var matchEraPatterns2 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns2 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns2 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
};
var parseQuarterPatterns2 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns2 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns2 = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
var matchDayPatterns2 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns2 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns2 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
};
var parseDayPeriodPatterns2 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match2 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern2,
    parsePattern: parseOrdinalNumberPattern2,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns2,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns2,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns2,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns2,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns2,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns2,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns2,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/zh-CN.js
var zhCN = {
  code: "zh-CN",
  formatDistance: formatDistance2,
  formatLong: formatLong2,
  formatRelative: formatRelative2,
  localize: localize2,
  match: match2,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// node_modules/date-fns/locale/zh-TW/_lib/formatDistance.js
var formatDistanceLocale3 = {
  lessThanXSeconds: {
    one: "\u5C11\u65BC 1 \u79D2",
    other: "\u5C11\u65BC {{count}} \u79D2"
  },
  xSeconds: {
    one: "1 \u79D2",
    other: "{{count}} \u79D2"
  },
  halfAMinute: "\u534A\u5206\u9418",
  lessThanXMinutes: {
    one: "\u5C11\u65BC 1 \u5206\u9418",
    other: "\u5C11\u65BC {{count}} \u5206\u9418"
  },
  xMinutes: {
    one: "1 \u5206\u9418",
    other: "{{count}} \u5206\u9418"
  },
  xHours: {
    one: "1 \u5C0F\u6642",
    other: "{{count}} \u5C0F\u6642"
  },
  aboutXHours: {
    one: "\u5927\u7D04 1 \u5C0F\u6642",
    other: "\u5927\u7D04 {{count}} \u5C0F\u6642"
  },
  xDays: {
    one: "1 \u5929",
    other: "{{count}} \u5929"
  },
  aboutXWeeks: {
    one: "\u5927\u7D04 1 \u500B\u661F\u671F",
    other: "\u5927\u7D04 {{count}} \u500B\u661F\u671F"
  },
  xWeeks: {
    one: "1 \u500B\u661F\u671F",
    other: "{{count}} \u500B\u661F\u671F"
  },
  aboutXMonths: {
    one: "\u5927\u7D04 1 \u500B\u6708",
    other: "\u5927\u7D04 {{count}} \u500B\u6708"
  },
  xMonths: {
    one: "1 \u500B\u6708",
    other: "{{count}} \u500B\u6708"
  },
  aboutXYears: {
    one: "\u5927\u7D04 1 \u5E74",
    other: "\u5927\u7D04 {{count}} \u5E74"
  },
  xYears: {
    one: "1 \u5E74",
    other: "{{count}} \u5E74"
  },
  overXYears: {
    one: "\u8D85\u904E 1 \u5E74",
    other: "\u8D85\u904E {{count}} \u5E74"
  },
  almostXYears: {
    one: "\u5C07\u8FD1 1 \u5E74",
    other: "\u5C07\u8FD1 {{count}} \u5E74"
  }
};
var formatDistance3 = (token, count, options) => {
  let result;
  const tokenValue = formatDistanceLocale3[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", String(count));
  }
  if (options?.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return result + "\u5167";
    } else {
      return result + "\u524D";
    }
  }
  return result;
};

// node_modules/date-fns/locale/zh-TW/_lib/formatLong.js
var dateFormats3 = {
  full: "y'\u5E74'M'\u6708'd'\u65E5' EEEE",
  long: "y'\u5E74'M'\u6708'd'\u65E5'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
};
var timeFormats3 = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
};
var dateTimeFormats3 = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
};
var formatLong3 = {
  date: buildFormatLongFn({
    formats: dateFormats3,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats3,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats3,
    defaultWidth: "full"
  })
};

// node_modules/date-fns/locale/zh-TW/_lib/formatRelative.js
var formatRelativeLocale3 = {
  lastWeek: "'\u4E0A\u500B'eeee p",
  yesterday: "'\u6628\u5929' p",
  today: "'\u4ECA\u5929' p",
  tomorrow: "'\u660E\u5929' p",
  nextWeek: "'\u4E0B\u500B'eeee p",
  other: "P"
};
var formatRelative3 = (token, _date, _baseDate, _options) => formatRelativeLocale3[token];

// node_modules/date-fns/locale/zh-TW/_lib/localize.js
var eraValues3 = {
  narrow: ["\u524D", "\u516C\u5143"],
  abbreviated: ["\u524D", "\u516C\u5143"],
  wide: ["\u516C\u5143\u524D", "\u516C\u5143"]
};
var quarterValues3 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["\u7B2C\u4E00\u523B", "\u7B2C\u4E8C\u523B", "\u7B2C\u4E09\u523B", "\u7B2C\u56DB\u523B"],
  wide: ["\u7B2C\u4E00\u523B\u9418", "\u7B2C\u4E8C\u523B\u9418", "\u7B2C\u4E09\u523B\u9418", "\u7B2C\u56DB\u523B\u9418"]
};
var monthValues3 = {
  narrow: [
    "\u4E00",
    "\u4E8C",
    "\u4E09",
    "\u56DB",
    "\u4E94",
    "\u516D",
    "\u4E03",
    "\u516B",
    "\u4E5D",
    "\u5341",
    "\u5341\u4E00",
    "\u5341\u4E8C"
  ],
  abbreviated: [
    "1\u6708",
    "2\u6708",
    "3\u6708",
    "4\u6708",
    "5\u6708",
    "6\u6708",
    "7\u6708",
    "8\u6708",
    "9\u6708",
    "10\u6708",
    "11\u6708",
    "12\u6708"
  ],
  wide: [
    "\u4E00\u6708",
    "\u4E8C\u6708",
    "\u4E09\u6708",
    "\u56DB\u6708",
    "\u4E94\u6708",
    "\u516D\u6708",
    "\u4E03\u6708",
    "\u516B\u6708",
    "\u4E5D\u6708",
    "\u5341\u6708",
    "\u5341\u4E00\u6708",
    "\u5341\u4E8C\u6708"
  ]
};
var dayValues3 = {
  narrow: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  short: ["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"],
  abbreviated: ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"],
  wide: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"]
};
var dayPeriodValues3 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  }
};
var formattingDayPeriodValues3 = {
  narrow: {
    am: "\u4E0A",
    pm: "\u4E0B",
    midnight: "\u51CC\u6668",
    noon: "\u5348",
    morning: "\u65E9",
    afternoon: "\u4E0B\u5348",
    evening: "\u665A",
    night: "\u591C"
  },
  abbreviated: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  },
  wide: {
    am: "\u4E0A\u5348",
    pm: "\u4E0B\u5348",
    midnight: "\u51CC\u6668",
    noon: "\u4E2D\u5348",
    morning: "\u65E9\u6668",
    afternoon: "\u4E2D\u5348",
    evening: "\u665A\u4E0A",
    night: "\u591C\u9593"
  }
};
var ordinalNumber3 = (dirtyNumber, options) => {
  const number = Number(dirtyNumber);
  switch (options?.unit) {
    case "date":
      return number + "\u65E5";
    case "hour":
      return number + "\u6642";
    case "minute":
      return number + "\u5206";
    case "second":
      return number + "\u79D2";
    default:
      return "\u7B2C " + number;
  }
};
var localize3 = {
  ordinalNumber: ordinalNumber3,
  era: buildLocalizeFn({
    values: eraValues3,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues3,
    defaultWidth: "wide",
    argumentCallback: (quarter) => quarter - 1
  }),
  month: buildLocalizeFn({
    values: monthValues3,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues3,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues3,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues3,
    defaultFormattingWidth: "wide"
  })
};

// node_modules/date-fns/locale/zh-TW/_lib/match.js
var matchOrdinalNumberPattern3 = /^(第\s*)?\d+(日|時|分|秒)?/i;
var parseOrdinalNumberPattern3 = /\d+/i;
var matchEraPatterns3 = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
};
var parseEraPatterns3 = {
  any: [/^(前)/i, /^(公元)/i]
};
var matchQuarterPatterns3 = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻鐘/i
};
var parseQuarterPatterns3 = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
};
var matchMonthPatterns3 = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
};
var parseMonthPatterns3 = {
  narrow: [
    /^一/i,
    /^二/i,
    /^三/i,
    /^四/i,
    /^五/i,
    /^六/i,
    /^七/i,
    /^八/i,
    /^九/i,
    /^十(?!(一|二))/i,
    /^十一/i,
    /^十二/i
  ],
  any: [
    /^一|1/i,
    /^二|2/i,
    /^三|3/i,
    /^四|4/i,
    /^五|5/i,
    /^六|6/i,
    /^七|7/i,
    /^八|8/i,
    /^九|9/i,
    /^十(?!(一|二))|10/i,
    /^十一|11/i,
    /^十二|12/i
  ]
};
var matchDayPatterns3 = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^週[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
};
var parseDayPatterns3 = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
};
var matchDayPeriodPatterns3 = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨)/i
};
var parseDayPeriodPatterns3 = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
};
var match3 = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern3,
    parsePattern: parseOrdinalNumberPattern3,
    valueCallback: (value) => parseInt(value, 10)
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns3,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns3,
    defaultParseWidth: "any",
    valueCallback: (index2) => index2 + 1
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns3,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns3,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns3,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns3,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns3,
    defaultParseWidth: "any"
  })
};

// node_modules/date-fns/locale/zh-TW.js
var zhTW = {
  code: "zh-TW",
  formatDistance: formatDistance3,
  formatLong: formatLong3,
  formatRelative: formatRelative3,
  localize: localize3,
  match: match3,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};

// node_modules/ngx-tethys/fesm2022/ngx-tethys-i18n.mjs
var ThyLocaleType;
(function(ThyLocaleType2) {
  ThyLocaleType2["zhHans"] = "zh-hans";
  ThyLocaleType2["zhHant"] = "zh-hant";
  ThyLocaleType2["enUs"] = "en-us";
  ThyLocaleType2["jaJp"] = "ja-jp";
  ThyLocaleType2["deDe"] = "de-de";
})(ThyLocaleType || (ThyLocaleType = {}));
var THY_I18N_LOCALE_ID = new InjectionToken("thy-i18n-locale-id");
var THY_I18N_ZH_HANS = new InjectionToken("thy-i18n-zh-hans");
var THY_I18N_ZH_HANT = new InjectionToken("thy-i18n-zh-hant");
var THY_I18N_EN_US = new InjectionToken("thy-i18n-en-us");
var THY_I18N_JA_JP = new InjectionToken("thy-i18n-ja-jp");
var THY_I18N_DE_DE = new InjectionToken("thy-i18n-de-de");
function normalizeLocale(localeId) {
  return localeId?.toLowerCase().replace(/_/g, "-");
}
function getDefaultLocaleId() {
  let defaultLocaleId = ThyLocaleType.zhHans;
  const allLocales = [ThyLocaleType.zhHans, ThyLocaleType.zhHant, ThyLocaleType.enUs, ThyLocaleType.jaJp, ThyLocaleType.deDe];
  if (typeof window !== "undefined" && window?.navigator?.language) {
    defaultLocaleId = window.navigator?.language?.toLowerCase();
  }
  return allLocales.includes(normalizeLocale(defaultLocaleId)) ? defaultLocaleId : ThyLocaleType.zhHans;
}
var zhHansLocale = {
  id: ThyLocaleType.zhHans,
  layout: {
    expand: "\u5C55\u5F00",
    collapse: "\u6536\u8D77"
  },
  datePicker: {
    yearFormat: "yyyy\u5E74",
    // Used in header of month picker
    monthFormat: "MMM",
    // Used in header of date picker, advanced range picker （2月）
    weekFormat: "EEEEE",
    // Used in date picker table （六）
    fullWeekFormat: "EE",
    // Used in calendar (周六)
    weekThFormat: "yyyy-ww\u5468",
    // Used in week picker
    dateFormat: "yyyy\u5E74MM\u6708dd\u65E5",
    yearQuarterFormat: "yyyy\u5E74 'Q'q",
    yearMonthFormat: "yyyy\u5E74 MM\u6708",
    yearText: "\u5E74\u4EFD",
    quarterText: "\u5B63\u5EA6",
    monthText: "\u6708\u4EFD",
    week: "\u5468",
    prefixWeek: "\u5468",
    previousYear: "\u4E0A\u4E00\u5E74",
    nextYear: "\u4E0B\u4E00\u5E74",
    previousMonth: "\u4E0A\u4E2A\u6708",
    nextMonth: "\u4E0B\u4E2A\u6708",
    today: "\u4ECA\u5929",
    tomorrow: "\u660E\u5929",
    nextWeek: "\u4E0B\u5468",
    lastSevenDays: "\u6700\u8FD1 7 \u5929",
    lastThirtyDays: "\u6700\u8FD1 30 \u5929",
    currentMonth: "\u672C\u6708",
    currentWeek: "\u672C\u5468",
    advance: "\u9AD8\u7EA7\u9009\u9879",
    custom: "\u81EA\u5B9A\u4E49",
    startDate: "\u5F00\u59CB\u65E5\u671F",
    endDate: "\u7ED3\u675F\u65E5\u671F",
    setTime: "\u8BBE\u7F6E\u65F6\u95F4",
    placeholder: "\u9009\u62E9\u65E5\u671F",
    ok: "\u786E\u5B9A",
    clear: "\u6E05\u9664"
  },
  dateRange: {
    custom: "\u81EA\u5B9A\u4E49",
    currentWeek: "\u672C\u5468",
    currentMonth: "\u672C\u6708"
  },
  timePicker: {
    placeholder: "\u9009\u62E9\u65F6\u95F4",
    now: "\u6B64\u523B",
    ok: "\u786E\u5B9A"
  },
  calendar: {
    today: "\u4ECA\u5929",
    yearMonthFormat: "yyyy\u5E74MM\u6708"
  },
  autocomplete: {
    empty: "\u6682\u65E0\u6570\u636E"
  },
  transfer: {
    maxLimit: "(\u4E0A\u9650{max}\u4E2A)",
    maxLockLimit: "\u9501\u5B9A (\u4E0A\u9650{maxLock}\u4E2A)",
    unlocked: "\u672A\u9501\u5B9A"
  },
  colorPicker: {
    defaultColor: "\u9ED8\u8BA4\u989C\u8272",
    noFillColor: "\u65E0\u586B\u5145\u8272",
    recentUsedColor: "\u6700\u8FD1\u4F7F\u7528\u81EA\u5B9A\u4E49\u989C\u8272",
    customColor: "\u81EA\u5B9A\u4E49\u989C\u8272",
    none: "\u6682\u65E0"
  },
  strength: {
    highest: "\u6700\u9AD8",
    high: "\u9AD8",
    medium: "\u4E2D",
    low: "\u4F4E"
  },
  guider: {
    skip: "\u8DF3\u8FC7",
    prev: "\u4E0A\u4E00\u6B65",
    next: "\u4E0B\u4E00\u6B65",
    finish: "\u5B8C\u6210"
  },
  copy: {
    tips: "\u70B9\u51FB\u590D\u5236",
    success: "\u590D\u5236\u6210\u529F",
    error: "\u590D\u5236\u5931\u8D25"
  },
  nav: {
    more: "\u66F4\u591A"
  },
  dialog: {
    title: "\u786E\u8BA4\u5220\u9664",
    ok: "\u786E\u5B9A",
    cancel: "\u53D6\u6D88"
  },
  select: {
    placeholder: "\u8BF7\u9009\u62E9",
    empty: "\u6682\u65E0\u6570\u636E"
  },
  treeSelect: {
    placeholder: "\u8BF7\u9009\u62E9",
    empty: "\u6682\u65E0\u6570\u636E"
  },
  cascader: {
    placeholder: "\u8BF7\u9009\u62E9",
    empty: "\u6682\u65E0\u6570\u636E"
  },
  pagination: {
    page: "\u9875",
    order: "\u7B2C",
    total: "\u5171",
    totalCount: "\u5171{total}\u9875",
    jumpTo: "\u8DF3\u81F3",
    firstPage: "\u7B2C\u4E00\u9875",
    lastPage: "\u6700\u540E\u4E00\u9875",
    defaultUnit: "\u6761"
  },
  form: {
    required: "\u8BE5\u9009\u9879\u4E0D\u80FD\u4E3A\u7A7A",
    maxlength: "\u8BE5\u9009\u9879\u8F93\u5165\u503C\u957F\u5EA6\u4E0D\u80FD\u5927\u4E8E{maxlength}",
    minlength: "\u8BE5\u9009\u9879\u8F93\u5165\u503C\u957F\u5EA6\u4E0D\u80FD\u5C0F\u4E8E{minlength}",
    uniqueCheck: "\u8F93\u5165\u503C\u5DF2\u7ECF\u5B58\u5728\uFF0C\u8BF7\u91CD\u65B0\u8F93\u5165",
    email: "\u8F93\u5165\u90AE\u4EF6\u7684\u683C\u5F0F\u4E0D\u6B63\u786E",
    confirm: "\u4E24\u6B21\u8F93\u5165\u4E0D\u4E00\u81F4",
    pattern: "\u8BE5\u9009\u9879\u8F93\u5165\u683C\u5F0F\u4E0D\u6B63\u786E",
    number: "\u5FC5\u987B\u8F93\u5165\u6570\u5B57",
    url: "\u8F93\u5165URL\u683C\u5F0F\u4E0D\u6B63\u786E",
    max: "\u8BE5\u9009\u9879\u8F93\u5165\u503C\u4E0D\u80FD\u5927\u4E8E{max}",
    min: "\u8BE5\u9009\u9879\u8F93\u5165\u503C\u4E0D\u80FD\u5C0F\u4E8E{min}"
  },
  empty: {
    noDataText: "\u6682\u65E0\u6570\u636E"
  },
  image: {
    zoomOut: "\u7F29\u5C0F",
    zoomIn: "\u653E\u5927",
    originalSize: "\u539F\u59CB\u6BD4\u4F8B",
    fitToScreen: "\u9002\u5E94\u5C4F\u5E55",
    fullScreen: "\u5168\u5C4F\u663E\u793A",
    spin: "\u65CB\u8F6C",
    download: "\u4E0B\u8F7D",
    viewOriginal: "\u67E5\u770B\u539F\u56FE",
    copyLink: "\u590D\u5236\u94FE\u63A5",
    exitPreview: "\u9000\u51FA\u9884\u89C8",
    exitFullScreen: "\u9000\u51FA\u5168\u5C4F",
    copySuccess: "\u590D\u5236\u56FE\u7247\u5730\u5740\u6210\u529F",
    copyError: "\u590D\u5236\u56FE\u7247\u5730\u5740\u5931\u8D25",
    prev: "\u4E0A\u4E00\u5F20",
    next: "\u4E0B\u4E00\u5F20"
  },
  notify: {
    success: "\u6210\u529F",
    warning: "\u8B66\u544A",
    error: "\u9519\u8BEF",
    info: "\u63D0\u793A",
    detail: "\u8BE6\u60C5"
  },
  shared: {
    comma: "\uFF0C"
  }
};
var zhHantLocale = {
  id: ThyLocaleType.zhHant,
  layout: {
    expand: "\u5C55\u958B",
    collapse: "\u6536\u8D77"
  },
  datePicker: {
    yearFormat: "yyyy\u5E74",
    monthFormat: "MMM",
    weekFormat: "EEEEE",
    fullWeekFormat: "EE",
    weekThFormat: "yyyy-ww\u9031",
    dateFormat: "yyyy\u5E74MM\u6708dd\u65E5",
    yearQuarterFormat: "yyyy\u5E74 'Q'q",
    yearMonthFormat: "yyyy\u5E74 MM\u6708",
    yearText: "\u5E74\u4EFD",
    quarterText: "\u5B63\u5EA6",
    monthText: "\u6708\u4EFD",
    week: "\u9031",
    prefixWeek: "\u9031",
    previousYear: "\u4E0A\u4E00\u5E74",
    nextYear: "\u4E0B\u4E00\u5E74",
    previousMonth: "\u4E0A\u500B\u6708",
    nextMonth: "\u4E0B\u500B\u6708",
    today: "\u4ECA\u5929",
    tomorrow: "\u660E\u5929",
    nextWeek: "\u4E0B\u9031",
    lastSevenDays: "\u6700\u8FD1 7 \u5929",
    lastThirtyDays: "\u6700\u8FD1 30 \u5929",
    currentMonth: "\u672C\u6708",
    currentWeek: "\u672C\u9031",
    advance: "\u9AD8\u7D1A\u9078\u9805",
    custom: "\u81EA\u8A02",
    startDate: "\u958B\u59CB\u65E5\u671F",
    endDate: "\u7D50\u675F\u65E5\u671F",
    setTime: "\u8A2D\u7F6E\u6642\u9593",
    placeholder: "\u9078\u64C7\u65E5\u671F",
    ok: "\u78BA\u5B9A",
    clear: "\u6E05\u9664"
  },
  dateRange: {
    custom: "\u81EA\u8A02",
    currentWeek: "\u672C\u9031",
    currentMonth: "\u672C\u6708"
  },
  timePicker: {
    placeholder: "\u9078\u64C7\u6642\u9593",
    now: "\u6B64\u523B",
    ok: "\u78BA\u5B9A"
  },
  calendar: {
    today: "\u4ECA\u5929",
    yearMonthFormat: "yyyy\u5E74MM\u6708"
  },
  autocomplete: {
    empty: "\u66AB\u7121\u6578\u64DA"
  },
  transfer: {
    maxLimit: "(\u4E0A\u9650{max}\u500B)",
    maxLockLimit: "\u9396\u5B9A (\u4E0A\u9650{maxLock}\u500B)",
    unlocked: "\u672A\u9396\u5B9A"
  },
  colorPicker: {
    defaultColor: "\u9810\u8A2D\u984F\u8272",
    noFillColor: "\u7121\u586B\u5145\u8272",
    recentUsedColor: "\u6700\u8FD1\u4F7F\u7528\u81EA\u8A02\u984F\u8272",
    customColor: "\u81EA\u8A02\u984F\u8272",
    none: "\u66AB\u7121"
  },
  strength: {
    highest: "\u6700\u9AD8",
    high: "\u9AD8",
    medium: "\u4E2D",
    low: "\u4F4E"
  },
  guider: {
    skip: "\u8DF3\u904E",
    prev: "\u4E0A\u4E00\u6B65",
    next: "\u4E0B\u4E00\u6B65",
    finish: "\u5B8C\u6210"
  },
  copy: {
    tips: "\u9EDE\u64CA\u8907\u88FD",
    success: "\u8907\u88FD\u6210\u529F",
    error: "\u8907\u88FD\u5931\u6557"
  },
  nav: {
    more: "\u66F4\u591A"
  },
  dialog: {
    title: "\u78BA\u8A8D\u522A\u9664",
    ok: "\u78BA\u5B9A",
    cancel: "\u53D6\u6D88"
  },
  select: {
    placeholder: "\u8ACB\u9078\u64C7",
    empty: "\u66AB\u7121\u6578\u64DA"
  },
  treeSelect: {
    placeholder: "\u8ACB\u9078\u64C7",
    empty: "\u66AB\u7121\u6578\u64DA"
  },
  cascader: {
    placeholder: "\u8ACB\u9078\u64C7",
    empty: "\u66AB\u7121\u6578\u64DA"
  },
  pagination: {
    page: "\u9801",
    order: "\u7B2C",
    total: "\u5171",
    totalCount: "\u5171{total}\u9801",
    jumpTo: "\u8DF3\u81F3",
    firstPage: "\u7B2C\u4E00\u9801",
    lastPage: "\u6700\u5F8C\u4E00\u9801",
    defaultUnit: "\u500B"
  },
  form: {
    required: "\u8A72\u9078\u9805\u4E0D\u80FD\u4E3A\u7A7A",
    maxlength: "\u8A72\u9078\u9805\u8F38\u5165\u503C\u9577\u5EA6\u4E0D\u80FD\u5927\u65BC{maxlength}",
    minlength: "\u8A72\u9078\u9805\u8F38\u5165\u503C\u9577\u5EA6\u4E0D\u80FD\u5C0F\u65BC{minlength}",
    uniqueCheck: "\u8F38\u5165\u503C\u5DF2\u7D93\u5B58\u5728\uFF0C\u8ACB\u91CD\u65B0\u8F38\u5165",
    email: "\u8F38\u5165\u90F5\u4EF6\u7684\u683C\u5F0F\u4E0D\u6B63\u78BA",
    confirm: "\u5169\u6B21\u8F38\u5165\u4E0D\u4E00\u81F4",
    pattern: "\u8A72\u9078\u9805\u8F38\u5165\u683C\u5F0F\u4E0D\u6B63\u78BA",
    number: "\u5FC5\u9808\u8F38\u5165\u6578\u5B57",
    url: "\u8F38\u5165URL\u683C\u5F0F\u4E0D\u6B63\u78BA",
    max: "\u8A72\u9078\u9805\u8F38\u5165\u503C\u4E0D\u80FD\u5927\u65BC{max}",
    min: "\u8A72\u9078\u9805\u8F38\u5165\u503C\u4E0D\u80FD\u5C0F\u65BC{min}"
  },
  empty: {
    noDataText: "\u66AB\u7121\u8CC7\u6599"
  },
  image: {
    zoomOut: "\u7E2E\u5C0F",
    zoomIn: "\u653E\u5927",
    originalSize: "\u539F\u59CB\u6BD4\u4F8B",
    fitToScreen: "\u9069\u61C9\u5C4F\u5E55",
    fullScreen: "\u5168\u5C4F\u986F\u793A",
    spin: "\u65CB\u8F49",
    download: "\u4E0B\u8F09",
    viewOriginal: "\u67E5\u770B\u539F\u5716",
    copyLink: "\u8907\u88FD\u9023\u7D50",
    exitPreview: "\u9000\u51FA\u9810\u89BD",
    exitFullScreen: "\u9000\u51FA\u5168\u5C4F",
    copySuccess: "\u8907\u88FD\u5716\u7247\u5730\u5740\u6210\u529F",
    copyError: "\u8907\u88FD\u5716\u7247\u5730\u5740\u5931\u6557",
    prev: "\u4E0A\u4E00\u5F35",
    next: "\u4E0B\u4E00\u5F35"
  },
  notify: {
    success: "\u6210\u529F",
    warning: "\u8B66\u544A",
    error: "\u932F\u8AA4",
    info: "\u63D0\u793A",
    detail: "\u8A73\u60C5"
  },
  shared: {
    comma: "\uFF0C"
  }
};
var enUsLocale = {
  id: ThyLocaleType.enUs,
  layout: {
    expand: "Expand",
    collapse: "Collapse"
  },
  datePicker: {
    yearFormat: "yyyy",
    // eg. 2025
    monthFormat: "MMM",
    // eg. Sep
    weekFormat: "EEE",
    // eg. Tue
    fullWeekFormat: "EEE",
    // eg. Tue
    weekThFormat: "yyyy-ww",
    //  eg. 2025-01st、2025-02nd、2025-03rd、2025-27th
    dateFormat: "yyyy-MM-dd",
    // eg. 2025-09-02
    yearQuarterFormat: "yyyy-'Q'q",
    yearMonthFormat: "yyyy-MM",
    yearText: "Year",
    quarterText: "Quarter",
    monthText: "Month",
    week: "Week",
    prefixWeek: "",
    previousYear: "Previous year",
    nextYear: "Next year",
    previousMonth: "Previous month",
    nextMonth: "Next month",
    today: "Today",
    tomorrow: "Tomorrow",
    nextWeek: "Next week",
    lastSevenDays: "7 days",
    lastThirtyDays: "30 days",
    currentMonth: "This month",
    currentWeek: "This week",
    advance: "Advance",
    custom: "Custom",
    startDate: "Start date",
    endDate: "End date",
    setTime: "Set time",
    placeholder: "Select date",
    ok: "Ok",
    clear: "Clear"
  },
  dateRange: {
    custom: "Custom",
    currentWeek: "This week",
    currentMonth: "This month"
  },
  timePicker: {
    placeholder: "Select time",
    now: "Now",
    ok: "Ok"
  },
  calendar: {
    today: "Today",
    yearMonthFormat: "yyyy-MM"
    // eg. 2025-09
  },
  autocomplete: {
    empty: "No data available"
  },
  transfer: {
    maxLimit: "(Max limit: {max})",
    maxLockLimit: "Lock (Max limit: {maxLock})",
    unlocked: "Unlocked"
  },
  colorPicker: {
    defaultColor: "Default color",
    noFillColor: "No fill color",
    recentUsedColor: "Recently used custom color",
    customColor: "Custom color",
    none: "None"
  },
  strength: {
    highest: "Highest",
    high: "High",
    medium: "Medium",
    low: "Low"
  },
  guider: {
    skip: "Skip",
    prev: "Previous",
    next: "Next",
    finish: "Finish"
  },
  copy: {
    tips: "Click to copy",
    success: "Copy succeeded",
    error: "Copy failed"
  },
  nav: {
    more: "More"
  },
  dialog: {
    title: "Confirm",
    ok: "Ok",
    cancel: "Cancel"
  },
  select: {
    placeholder: "Select",
    empty: "No data available"
  },
  treeSelect: {
    placeholder: "Select",
    empty: "No data available"
  },
  cascader: {
    placeholder: "Select",
    empty: "No data available"
  },
  pagination: {
    page: "page",
    order: "No.",
    total: "Total: ",
    totalCount: "Total: {total}",
    jumpTo: "Go to",
    firstPage: "First page",
    lastPage: "Last page",
    defaultUnit: ""
  },
  form: {
    required: "This option is required",
    maxlength: "Input cannot exceed {maxlength} characters",
    minlength: "Input must be at least {minlength} characters",
    uniqueCheck: "Value already exists, please try again",
    email: "Invalid email format",
    confirm: "Inputs do not match",
    pattern: "Invalid input format",
    number: "A number is required",
    url: "Invalid URL format",
    max: "Input cannot be greater than {max}",
    min: "Input cannot be less than {min}"
  },
  empty: {
    noDataText: "No data available"
  },
  image: {
    zoomOut: "Zoom out",
    zoomIn: "Zoom in",
    originalSize: "Original size",
    fitToScreen: "Fit to screen",
    fullScreen: "Full screen",
    spin: "Spin",
    download: "Download",
    viewOriginal: "View original",
    copyLink: "Copy link",
    exitPreview: "Exit preview",
    exitFullScreen: "Exit full screen",
    copySuccess: "Copied successfully",
    copyError: "Copy failed",
    prev: "Previous",
    next: "Next"
  },
  notify: {
    success: "Success",
    warning: "Warning",
    error: "Error",
    info: "Tip",
    detail: "More"
  },
  shared: {
    comma: ","
  }
};
var jaJpLocale = {
  id: ThyLocaleType.jaJp,
  layout: {
    expand: "\u5C55\u958B",
    collapse: "\u6298\u308A\u305F\u305F\u307F"
  },
  datePicker: {
    yearFormat: "yyyy\u5E74",
    monthFormat: "MMM",
    weekFormat: "EEEEE",
    fullWeekFormat: "EE",
    weekThFormat: "yyyy-ww\u9031",
    dateFormat: "yyyy\u5E74MM\u6708dd\u65E5",
    yearQuarterFormat: "yyyy-'Q'q",
    yearMonthFormat: "yyyy-MM",
    yearText: "\u5E74",
    quarterText: "\u56DB\u534A\u671F",
    monthText: "\u6708",
    week: "\u9031",
    prefixWeek: "\u9031",
    previousYear: "\u6628\u5E74",
    nextYear: "\u6765\u5E74",
    previousMonth: "\u5148\u6708",
    nextMonth: "\u6765\u6708",
    today: "\u4ECA\u65E5",
    tomorrow: "\u660E\u65E5",
    nextWeek: "\u6765\u9031",
    lastSevenDays: "\u904E\u53BB7\u65E5\u9593",
    lastThirtyDays: "\u904E\u53BB30\u65E5\u9593",
    currentMonth: "\u4ECA\u6708",
    currentWeek: "\u4ECA\u9031",
    advance: "\u9AD8\u5EA6\u306A\u30AA\u30D7\u30B7\u30E7\u30F3",
    custom: "\u30AB\u30B9\u30BF\u30E0",
    startDate: "\u958B\u59CB\u65E5",
    endDate: "\u7D42\u4E86\u65E5",
    setTime: "\u6642\u9593\u3092\u8A2D\u5B9A",
    placeholder: "\u65E5\u4ED8\u3092\u9078\u629E",
    ok: "\u78BA\u8A8D",
    clear: "\u30AF\u30EA\u30A2"
  },
  dateRange: {
    custom: "\u30AB\u30B9\u30BF\u30E0",
    currentWeek: "\u4ECA\u9031",
    currentMonth: "\u4ECA\u6708"
  },
  timePicker: {
    placeholder: "\u6642\u9593\u3092\u9078\u629E",
    now: "\u73FE\u5728",
    ok: "\u3082\u3061\u308D\u3093"
  },
  calendar: {
    today: "\u4ECA\u65E5",
    yearMonthFormat: "yyyy\u5E74MM\u6708"
  },
  autocomplete: {
    empty: "\u307E\u3060\u30C7\u30FC\u30BF\u306F\u3042\u308A\u307E\u305B\u3093"
  },
  transfer: {
    maxLimit: "(\u4E0A\u9650{max}\u500B)",
    maxLockLimit: "\u30ED\u30C3\u30AF (\u4E0A\u9650{maxLock}\u500B)",
    unlocked: "\u30ED\u30C3\u30AF\u89E3\u9664"
  },
  colorPicker: {
    defaultColor: "\u30C7\u30D5\u30A9\u30EB\u30C8\u30AB\u30E9\u30FC",
    noFillColor: "\u5857\u308A\u3064\u3076\u3057\u306A\u3057",
    recentUsedColor: "\u6700\u8FD1\u4F7F\u7528\u3057\u305F\u30AB\u30B9\u30BF\u30E0\u30AB\u30E9\u30FC",
    customColor: "\u30AB\u30B9\u30BF\u30E0\u30AB\u30E9\u30FC",
    none: "\u306A\u3057"
  },
  strength: {
    highest: "\u6700\u9AD8",
    high: "\u9AD8",
    medium: "\u4E2D",
    low: "\u4F4E"
  },
  guider: {
    skip: "\u30B9\u30AD\u30C3\u30D7",
    prev: "\u524D\u3078",
    next: "\u6B21\u3078",
    finish: "\u5B8C\u4E86"
  },
  copy: {
    tips: "\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u30B3\u30D4\u30FC",
    success: "\u30B3\u30D4\u30FC\u6210\u529F",
    error: "\u30B3\u30D4\u30FC\u5931\u6557"
  },
  nav: {
    more: "\u3082\u3063\u3068\u898B\u308B"
  },
  dialog: {
    title: "\u524A\u9664\u306E\u78BA\u8A8D",
    ok: "\u78BA\u8A8D",
    cancel: "\u30AD\u30E3\u30F3\u30BB\u30EB"
  },
  select: {
    placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
    empty: "\u307E\u3060\u30C7\u30FC\u30BF\u306F\u3042\u308A\u307E\u305B\u3093"
  },
  treeSelect: {
    placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
    empty: "\u307E\u3060\u30C7\u30FC\u30BF\u306F\u3042\u308A\u307E\u305B\u3093"
  },
  cascader: {
    placeholder: "\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044",
    empty: "\u307E\u3060\u30C7\u30FC\u30BF\u306F\u3042\u308A\u307E\u305B\u3093"
  },
  pagination: {
    page: "\u30DA\u30FC\u30B8",
    order: "\u7B2C",
    total: "\u5408\u8A08",
    totalCount: "\u5408\u8A08 {total}",
    jumpTo: "\u30B8\u30E3\u30F3\u30D7",
    firstPage: "\u6700\u521D\u306E\u30DA\u30FC\u30B8",
    lastPage: "\u6700\u5F8C\u306E\u30DA\u30FC\u30B8",
    defaultUnit: "\u6761"
  },
  form: {
    required: "\u3053\u306E\u9078\u629E\u80A2\u306F\u7A7A\u306B\u3067\u304D\u307E\u305B\u3093",
    maxlength: "\u3053\u306E\u9078\u629E\u80A2\u306E\u5165\u529B\u5024\u306E\u9577\u3055\u306F{maxlength}\u3092\u8D85\u3048\u3066\u306F\u3044\u3051\u307E\u305B\u3093",
    minlength: "\u3053\u306E\u9078\u629E\u80A2\u306E\u5165\u529B\u5024\u306E\u9577\u3055\u306F{minlength}\u672A\u6E80\u3067\u306F\u3044\u3051\u307E\u305B\u3093",
    uniqueCheck: "\u5165\u529B\u5024\u306F\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059\u3002\u518D\u5165\u529B\u3057\u3066\u304F\u3060\u3055\u3044",
    email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9\u306E\u5F62\u5F0F\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093",
    confirm: "\u4E8C\u56DE\u306E\u5165\u529B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093",
    pattern: "\u3053\u306E\u9078\u629E\u80A2\u306E\u5165\u529B\u5F62\u5F0F\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093",
    number: "\u6570\u5B57\u3092\u5165\u529B\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059",
    url: "URL\u5F62\u5F0F\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093",
    max: "\u3053\u306E\u9078\u629E\u80A2\u306E\u5165\u529B\u5024\u306F{max}\u3092\u8D85\u3048\u3066\u306F\u3044\u3051\u307E\u305B\u3093",
    min: "\u3053\u306E\u9078\u629E\u80A2\u306E\u5165\u529B\u5024\u306F{min}\u672A\u6E80\u3067\u306F\u3044\u3051\u307E\u305B\u3093"
  },
  empty: {
    noDataText: "\u30C7\u30FC\u30BF\u306F\u3042\u308A\u307E\u305B\u3093"
  },
  image: {
    zoomOut: "\u7E2E\u5C0F",
    zoomIn: "\u62E1\u5927",
    originalSize: "\u5143\u306E\u30B5\u30A4\u30BA",
    fitToScreen: "\u753B\u9762\u306B\u5408\u308F\u305B\u308B",
    fullScreen: "\u5168\u753B\u9762\u8868\u793A",
    spin: "\u56DE\u8EE2",
    download: "\u30C0\u30A6\u30F3\u30ED\u30FC\u30C9",
    viewOriginal: "\u5143\u306E\u753B\u50CF\u3092\u8868\u793A",
    copyLink: "\u30EA\u30F3\u30AF\u3092\u30B3\u30D4\u30FC",
    exitPreview: "\u30D7\u30EC\u30D3\u30E5\u30FC\u3092\u7D42\u4E86",
    exitFullScreen: "\u5168\u753B\u9762\u8868\u793A\u3092\u7D42\u4E86",
    copySuccess: "\u753B\u50CF\u306EURL\u3092\u30B3\u30D4\u30FC\u3057\u307E\u3057\u305F",
    copyError: "\u753B\u50CF\u306EURL\u3092\u30B3\u30D4\u30FC\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F",
    prev: "\u524D\u306E\u753B\u50CF",
    next: "\u6B21\u306E\u753B\u50CF"
  },
  notify: {
    success: "\u6210\u529F",
    warning: "\u8B66\u544A",
    error: "\u30A8\u30E9\u30FC",
    info: "\u60C5\u5831",
    detail: "\u8A73\u7D30"
  },
  shared: {
    comma: "\uFF0C"
  }
};
var deDeLocale = {
  id: ThyLocaleType.deDe,
  layout: {
    expand: "Aufklappen",
    collapse: "Zuklappen"
  },
  datePicker: {
    yearFormat: "yyyy",
    monthFormat: "MMM",
    //  MMM：月份缩写。  MMMM：月份全称。
    weekFormat: "EE",
    fullWeekFormat: "EE",
    weekThFormat: "yyyy-ww",
    dateFormat: "yyyy-MM-dd",
    yearQuarterFormat: "yyyy-'Q'q",
    yearMonthFormat: "yyyy-MM",
    yearText: "Jahr",
    quarterText: "Quartal",
    monthText: "Monat",
    week: "Woche",
    prefixWeek: "Woche",
    previousYear: "Vorjahr",
    nextYear: "N\xE4chstes Jahr",
    previousMonth: "Letzter Monat",
    nextMonth: "N\xE4chster Monat",
    today: "Heute",
    tomorrow: "Morgen",
    nextWeek: "N\xE4chste Woche",
    lastSevenDays: "Letzte 7 Tage",
    lastThirtyDays: "Letzte 30 Tage",
    currentMonth: "Diesen Monat",
    currentWeek: "Diese Woche",
    advance: "Erweiterte Optionen",
    custom: "Benutzerdefiniert",
    startDate: "Startdatum",
    endDate: "Enddatum",
    setTime: "Zeit einstellen",
    placeholder: "Datum ausw\xE4hlen",
    ok: "Best\xE4tigen",
    clear: "L\xF6schen"
  },
  dateRange: {
    custom: "Benutzerdefiniert",
    currentWeek: "Diese Woche",
    currentMonth: "Diesen Monat"
  },
  timePicker: {
    placeholder: "Zeit ausw\xE4hlen",
    now: "Jetzt",
    ok: "Best\xE4tigen"
  },
  calendar: {
    today: "Heute",
    yearMonthFormat: "yyyy-MM"
  },
  autocomplete: {
    empty: "Noch keine Daten"
  },
  transfer: {
    maxLimit: "(Maximal {max} St\xFCck)",
    maxLockLimit: "Gesperrt (Maximal {maxLock} St\xFCck)",
    unlocked: "Entsperrt"
  },
  colorPicker: {
    defaultColor: "Standardfarbe",
    noFillColor: "Keine F\xFCllfarbe",
    recentUsedColor: "K\xFCrzlich verwendet",
    customColor: "Benutzerdefinierte Farbe",
    none: "Keine"
  },
  strength: {
    highest: "H\xF6chste",
    high: "Hoch",
    medium: "Mittel",
    low: "Niedrig"
  },
  guider: {
    skip: "\xDCberspringen",
    prev: "Zur\xFCck",
    next: "Weiter",
    finish: "Abschlie\xDFen"
  },
  copy: {
    tips: "Klicken Sie, um zu kopieren",
    success: "Kopieren erfolgreich",
    error: "Kopieren fehlgeschlagen"
  },
  nav: {
    more: "Mehr"
  },
  dialog: {
    title: "L\xF6schbest\xE4tigung",
    ok: "Best\xE4tigen",
    cancel: "Abbrechen"
  },
  select: {
    placeholder: "Bitte w\xE4hlen",
    empty: "Noch keine Daten"
  },
  treeSelect: {
    placeholder: "Bitte w\xE4hlen",
    empty: "Noch keine Daten"
  },
  cascader: {
    placeholder: "Bitte w\xE4hlen",
    empty: "Noch keine Daten"
  },
  pagination: {
    page: "Seite",
    order: "Die",
    total: "Insgesamt",
    totalCount: "Gesamt {total}",
    jumpTo: "Springen zu",
    firstPage: "Erste Seite",
    lastPage: "Letzte Seite",
    defaultUnit: "Eintr\xE4ge"
  },
  form: {
    required: "Dieses Feld darf nicht leer sein",
    maxlength: "Die Eingabel\xE4nge darf {maxlength} nicht \xFCberschreiten",
    minlength: "Die Eingabel\xE4nge darf {minlength} nicht unterschreiten",
    uniqueCheck: "Der eingegebene Wert existiert bereits, bitte erneut eingeben",
    email: "Das Format der E-Mail-Adresse ist ung\xFCltig",
    confirm: "Die Eingaben stimmen nicht \xFCberein",
    pattern: "Das Eingabeformat ist ung\xFCltig",
    number: "Es muss eine Zahl eingegeben werden",
    url: "Das Format der URL ist ung\xFCltig",
    max: "Der eingegebene Wert darf {max} nicht \xFCberschreiten",
    min: "Der eingegebene Wert darf {min} nicht unterschreiten"
  },
  empty: {
    noDataText: "Keine Daten vorhanden"
  },
  image: {
    zoomOut: "Verkleinern",
    zoomIn: "Vergr\xF6\xDFern",
    originalSize: "Originalgr\xF6\xDFe",
    fitToScreen: "An den Bildschirm anpassen",
    fullScreen: "Vollbild anzeigen",
    spin: "Drehen",
    download: "Herunterladen",
    viewOriginal: "Original anzeigen",
    copyLink: "Link kopieren",
    exitPreview: "Vorschau beenden",
    exitFullScreen: "Vollbildmodus beenden",
    copySuccess: "Link erfolgreich kopiert",
    copyError: "Link kopieren fehlgeschlagen",
    prev: "Vorherige",
    next: "N\xE4chste"
  },
  notify: {
    success: "Erfolg",
    warning: "Warnung",
    error: "Fehler",
    info: "Hinweis",
    detail: "Details"
  },
  shared: {
    comma: ","
  }
};
var ThyI18nService = class _ThyI18nService {
  constructor() {
    this.locales = {
      [ThyLocaleType.zhHans]: inject(THY_I18N_ZH_HANS, {
        optional: true
      }) || zhHansLocale,
      [ThyLocaleType.zhHant]: inject(THY_I18N_ZH_HANT, {
        optional: true
      }) || zhHantLocale,
      [ThyLocaleType.enUs]: inject(THY_I18N_EN_US, {
        optional: true
      }) || enUsLocale,
      [ThyLocaleType.jaJp]: inject(THY_I18N_JA_JP, {
        optional: true
      }) || jaJpLocale,
      [ThyLocaleType.deDe]: inject(THY_I18N_DE_DE, {
        optional: true
      }) || deDeLocale
    };
    this.defaultLocaleId = normalizeLocale(inject(THY_I18N_LOCALE_ID, {
      optional: true
    })) || getDefaultLocaleId();
    this.locale = signal(this.locales[this.defaultLocaleId], ...ngDevMode ? [{
      debugName: "locale"
    }] : []);
  }
  /**
   * 设置语言
   * @param id
   */
  setLocale(id) {
    let localeId = normalizeLocale(id);
    if (localeId.includes("zh") && localeId !== ThyLocaleType.zhHans && localeId !== ThyLocaleType.zhHant) {
      localeId = ThyLocaleType.zhHans;
    }
    this.locale.set(this.locales[localeId] || this.locales[this.defaultLocaleId] || {});
  }
  /**
   * 获取当前语言
   */
  getLocale() {
    return this.locale;
  }
  static {
    this.\u0275fac = function ThyI18nService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyI18nService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyI18nService,
      factory: _ThyI18nService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyI18nService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function injectLocale(key) {
  const i18n = inject(ThyI18nService);
  const allLocale = i18n.getLocale();
  return computed(() => {
    if (key) {
      return allLocale()[key] ?? allLocale();
    }
    return allLocale();
  });
}

// node_modules/date-fns-tz/dist/esm/_lib/tzTokenizeDate/index.js
function tzTokenizeDate(date, timeZone) {
  const dtf = getDateTimeFormat(timeZone);
  return "formatToParts" in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);
}
var typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function partsOffset(dtf, date) {
  try {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0; i < formatted.length; i++) {
      const pos = typeToPos[formatted[i].type];
      if (pos !== void 0) {
        filled[pos] = parseInt(formatted[i].value, 10);
      }
    }
    return filled;
  } catch (error) {
    if (error instanceof RangeError) {
      return [NaN];
    }
    throw error;
  }
}
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date);
  const parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
  return [
    parseInt(parsed[3], 10),
    parseInt(parsed[1], 10),
    parseInt(parsed[2], 10),
    parseInt(parsed[4], 10),
    parseInt(parsed[5], 10),
    parseInt(parsed[6], 10)
  ];
}
var dtfCache = {};
var testDateFormatted = new Intl.DateTimeFormat("en-US", {
  hourCycle: "h23",
  timeZone: "America/New_York",
  year: "numeric",
  month: "2-digit",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
  second: "2-digit"
}).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z"));
var hourCycleSupported = testDateFormatted === "06/25/2014, 00:00:00" || testDateFormatted === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
function getDateTimeFormat(timeZone) {
  if (!dtfCache[timeZone]) {
    dtfCache[timeZone] = hourCycleSupported ? new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return dtfCache[timeZone];
}

// node_modules/date-fns-tz/dist/esm/_lib/newDateUTC/index.js
function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
  const utcDate = /* @__PURE__ */ new Date(0);
  utcDate.setUTCFullYear(fullYear, month, day);
  utcDate.setUTCHours(hour, minute, second, millisecond);
  return utcDate;
}

// node_modules/date-fns-tz/dist/esm/_lib/tzParseTimezone/index.js
var MILLISECONDS_IN_HOUR = 36e5;
var MILLISECONDS_IN_MINUTE = 6e4;
var patterns = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-])(\d{2}):?(\d{2})$/
};
function tzParseTimezone(timezoneString, date, isUtcDate) {
  if (!timezoneString) {
    return 0;
  }
  let token = patterns.timezoneZ.exec(timezoneString);
  if (token) {
    return 0;
  }
  let hours;
  let absoluteOffset;
  token = patterns.timezoneHH.exec(timezoneString);
  if (token) {
    hours = parseInt(token[1], 10);
    if (!validateTimezone(hours)) {
      return NaN;
    }
    return -(hours * MILLISECONDS_IN_HOUR);
  }
  token = patterns.timezoneHHMM.exec(timezoneString);
  if (token) {
    hours = parseInt(token[2], 10);
    const minutes = parseInt(token[3], 10);
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;
    return token[1] === "+" ? -absoluteOffset : absoluteOffset;
  }
  if (isValidTimezoneIANAString(timezoneString)) {
    date = new Date(date || Date.now());
    const utcDate = isUtcDate ? date : toUtcDate(date);
    const offset = calcOffset(utcDate, timezoneString);
    const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);
    return -fixedOffset;
  }
  return NaN;
}
function toUtcDate(date) {
  return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());
}
function calcOffset(date, timezoneString) {
  const tokens = tzTokenizeDate(date, timezoneString);
  const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();
  let asTS = date.getTime();
  const over = asTS % 1e3;
  asTS -= over >= 0 ? over : 1e3 + over;
  return asUTC - asTS;
}
function fixOffset(date, offset, timezoneString) {
  const localTS = date.getTime();
  let utcGuess = localTS - offset;
  const o2 = calcOffset(new Date(utcGuess), timezoneString);
  if (offset === o2) {
    return offset;
  }
  utcGuess -= o2 - offset;
  const o3 = calcOffset(new Date(utcGuess), timezoneString);
  if (o2 === o3) {
    return o2;
  }
  return Math.max(o2, o3);
}
function validateTimezone(hours, minutes) {
  return -23 <= hours && hours <= 23 && (minutes == null || 0 <= minutes && minutes <= 59);
}
var validIANATimezoneCache = {};
function isValidTimezoneIANAString(timeZoneString) {
  if (validIANATimezoneCache[timeZoneString])
    return true;
  try {
    new Intl.DateTimeFormat(void 0, { timeZone: timeZoneString });
    validIANATimezoneCache[timeZoneString] = true;
    return true;
  } catch (error) {
    return false;
  }
}

// node_modules/date-fns-tz/dist/esm/format/formatters/index.js
var MILLISECONDS_IN_MINUTE2 = 60 * 1e3;

// node_modules/date-fns-tz/dist/esm/_lib/getTimezoneOffsetInMilliseconds/index.js
function getTimezoneOffsetInMilliseconds(date) {
  const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return +date - +utcDate;
}

// node_modules/date-fns-tz/dist/esm/_lib/tzPattern/index.js
var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;

// node_modules/date-fns-tz/dist/esm/toDate/index.js
var MILLISECONDS_IN_HOUR2 = 36e5;
var MILLISECONDS_IN_MINUTE3 = 6e4;
var DEFAULT_ADDITIONAL_DIGITS = 2;
var patterns2 = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  // year tokens
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    // 0 additional digits
    /^([+-]\d{3})$/,
    // 1 additional digit
    /^([+-]\d{4})$/
    // 2 additional digits
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    // 0 additional digits
    /^([+-]\d{5})/,
    // 1 additional digit
    /^([+-]\d{6})/
    // 2 additional digits
  ],
  // date tokens
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  // time zone tokens (to identify the presence of a tz)
  timeZone: tzPattern
};
function toDate2(argument, options = {}) {
  if (arguments.length < 1) {
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  }
  if (argument === null) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (argument instanceof Date || typeof argument === "object" && Object.prototype.toString.call(argument) === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || Object.prototype.toString.call(argument) === "[object Number]") {
    return new Date(argument);
  } else if (!(Object.prototype.toString.call(argument) === "[object String]")) {
    return /* @__PURE__ */ new Date(NaN);
  }
  const dateStrings = splitDateString(argument);
  const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);
  const date = parseDate(restDateString, year);
  if (date === null || isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (date) {
    const timestamp = date.getTime();
    let time = 0;
    let offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (time === null || isNaN(time)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    }
    if (dateStrings.timeZone || options.timeZone) {
      offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
      if (isNaN(offset)) {
        return /* @__PURE__ */ new Date(NaN);
      }
    } else {
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
      offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
    }
    return new Date(timestamp + time + offset);
  } else {
    return /* @__PURE__ */ new Date(NaN);
  }
}
function splitDateString(dateString) {
  const dateStrings = {};
  let parts = patterns2.dateTimePattern.exec(dateString);
  let timeString;
  if (!parts) {
    parts = patterns2.datePattern.exec(dateString);
    if (parts) {
      dateStrings.date = parts[1];
      timeString = parts[2];
    } else {
      dateStrings.date = null;
      timeString = dateString;
    }
  } else {
    dateStrings.date = parts[1];
    timeString = parts[3];
  }
  if (timeString) {
    const token = patterns2.timeZone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timeZone = token[1].trim();
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  if (dateString) {
    const patternYYY = patterns2.YYY[additionalDigits];
    const patternYYYYY = patterns2.YYYYY[additionalDigits];
    let token = patterns2.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      const yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length)
      };
    }
    token = patterns2.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      const centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length)
      };
    }
  }
  return {
    year: null
  };
}
function parseDate(dateString, year) {
  if (year === null) {
    return null;
  }
  let date;
  let month;
  let week;
  if (!dateString || !dateString.length) {
    date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(year);
    return date;
  }
  let token = patterns2.MM.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    if (!validateDate(year, month)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month);
    return date;
  }
  token = patterns2.DDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    const dayOfYear = parseInt(token[1], 10);
    if (!validateDayOfYearDate(year, dayOfYear)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, 0, dayOfYear);
    return date;
  }
  token = patterns2.MMDD.exec(dateString);
  if (token) {
    date = /* @__PURE__ */ new Date(0);
    month = parseInt(token[1], 10) - 1;
    const day = parseInt(token[2], 10);
    if (!validateDate(year, month, day)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    date.setUTCFullYear(year, month, day);
    return date;
  }
  token = patterns2.Www.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    if (!validateWeekDate(week)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week);
  }
  token = patterns2.WwwD.exec(dateString);
  if (token) {
    week = parseInt(token[1], 10) - 1;
    const dayOfWeek = parseInt(token[2], 10) - 1;
    if (!validateWeekDate(week, dayOfWeek)) {
      return /* @__PURE__ */ new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  }
  return null;
}
function parseTime(timeString) {
  let hours;
  let minutes;
  let token = patterns2.HH.exec(timeString);
  if (token) {
    hours = parseFloat(token[1].replace(",", "."));
    if (!validateTime(hours)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2;
  }
  token = patterns2.HHMM.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseFloat(token[2].replace(",", "."));
    if (!validateTime(hours, minutes)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3;
  }
  token = patterns2.HHMMSS.exec(timeString);
  if (token) {
    hours = parseInt(token[1], 10);
    minutes = parseInt(token[2], 10);
    const seconds = parseFloat(token[3].replace(",", "."));
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours % 24 * MILLISECONDS_IN_HOUR2 + minutes * MILLISECONDS_IN_MINUTE3 + seconds * 1e3;
  }
  return null;
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  week = week || 0;
  day = day || 0;
  const date = /* @__PURE__ */ new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  const fourthOfJanuaryDay = date.getUTCDay() || 7;
  const diff = week * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  if (month < 0 || month > 11) {
    return false;
  }
  if (date != null) {
    if (date < 1) {
      return false;
    }
    const isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
      return false;
    }
    if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
      return false;
    }
  }
  return true;
}
function validateDayOfYearDate(year, dayOfYear) {
  if (dayOfYear < 1) {
    return false;
  }
  const isLeapYear = isLeapYearIndex(year);
  if (isLeapYear && dayOfYear > 366) {
    return false;
  }
  if (!isLeapYear && dayOfYear > 365) {
    return false;
  }
  return true;
}
function validateWeekDate(week, day) {
  if (week < 0 || week > 52) {
    return false;
  }
  if (day != null && (day < 0 || day > 6)) {
    return false;
  }
  return true;
}
function validateTime(hours, minutes, seconds) {
  if (hours < 0 || hours >= 25) {
    return false;
  }
  if (minutes != null && (minutes < 0 || minutes >= 60)) {
    return false;
  }
  if (seconds != null && (seconds < 0 || seconds >= 60)) {
    return false;
  }
  return true;
}

// node_modules/date-fns-tz/dist/esm/fromZonedTime/index.js
function fromZonedTime(date, timeZone, options) {
  if (typeof date === "string" && !date.match(tzPattern)) {
    return toDate2(date, __spreadProps(__spreadValues({}, options), { timeZone }));
  }
  date = toDate2(date, options);
  const utc = newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()).getTime();
  const offsetMilliseconds = tzParseTimezone(timeZone, new Date(utc));
  return new Date(utc + offsetMilliseconds);
}

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
var keycodes_exports = {};
__export(keycodes_exports, {
  A: () => A,
  ALT: () => ALT,
  APOSTROPHE: () => APOSTROPHE,
  AT_SIGN: () => AT_SIGN,
  B: () => B,
  BACKSLASH: () => BACKSLASH,
  BACKSPACE: () => BACKSPACE,
  C: () => C,
  CAPS_LOCK: () => CAPS_LOCK,
  CLOSE_SQUARE_BRACKET: () => CLOSE_SQUARE_BRACKET,
  COMMA: () => COMMA,
  CONTEXT_MENU: () => CONTEXT_MENU,
  CONTROL: () => CONTROL,
  D: () => D,
  DASH: () => DASH,
  DELETE: () => DELETE,
  DOWN_ARROW: () => DOWN_ARROW,
  E: () => E,
  EIGHT: () => EIGHT,
  END: () => END,
  ENTER: () => ENTER,
  EQUALS: () => EQUALS,
  ESCAPE: () => ESCAPE,
  F: () => F,
  F1: () => F1,
  F10: () => F10,
  F11: () => F11,
  F12: () => F12,
  F2: () => F2,
  F3: () => F3,
  F4: () => F4,
  F5: () => F5,
  F6: () => F6,
  F7: () => F7,
  F8: () => F8,
  F9: () => F9,
  FF_EQUALS: () => FF_EQUALS,
  FF_MINUS: () => FF_MINUS,
  FF_MUTE: () => FF_MUTE,
  FF_SEMICOLON: () => FF_SEMICOLON,
  FF_VOLUME_DOWN: () => FF_VOLUME_DOWN,
  FF_VOLUME_UP: () => FF_VOLUME_UP,
  FIRST_MEDIA: () => FIRST_MEDIA,
  FIVE: () => FIVE,
  FOUR: () => FOUR,
  G: () => G,
  H: () => H,
  HOME: () => HOME,
  I: () => I,
  INSERT: () => INSERT,
  J: () => J,
  K: () => K,
  L: () => L,
  LAST_MEDIA: () => LAST_MEDIA,
  LEFT_ARROW: () => LEFT_ARROW,
  M: () => M,
  MAC_ENTER: () => MAC_ENTER,
  MAC_META: () => MAC_META,
  MAC_WK_CMD_LEFT: () => MAC_WK_CMD_LEFT,
  MAC_WK_CMD_RIGHT: () => MAC_WK_CMD_RIGHT,
  META: () => META,
  MUTE: () => MUTE,
  N: () => N,
  NINE: () => NINE,
  NUMPAD_DIVIDE: () => NUMPAD_DIVIDE,
  NUMPAD_EIGHT: () => NUMPAD_EIGHT,
  NUMPAD_FIVE: () => NUMPAD_FIVE,
  NUMPAD_FOUR: () => NUMPAD_FOUR,
  NUMPAD_MINUS: () => NUMPAD_MINUS,
  NUMPAD_MULTIPLY: () => NUMPAD_MULTIPLY,
  NUMPAD_NINE: () => NUMPAD_NINE,
  NUMPAD_ONE: () => NUMPAD_ONE,
  NUMPAD_PERIOD: () => NUMPAD_PERIOD,
  NUMPAD_PLUS: () => NUMPAD_PLUS,
  NUMPAD_SEVEN: () => NUMPAD_SEVEN,
  NUMPAD_SIX: () => NUMPAD_SIX,
  NUMPAD_THREE: () => NUMPAD_THREE,
  NUMPAD_TWO: () => NUMPAD_TWO,
  NUMPAD_ZERO: () => NUMPAD_ZERO,
  NUM_CENTER: () => NUM_CENTER,
  NUM_LOCK: () => NUM_LOCK,
  O: () => O,
  ONE: () => ONE,
  OPEN_SQUARE_BRACKET: () => OPEN_SQUARE_BRACKET,
  P: () => P,
  PAGE_DOWN: () => PAGE_DOWN,
  PAGE_UP: () => PAGE_UP,
  PAUSE: () => PAUSE,
  PERIOD: () => PERIOD,
  PLUS_SIGN: () => PLUS_SIGN,
  PRINT_SCREEN: () => PRINT_SCREEN,
  Q: () => Q,
  QUESTION_MARK: () => QUESTION_MARK,
  R: () => R,
  RIGHT_ARROW: () => RIGHT_ARROW,
  S: () => S,
  SCROLL_LOCK: () => SCROLL_LOCK,
  SEMICOLON: () => SEMICOLON,
  SEVEN: () => SEVEN,
  SHIFT: () => SHIFT,
  SINGLE_QUOTE: () => SINGLE_QUOTE,
  SIX: () => SIX,
  SLASH: () => SLASH,
  SPACE: () => SPACE,
  T: () => T,
  TAB: () => TAB,
  THREE: () => THREE,
  TILDE: () => TILDE,
  TWO: () => TWO,
  U: () => U,
  UP_ARROW: () => UP_ARROW,
  V: () => V,
  VOLUME_DOWN: () => VOLUME_DOWN,
  VOLUME_UP: () => VOLUME_UP,
  W: () => W,
  X: () => X,
  Y: () => Y,
  Z: () => Z,
  ZERO: () => ZERO,
  hasModifierKey: () => hasModifierKey
});

// node_modules/@angular/cdk/fesm2022/_keycodes-chunk.mjs
var MAC_ENTER = 3;
var BACKSPACE = 8;
var TAB = 9;
var NUM_CENTER = 12;
var ENTER = 13;
var SHIFT = 16;
var CONTROL = 17;
var ALT = 18;
var PAUSE = 19;
var CAPS_LOCK = 20;
var ESCAPE = 27;
var SPACE = 32;
var PAGE_UP = 33;
var PAGE_DOWN = 34;
var END = 35;
var HOME = 36;
var LEFT_ARROW = 37;
var UP_ARROW = 38;
var RIGHT_ARROW = 39;
var DOWN_ARROW = 40;
var PLUS_SIGN = 43;
var PRINT_SCREEN = 44;
var INSERT = 45;
var DELETE = 46;
var ZERO = 48;
var ONE = 49;
var TWO = 50;
var THREE = 51;
var FOUR = 52;
var FIVE = 53;
var SIX = 54;
var SEVEN = 55;
var EIGHT = 56;
var NINE = 57;
var FF_SEMICOLON = 59;
var FF_EQUALS = 61;
var QUESTION_MARK = 63;
var AT_SIGN = 64;
var A = 65;
var B = 66;
var C = 67;
var D = 68;
var E = 69;
var F = 70;
var G = 71;
var H = 72;
var I = 73;
var J = 74;
var K = 75;
var L = 76;
var M = 77;
var N = 78;
var O = 79;
var P = 80;
var Q = 81;
var R = 82;
var S = 83;
var T = 84;
var U = 85;
var V = 86;
var W = 87;
var X = 88;
var Y = 89;
var Z = 90;
var META = 91;
var MAC_WK_CMD_LEFT = 91;
var MAC_WK_CMD_RIGHT = 93;
var CONTEXT_MENU = 93;
var NUMPAD_ZERO = 96;
var NUMPAD_ONE = 97;
var NUMPAD_TWO = 98;
var NUMPAD_THREE = 99;
var NUMPAD_FOUR = 100;
var NUMPAD_FIVE = 101;
var NUMPAD_SIX = 102;
var NUMPAD_SEVEN = 103;
var NUMPAD_EIGHT = 104;
var NUMPAD_NINE = 105;
var NUMPAD_MULTIPLY = 106;
var NUMPAD_PLUS = 107;
var NUMPAD_MINUS = 109;
var NUMPAD_PERIOD = 110;
var NUMPAD_DIVIDE = 111;
var F1 = 112;
var F2 = 113;
var F3 = 114;
var F4 = 115;
var F5 = 116;
var F6 = 117;
var F7 = 118;
var F8 = 119;
var F9 = 120;
var F10 = 121;
var F11 = 122;
var F12 = 123;
var NUM_LOCK = 144;
var SCROLL_LOCK = 145;
var FIRST_MEDIA = 166;
var FF_MINUS = 173;
var MUTE = 173;
var VOLUME_DOWN = 174;
var VOLUME_UP = 175;
var FF_MUTE = 181;
var FF_VOLUME_DOWN = 182;
var LAST_MEDIA = 183;
var FF_VOLUME_UP = 183;
var SEMICOLON = 186;
var EQUALS = 187;
var COMMA = 188;
var DASH = 189;
var PERIOD = 190;
var SLASH = 191;
var APOSTROPHE = 192;
var TILDE = 192;
var OPEN_SQUARE_BRACKET = 219;
var BACKSLASH = 220;
var CLOSE_SQUARE_BRACKET = 221;
var SINGLE_QUOTE = 222;
var MAC_META = 224;

// node_modules/@angular/cdk/fesm2022/keycodes.mjs
function hasModifierKey(event, ...modifiers) {
  if (modifiers.length) {
    return modifiers.some((modifier) => event[modifier]);
  }
  return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;
}

// node_modules/ngx-tethys/fesm2022/ngx-tethys-util.mjs
var differenceInCalendarDays2 = differenceInCalendarDays;
var differenceInCalendarMonths2 = differenceInCalendarMonths;
var differenceInCalendarYears2 = differenceInCalendarYears;
var differenceInCalendarQuarters2 = differenceInCalendarQuarters;
var differenceInWeeks2 = differenceInWeeks;
var differenceInHours2 = differenceInHours;
var differenceInMinutes2 = differenceInMinutes;
var differenceInSeconds2 = differenceInSeconds;
var differenceInDays2 = differenceInDays;
var isSameDay2 = isSameDay;
var isSameHour2 = isSameHour;
var isSameMinute2 = isSameMinute;
var isSameMonth2 = isSameMonth;
var isSameSecond2 = isSameSecond;
var isSameYear2 = isSameYear;
var isSameQuarter2 = isSameQuarter;
var isToday2 = isToday;
var isTomorrow2 = isTomorrow;
var isValid2 = isValid;
var setYear2 = setYear;
var startOfMonth2 = startOfMonth;
var startOfWeek2 = startOfWeek;
var addMonths2 = addMonths;
var addYears2 = addYears;
var setDay2 = setDay;
var setMonth2 = setMonth;
var setQuarter2 = setQuarter;
var getUnixTime2 = getUnixTime;
var startOfDay2 = startOfDay;
var endOfDay2 = endOfDay;
var fromUnixTime2 = fromUnixTime;
var isWeekend2 = isWeekend;
var getWeek2 = getWeek;
var getDaysInMonth2 = getDaysInMonth;
var addSeconds2 = addSeconds;
var addMinutes2 = addMinutes;
var addHours2 = addHours;
var addWeeks2 = addWeeks;
var addQuarters2 = addQuarters;
var startOfQuarter2 = startOfQuarter;
var startOfYear2 = startOfYear;
var startOfISOWeek2 = startOfISOWeek;
var endOfWeek2 = endOfWeek;
var endOfMonth2 = endOfMonth;
var endOfQuarter2 = endOfQuarter;
var endOfYear2 = endOfYear;
var endOfISOWeek2 = endOfISOWeek;
var format3 = format;
var getQuarter2 = getQuarter;
var addDays2 = addDays;
var subDays2 = subDays;
var subWeeks2 = subWeeks;
var setDefaultOptions2 = setDefaultOptions;
var getDateFnsLocale = (locale2) => {
  switch (locale2) {
    case ThyLocaleType.zhHans:
      return zhCN;
    case ThyLocaleType.zhHant:
      return zhTW;
    case ThyLocaleType.enUs:
      return enUS;
    case ThyLocaleType.jaJp:
      return ja;
    case ThyLocaleType.deDe:
      return de;
    default:
      return zhCN;
  }
};
function isUndefined(value) {
  return value === void 0;
}
function isNull(value) {
  return value === null;
}
function isUndefinedOrNull(value) {
  return isUndefined(value) || isNull(value);
}
function isArray(value) {
  return value && baseGetTag(value) === "[object Array]";
}
function isEmpty(value) {
  return !(isArray(value) && value.length > 0);
}
function isString(value) {
  return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) === "[object String]";
}
function isObjectLike(value) {
  return value !== null && typeof value === "object";
}
function baseGetTag(value) {
  const objectProto = Object.prototype;
  const hasOwnProperty = objectProto.hasOwnProperty;
  const toString = objectProto.toString;
  const symToStringTag = typeof Symbol !== "undefined" ? Symbol.toStringTag : void 0;
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  if (!(symToStringTag && symToStringTag in Object(value))) {
    return toString.call(value);
  }
  const isOwn = hasOwnProperty.call(value, symToStringTag);
  const tag = value[symToStringTag];
  let unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e) {
  }
  const result = toString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function isNumber2(value) {
  return typeof value === "number" || isObjectLike(value) && baseGetTag(value) === "[object Number]";
}
function isObject(value) {
  const type = typeof value;
  return !!value && (type === "object" || type === "function");
}
function isFunction(value) {
  const type = typeof value;
  return !!value && type === "function";
}
function isDate(value) {
  const type = typeof value;
  return !!value && type === "object" && !!value.getTime;
}
function coerceArray2(value) {
  return Array.isArray(value) ? value : [value];
}
function get(object, path, defaultValue) {
  const paths = path.split(".");
  let result = object[paths.shift()];
  while (result && paths.length) {
    result = result[paths.shift()];
  }
  return result === void 0 ? defaultValue : result;
}
function set(object, path, value) {
  if (object == null) {
    return object;
  }
  const paths = path.split(".");
  let index2 = -1;
  const length = paths.length;
  const lastIndex = length - 1;
  let nested = object;
  while (nested !== null && ++index2 < length) {
    const key = paths[index2];
    if (isObject(nested)) {
      if (index2 === lastIndex) {
        nested[key] = value;
        nested = nested[key];
        break;
      } else {
        if (nested[key] == null) {
          nested[key] = {};
        }
      }
    }
    nested = nested[key];
  }
  return object;
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && baseGetTag(value) === "[object Boolean]";
}
function isClass(value) {
  return isFunction(value) && /^\s*class\s+/.test(value.toString());
}
function htmlElementIsEmpty(element) {
  if (element && element.childNodes) {
    const nodes = element.childNodes;
    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.nodeType === Node.ELEMENT_NODE && node.outerHTML.toString().trim().length !== 0) {
        return false;
      } else if (node.nodeType === Node.TEXT_NODE && node.textContent.toString().trim().length !== 0) {
        return false;
      } else if (node.nodeType !== Node.COMMENT_NODE) {
        return false;
      }
    }
  }
  return true;
}
function hexToRgb(hexValue, alpha) {
  const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  const hex = hexValue.replace(rgx, (m, r, g, b) => r + r + g + g + b + b);
  const rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!rgb)
    return;
  const resultR = parseInt(rgb[1], 16);
  const resultG = parseInt(rgb[2], 16);
  const resultB = parseInt(rgb[3], 16);
  if (!isUndefinedOrNull(alpha)) {
    return `rgba(${resultR}, ${resultG}, ${resultB}, ${alpha})`;
  } else {
    return `rgb(${resultR}, ${resultG}, ${resultB})`;
  }
}
function dateToUnixTimestamp(date) {
  if (isNumber2(date)) {
    if (date.toString().length === 10) {
      return date;
    } else {
      return parseInt((date / 1e3).toFixed(0), 10);
    }
  } else {
    return parseInt((date.getTime() / 1e3).toFixed(0), 10);
  }
}
function clamp(value, min = 0, max = 100) {
  return Math.max(min, Math.min(max, value));
}
function keyBy2(array, key) {
  const result = {};
  array.forEach((item) => {
    const keyValue = item[key];
    result[keyValue] = item;
  });
  return result;
}
function indexKeyBy(array, key) {
  const result = {};
  array.forEach((item, index2) => {
    const keyValue = item[key];
    result[keyValue] = index2;
  });
  return result;
}
function upperFirst(string) {
  return string.slice(0, 1).toUpperCase() + string.slice(1);
}
function camelCase(values) {
  if (isArray(values)) {
    return values.reduce((result, word, index2) => {
      word = word.toLowerCase();
      return result + (index2 ? upperFirst(word) : word);
    }, "");
  } else {
    return;
  }
}
function generateRandomStr() {
  return Math.random().toString(36).substring(2);
}
function isTemplateRef(value) {
  return value instanceof TemplateRef;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement;
}
function isElementRef(value) {
  return value instanceof ElementRef;
}
function coerceBooleanProperty2(value) {
  if (value === "" || value && value !== "false") {
    return true;
  } else {
    return false;
  }
}
function coerceNumberValue(value, fallbackValue = 0) {
  return _isNumberValue(value) ? Number(value) : fallbackValue;
}
function coerceCssPixelValue2(value) {
  value = _isNumberValue(value) ? Number(value) : value;
  return coerceCssPixelValue(value);
}
function valueFunctionProp(prop, ...args) {
  return typeof prop === "function" ? prop(...args) : prop;
}
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    if (objA[key] !== objB[key]) {
      return false;
    }
  }
  return true;
}
function concatArray(items, originalItems = []) {
  let _originalItems = [];
  if (!originalItems) {
    _originalItems = [];
  } else {
    _originalItems = coerceArray2(originalItems);
  }
  if (items) {
    if (isArray(items)) {
      return [..._originalItems, ...items];
    } else {
      return [..._originalItems, items];
    }
  } else {
    return _originalItems;
  }
}
function humanizeBytes(bytes, noSpace = false, fractionDigits = 1) {
  if (bytes === 0) {
    return "0 Byte";
  }
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB", "PB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(fractionDigits)) + (noSpace ? "" : " ") + sizes[i];
}
function isFloat(value) {
  if (!value) {
    return false;
  }
  return /^[-+]?([0-9]+([.][0-9]*)?|[.][0-9]+)([Ee][-+]?[0-9]+)?$/.test(value);
}
function hasTimeInStringDate(dateString) {
  const standardFormat = /\d{4}[-/]\d{1,2}[-/]\d{1,2}\s+\d{1,2}:\d{1,2}/;
  const chineseFormat = /\d{4}年\d{1,2}月\d{1,2}日?\s+\d{1,2}[时:]\d{1,2}[分]?/;
  const reverseEnglishFormat = /\d{1,2}\s+[A-Za-z]{3,}\s+\d{4}\s+\d{1,2}:\d{1,2}/;
  const englishFormat = /[A-Za-z]{3,}\s+\d{1,2},?\s+\d{4}\s+\d{1,2}:\d{1,2}/;
  const isoFormat = /\d{4}-\d{2}-\d{2}T\d{2}:\d{2}/;
  return standardFormat.test(dateString) || chineseFormat.test(dateString) || reverseEnglishFormat.test(dateString) || englishFormat.test(dateString) || isoFormat.test(dateString);
}
var index = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  camelCase,
  clamp,
  coerceArray: coerceArray2,
  coerceBooleanProperty: coerceBooleanProperty2,
  coerceCssPixelValue: coerceCssPixelValue2,
  coerceNumberValue,
  concatArray,
  dateToUnixTimestamp,
  generateRandomStr,
  get,
  hasTimeInStringDate,
  hexToRgb,
  htmlElementIsEmpty,
  humanizeBytes,
  indexKeyBy,
  isArray,
  isBoolean,
  isClass,
  isDate,
  isElementRef,
  isEmpty,
  isFloat,
  isFunction,
  isHTMLElement,
  isNull,
  isNumber: isNumber2,
  isObject,
  isString,
  isTemplateRef,
  isUndefined,
  isUndefinedOrNull,
  keyBy: keyBy2,
  set,
  shallowEqual,
  valueFunctionProp
});
function sortRangeValue(rangeValue) {
  if (Array.isArray(rangeValue)) {
    const [start, end] = rangeValue;
    return start && end && start.isAfterSecond(end) ? [end, start] : [start, end];
  }
  return rangeValue;
}
var DEFAULT_TIMEZONE = "Asia/Shanghai";
var TinyDate = class _TinyDate {
  static {
    this.locale = getDefaultLocaleId();
  }
  static {
    this.dateFnsLocale = getDateFnsLocale(_TinyDate.locale);
  }
  static {
    this.defaultTimeZone = DEFAULT_TIMEZONE;
  }
  constructor(date, zone) {
    setDefaultOptions2({ locale: _TinyDate.dateFnsLocale });
    this.useTimeZone = zone || _TinyDate.defaultTimeZone;
    if (date) {
      if (date instanceof Date) {
        this.nativeDate = _TinyDate.utcToZonedTime(date, this.useTimeZone);
      } else if (typeof date === "string") {
        if (hasTimeInStringDate(date)) {
          const originTime = new Date(date);
          const zoneTime = TZDate.tz(this.useTimeZone, originTime);
          const utcDate = fromZonedTime(zoneTime, this.useTimeZone).toISOString();
          this.nativeDate = new TZDate(utcDate, this.useTimeZone);
        } else {
          this.nativeDate = new TZDate(date, this.useTimeZone);
        }
      } else if (typeof date === "number") {
        this.nativeDate = new TZDate(date, this.useTimeZone);
      } else if (typeof ngDevMode === "undefined" || ngDevMode) {
        throw new Error(`The input date type is not supported expect Date | string | number | { date: number; with_time: 0 | 1}, actual ${JSON.stringify(date)}`);
      }
    } else {
      this.nativeDate = new TZDate(Date.now(), this.useTimeZone);
    }
  }
  static setDefaultLocale(locale2) {
    _TinyDate.locale = locale2;
    _TinyDate.dateFnsLocale = getDateFnsLocale(locale2);
    return setDefaultOptions2({ locale: _TinyDate.dateFnsLocale });
  }
  static getDefaultLocale() {
    return { locale: _TinyDate.locale, dateFnsLocale: _TinyDate.dateFnsLocale };
  }
  static setDefaultTimeZone(zone) {
    _TinyDate.defaultTimeZone = zone ?? DEFAULT_TIMEZONE;
  }
  static getDefaultTimeZone() {
    return _TinyDate.defaultTimeZone;
  }
  static utcToZonedTime(value, timeZone) {
    return TZDate.tz(timeZone || _TinyDate.defaultTimeZone, value);
  }
  static createDateInTimeZone(year, month, day, hours, minutes, seconds, timeZone) {
    return new TZDate(year, month, day, hours, minutes, seconds, timeZone || _TinyDate.defaultTimeZone);
  }
  static fromUnixTime(unixTime, timeZone) {
    return new _TinyDate(fromUnixTime2(unixTime), timeZone || _TinyDate.defaultTimeZone);
  }
  // get
  getTime() {
    return this.nativeDate.getTime();
  }
  getDate() {
    return this.nativeDate.getDate();
  }
  getYear() {
    return this.nativeDate.getFullYear();
  }
  getQuarter() {
    return getQuarter2(this.nativeDate);
  }
  getMonth() {
    return this.nativeDate.getMonth();
  }
  getFullYear() {
    return this.nativeDate.getFullYear();
  }
  getWeek(options = { weekStartsOn: 1 }) {
    return getWeek2(this.nativeDate, options);
  }
  getDay() {
    return this.nativeDate.getDay();
  }
  getHours() {
    return this.nativeDate.getHours();
  }
  getMinutes() {
    return this.nativeDate.getMinutes();
  }
  getSeconds() {
    return this.nativeDate.getSeconds();
  }
  getMilliseconds() {
    return this.nativeDate.getMilliseconds();
  }
  getDaysInMonth() {
    return getDaysInMonth2(this.nativeDate);
  }
  getDaysInQuarter() {
    return differenceInCalendarDays2(this.endOfQuarter().addSeconds(1).nativeDate, this.startOfQuarter().nativeDate);
  }
  // set
  setDate(amount) {
    return new _TinyDate(this.nativeDate.setDate(amount), this.useTimeZone);
  }
  setHms(hour, minute, second) {
    return new _TinyDate(this.nativeDate?.setHours(hour, minute, second), this.useTimeZone);
  }
  setYear(year) {
    return new _TinyDate(setYear2(this.nativeDate, year), this.useTimeZone);
  }
  setMonth(month) {
    return new _TinyDate(setMonth2(this.nativeDate, month), this.useTimeZone);
  }
  setQuarter(quarter) {
    return new _TinyDate(setQuarter2(this.nativeDate, quarter), this.useTimeZone);
  }
  setDay(day, options) {
    return new _TinyDate(setDay2(this.nativeDate, day, options), this.useTimeZone);
  }
  setHours(hours) {
    return new _TinyDate(setHours(this.nativeDate, hours), this.useTimeZone);
  }
  setMinutes(minutes) {
    return new _TinyDate(setMinutes(this.nativeDate, minutes), this.useTimeZone);
  }
  setSeconds(seconds) {
    return new _TinyDate(setSeconds(this.nativeDate, seconds), this.useTimeZone);
  }
  // add
  addYears(amount) {
    return new _TinyDate(addYears2(this.nativeDate, amount), this.useTimeZone);
  }
  addQuarters(amount) {
    return new _TinyDate(addQuarters2(this.nativeDate, amount), this.useTimeZone);
  }
  addMonths(amount) {
    return new _TinyDate(addMonths2(this.nativeDate, amount), this.useTimeZone);
  }
  addWeeks(amount) {
    return new _TinyDate(addWeeks2(this.nativeDate, amount), this.useTimeZone);
  }
  addDays(amount) {
    return new _TinyDate(addDays2(this.nativeDate, amount), this.useTimeZone);
  }
  addHours(amount) {
    return new _TinyDate(addHours2(this.nativeDate, amount), this.useTimeZone);
  }
  addSeconds(amount) {
    return new _TinyDate(addSeconds2(this.nativeDate, amount), this.useTimeZone);
  }
  addMinutes(amount) {
    return new _TinyDate(addMinutes2(this.nativeDate, amount), this.useTimeZone);
  }
  // isSame
  isSame(date, grain = "day") {
    let fn;
    switch (grain) {
      case "decade":
        fn = (pre, next) => Math.abs(pre.getFullYear() - next.getFullYear()) < 11;
        break;
      case "year":
        fn = isSameYear2;
        break;
      case "month":
        fn = isSameMonth2;
        break;
      case "quarter":
        fn = isSameQuarter2;
        break;
      case "day":
        fn = isSameDay2;
        break;
      case "hour":
        fn = isSameHour2;
        break;
      case "minute":
        fn = isSameMinute2;
        break;
      case "second":
        fn = isSameSecond2;
        break;
      default:
        fn = isSameDay2;
        break;
    }
    return fn(this.nativeDate, this.toNativeDate(date));
  }
  isSameYear(date) {
    return this.isSame(date, "year");
  }
  isSameMonth(date) {
    return this.isSame(date, "month");
  }
  isSameQuarter(date) {
    return this.isSame(date, "quarter");
  }
  isSameDay(date) {
    return this.isSame(date, "day");
  }
  isSameHour(date) {
    return this.isSame(date, "hour");
  }
  isSameMinute(date) {
    return this.isSame(date, "minute");
  }
  isSameSecond(date) {
    return this.isSame(date, "second");
  }
  // isBefore and isAfter
  isBeforeYear(date) {
    return this.compare(date, "year");
  }
  isBeforeQuarter(date) {
    return this.compare(date, "quarter");
  }
  isBeforeMonth(date) {
    return this.compare(date, "month");
  }
  isBeforeWeek(date) {
    return this.compare(date, "week");
  }
  isBeforeDay(date) {
    return this.compare(date, "day");
  }
  isBeforeHour(date) {
    return this.compare(date, "hour");
  }
  isBeforeMinute(date) {
    return this.compare(date, "minute");
  }
  isBeforeSecond(date) {
    return this.compare(date, "second");
  }
  isAfterYear(date) {
    return this.compare(date, "year", false);
  }
  isAfterQuarter(date) {
    return this.compare(date, "quarter", false);
  }
  isAfterMonth(date) {
    return this.compare(date, "month", false);
  }
  isAfterWeek(date) {
    return this.compare(date, "week", false);
  }
  isAfterDay(date) {
    return this.compare(date, "day", false);
  }
  isAfterHour(date) {
    return this.compare(date, "hour", false);
  }
  isAfterMinute(date) {
    return this.compare(date, "minute", false);
  }
  isAfterSecond(date) {
    return this.compare(date, "second", false);
  }
  // is
  isWeekend() {
    return isWeekend2(this.nativeDate);
  }
  isToday() {
    return isToday2(this.nativeDate);
  }
  isTomorrow() {
    return isTomorrow2(this.nativeDate);
  }
  isValid() {
    return isValid2(this.nativeDate);
  }
  // startOf and endOf
  startOfYear() {
    return new _TinyDate(startOfYear2(this.nativeDate), this.useTimeZone);
  }
  startOfQuarter() {
    return new _TinyDate(startOfQuarter2(this.nativeDate), this.useTimeZone);
  }
  startOfMonth() {
    return new _TinyDate(startOfMonth2(this.nativeDate), this.useTimeZone);
  }
  startOfWeek(options) {
    return new _TinyDate(startOfWeek2(this.nativeDate, options), this.useTimeZone);
  }
  startOfDay() {
    return new _TinyDate(startOfDay2(this.nativeDate), this.useTimeZone);
  }
  endOfYear() {
    return new _TinyDate(endOfYear2(this.nativeDate), this.useTimeZone);
  }
  endOfQuarter() {
    return new _TinyDate(endOfQuarter2(this.nativeDate), this.useTimeZone);
  }
  endOfMonth() {
    return new _TinyDate(endOfMonth2(this.nativeDate), this.useTimeZone);
  }
  endOfWeek(options) {
    return new _TinyDate(endOfWeek2(this.nativeDate, options), this.useTimeZone);
  }
  endOfDay() {
    return new _TinyDate(endOfDay2(this.nativeDate), this.useTimeZone);
  }
  // other
  format(mat, options) {
    return format3(this.nativeDate, mat, options);
  }
  calendarStart(options) {
    return new _TinyDate(startOfWeek2(startOfMonth2(this.nativeDate), options), this.useTimeZone);
  }
  clone() {
    return new _TinyDate(this.nativeDate, this.useTimeZone);
  }
  getUnixTime() {
    return getUnixTime2(this.nativeDate);
  }
  compare(date, grain = "day", isBefore = true) {
    if (date === null) {
      return false;
    }
    let fn;
    switch (grain) {
      case "year":
        fn = differenceInCalendarYears2;
        break;
      case "quarter":
        fn = differenceInCalendarQuarters2;
        break;
      case "month":
        fn = differenceInCalendarMonths2;
        break;
      case "day":
        fn = differenceInCalendarDays2;
        break;
      case "week":
        fn = differenceInWeeks2;
        break;
      case "hour":
        fn = differenceInHours2;
        break;
      case "minute":
        fn = differenceInMinutes2;
        break;
      case "second":
        fn = differenceInSeconds2;
        break;
      default:
        fn = differenceInCalendarDays2;
        break;
    }
    return isBefore ? fn(this.nativeDate, this.toNativeDate(date)) < 0 : fn(this.nativeDate, this.toNativeDate(date)) > 0;
  }
  toNativeDate(date) {
    return date instanceof _TinyDate ? date.nativeDate : date;
  }
  startOfISOWeek() {
    return new _TinyDate(startOfISOWeek2(this.nativeDate), this.useTimeZone);
  }
  endOfISOWeek() {
    return new _TinyDate(endOfISOWeek2(this.nativeDate), this.useTimeZone);
  }
  differenceInDays(date) {
    return differenceInDays2(this.nativeDate, date);
  }
  differenceInHours(date) {
    return differenceInHours2(this.nativeDate, date);
  }
  subWeeks(amount) {
    return new _TinyDate(subWeeks2(this.nativeDate, amount), this.useTimeZone);
  }
  subDays(amount) {
    return new _TinyDate(subDays2(this.nativeDate, amount), this.useTimeZone);
  }
};
var proto = Element.prototype;
var vendor = proto.matches || proto["matchesSelector"] || proto["webkitMatchesSelector"] || proto["mozMatchesSelector"] || proto["msMatchesSelector"] || proto["oMatchesSelector"];
function getWindow(elem) {
  return elem != null && elem === elem.window ? elem : elem.nodeType === 9 && elem.defaultView;
}
function getElementOffset(elem) {
  let docElem, win, doc;
  if (!elem) {
    return;
  }
  if (!elem.getClientRects().length) {
    return { top: 0, left: 0 };
  }
  const rect = elem.getBoundingClientRect();
  if (rect.width || rect.height) {
    doc = elem.ownerDocument;
    win = getWindow(doc);
    docElem = doc.documentElement;
    return {
      top: rect.top + win.pageYOffset - docElem.clientTop,
      left: rect.left + win.pageXOffset - docElem.clientLeft,
      height: rect.height,
      width: rect.width
    };
  }
  return rect;
}
function isTouchEvent(event) {
  return event.type.startsWith("touch");
}
function assertIconOnly(wrapperElement) {
  const listOfNode = Array.from(wrapperElement.childNodes);
  const iconCount = listOfNode.filter((node) => ["THY-ICON", "I"].includes(node.nodeName)).length;
  const noText = listOfNode.every((node) => node.nodeName !== "#text");
  const noSpan = listOfNode.every((node) => node.nodeName !== "SPAN");
  const isIconOnly = noSpan && noText && iconCount >= 1;
  return isIconOnly;
}
function elementMatchClosest(element, selectors) {
  let matched = false;
  if (element && element.closest) {
    matched = !!coerceArray2(selectors).find((selector) => {
      return element.closest(selector);
    });
  }
  return matched;
}
var record = {};
var logWarnDeprecation = true;
var PREFIX = "[NGX-TETHYS]:";
function notRecorded(...args) {
  const asRecord = args.reduce((acc, c) => acc + c.toString(), "");
  if (record[asRecord]) {
    return false;
  } else {
    record[asRecord] = true;
    return true;
  }
}
function consoleCommonBehavior(consoleFunc, ...args) {
  if (isDevMode() && notRecorded(...args)) {
    consoleFunc(...args);
  }
}
function createWarnDeprecation(prefix) {
  return (...args) => {
    const stack = new Error().stack;
    return consoleCommonBehavior((...arg) => {
      if (logWarnDeprecation) {
        console.warn(prefix, "deprecated:", ...arg, stack);
      }
    }, ...args);
  };
}
var warnDeprecation = createWarnDeprecation(PREFIX);

// node_modules/ngx-tethys/fesm2022/ngx-tethys-icon.mjs
var _c0 = ["*"];
var printErrorWhenNotFound = true;
function setPrintErrorWhenIconNotFound(value) {
  printErrorWhenNotFound = value;
}
function getWhetherPrintErrorWhenIconNotFound() {
  return printErrorWhenNotFound;
}
var SvgIconConfig = class {
  constructor(data) {
    if (data && !!data.nodeName) {
      this.svgElement = data;
    } else {
      this.url = data;
    }
  }
};
var ThyIconRegistry = class _ThyIconRegistry {
  constructor() {
    this.sanitizer = inject(DomSanitizer);
    this.httpClient = inject(HttpClient, {
      optional: false
    });
    this.document = inject(DOCUMENT);
    this.defaultFontSetClass = "wt-icon";
    this.internalIconMode = "svg";
    this.svgIconConfigs = /* @__PURE__ */ new Map();
    this.svgIconSetConfigs = /* @__PURE__ */ new Map();
    this.inProgressUrlFetches = /* @__PURE__ */ new Map();
  }
  get iconMode() {
    return this.internalIconMode;
  }
  getIconNameNotFoundError(iconName) {
    return Error(`Unable to find icon with the name "${iconName}"`);
  }
  getIconFailedToSanitizeLiteralError(literal) {
    return Error(`The literal provided to ThyIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${literal}".`);
  }
  internalAddSvgIconSet(namespace, config2) {
    const configNamespace = this.svgIconSetConfigs.get(namespace);
    if (configNamespace) {
      configNamespace.push(config2);
    } else {
      this.svgIconSetConfigs.set(namespace, [config2]);
    }
    return this;
  }
  cloneSvg(svg) {
    return svg.cloneNode(true);
  }
  fetchUrl(safeUrl) {
    if (safeUrl == null) {
      throw Error(`Cannot fetch icon from URL "${safeUrl}".`);
    }
    const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !url) {
      throw new Error(`The URL provided to ThyIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${url}".`);
    }
    const inProgressFetch = this.inProgressUrlFetches.get(url);
    if (inProgressFetch) {
      return inProgressFetch;
    } else {
      const req = this.httpClient.get(url, {
        responseType: "text"
      }).pipe(finalize(() => this.inProgressUrlFetches.delete(url)), share());
      this.inProgressUrlFetches.set(url, req);
      return req;
    }
  }
  toSvgElement(element) {
    const svg = this.svgElementFromString("<svg></svg>");
    for (let i = 0; i < element.childNodes.length; i++) {
      if (element.childNodes[i].nodeType === this.document.ELEMENT_NODE) {
        svg.appendChild(element.childNodes[i].cloneNode(true));
      }
    }
    return svg;
  }
  extractSvgIconFromIconSet(iconSet, iconName) {
    const iconSource = iconSet.querySelector(`[id="${iconName}"]`);
    if (!iconSource) {
      return null;
    }
    const iconElement = iconSource.cloneNode(true);
    iconElement.removeAttribute("id");
    if (iconElement.nodeName.toLowerCase() === "svg") {
      return this.setSvgAttributes(iconElement);
    }
    if (iconElement.nodeName.toLowerCase() === "symbol") {
      return this.setSvgAttributes(this.toSvgElement(iconElement));
    }
    const svg = this.svgElementFromString("<svg></svg>");
    svg.appendChild(iconElement);
    return this.setSvgAttributes(svg);
  }
  extractIconWithNameFromIconSetConfigs(iconName, iconSetConfigs) {
    for (let i = iconSetConfigs.length - 1; i >= 0; i--) {
      const config2 = iconSetConfigs[i];
      if (config2.svgElement) {
        const foundIcon = this.extractSvgIconFromIconSet(config2.svgElement, iconName);
        if (foundIcon) {
          return foundIcon;
        }
      }
    }
    return null;
  }
  svgElementFromString(str) {
    const div = this.document.createElement("DIV");
    div.innerHTML = str;
    const svg = div.querySelector("svg");
    if (!svg) {
      throw Error("<svg> tag not found");
    }
    return svg;
  }
  setSvgAttributes(svg) {
    svg.setAttribute("fit", "");
    svg.setAttribute("height", "1em");
    svg.setAttribute("width", "1em");
    svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
    svg.setAttribute("focusable", "false");
    return svg;
  }
  createSvgElementForSingleIcon(responseText) {
    const svg = this.svgElementFromString(responseText);
    this.setSvgAttributes(svg);
    return svg;
  }
  loadSvgIconFromConfig(config2) {
    return this.fetchUrl(config2.url).pipe(map((svgText) => this.createSvgElementForSingleIcon(svgText)));
  }
  loadSvgIconSetFromConfig(config2) {
    if (config2.svgElement) {
      return of(config2.svgElement);
    }
    return this.fetchUrl(config2.url).pipe(map((svgText) => {
      if (!config2.svgElement) {
        config2.svgElement = this.svgElementFromString(svgText);
      }
      return config2.svgElement;
    }));
  }
  getSvgFromConfig(config2) {
    if (config2.svgElement) {
      return of(this.cloneSvg(config2.svgElement));
    } else {
      return this.loadSvgIconFromConfig(config2).pipe(tap((svg) => config2.svgElement = svg), map((svg) => this.cloneSvg(svg)));
    }
  }
  getSvgFromIconSetConfigs(name, iconSetConfigs) {
    const namedIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
    if (namedIcon) {
      return of(namedIcon);
    }
    const iconSetFetchRequests = iconSetConfigs.filter((iconSetConfig) => !iconSetConfig.svgElement).map((iconSetConfig) => {
      return this.loadSvgIconSetFromConfig(iconSetConfig).pipe(catchError((err) => {
        const url = this.sanitizer.sanitize(SecurityContext.RESOURCE_URL, iconSetConfig.url);
        console.error(`Loading icon set URL: ${url} failed: ${err.message}`);
        return of(null);
      }));
    });
    return forkJoin(iconSetFetchRequests).pipe(map(() => {
      const foundIcon = this.extractIconWithNameFromIconSetConfigs(name, iconSetConfigs);
      if (!foundIcon) {
        throw this.getIconNameNotFoundError(name);
      }
      return foundIcon;
    }));
  }
  internalAddSvgIconConfig(namespace, iconName, config2) {
    this.svgIconConfigs.set(this.buildIconKey(namespace, iconName), config2);
    return this;
  }
  buildIconKey(namespace, name) {
    return `${namespace}:${name}`;
  }
  splitIconName(iconName) {
    if (!iconName) {
      return ["", ""];
    }
    const parts = iconName.split(":");
    switch (parts.length) {
      case 1:
        return ["", parts[0]];
      // Use default namespace.
      case 2:
        return parts;
      default:
        throw Error(`Invalid icon name: "${iconName}"`);
    }
  }
  addSvgIconSetInNamespace(namespace, url) {
    url = isString(url) ? this.sanitizer.bypassSecurityTrustResourceUrl(url) : url;
    return this.internalAddSvgIconSet(namespace, new SvgIconConfig(url));
  }
  /**
   * 添加SVG图标集，添加到默认命名空间
   */
  addSvgIconSet(url) {
    return this.addSvgIconSetInNamespace("", url);
  }
  addSvgIconSetLiteralInNamespace(namespace, literal) {
    const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
    if (!sanitizedLiteral) {
      throw this.getIconFailedToSanitizeLiteralError(literal);
    }
    const svgElement = this.svgElementFromString(sanitizedLiteral);
    return this.internalAddSvgIconSet(namespace, new SvgIconConfig(svgElement));
  }
  addSvgIconSetLiteral(literal) {
    return this.addSvgIconSetLiteralInNamespace("", literal);
  }
  /**
   * @description.en-us Registers an icon by URL in the specified namespace.
   * @description 添加单个SVG图标到指定的命名空间
   * @param namespace Namespace in which the icon should be registered.
   * @param iconName Name under which the icon should be registered.
   * @param url
   */
  addSvgIconInNamespace(namespace, iconName, url) {
    url = isString(url) ? this.sanitizer.bypassSecurityTrustResourceUrl(url) : url;
    return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(url));
  }
  /**
   * @description.en-us Registers an icon by URL in the default namespace.
   * @description 添加单个SVG图标
   * @param iconName Name under which the icon should be registered.
   * @param url
   */
  addSvgIcon(iconName, url) {
    return this.addSvgIconInNamespace("", iconName, url);
  }
  /**
   * @description.en-us Registers an icon using an HTML string in the default namespace.
   * @description 添加单个SVG图标字符串，直接传入 SVG HTML 字符串
   * @param iconName Name under which the icon should be registered.
   * @param literal SVG source of the icon.
   */
  addSvgIconLiteral(iconName, literal) {
    return this.addSvgIconLiteralInNamespace("", iconName, literal);
  }
  /**
   * @description.en-us Registers an icon using an HTML string in the specified namespace.
   * @description 添加单个SVG图标字符串到指定的命名空间，直接传入 SVG HTML 字符串
   * @param namespace Namespace in which the icon should be registered.
   * @param iconName Name under which the icon should be registered.
   * @param literal SVG source of the icon.
   */
  addSvgIconLiteralInNamespace(namespace, iconName, literal) {
    literal = isString(literal) ? this.sanitizer.bypassSecurityTrustHtml(literal) : literal;
    const sanitizedLiteral = this.sanitizer.sanitize(SecurityContext.HTML, literal);
    if (!sanitizedLiteral) {
      throw this.getIconFailedToSanitizeLiteralError(literal);
    }
    const svgElement = this.createSvgElementForSingleIcon(sanitizedLiteral);
    return this.internalAddSvgIconConfig(namespace, iconName, new SvgIconConfig(svgElement));
  }
  getDefaultFontSetClass() {
    return this.defaultFontSetClass;
  }
  getFontSetClassByAlias(fontSet) {
    return fontSet;
  }
  /**
   * 获取某个图标
   */
  getSvgIcon(name, namespace = "") {
    const key = this.buildIconKey(namespace, name);
    const config2 = this.svgIconConfigs.get(key);
    if (config2) {
      return this.getSvgFromConfig(config2);
    }
    const iconSetConfigs = this.svgIconSetConfigs.get(namespace);
    if (iconSetConfigs) {
      return this.getSvgFromIconSetConfigs(name, iconSetConfigs);
    }
    return throwError(this.getIconNameNotFoundError(key));
  }
  setIconMode(mode) {
    this.internalIconMode = mode;
  }
  static {
    this.\u0275fac = function ThyIconRegistry_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyIconRegistry)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyIconRegistry,
      factory: _ThyIconRegistry.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyIconRegistry, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var iconSuffixMap = {
  fill: "fill",
  twotone: "tt"
};
var ThyIcon = class _ThyIcon {
  constructor() {
    this.render = inject(Renderer2);
    this.elementRef = inject(ElementRef);
    this.iconRegistry = inject(ThyIconRegistry);
    this.thyIconType = input("outline", ...ngDevMode ? [{
      debugName: "thyIconType"
    }] : []);
    this.thyTwotoneColor = input(...ngDevMode ? [void 0, {
      debugName: "thyTwotoneColor"
    }] : []);
    this.thyIconName = input.required(...ngDevMode ? [{
      debugName: "thyIconName"
    }] : []);
    this.thyIconRotate = input(void 0, ...ngDevMode ? [{
      debugName: "thyIconRotate",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyIconSet = input(...ngDevMode ? [void 0, {
      debugName: "thyIconSet"
    }] : []);
    this.thyIconLegging = input(false, ...ngDevMode ? [{
      debugName: "thyIconLegging",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyIconLinearGradient = input(false, ...ngDevMode ? [{
      debugName: "thyIconLinearGradient",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.hostRenderer = useHostRenderer();
    effect(() => {
      this.updateClasses();
    });
    effect(() => {
      this.setStyleRotate();
    });
  }
  updateClasses() {
    const [namespace, iconName] = this.iconRegistry.splitIconName(this.thyIconName());
    if (iconName) {
      if (this.iconRegistry.iconMode === "svg") {
        this.iconRegistry.getSvgIcon(this.buildIconNameByType(iconName), namespace).pipe(take(1)).subscribe((svg) => {
          this.setSvgElement(svg);
        }, (error) => {
          if (getWhetherPrintErrorWhenIconNotFound()) {
            console.error(`Error retrieving icon: ${error.message}`);
          }
        });
        this.hostRenderer.updateClass([`thy-icon${namespace ? `-${namespace}` : ``}-${this.buildIconNameByType(iconName)}`]);
      } else {
        const fontSetClass = this.thyIconSet() ? this.iconRegistry.getFontSetClassByAlias(this.thyIconSet()) : this.iconRegistry.getDefaultFontSetClass();
        this.hostRenderer.updateClass([fontSetClass, `${fontSetClass}-${this.thyIconName()}`]);
      }
    }
  }
  setStyleRotate() {
    if (this.thyIconRotate() !== void 0) {
      const svg = this.elementRef.nativeElement.querySelector("svg");
      if (!svg) {
        return;
      }
      this.render.setStyle(svg, "transform", `rotate(${this.thyIconRotate()}deg)`);
    }
  }
  //#region svg element
  setSvgElement(svg) {
    this.clearSvgElement();
    const styleTags = svg.querySelectorAll("style");
    for (let i = 0; i < styleTags.length; i++) {
      styleTags[i].textContent += " ";
    }
    if (this.thyIconType() === "twotone") {
      const allPaths = svg.querySelectorAll("path");
      if (allPaths.length > 1) {
        allPaths.forEach((child, index2) => {
          if (child.getAttribute("id").includes("secondary-color")) {
            child.setAttribute("fill", this.thyTwotoneColor());
          }
        });
      }
    }
    if (this.thyIconLinearGradient()) {
      this.setBaseUrl(svg);
      this.clearTitleElement(svg);
    }
    this.elementRef.nativeElement.appendChild(svg);
    this.setStyleRotate();
  }
  clearSvgElement() {
    const layoutElement = this.elementRef.nativeElement;
    let childCount = layoutElement.childNodes.length;
    while (childCount--) {
      const child = layoutElement.childNodes[childCount];
      if (child.nodeType !== 1 || child.nodeName.toLowerCase() === "svg") {
        layoutElement.removeChild(child);
      }
    }
  }
  //#endregion
  buildIconNameByType(iconName) {
    if (this.thyIconType() && ["fill", "twotone"].indexOf(this.thyIconType()) >= 0) {
      const suffix = iconSuffixMap[this.thyIconType()];
      return iconName.includes(`-${suffix}`) ? iconName : `${iconName}-${suffix}`;
    } else {
      return iconName;
    }
  }
  /**
   * Support Safari SVG LinearGradient.
   * @param svg
   */
  setBaseUrl(svg) {
    const styleElements = svg.querySelectorAll("style");
    styleElements.forEach((n) => {
      if (n.style.cssText.includes("url")) {
        n.style.fill = n.style.fill.replace('url("', `url("${location.pathname}`);
      }
      if (n.style.cssText.includes("clip-path")) {
        n.style.clipPath = n.style.clipPath.replace('url("', `url("${location.pathname}`);
      }
    });
  }
  clearTitleElement(svg) {
    const titleElement = svg.querySelector("title");
    titleElement && titleElement.remove();
  }
  static {
    this.\u0275fac = function ThyIcon_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyIcon)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyIcon,
      selectors: [["thy-icon"], ["", "thy-icon", ""]],
      hostAttrs: [1, "thy-icon"],
      hostVars: 2,
      hostBindings: function ThyIcon_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-icon-legging", ctx.thyIconLegging());
        }
      },
      inputs: {
        thyIconType: [1, "thyIconType"],
        thyTwotoneColor: [1, "thyTwotoneColor"],
        thyIconName: [1, "thyIconName"],
        thyIconRotate: [1, "thyIconRotate"],
        thyIconSet: [1, "thyIconSet"],
        thyIconLegging: [1, "thyIconLegging"],
        thyIconLinearGradient: [1, "thyIconLinearGradient"]
      },
      ngContentSelectors: _c0,
      decls: 1,
      vars: 0,
      template: function ThyIcon_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyIcon, [{
    type: Component,
    args: [{
      selector: "thy-icon, [thy-icon]",
      template: "<ng-content></ng-content>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "thy-icon",
        "[class.thy-icon-legging]": "thyIconLegging()"
      }
    }]
  }], () => [], {
    thyIconType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconType",
        required: false
      }]
    }],
    thyTwotoneColor: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTwotoneColor",
        required: false
      }]
    }],
    thyIconName: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconName",
        required: true
      }]
    }],
    thyIconRotate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconRotate",
        required: false
      }]
    }],
    thyIconSet: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconSet",
        required: false
      }]
    }],
    thyIconLegging: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconLegging",
        required: false
      }]
    }],
    thyIconLinearGradient: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconLinearGradient",
        required: false
      }]
    }]
  });
})();
var ThyIconModule = class _ThyIconModule {
  static {
    this.\u0275fac = function ThyIconModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyIconModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyIconModule,
      imports: [ThyIcon, CommonModule, FormsModule],
      exports: [ThyIcon]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, FormsModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyIconModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      exports: [ThyIcon],
      imports: [ThyIcon, CommonModule, FormsModule],
      providers: []
    }]
  }], null, null);
})();

// node_modules/@tethys/cdk/fesm2022/tethys-cdk-is.mjs
function isUndefined2(value) {
  return value === void 0;
}
function isNull2(value) {
  return value === null;
}
function isUndefinedOrNull2(value) {
  return isUndefined2(value) || isNull2(value);
}
function isArray2(value) {
  return value && baseGetTag2(value) === "[object Array]";
}
function isString2(value) {
  return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) === "[object String]";
}
function isObjectLike2(value) {
  return value !== null && typeof value === "object";
}
function baseGetTag2(value) {
  const objectProto = Object.prototype;
  const hasOwnProperty = objectProto.hasOwnProperty;
  const toString = objectProto.toString;
  const symToStringTag = typeof Symbol !== "undefined" ? Symbol.toStringTag : void 0;
  if (value == null) {
    return value === void 0 ? "[object Undefined]" : "[object Null]";
  }
  if (!(symToStringTag && symToStringTag in Object(value))) {
    return toString.call(value);
  }
  const isOwn = hasOwnProperty.call(value, symToStringTag);
  const tag = value[symToStringTag];
  let unmasked = false;
  try {
    value[symToStringTag] = void 0;
    unmasked = true;
  } catch (e) {
  }
  const result = toString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
function isFormElement(elementOrRef) {
  const element = coerceElement(elementOrRef);
  if (!(element instanceof HTMLElement)) {
    return false;
  }
  const name = element.nodeName.toLowerCase();
  const type = (element.getAttribute("type") || "").toLowerCase();
  return name === "select" || name === "textarea" || name === "input" && type !== "submit" && type !== "reset" && type !== "checkbox" && type !== "radio" && type !== "file" || element.isContentEditable;
}
function isMacPlatform(userAgent = navigator.userAgent) {
  return /macintosh|mac os x/i.test(userAgent);
}

// node_modules/@tethys/cdk/fesm2022/tethys-cdk-event.mjs
var DEFAULT_EVENT_TIME = 100;
var ThyEventDispatcher = class _ThyEventDispatcher {
  _addGlobalListener() {
    this._globalSubscription = this.ngZone.runOutsideAngular(() => {
      return fromEvent(this.document, this.eventName).subscribe((event) => {
        this._event$.next(event);
      });
    });
  }
  _removeGlobalListener() {
    if (this._globalSubscription) {
      this._globalSubscription.unsubscribe();
      this._globalSubscription = null;
    }
  }
  get globalSubscription() {
    return this._globalSubscription;
  }
  constructor() {
    this._globalSubscription = null;
    this._event$ = new Subject();
    this._subscriptionCount = 0;
    this.document = inject(DOCUMENT);
    this.ngZone = inject(NgZone);
  }
  subscribe(auditTimeInMs = DEFAULT_EVENT_TIME) {
    return new Observable((observer) => {
      if (!this._globalSubscription) {
        this._addGlobalListener();
      }
      const subscription = auditTimeInMs > 0 ? this._event$.pipe(auditTime(auditTimeInMs)).subscribe(observer) : this._event$.subscribe(observer);
      this._subscriptionCount++;
      return () => {
        subscription.unsubscribe();
        this._subscriptionCount--;
        if (!this._subscriptionCount) {
          this._removeGlobalListener();
        }
      };
    });
  }
  ngOnDestroy() {
    this._removeGlobalListener();
    this._event$.complete();
  }
  static {
    this.\u0275fac = function ThyEventDispatcher_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyEventDispatcher)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyEventDispatcher
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyEventDispatcher, [{
    type: Directive
  }], () => [], null);
})();
var DEFAULT_CLICKED_TIME = 100;
var ThyClickDispatcher = class _ThyClickDispatcher extends ThyEventDispatcher {
  constructor() {
    super(...arguments);
    this.eventName = "click";
  }
  clicked(auditTimeInMs = DEFAULT_CLICKED_TIME) {
    return this.subscribe(auditTimeInMs);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyClickDispatcher_BaseFactory;
      return function ThyClickDispatcher_Factory(__ngFactoryType__) {
        return (\u0275ThyClickDispatcher_BaseFactory || (\u0275ThyClickDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_ThyClickDispatcher)))(__ngFactoryType__ || _ThyClickDispatcher);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyClickDispatcher,
      factory: _ThyClickDispatcher.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var DEFAULT_KEYDOWN_TIME = 100;
var ThyKeyboardDispatcher = class _ThyKeyboardDispatcher extends ThyEventDispatcher {
  constructor() {
    super(...arguments);
    this.eventName = "keydown";
  }
  keydown(auditTimeInMs = DEFAULT_KEYDOWN_TIME) {
    return this.subscribe(auditTimeInMs);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyKeyboardDispatcher_BaseFactory;
      return function ThyKeyboardDispatcher_Factory(__ngFactoryType__) {
        return (\u0275ThyKeyboardDispatcher_BaseFactory || (\u0275ThyKeyboardDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_ThyKeyboardDispatcher)))(__ngFactoryType__ || _ThyKeyboardDispatcher);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyKeyboardDispatcher,
      factory: _ThyKeyboardDispatcher.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();

// node_modules/@tethys/cdk/fesm2022/tethys-cdk-hotkey.mjs
var modifierKeyNames = [`Control`, "Alt", "Meta", "Shift"];
function showShift(event) {
  const {
    shiftKey,
    code: code2,
    key
  } = event;
  return shiftKey && !(code2.startsWith("Key") && key.toUpperCase() === key);
}
function hotkey(event) {
  const {
    ctrlKey,
    altKey,
    metaKey,
    key
  } = event;
  const hotkeyString = [];
  const modifiers = [ctrlKey, altKey, metaKey, showShift(event)];
  for (const [i, mod] of modifiers.entries()) {
    if (mod) hotkeyString.push(modifierKeyNames[i]);
  }
  if (!modifierKeyNames.includes(key)) {
    hotkeyString.push(key);
  }
  return hotkeyString.join("+");
}
function isHotkey(event, key) {
  return key.toUpperCase() === hotkey(event).toUpperCase();
}
function runInZone(zone) {
  return (source) => {
    return new Observable((observer) => {
      const onNext = (value) => zone.run(() => observer.next(value));
      const onError = (e) => zone.run(() => observer.error(e));
      const onComplete = () => zone.run(() => observer.complete());
      return source.subscribe(onNext, onError, onComplete);
    });
  };
}
var ThyHotkeyDispatcher = class _ThyHotkeyDispatcher extends ThyEventDispatcher {
  constructor() {
    super(...arguments);
    this.eventName = "keydown";
  }
  createKeydownObservable(scope) {
    if (scope === this.document) {
      return this.subscribe();
    } else {
      return fromEvent(scope, "keydown");
    }
  }
  /**
   *  热键事件订阅
   */
  keydown(hotkey2, scope) {
    const hotkeys = isString2(hotkey2) ? hotkey2.split(",") : hotkey2;
    const scopeElement = coerceElement(isUndefinedOrNull2(scope) ? this.document : scope);
    const keydown = this.createKeydownObservable(scopeElement);
    return new Observable((subscriber) => {
      const subscription = keydown.pipe(filter((event) => {
        return hotkeys.some((key) => isHotkey(event, key));
      })).subscribe((event) => {
        if (isFormElement(this.document.activeElement) && this.document.activeElement !== scope) {
          return;
        }
        subscriber.next(event);
      });
      return () => {
        subscription.unsubscribe();
      };
    }).pipe(runInZone(this.ngZone));
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyHotkeyDispatcher_BaseFactory;
      return function ThyHotkeyDispatcher_Factory(__ngFactoryType__) {
        return (\u0275ThyHotkeyDispatcher_BaseFactory || (\u0275ThyHotkeyDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_ThyHotkeyDispatcher)))(__ngFactoryType__ || _ThyHotkeyDispatcher);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyHotkeyDispatcher,
      factory: _ThyHotkeyDispatcher.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyHotkeyDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ThyHotkeyDirective = class _ThyHotkeyDirective {
  constructor() {
    this.document = inject(DOCUMENT);
    this.hotkeyDispatcher = inject(ThyHotkeyDispatcher);
    this.elementRef = inject(ElementRef);
    this.thyHotkey = input(...ngDevMode ? [void 0, {
      debugName: "thyHotkey"
    }] : []);
    this.thyHotkeyScope = input(...ngDevMode ? [void 0, {
      debugName: "thyHotkeyScope"
    }] : []);
    this.thyHotkeyListener = output();
  }
  ngOnInit() {
    const hotkeyScope = this.thyHotkeyScope();
    const scope = isString2(hotkeyScope) ? this.document.querySelector(hotkeyScope) : hotkeyScope;
    this.subscription = this.hotkeyDispatcher.keydown(this.thyHotkey(), scope).subscribe((event) => {
      event.preventDefault();
      event.stopPropagation();
      if (isFormElement(this.elementRef)) {
        this.elementRef.nativeElement.focus();
      } else {
        this.elementRef.nativeElement.click();
      }
      this.thyHotkeyListener.emit(event);
    });
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  static {
    this.\u0275fac = function ThyHotkeyDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyHotkeyDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyHotkeyDirective,
      selectors: [["", "thyHotkey", ""]],
      inputs: {
        thyHotkey: [1, "thyHotkey"],
        thyHotkeyScope: [1, "thyHotkeyScope"]
      },
      outputs: {
        thyHotkeyListener: "thyHotkeyListener"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyHotkeyDirective, [{
    type: Directive,
    args: [{
      selector: "[thyHotkey]"
    }]
  }], null, {
    thyHotkey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHotkey",
        required: false
      }]
    }],
    thyHotkeyScope: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHotkeyScope",
        required: false
      }]
    }],
    thyHotkeyListener: [{
      type: Output,
      args: ["thyHotkeyListener"]
    }]
  });
})();
var ThyHotkeyModule = class _ThyHotkeyModule {
  static {
    this.\u0275fac = function ThyHotkeyModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyHotkeyModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyHotkeyModule,
      imports: [ThyHotkeyDirective],
      exports: [ThyHotkeyDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyHotkeyModule, [{
    type: NgModule,
    args: [{
      imports: [ThyHotkeyDirective],
      exports: [ThyHotkeyDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_passive-listeners-chunk.mjs
var supportsPassiveEvents;
function supportsPassiveEventListeners() {
  if (supportsPassiveEvents == null && typeof window !== "undefined") {
    try {
      window.addEventListener("test", null, Object.defineProperty({}, "passive", {
        get: () => supportsPassiveEvents = true
      }));
    } finally {
      supportsPassiveEvents = supportsPassiveEvents || false;
    }
  }
  return supportsPassiveEvents;
}
function normalizePassiveListenerOptions(options) {
  return supportsPassiveEventListeners() ? options : !!options.capture;
}

// node_modules/@angular/cdk/fesm2022/_test-environment-chunk.mjs
function _isTestEnvironment() {
  return typeof __karma__ !== "undefined" && !!__karma__ || typeof jasmine !== "undefined" && !!jasmine || typeof jest !== "undefined" && !!jest || typeof Mocha !== "undefined" && !!Mocha;
}

// node_modules/@angular/cdk/fesm2022/platform.mjs
var PlatformModule = class _PlatformModule {
  static \u0275fac = function PlatformModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PlatformModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _PlatformModule
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PlatformModule, [{
    type: NgModule,
    args: [{}]
  }], null, null);
})();

// node_modules/@angular/core/fesm2022/rxjs-interop.mjs
function takeUntilDestroyed(destroyRef) {
  if (!destroyRef) {
    ngDevMode && assertInInjectionContext(takeUntilDestroyed);
    destroyRef = inject(DestroyRef);
  }
  const destroyed$ = new Observable((subscriber) => {
    if (destroyRef.destroyed) {
      subscriber.next();
      return;
    }
    const unregisterFn = destroyRef.onDestroy(subscriber.next.bind(subscriber));
    return unregisterFn;
  });
  return (source) => {
    return source.pipe(takeUntil(destroyed$));
  };
}
function outputToObservable(ref) {
  const destroyRef = getOutputDestroyRef(ref);
  return new Observable((observer) => {
    const unregisterOnDestroy = destroyRef?.onDestroy(() => observer.complete());
    const subscription = ref.subscribe((v) => observer.next(v));
    return () => {
      subscription.unsubscribe();
      unregisterOnDestroy?.();
    };
  });
}
function toSignal(source, options) {
  typeof ngDevMode !== "undefined" && ngDevMode && assertNotInReactiveContext(toSignal, "Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.");
  const requiresCleanup = !options?.manualCleanup;
  if (ngDevMode && requiresCleanup && !options?.injector) {
    assertInInjectionContext(toSignal);
  }
  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;
  const equal = makeToSignalEqual(options?.equal);
  let state2;
  if (options?.requireSync) {
    state2 = signal({
      kind: 0
    }, __spreadValues({
      equal
    }, ngDevMode ? createDebugNameObject(options?.debugName, "state") : void 0));
  } else {
    state2 = signal({
      kind: 1,
      value: options?.initialValue
    }, __spreadValues({
      equal
    }, ngDevMode ? createDebugNameObject(options?.debugName, "state") : void 0));
  }
  let destroyUnregisterFn;
  const sub = source.subscribe({
    next: (value) => state2.set({
      kind: 1,
      value
    }),
    error: (error) => {
      state2.set({
        kind: 2,
        error
      });
      destroyUnregisterFn?.();
    },
    complete: () => {
      destroyUnregisterFn?.();
    }
  });
  if (options?.requireSync && state2().kind === 0) {
    throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
  }
  destroyUnregisterFn = cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));
  return computed(() => {
    const current = state2();
    switch (current.kind) {
      case 1:
        return current.value;
      case 2:
        throw current.error;
      case 0:
        throw new RuntimeError(601, (typeof ngDevMode === "undefined" || ngDevMode) && "`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.");
    }
  }, __spreadValues({
    equal: options?.equal
  }, ngDevMode ? createDebugNameObject(options?.debugName, "source") : void 0));
}
function makeToSignalEqual(userEquality = Object.is) {
  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);
}
function createDebugNameObject(toSignalDebugName, internalSignalDebugName) {
  return {
    debugName: `toSignal${toSignalDebugName ? "#" + toSignalDebugName : ""}.${internalSignalDebugName}`
  };
}

// node_modules/ngx-tethys/fesm2022/ngx-tethys-resizable.mjs
var _c02 = ["*"];
function ThyResizeHandle_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElement(0, "div", 0);
  }
}
function ThyResizeHandles_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-resize-handle", 0);
  }
  if (rf & 2) {
    const dir_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("thyLine", ctx_r1.thyLine())("thyDirection", dir_r1);
  }
}
var ThyResizableService = class _ThyResizableService {
  constructor() {
    this.ngZone = inject(NgZone);
    this.listeners = /* @__PURE__ */ new Map();
    this.handleMouseDownOutsideAngular$ = new Subject();
    this.documentMouseUpOutsideAngular$ = new Subject();
    this.documentMouseMoveOutsideAngular$ = new Subject();
    this.mouseEnteredOutsideAngular$ = new Subject();
    const document2 = inject(DOCUMENT);
    this.document = document2;
  }
  startResizing(event) {
    const _isTouchEvent = isTouchEvent(event);
    this.clearListeners();
    const moveEvent = _isTouchEvent ? "touchmove" : "mousemove";
    const upEvent = _isTouchEvent ? "touchend" : "mouseup";
    const moveEventHandler = (e) => {
      this.documentMouseMoveOutsideAngular$.next(e);
    };
    const upEventHandler = (e) => {
      this.documentMouseUpOutsideAngular$.next(e);
      this.clearListeners();
    };
    this.listeners.set(moveEvent, moveEventHandler);
    this.listeners.set(upEvent, upEventHandler);
    this.ngZone.runOutsideAngular(() => {
      this.listeners.forEach((handler, name) => {
        this.document.addEventListener(name, handler);
      });
    });
  }
  clearListeners() {
    this.listeners.forEach((handler, name) => {
      this.document.removeEventListener(name, handler);
    });
    this.listeners.clear();
  }
  ngOnDestroy() {
    this.handleMouseDownOutsideAngular$.complete();
    this.documentMouseUpOutsideAngular$.complete();
    this.documentMouseMoveOutsideAngular$.complete();
    this.mouseEnteredOutsideAngular$.complete();
    this.clearListeners();
  }
  static {
    this.\u0275fac = function ThyResizableService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyResizableService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyResizableService,
      factory: _ThyResizableService.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyResizableService, [{
    type: Injectable
  }], () => [], null);
})();
function getEventWithPoint(event) {
  return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;
}
function ensureInBounds(value, boundValue) {
  return value ? value < boundValue ? value : boundValue : boundValue;
}
function setCompatibleStyle(element, key, value) {
  element.style[key] = value;
  element.style[`-webkit-${key}`] = value;
  element.style[`-moz-${key}`] = value;
  element.style[`-ms-${key}`] = value;
}
var ThyResizableDirective = class _ThyResizableDirective {
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.platform = inject(Platform);
    this.ngZone = inject(NgZone);
    this.thyResizableService = inject(ThyResizableService);
    this.thyBounds = input("parent", ...ngDevMode ? [{
      debugName: "thyBounds"
    }] : []);
    this.thyMaxHeight = input(void 0, ...ngDevMode ? [{
      debugName: "thyMaxHeight",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyMaxWidth = input(void 0, ...ngDevMode ? [{
      debugName: "thyMaxWidth",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyMinHeight = input(40, ...ngDevMode ? [{
      debugName: "thyMinHeight",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyMinWidth = input(40, ...ngDevMode ? [{
      debugName: "thyMinWidth",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyGridColumnCount = input(-1, ...ngDevMode ? [{
      debugName: "thyGridColumnCount",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyMaxColumn = input(-1, ...ngDevMode ? [{
      debugName: "thyMaxColumn",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyMinColumn = input(-1, ...ngDevMode ? [{
      debugName: "thyMinColumn",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyLockAspectRatio = input(false, ...ngDevMode ? [{
      debugName: "thyLockAspectRatio",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPreview = input(false, ...ngDevMode ? [{
      debugName: "thyPreview",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyResize = output();
    this.thyResizeStart = output();
    this.thyResizeEnd = output();
    this.resizing = signal(false, ...ngDevMode ? [{
      debugName: "resizing"
    }] : []);
    this.sizeCache = null;
    this.ghostElement = null;
    this.currentHandleEvent = null;
    this.destroyRef = inject(DestroyRef);
    this.thyResizableService.handleMouseDownOutsideAngular$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
      if (this.thyDisabled()) {
        return;
      }
      this.resizing.set(true);
      const {
        mouseEvent
      } = event;
      this.thyResizableService.startResizing(mouseEvent);
      this.currentHandleEvent = event;
      this.setCursor();
      this.ngZone.run(() => this.thyResizeStart.emit({
        mouseEvent
      }));
      this.nativeElementRect = this.nativeElement.getBoundingClientRect();
    });
    this.thyResizableService.documentMouseUpOutsideAngular$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
      if (this.resizing()) {
        this.ngZone.run(() => {
          this.resizing.set(false);
        });
        this.thyResizableService.documentMouseUpOutsideAngular$.next(event);
        this.endResize(event);
      }
    });
    this.thyResizableService.documentMouseMoveOutsideAngular$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
      if (this.resizing()) {
        this.resize(event);
      }
    });
    this.bindMouseEnterAndLeaveEvents();
  }
  bindMouseEnterAndLeaveEvents() {
    if (!this.platform.isBrowser) {
      return;
    }
    this.ngZone.runOutsideAngular(() => {
      fromEvent(this.nativeElement, "mouseenter").pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
        this.thyResizableService.mouseEnteredOutsideAngular$.next(true);
      });
      fromEvent(this.nativeElement, "mouseleave").pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
        this.thyResizableService.mouseEnteredOutsideAngular$.next(false);
      });
    });
  }
  setCursor() {
    switch (this.currentHandleEvent.direction) {
      case "left":
      case "right":
        this.renderer.setStyle(document.body, "cursor", "ew-resize");
        break;
      case "top":
      case "bottom":
        this.renderer.setStyle(document.body, "cursor", "ns-resize");
        break;
      case "topLeft":
      case "bottomRight":
        this.renderer.setStyle(document.body, "cursor", "nwse-resize");
        break;
      case "topRight":
      case "bottomLeft":
        this.renderer.setStyle(document.body, "cursor", "nesw-resize");
        break;
    }
    setCompatibleStyle(document.body, "user-select", "none");
  }
  endResize(event) {
    this.renderer.setStyle(document.body, "cursor", "");
    setCompatibleStyle(document.body, "user-select", "");
    this.removeGhostElement();
    const size = this.sizeCache ? __spreadValues({}, this.sizeCache) : {
      width: this.nativeElementRect.width,
      height: this.nativeElementRect.height
    };
    this.ngZone.run(() => {
      this.thyResizeEnd.emit(__spreadProps(__spreadValues({}, size), {
        mouseEvent: event
      }));
    });
    this.sizeCache = null;
    this.currentHandleEvent = null;
  }
  resize(event) {
    const nativeElementRect = this.nativeElementRect;
    const resizeEvent = getEventWithPoint(event);
    const handleEvent = getEventWithPoint(this.currentHandleEvent.mouseEvent);
    let width = nativeElementRect.width;
    let height = nativeElementRect.height;
    const ratio = this.thyLockAspectRatio() ? width / height : -1;
    switch (this.currentHandleEvent.direction) {
      case "bottomRight":
        width = resizeEvent.clientX - nativeElementRect.left;
        height = resizeEvent.clientY - nativeElementRect.top;
        break;
      case "bottomLeft":
        width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
        height = resizeEvent.clientY - nativeElementRect.top;
        break;
      case "topRight":
        width = resizeEvent.clientX - nativeElementRect.left;
        height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
        break;
      case "topLeft":
        width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
        height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
        break;
      case "top":
        height = nativeElementRect.height + (handleEvent.clientY - resizeEvent.clientY);
        break;
      case "right":
        width = resizeEvent.clientX - nativeElementRect.left;
        break;
      case "bottom":
        height = resizeEvent.clientY - nativeElementRect.top;
        break;
      case "left":
        width = nativeElementRect.width + (handleEvent.clientX - resizeEvent.clientX);
    }
    const size = this.calcSize(width, height, ratio);
    this.sizeCache = __spreadValues({}, size);
    this.ngZone.run(() => {
      this.thyResize.emit(__spreadProps(__spreadValues({}, size), {
        mouseEvent: event
      }));
    });
    if (this.thyPreview()) {
      this.previewResize(size);
    }
  }
  calcSize(width, height, ratio) {
    let newWidth;
    let newHeight;
    let maxWidth;
    let col = 0;
    let spanWidth = 0;
    let minWidth = this.thyMinWidth();
    let boundWidth = Infinity;
    let boundHeight = Infinity;
    const bounds = this.thyBounds();
    if (bounds === "parent") {
      const parent = this.renderer.parentNode(this.nativeElement);
      if (parent instanceof HTMLElement) {
        const parentRect = parent.getBoundingClientRect();
        boundWidth = parentRect.width;
        boundHeight = parentRect.height;
      }
    } else if (bounds === "window") {
      if (typeof window !== "undefined") {
        boundWidth = window.innerWidth;
        boundHeight = window.innerHeight;
      }
    } else if (bounds && bounds.nativeElement && bounds.nativeElement instanceof HTMLElement) {
      const boundsRect = bounds.nativeElement.getBoundingClientRect();
      boundWidth = boundsRect.width;
      boundHeight = boundsRect.height;
    }
    maxWidth = ensureInBounds(this.thyMaxWidth(), boundWidth);
    const maxHeight = ensureInBounds(this.thyMaxHeight(), boundHeight);
    const gridColumnCount = this.thyGridColumnCount();
    if (gridColumnCount !== -1) {
      spanWidth = maxWidth / gridColumnCount;
      const minColumn = this.thyMinColumn();
      minWidth = minColumn !== -1 ? spanWidth * minColumn : minWidth;
      const maxColumn = this.thyMaxColumn();
      maxWidth = maxColumn !== -1 ? spanWidth * maxColumn : maxWidth;
    }
    const minHeight = this.thyMinHeight();
    if (ratio !== -1) {
      if (/(left|right)/i.test(this.currentHandleEvent.direction)) {
        newWidth = Math.min(Math.max(width, minWidth), maxWidth);
        newHeight = Math.min(Math.max(newWidth / ratio, minHeight), maxHeight);
        if (newHeight >= maxHeight || newHeight <= minHeight) {
          newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
        }
      } else {
        newHeight = Math.min(Math.max(height, minHeight), maxHeight);
        newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);
        if (newWidth >= maxWidth || newWidth <= minWidth) {
          newHeight = Math.min(Math.max(newWidth / ratio, minHeight), maxHeight);
        }
      }
    } else {
      newWidth = Math.min(Math.max(width, minWidth), maxWidth);
      newHeight = Math.min(Math.max(height, minHeight), maxHeight);
    }
    if (gridColumnCount !== -1) {
      col = Math.round(newWidth / spanWidth);
      newWidth = col * spanWidth;
    }
    return {
      col,
      width: newWidth,
      height: newHeight
    };
  }
  previewResize({
    width,
    height
  }) {
    this.createGhostElement();
    this.renderer.setStyle(this.ghostElement, "width", `${width}px`);
    this.renderer.setStyle(this.ghostElement, "height", `${height}px`);
  }
  createGhostElement() {
    if (!this.ghostElement) {
      this.ghostElement = this.renderer.createElement("div");
      this.renderer.setAttribute(this.ghostElement, "class", "thy-resizable-preview");
    }
    this.renderer.appendChild(this.nativeElement, this.ghostElement);
  }
  removeGhostElement() {
    if (this.ghostElement) {
      this.renderer.removeChild(this.nativeElement, this.ghostElement);
    }
  }
  ngOnDestroy() {
    this.ghostElement = null;
    this.sizeCache = null;
  }
  static {
    this.\u0275fac = function ThyResizableDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyResizableDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyResizableDirective,
      selectors: [["", "thyResizable", ""]],
      hostAttrs: [1, "thy-resizable"],
      hostVars: 4,
      hostBindings: function ThyResizableDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-resizable-resizing", ctx.resizing())("thy-resizable-disabled", ctx.thyDisabled());
        }
      },
      inputs: {
        thyBounds: [1, "thyBounds"],
        thyMaxHeight: [1, "thyMaxHeight"],
        thyMaxWidth: [1, "thyMaxWidth"],
        thyMinHeight: [1, "thyMinHeight"],
        thyMinWidth: [1, "thyMinWidth"],
        thyGridColumnCount: [1, "thyGridColumnCount"],
        thyMaxColumn: [1, "thyMaxColumn"],
        thyMinColumn: [1, "thyMinColumn"],
        thyLockAspectRatio: [1, "thyLockAspectRatio"],
        thyPreview: [1, "thyPreview"],
        thyDisabled: [1, "thyDisabled"]
      },
      outputs: {
        thyResize: "thyResize",
        thyResizeStart: "thyResizeStart",
        thyResizeEnd: "thyResizeEnd"
      },
      features: [\u0275\u0275ProvidersFeature([ThyResizableService])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyResizableDirective, [{
    type: Directive,
    args: [{
      selector: "[thyResizable]",
      providers: [ThyResizableService],
      host: {
        class: "thy-resizable",
        "[class.thy-resizable-resizing]": "resizing()",
        "[class.thy-resizable-disabled]": "thyDisabled()"
      }
    }]
  }], () => [], {
    thyBounds: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyBounds",
        required: false
      }]
    }],
    thyMaxHeight: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMaxHeight",
        required: false
      }]
    }],
    thyMaxWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMaxWidth",
        required: false
      }]
    }],
    thyMinHeight: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinHeight",
        required: false
      }]
    }],
    thyMinWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinWidth",
        required: false
      }]
    }],
    thyGridColumnCount: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGridColumnCount",
        required: false
      }]
    }],
    thyMaxColumn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMaxColumn",
        required: false
      }]
    }],
    thyMinColumn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinColumn",
        required: false
      }]
    }],
    thyLockAspectRatio: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLockAspectRatio",
        required: false
      }]
    }],
    thyPreview: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPreview",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    thyResize: [{
      type: Output,
      args: ["thyResize"]
    }],
    thyResizeStart: [{
      type: Output,
      args: ["thyResizeStart"]
    }],
    thyResizeEnd: [{
      type: Output,
      args: ["thyResizeEnd"]
    }]
  });
})();
var ThyResizeHandleMouseDownEvent = class {
  constructor(direction, mouseEvent) {
    this.direction = direction;
    this.mouseEvent = mouseEvent;
  }
};
var passiveEventListenerOptions = normalizePassiveListenerOptions({
  passive: true
});
var ThyResizeHandle = class _ThyResizeHandle {
  constructor() {
    this.ngZone = inject(NgZone);
    this.thyResizableService = inject(ThyResizableService);
    this.host = inject(ElementRef);
    this.thyDirection = input("bottomRight", ...ngDevMode ? [{
      debugName: "thyDirection"
    }] : []);
    this.thyLine = input(false, ...ngDevMode ? [{
      debugName: "thyLine",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyMouseDown = output();
    this.hostRenderer = useHostRenderer();
    this.destroyRef = inject(DestroyRef);
  }
  ngOnInit() {
    this.thyResizableService.mouseEnteredOutsideAngular$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe((entered) => {
      if (entered) {
        this.hostRenderer.addClass("thy-resizable-handle-box-hover");
      } else {
        this.hostRenderer.removeClass("thy-resizable-handle-box-hover");
      }
    });
    this.ngZone.runOutsideAngular(() => {
      merge(fromEvent(this.host.nativeElement, "mousedown", passiveEventListenerOptions), fromEvent(this.host.nativeElement, "touchstart", passiveEventListenerOptions)).pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
        this.thyResizableService.handleMouseDownOutsideAngular$.next(new ThyResizeHandleMouseDownEvent(this.thyDirection(), event));
      });
    });
  }
  static {
    this.\u0275fac = function ThyResizeHandle_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyResizeHandle)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyResizeHandle,
      selectors: [["thy-resize-handle"], ["", "thy-resize-handle", ""]],
      hostAttrs: [1, "thy-resizable-handle"],
      hostVars: 18,
      hostBindings: function ThyResizeHandle_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-resizable-handle-top", ctx.thyDirection() === "top")("thy-resizable-handle-right", ctx.thyDirection() === "right")("thy-resizable-handle-bottom", ctx.thyDirection() === "bottom")("thy-resizable-handle-left", ctx.thyDirection() === "left")("thy-resizable-handle-topRight", ctx.thyDirection() === "topRight")("thy-resizable-handle-bottomRight", ctx.thyDirection() === "bottomRight")("thy-resizable-handle-bottomLeft", ctx.thyDirection() === "bottomLeft")("thy-resizable-handle-topLeft", ctx.thyDirection() === "topLeft")("thy-resizable-handle-box-hover", ctx.entered);
        }
      },
      inputs: {
        thyDirection: [1, "thyDirection"],
        thyLine: [1, "thyLine"]
      },
      outputs: {
        thyMouseDown: "thyMouseDown"
      },
      exportAs: ["thyResizeHandle"],
      ngContentSelectors: _c02,
      decls: 2,
      vars: 1,
      consts: [[1, "thy-resizable-handle-line"]],
      template: function ThyResizeHandle_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
          \u0275\u0275conditionalCreate(1, ThyResizeHandle_Conditional_1_Template, 1, 0, "div", 0);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyLine() ? 1 : -1);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyResizeHandle, [{
    type: Component,
    args: [{
      selector: "thy-resize-handle, [thy-resize-handle]",
      exportAs: "thyResizeHandle",
      template: `
        <ng-content></ng-content>
        @if (thyLine()) {
            <div class="thy-resizable-handle-line"></div>
        }
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-resizable-handle",
        "[class.thy-resizable-handle-top]": `thyDirection() === 'top'`,
        "[class.thy-resizable-handle-right]": `thyDirection() === 'right'`,
        "[class.thy-resizable-handle-bottom]": `thyDirection() === 'bottom'`,
        "[class.thy-resizable-handle-left]": `thyDirection() === 'left'`,
        "[class.thy-resizable-handle-topRight]": `thyDirection() === 'topRight'`,
        "[class.thy-resizable-handle-bottomRight]": `thyDirection() === 'bottomRight'`,
        "[class.thy-resizable-handle-bottomLeft]": `thyDirection() === 'bottomLeft'`,
        "[class.thy-resizable-handle-topLeft]": `thyDirection() === 'topLeft'`,
        "[class.thy-resizable-handle-box-hover]": "entered"
      },
      imports: []
    }]
  }], null, {
    thyDirection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDirection",
        required: false
      }]
    }],
    thyLine: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLine",
        required: false
      }]
    }],
    thyMouseDown: [{
      type: Output,
      args: ["thyMouseDown"]
    }]
  });
})();
var DEFAULT_RESIZE_DIRECTION = ["bottomRight", "topRight", "bottomLeft", "topLeft", "bottom", "right", "top", "left"];
var ThyResizeHandles = class _ThyResizeHandles {
  constructor() {
    this.thyDirections = input(DEFAULT_RESIZE_DIRECTION, ...ngDevMode ? [{
      debugName: "thyDirections"
    }] : []);
    this.thyLine = input(false, ...ngDevMode ? [{
      debugName: "thyLine",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.directions = computed(() => {
      const directions = this.thyDirections();
      return new Set(directions);
    }, ...ngDevMode ? [{
      debugName: "directions"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyResizeHandles_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyResizeHandles)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyResizeHandles,
      selectors: [["thy-resize-handles"]],
      inputs: {
        thyDirections: [1, "thyDirections"],
        thyLine: [1, "thyLine"]
      },
      exportAs: ["thyResizeHandles"],
      decls: 2,
      vars: 0,
      consts: [[3, "thyLine", "thyDirection"]],
      template: function ThyResizeHandles_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275repeaterCreate(0, ThyResizeHandles_For_1_Template, 1, 2, "thy-resize-handle", 0, \u0275\u0275repeaterTrackByIndex);
        }
        if (rf & 2) {
          \u0275\u0275repeater(ctx.directions());
        }
      },
      dependencies: [ThyResizeHandle],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyResizeHandles, [{
    type: Component,
    args: [{
      selector: "thy-resize-handles",
      exportAs: "thyResizeHandles",
      template: `
        @for (dir of directions(); track $index) {
            <thy-resize-handle [thyLine]="thyLine()" [thyDirection]="dir"></thy-resize-handle>
        }
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [ThyResizeHandle]
    }]
  }], null, {
    thyDirections: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDirections",
        required: false
      }]
    }],
    thyLine: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLine",
        required: false
      }]
    }]
  });
})();
var ThyResizableModule = class _ThyResizableModule {
  static {
    this.\u0275fac = function ThyResizableModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyResizableModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyResizableModule,
      imports: [CommonModule, ThyResizableDirective, ThyResizeHandle, ThyResizeHandles],
      exports: [ThyResizableDirective, ThyResizeHandle, ThyResizeHandles]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyResizableModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyResizableDirective, ThyResizeHandle, ThyResizeHandles],
      exports: [ThyResizableDirective, ThyResizeHandle, ThyResizeHandles]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/portal.mjs
function throwNullPortalError() {
  throw Error("Must provide a portal to attach");
}
function throwPortalAlreadyAttachedError() {
  throw Error("Host already has a portal attached");
}
function throwPortalOutletAlreadyDisposedError() {
  throw Error("This PortalOutlet has already been disposed");
}
function throwUnknownPortalTypeError() {
  throw Error("Attempting to attach an unknown Portal type. BasePortalOutlet accepts either a ComponentPortal or a TemplatePortal.");
}
function throwNullPortalOutletError() {
  throw Error("Attempting to attach a portal to a null PortalOutlet");
}
function throwNoPortalAttachedError() {
  throw Error("Attempting to detach a portal that is not attached to a host");
}
var Portal = class {
  _attachedHost;
  attach(host) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (host == null) {
        throwNullPortalOutletError();
      }
      if (host.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
    }
    this._attachedHost = host;
    return host.attach(this);
  }
  detach() {
    let host = this._attachedHost;
    if (host != null) {
      this._attachedHost = null;
      host.detach();
    } else if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwNoPortalAttachedError();
    }
  }
  get isAttached() {
    return this._attachedHost != null;
  }
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal = class extends Portal {
  component;
  viewContainerRef;
  injector;
  projectableNodes;
  constructor(component, viewContainerRef, injector, projectableNodes) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.projectableNodes = projectableNodes;
  }
};
var TemplatePortal = class extends Portal {
  templateRef;
  viewContainerRef;
  context;
  injector;
  constructor(templateRef, viewContainerRef, context, injector) {
    super();
    this.templateRef = templateRef;
    this.viewContainerRef = viewContainerRef;
    this.context = context;
    this.injector = injector;
  }
  get origin() {
    return this.templateRef.elementRef;
  }
  attach(host, context = this.context) {
    this.context = context;
    return super.attach(host);
  }
  detach() {
    this.context = void 0;
    return super.detach();
  }
};
var DomPortal = class extends Portal {
  element;
  constructor(element) {
    super();
    this.element = element instanceof ElementRef ? element.nativeElement : element;
  }
};
var BasePortalOutlet = class {
  _attachedPortal;
  _disposeFn;
  _isDisposed = false;
  hasAttached() {
    return !!this._attachedPortal;
  }
  attach(portal) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!portal) {
        throwNullPortalError();
      }
      if (this.hasAttached()) {
        throwPortalAlreadyAttachedError();
      }
      if (this._isDisposed) {
        throwPortalOutletAlreadyDisposedError();
      }
    }
    if (portal instanceof ComponentPortal) {
      this._attachedPortal = portal;
      return this.attachComponentPortal(portal);
    } else if (portal instanceof TemplatePortal) {
      this._attachedPortal = portal;
      return this.attachTemplatePortal(portal);
    } else if (this.attachDomPortal && portal instanceof DomPortal) {
      this._attachedPortal = portal;
      return this.attachDomPortal(portal);
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      throwUnknownPortalTypeError();
    }
  }
  attachDomPortal = null;
  detach() {
    if (this._attachedPortal) {
      this._attachedPortal.setAttachedHost(null);
      this._attachedPortal = null;
    }
    this._invokeDisposeFn();
  }
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this._invokeDisposeFn();
    this._isDisposed = true;
  }
  setDisposeFn(fn) {
    this._disposeFn = fn;
  }
  _invokeDisposeFn() {
    if (this._disposeFn) {
      this._disposeFn();
      this._disposeFn = null;
    }
  }
};
var DomPortalOutlet = class extends BasePortalOutlet {
  outletElement;
  _appRef;
  _defaultInjector;
  constructor(outletElement, _appRef, _defaultInjector) {
    super();
    this.outletElement = outletElement;
    this._appRef = _appRef;
    this._defaultInjector = _defaultInjector;
  }
  attachComponentPortal(portal) {
    let componentRef;
    if (portal.viewContainerRef) {
      const injector = portal.injector || portal.viewContainerRef.injector;
      const ngModuleRef = injector.get(NgModuleRef$1, null, {
        optional: true
      }) || void 0;
      componentRef = portal.viewContainerRef.createComponent(portal.component, {
        index: portal.viewContainerRef.length,
        injector,
        ngModuleRef,
        projectableNodes: portal.projectableNodes || void 0
      });
      this.setDisposeFn(() => componentRef.destroy());
    } else {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._appRef) {
        throw Error("Cannot attach component portal to outlet without an ApplicationRef.");
      }
      const appRef = this._appRef;
      const elementInjector = portal.injector || this._defaultInjector || Injector.NULL;
      const environmentInjector = elementInjector.get(EnvironmentInjector, appRef.injector);
      componentRef = createComponent(portal.component, {
        elementInjector,
        environmentInjector,
        projectableNodes: portal.projectableNodes || void 0
      });
      appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        if (appRef.viewCount > 0) {
          appRef.detachView(componentRef.hostView);
        }
        componentRef.destroy();
      });
    }
    this.outletElement.appendChild(this._getComponentRootNode(componentRef));
    this._attachedPortal = portal;
    return componentRef;
  }
  attachTemplatePortal(portal) {
    let viewContainer = portal.viewContainerRef;
    let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    viewRef.rootNodes.forEach((rootNode) => this.outletElement.appendChild(rootNode));
    viewRef.detectChanges();
    this.setDisposeFn(() => {
      let index2 = viewContainer.indexOf(viewRef);
      if (index2 !== -1) {
        viewContainer.remove(index2);
      }
    });
    this._attachedPortal = portal;
    return viewRef;
  }
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this.outletElement.ownerDocument.createComment("dom-portal");
    element.parentNode.insertBefore(anchorNode, element);
    this.outletElement.appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  dispose() {
    super.dispose();
    this.outletElement.remove();
  }
  _getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var CdkPortal = class _CdkPortal extends TemplatePortal {
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    super(templateRef, viewContainerRef);
  }
  static \u0275fac = function CdkPortal_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortal)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkPortal,
    selectors: [["", "cdkPortal", ""]],
    exportAs: ["cdkPortal"],
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortal, [{
    type: Directive,
    args: [{
      selector: "[cdkPortal]",
      exportAs: "cdkPortal"
    }]
  }], () => [], null);
})();
var CdkPortalOutlet = class _CdkPortalOutlet extends BasePortalOutlet {
  _moduleRef = inject(NgModuleRef$1, {
    optional: true
  });
  _document = inject(DOCUMENT);
  _viewContainerRef = inject(ViewContainerRef);
  _isInitialized = false;
  _attachedRef;
  constructor() {
    super();
  }
  get portal() {
    return this._attachedPortal;
  }
  set portal(portal) {
    if (this.hasAttached() && !portal && !this._isInitialized) {
      return;
    }
    if (this.hasAttached()) {
      super.detach();
    }
    if (portal) {
      super.attach(portal);
    }
    this._attachedPortal = portal || null;
  }
  attached = new EventEmitter();
  get attachedRef() {
    return this._attachedRef;
  }
  ngOnInit() {
    this._isInitialized = true;
  }
  ngOnDestroy() {
    super.dispose();
    this._attachedRef = this._attachedPortal = null;
  }
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this._viewContainerRef;
    const ref = viewContainerRef.createComponent(portal.component, {
      index: viewContainerRef.length,
      injector: portal.injector || viewContainerRef.injector,
      projectableNodes: portal.projectableNodes || void 0,
      ngModuleRef: this._moduleRef || void 0
    });
    if (viewContainerRef !== this._viewContainerRef) {
      this._getRootNode().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this._attachedRef = ref;
    this.attached.emit(ref);
    return ref;
  }
  attachTemplatePortal(portal) {
    portal.setAttachedHost(this);
    const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context, {
      injector: portal.injector
    });
    super.setDisposeFn(() => this._viewContainerRef.clear());
    this._attachedPortal = portal;
    this._attachedRef = viewRef;
    this.attached.emit(viewRef);
    return viewRef;
  }
  attachDomPortal = (portal) => {
    const element = portal.element;
    if (!element.parentNode && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("DOM portal content must be attached to a parent node.");
    }
    const anchorNode = this._document.createComment("dom-portal");
    portal.setAttachedHost(this);
    element.parentNode.insertBefore(anchorNode, element);
    this._getRootNode().appendChild(element);
    this._attachedPortal = portal;
    super.setDisposeFn(() => {
      if (anchorNode.parentNode) {
        anchorNode.parentNode.replaceChild(element, anchorNode);
      }
    });
  };
  _getRootNode() {
    const nativeElement = this._viewContainerRef.element.nativeElement;
    return nativeElement.nodeType === nativeElement.ELEMENT_NODE ? nativeElement : nativeElement.parentNode;
  }
  static \u0275fac = function CdkPortalOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkPortalOutlet)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkPortalOutlet,
    selectors: [["", "cdkPortalOutlet", ""]],
    inputs: {
      portal: [0, "cdkPortalOutlet", "portal"]
    },
    outputs: {
      attached: "attached"
    },
    exportAs: ["cdkPortalOutlet"],
    features: [\u0275\u0275InheritDefinitionFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[cdkPortalOutlet]",
      exportAs: "cdkPortalOutlet"
    }]
  }], () => [], {
    portal: [{
      type: Input,
      args: ["cdkPortalOutlet"]
    }],
    attached: [{
      type: Output
    }]
  });
})();
var PortalModule = class _PortalModule {
  static \u0275fac = function PortalModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PortalModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _PortalModule,
    imports: [CdkPortal, CdkPortalOutlet],
    exports: [CdkPortal, CdkPortalOutlet]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PortalModule, [{
    type: NgModule,
    args: [{
      imports: [CdkPortal, CdkPortalOutlet],
      exports: [CdkPortal, CdkPortalOutlet]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_overlay-module-chunk.mjs
var scrollBehaviorSupported = supportsScrollBehavior();
function createBlockScrollStrategy(injector) {
  return new BlockScrollStrategy(injector.get(ViewportRuler), injector.get(DOCUMENT));
}
var BlockScrollStrategy = class {
  _viewportRuler;
  _previousHTMLStyles = {
    top: "",
    left: ""
  };
  _previousScrollPosition;
  _isEnabled = false;
  _document;
  constructor(_viewportRuler, document2) {
    this._viewportRuler = _viewportRuler;
    this._document = document2;
  }
  attach() {
  }
  enable() {
    if (this._canBeEnabled()) {
      const root = this._document.documentElement;
      this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();
      this._previousHTMLStyles.left = root.style.left || "";
      this._previousHTMLStyles.top = root.style.top || "";
      root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);
      root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);
      root.classList.add("cdk-global-scrollblock");
      this._isEnabled = true;
    }
  }
  disable() {
    if (this._isEnabled) {
      const html = this._document.documentElement;
      const body = this._document.body;
      const htmlStyle = html.style;
      const bodyStyle = body.style;
      const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || "";
      const previousBodyScrollBehavior = bodyStyle.scrollBehavior || "";
      this._isEnabled = false;
      htmlStyle.left = this._previousHTMLStyles.left;
      htmlStyle.top = this._previousHTMLStyles.top;
      html.classList.remove("cdk-global-scrollblock");
      if (scrollBehaviorSupported) {
        htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = "auto";
      }
      window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);
      if (scrollBehaviorSupported) {
        htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
        bodyStyle.scrollBehavior = previousBodyScrollBehavior;
      }
    }
  }
  _canBeEnabled() {
    const html = this._document.documentElement;
    if (html.classList.contains("cdk-global-scrollblock") || this._isEnabled) {
      return false;
    }
    const rootElement = this._document.documentElement;
    const viewport = this._viewportRuler.getViewportSize();
    return rootElement.scrollHeight > viewport.height || rootElement.scrollWidth > viewport.width;
  }
};
function getMatScrollStrategyAlreadyAttachedError() {
  return Error(`Scroll strategy has already been attached.`);
}
function createCloseScrollStrategy(injector, config2) {
  return new CloseScrollStrategy(injector.get(ScrollDispatcher), injector.get(NgZone), injector.get(ViewportRuler), config2);
}
var CloseScrollStrategy = class {
  _scrollDispatcher;
  _ngZone;
  _viewportRuler;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  _initialScrollPosition;
  constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._ngZone = _ngZone;
    this._viewportRuler = _viewportRuler;
    this._config = _config;
  }
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  enable() {
    if (this._scrollSubscription) {
      return;
    }
    const stream = this._scrollDispatcher.scrolled(0).pipe(filter((scrollable) => {
      return !scrollable || !this._overlayRef.overlayElement.contains(scrollable.getElementRef().nativeElement);
    }));
    if (this._config && this._config.threshold && this._config.threshold > 1) {
      this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;
      this._scrollSubscription = stream.subscribe(() => {
        const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;
        if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {
          this._detach();
        } else {
          this._overlayRef.updatePosition();
        }
      });
    } else {
      this._scrollSubscription = stream.subscribe(this._detach);
    }
  }
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
  _detach = () => {
    this.disable();
    if (this._overlayRef.hasAttached()) {
      this._ngZone.run(() => this._overlayRef.detach());
    }
  };
};
var NoopScrollStrategy = class {
  enable() {
  }
  disable() {
  }
  attach() {
  }
};
function isElementScrolledOutsideView(element, scrollContainers) {
  return scrollContainers.some((containerBounds) => {
    const outsideAbove = element.bottom < containerBounds.top;
    const outsideBelow = element.top > containerBounds.bottom;
    const outsideLeft = element.right < containerBounds.left;
    const outsideRight = element.left > containerBounds.right;
    return outsideAbove || outsideBelow || outsideLeft || outsideRight;
  });
}
function isElementClippedByScrolling(element, scrollContainers) {
  return scrollContainers.some((scrollContainerRect) => {
    const clippedAbove = element.top < scrollContainerRect.top;
    const clippedBelow = element.bottom > scrollContainerRect.bottom;
    const clippedLeft = element.left < scrollContainerRect.left;
    const clippedRight = element.right > scrollContainerRect.right;
    return clippedAbove || clippedBelow || clippedLeft || clippedRight;
  });
}
function createRepositionScrollStrategy(injector, config2) {
  return new RepositionScrollStrategy(injector.get(ScrollDispatcher), injector.get(ViewportRuler), injector.get(NgZone), config2);
}
var RepositionScrollStrategy = class {
  _scrollDispatcher;
  _viewportRuler;
  _ngZone;
  _config;
  _scrollSubscription = null;
  _overlayRef;
  constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {
    this._scrollDispatcher = _scrollDispatcher;
    this._viewportRuler = _viewportRuler;
    this._ngZone = _ngZone;
    this._config = _config;
  }
  attach(overlayRef) {
    if (this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw getMatScrollStrategyAlreadyAttachedError();
    }
    this._overlayRef = overlayRef;
  }
  enable() {
    if (!this._scrollSubscription) {
      const throttle = this._config ? this._config.scrollThrottle : 0;
      this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {
        this._overlayRef.updatePosition();
        if (this._config && this._config.autoClose) {
          const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();
          const {
            width,
            height
          } = this._viewportRuler.getViewportSize();
          const parentRects = [{
            width,
            height,
            bottom: height,
            right: width,
            top: 0,
            left: 0
          }];
          if (isElementScrolledOutsideView(overlayRect, parentRects)) {
            this.disable();
            this._ngZone.run(() => this._overlayRef.detach());
          }
        }
      });
    }
  }
  disable() {
    if (this._scrollSubscription) {
      this._scrollSubscription.unsubscribe();
      this._scrollSubscription = null;
    }
  }
  detach() {
    this.disable();
    this._overlayRef = null;
  }
};
var ScrollStrategyOptions = class _ScrollStrategyOptions {
  _injector = inject(Injector);
  constructor() {
  }
  noop = () => new NoopScrollStrategy();
  close = (config2) => createCloseScrollStrategy(this._injector, config2);
  block = () => createBlockScrollStrategy(this._injector);
  reposition = (config2) => createRepositionScrollStrategy(this._injector, config2);
  static \u0275fac = function ScrollStrategyOptions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ScrollStrategyOptions)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ScrollStrategyOptions,
    factory: _ScrollStrategyOptions.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ScrollStrategyOptions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayConfig = class {
  positionStrategy;
  scrollStrategy = new NoopScrollStrategy();
  panelClass = "";
  hasBackdrop = false;
  backdropClass = "cdk-overlay-dark-backdrop";
  disableAnimations;
  width;
  height;
  minWidth;
  minHeight;
  maxWidth;
  maxHeight;
  direction;
  disposeOnNavigation = false;
  usePopover;
  constructor(config2) {
    if (config2) {
      const configKeys = Object.keys(config2);
      for (const key of configKeys) {
        if (config2[key] !== void 0) {
          this[key] = config2[key];
        }
      }
    }
  }
};
var ConnectedOverlayPositionChange = class {
  connectionPair;
  scrollableViewProperties;
  constructor(connectionPair, scrollableViewProperties) {
    this.connectionPair = connectionPair;
    this.scrollableViewProperties = scrollableViewProperties;
  }
};
function validateVerticalPosition(property, value) {
  if (value !== "top" && value !== "bottom" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "top", "bottom" or "center".`);
  }
}
function validateHorizontalPosition(property, value) {
  if (value !== "start" && value !== "end" && value !== "center") {
    throw Error(`ConnectedPosition: Invalid ${property} "${value}". Expected "start", "end" or "center".`);
  }
}
var BaseOverlayDispatcher = class _BaseOverlayDispatcher {
  _attachedOverlays = [];
  _document = inject(DOCUMENT);
  _isAttached;
  constructor() {
  }
  ngOnDestroy() {
    this.detach();
  }
  add(overlayRef) {
    this.remove(overlayRef);
    this._attachedOverlays.push(overlayRef);
  }
  remove(overlayRef) {
    const index2 = this._attachedOverlays.indexOf(overlayRef);
    if (index2 > -1) {
      this._attachedOverlays.splice(index2, 1);
    }
    if (this._attachedOverlays.length === 0) {
      this.detach();
    }
  }
  static \u0275fac = function BaseOverlayDispatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BaseOverlayDispatcher)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BaseOverlayDispatcher,
    factory: _BaseOverlayDispatcher.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BaseOverlayDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OverlayKeyboardDispatcher = class _OverlayKeyboardDispatcher extends BaseOverlayDispatcher {
  _ngZone = inject(NgZone);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cleanupKeydown;
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      this._ngZone.runOutsideAngular(() => {
        this._cleanupKeydown = this._renderer.listen("body", "keydown", this._keydownListener);
      });
      this._isAttached = true;
    }
  }
  detach() {
    if (this._isAttached) {
      this._cleanupKeydown?.();
      this._isAttached = false;
    }
  }
  _keydownListener = (event) => {
    const overlays = this._attachedOverlays;
    for (let i = overlays.length - 1; i > -1; i--) {
      if (overlays[i]._keydownEvents.observers.length > 0) {
        this._ngZone.run(() => overlays[i]._keydownEvents.next(event));
        break;
      }
    }
  };
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275OverlayKeyboardDispatcher_BaseFactory;
    return function OverlayKeyboardDispatcher_Factory(__ngFactoryType__) {
      return (\u0275OverlayKeyboardDispatcher_BaseFactory || (\u0275OverlayKeyboardDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_OverlayKeyboardDispatcher)))(__ngFactoryType__ || _OverlayKeyboardDispatcher);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _OverlayKeyboardDispatcher,
    factory: _OverlayKeyboardDispatcher.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayKeyboardDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var OverlayOutsideClickDispatcher = class _OverlayOutsideClickDispatcher extends BaseOverlayDispatcher {
  _platform = inject(Platform);
  _ngZone = inject(NgZone);
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _cursorOriginalValue;
  _cursorStyleIsSet = false;
  _pointerDownEventTarget;
  _cleanups;
  add(overlayRef) {
    super.add(overlayRef);
    if (!this._isAttached) {
      const body = this._document.body;
      const eventOptions = {
        capture: true
      };
      const renderer = this._renderer;
      this._cleanups = this._ngZone.runOutsideAngular(() => [renderer.listen(body, "pointerdown", this._pointerDownListener, eventOptions), renderer.listen(body, "click", this._clickListener, eventOptions), renderer.listen(body, "auxclick", this._clickListener, eventOptions), renderer.listen(body, "contextmenu", this._clickListener, eventOptions)]);
      if (this._platform.IOS && !this._cursorStyleIsSet) {
        this._cursorOriginalValue = body.style.cursor;
        body.style.cursor = "pointer";
        this._cursorStyleIsSet = true;
      }
      this._isAttached = true;
    }
  }
  detach() {
    if (this._isAttached) {
      this._cleanups?.forEach((cleanup) => cleanup());
      this._cleanups = void 0;
      if (this._platform.IOS && this._cursorStyleIsSet) {
        this._document.body.style.cursor = this._cursorOriginalValue;
        this._cursorStyleIsSet = false;
      }
      this._isAttached = false;
    }
  }
  _pointerDownListener = (event) => {
    this._pointerDownEventTarget = _getEventTarget(event);
  };
  _clickListener = (event) => {
    const target = _getEventTarget(event);
    const origin = event.type === "click" && this._pointerDownEventTarget ? this._pointerDownEventTarget : target;
    this._pointerDownEventTarget = null;
    const overlays = this._attachedOverlays.slice();
    for (let i = overlays.length - 1; i > -1; i--) {
      const overlayRef = overlays[i];
      if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {
        continue;
      }
      if (containsPierceShadowDom(overlayRef.overlayElement, target) || containsPierceShadowDom(overlayRef.overlayElement, origin)) {
        break;
      }
      const outsidePointerEvents = overlayRef._outsidePointerEvents;
      if (this._ngZone) {
        this._ngZone.run(() => outsidePointerEvents.next(event));
      } else {
        outsidePointerEvents.next(event);
      }
    }
  };
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275OverlayOutsideClickDispatcher_BaseFactory;
    return function OverlayOutsideClickDispatcher_Factory(__ngFactoryType__) {
      return (\u0275OverlayOutsideClickDispatcher_BaseFactory || (\u0275OverlayOutsideClickDispatcher_BaseFactory = \u0275\u0275getInheritedFactory(_OverlayOutsideClickDispatcher)))(__ngFactoryType__ || _OverlayOutsideClickDispatcher);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _OverlayOutsideClickDispatcher,
    factory: _OverlayOutsideClickDispatcher.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayOutsideClickDispatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function containsPierceShadowDom(parent, child) {
  const supportsShadowRoot = typeof ShadowRoot !== "undefined" && ShadowRoot;
  let current = child;
  while (current) {
    if (current === parent) {
      return true;
    }
    current = supportsShadowRoot && current instanceof ShadowRoot ? current.host : current.parentNode;
  }
  return false;
}
var _CdkOverlayStyleLoader = class __CdkOverlayStyleLoader {
  static \u0275fac = function _CdkOverlayStyleLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __CdkOverlayStyleLoader)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: __CdkOverlayStyleLoader,
    selectors: [["ng-component"]],
    hostAttrs: ["cdk-overlay-style-loader", ""],
    decls: 0,
    vars: 0,
    template: function _CdkOverlayStyleLoader_Template(rf, ctx) {
    },
    styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0;touch-action:manipulation}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.cdk-overlay-popover{background:none;border:none;padding:0;outline:0;overflow:visible;position:fixed;pointer-events:none;white-space:normal;color:inherit;text-decoration:none;width:100%;height:100%;inset:auto;top:0;left:0}.cdk-overlay-popover::backdrop{display:none}.cdk-overlay-popover .cdk-overlay-backdrop{position:fixed;z-index:auto}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_CdkOverlayStyleLoader, [{
    type: Component,
    args: [{
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        "cdk-overlay-style-loader": ""
      },
      styles: [".cdk-overlay-container,.cdk-global-overlay-wrapper{pointer-events:none;top:0;left:0;height:100%;width:100%}.cdk-overlay-container{position:fixed}@layer cdk-overlay{.cdk-overlay-container{z-index:1000}}.cdk-overlay-container:empty{display:none}.cdk-global-overlay-wrapper{display:flex;position:absolute}@layer cdk-overlay{.cdk-global-overlay-wrapper{z-index:1000}}.cdk-overlay-pane{position:absolute;pointer-events:auto;box-sizing:border-box;display:flex;max-width:100%;max-height:100%}@layer cdk-overlay{.cdk-overlay-pane{z-index:1000}}.cdk-overlay-backdrop{position:absolute;top:0;bottom:0;left:0;right:0;pointer-events:auto;-webkit-tap-highlight-color:rgba(0,0,0,0);opacity:0;touch-action:manipulation}@layer cdk-overlay{.cdk-overlay-backdrop{z-index:1000;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}}@media(prefers-reduced-motion){.cdk-overlay-backdrop{transition-duration:1ms}}.cdk-overlay-backdrop-showing{opacity:1}@media(forced-colors: active){.cdk-overlay-backdrop-showing{opacity:.6}}@layer cdk-overlay{.cdk-overlay-dark-backdrop{background:rgba(0,0,0,.32)}}.cdk-overlay-transparent-backdrop{transition:visibility 1ms linear,opacity 1ms linear;visibility:hidden;opacity:1}.cdk-overlay-transparent-backdrop.cdk-overlay-backdrop-showing,.cdk-high-contrast-active .cdk-overlay-transparent-backdrop{opacity:0;visibility:visible}.cdk-overlay-backdrop-noop-animation{transition:none}.cdk-overlay-connected-position-bounding-box{position:absolute;display:flex;flex-direction:column;min-width:1px;min-height:1px}@layer cdk-overlay{.cdk-overlay-connected-position-bounding-box{z-index:1000}}.cdk-global-scrollblock{position:fixed;width:100%;overflow-y:scroll}.cdk-overlay-popover{background:none;border:none;padding:0;outline:0;overflow:visible;position:fixed;pointer-events:none;white-space:normal;color:inherit;text-decoration:none;width:100%;height:100%;inset:auto;top:0;left:0}.cdk-overlay-popover::backdrop{display:none}.cdk-overlay-popover .cdk-overlay-backdrop{position:fixed;z-index:auto}\n"]
    }]
  }], null, null);
})();
var OverlayContainer = class _OverlayContainer {
  _platform = inject(Platform);
  _containerElement;
  _document = inject(DOCUMENT);
  _styleLoader = inject(_CdkPrivateStyleLoader);
  constructor() {
  }
  ngOnDestroy() {
    this._containerElement?.remove();
  }
  getContainerElement() {
    this._loadStyles();
    if (!this._containerElement) {
      this._createContainer();
    }
    return this._containerElement;
  }
  _createContainer() {
    const containerClass = "cdk-overlay-container";
    if (this._platform.isBrowser || _isTestEnvironment()) {
      const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform="server"], .${containerClass}[platform="test"]`);
      for (let i = 0; i < oppositePlatformContainers.length; i++) {
        oppositePlatformContainers[i].remove();
      }
    }
    const container = this._document.createElement("div");
    container.classList.add(containerClass);
    if (_isTestEnvironment()) {
      container.setAttribute("platform", "test");
    } else if (!this._platform.isBrowser) {
      container.setAttribute("platform", "server");
    }
    this._document.body.appendChild(container);
    this._containerElement = container;
  }
  _loadStyles() {
    this._styleLoader.load(_CdkOverlayStyleLoader);
  }
  static \u0275fac = function OverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayContainer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _OverlayContainer,
    factory: _OverlayContainer.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var BackdropRef = class {
  _renderer;
  _ngZone;
  element;
  _cleanupClick;
  _cleanupTransitionEnd;
  _fallbackTimeout;
  constructor(document2, _renderer, _ngZone, onClick) {
    this._renderer = _renderer;
    this._ngZone = _ngZone;
    this.element = document2.createElement("div");
    this.element.classList.add("cdk-overlay-backdrop");
    this._cleanupClick = _renderer.listen(this.element, "click", onClick);
  }
  detach() {
    this._ngZone.runOutsideAngular(() => {
      const element = this.element;
      clearTimeout(this._fallbackTimeout);
      this._cleanupTransitionEnd?.();
      this._cleanupTransitionEnd = this._renderer.listen(element, "transitionend", this.dispose);
      this._fallbackTimeout = setTimeout(this.dispose, 500);
      element.style.pointerEvents = "none";
      element.classList.remove("cdk-overlay-backdrop-showing");
    });
  }
  dispose = () => {
    clearTimeout(this._fallbackTimeout);
    this._cleanupClick?.();
    this._cleanupTransitionEnd?.();
    this._cleanupClick = this._cleanupTransitionEnd = this._fallbackTimeout = void 0;
    this.element.remove();
  };
};
function isElement(value) {
  return value && value.nodeType === 1;
}
var OverlayRef = class {
  _portalOutlet;
  _host;
  _pane;
  _config;
  _ngZone;
  _keyboardDispatcher;
  _document;
  _location;
  _outsideClickDispatcher;
  _animationsDisabled;
  _injector;
  _renderer;
  _backdropClick = new Subject();
  _attachments = new Subject();
  _detachments = new Subject();
  _positionStrategy;
  _scrollStrategy;
  _locationChanges = Subscription.EMPTY;
  _backdropRef = null;
  _detachContentMutationObserver;
  _detachContentAfterRenderRef;
  _disposed;
  _previousHostParent;
  _keydownEvents = new Subject();
  _outsidePointerEvents = new Subject();
  _afterNextRenderRef;
  constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document2, _location, _outsideClickDispatcher, _animationsDisabled = false, _injector, _renderer) {
    this._portalOutlet = _portalOutlet;
    this._host = _host;
    this._pane = _pane;
    this._config = _config;
    this._ngZone = _ngZone;
    this._keyboardDispatcher = _keyboardDispatcher;
    this._document = _document2;
    this._location = _location;
    this._outsideClickDispatcher = _outsideClickDispatcher;
    this._animationsDisabled = _animationsDisabled;
    this._injector = _injector;
    this._renderer = _renderer;
    if (_config.scrollStrategy) {
      this._scrollStrategy = _config.scrollStrategy;
      this._scrollStrategy.attach(this);
    }
    this._positionStrategy = _config.positionStrategy;
  }
  get overlayElement() {
    return this._pane;
  }
  get backdropElement() {
    return this._backdropRef?.element || null;
  }
  get hostElement() {
    return this._host;
  }
  attach(portal) {
    if (this._disposed) {
      return null;
    }
    this._attachHost();
    const attachResult = this._portalOutlet.attach(portal);
    this._positionStrategy?.attach(this);
    this._updateStackingOrder();
    this._updateElementSize();
    this._updateElementDirection();
    if (this._scrollStrategy) {
      this._scrollStrategy.enable();
    }
    this._afterNextRenderRef?.destroy();
    this._afterNextRenderRef = afterNextRender(() => {
      if (this.hasAttached()) {
        this.updatePosition();
      }
    }, {
      injector: this._injector
    });
    this._togglePointerEvents(true);
    if (this._config.hasBackdrop) {
      this._attachBackdrop();
    }
    if (this._config.panelClass) {
      this._toggleClasses(this._pane, this._config.panelClass, true);
    }
    this._attachments.next();
    this._completeDetachContent();
    this._keyboardDispatcher.add(this);
    if (this._config.disposeOnNavigation) {
      this._locationChanges = this._location.subscribe(() => this.dispose());
    }
    this._outsideClickDispatcher.add(this);
    if (typeof attachResult?.onDestroy === "function") {
      attachResult.onDestroy(() => {
        if (this.hasAttached()) {
          this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach()));
        }
      });
    }
    return attachResult;
  }
  detach() {
    if (!this.hasAttached()) {
      return;
    }
    this.detachBackdrop();
    this._togglePointerEvents(false);
    if (this._positionStrategy && this._positionStrategy.detach) {
      this._positionStrategy.detach();
    }
    if (this._scrollStrategy) {
      this._scrollStrategy.disable();
    }
    const detachmentResult = this._portalOutlet.detach();
    this._detachments.next();
    this._completeDetachContent();
    this._keyboardDispatcher.remove(this);
    this._detachContentWhenEmpty();
    this._locationChanges.unsubscribe();
    this._outsideClickDispatcher.remove(this);
    return detachmentResult;
  }
  dispose() {
    if (this._disposed) {
      return;
    }
    const isAttached = this.hasAttached();
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._disposeScrollStrategy();
    this._backdropRef?.dispose();
    this._locationChanges.unsubscribe();
    this._keyboardDispatcher.remove(this);
    this._portalOutlet.dispose();
    this._attachments.complete();
    this._backdropClick.complete();
    this._keydownEvents.complete();
    this._outsidePointerEvents.complete();
    this._outsideClickDispatcher.remove(this);
    this._host?.remove();
    this._afterNextRenderRef?.destroy();
    this._previousHostParent = this._pane = this._host = this._backdropRef = null;
    if (isAttached) {
      this._detachments.next();
    }
    this._detachments.complete();
    this._completeDetachContent();
    this._disposed = true;
  }
  hasAttached() {
    return this._portalOutlet.hasAttached();
  }
  backdropClick() {
    return this._backdropClick;
  }
  attachments() {
    return this._attachments;
  }
  detachments() {
    return this._detachments;
  }
  keydownEvents() {
    return this._keydownEvents;
  }
  outsidePointerEvents() {
    return this._outsidePointerEvents;
  }
  getConfig() {
    return this._config;
  }
  updatePosition() {
    if (this._positionStrategy) {
      this._positionStrategy.apply();
    }
  }
  updatePositionStrategy(strategy) {
    if (strategy === this._positionStrategy) {
      return;
    }
    if (this._positionStrategy) {
      this._positionStrategy.dispose();
    }
    this._positionStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      this.updatePosition();
    }
  }
  updateSize(sizeConfig) {
    this._config = __spreadValues(__spreadValues({}, this._config), sizeConfig);
    this._updateElementSize();
  }
  setDirection(dir) {
    this._config = __spreadProps(__spreadValues({}, this._config), {
      direction: dir
    });
    this._updateElementDirection();
  }
  addPanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, true);
    }
  }
  removePanelClass(classes) {
    if (this._pane) {
      this._toggleClasses(this._pane, classes, false);
    }
  }
  getDirection() {
    const direction = this._config.direction;
    if (!direction) {
      return "ltr";
    }
    return typeof direction === "string" ? direction : direction.value;
  }
  updateScrollStrategy(strategy) {
    if (strategy === this._scrollStrategy) {
      return;
    }
    this._disposeScrollStrategy();
    this._scrollStrategy = strategy;
    if (this.hasAttached()) {
      strategy.attach(this);
      strategy.enable();
    }
  }
  _updateElementDirection() {
    this._host.setAttribute("dir", this.getDirection());
  }
  _updateElementSize() {
    if (!this._pane) {
      return;
    }
    const style2 = this._pane.style;
    style2.width = coerceCssPixelValue(this._config.width);
    style2.height = coerceCssPixelValue(this._config.height);
    style2.minWidth = coerceCssPixelValue(this._config.minWidth);
    style2.minHeight = coerceCssPixelValue(this._config.minHeight);
    style2.maxWidth = coerceCssPixelValue(this._config.maxWidth);
    style2.maxHeight = coerceCssPixelValue(this._config.maxHeight);
  }
  _togglePointerEvents(enablePointer) {
    this._pane.style.pointerEvents = enablePointer ? "" : "none";
  }
  _attachHost() {
    if (!this._host.parentElement) {
      const customInsertionPoint = this._config.usePopover ? this._positionStrategy?.getPopoverInsertionPoint?.() : null;
      if (isElement(customInsertionPoint)) {
        customInsertionPoint.after(this._host);
      } else if (customInsertionPoint?.type === "parent") {
        customInsertionPoint.element.appendChild(this._host);
      } else {
        this._previousHostParent?.appendChild(this._host);
      }
    }
    if (this._config.usePopover) {
      try {
        this._host["showPopover"]();
      } catch {
      }
    }
  }
  _attachBackdrop() {
    const showingClass = "cdk-overlay-backdrop-showing";
    this._backdropRef?.dispose();
    this._backdropRef = new BackdropRef(this._document, this._renderer, this._ngZone, (event) => {
      this._backdropClick.next(event);
    });
    if (this._animationsDisabled) {
      this._backdropRef.element.classList.add("cdk-overlay-backdrop-noop-animation");
    }
    if (this._config.backdropClass) {
      this._toggleClasses(this._backdropRef.element, this._config.backdropClass, true);
    }
    if (this._config.usePopover) {
      this._host.prepend(this._backdropRef.element);
    } else {
      this._host.parentElement.insertBefore(this._backdropRef.element, this._host);
    }
    if (!this._animationsDisabled && typeof requestAnimationFrame !== "undefined") {
      this._ngZone.runOutsideAngular(() => {
        requestAnimationFrame(() => this._backdropRef?.element.classList.add(showingClass));
      });
    } else {
      this._backdropRef.element.classList.add(showingClass);
    }
  }
  _updateStackingOrder() {
    if (!this._config.usePopover && this._host.nextSibling) {
      this._host.parentNode.appendChild(this._host);
    }
  }
  detachBackdrop() {
    if (this._animationsDisabled) {
      this._backdropRef?.dispose();
      this._backdropRef = null;
    } else {
      this._backdropRef?.detach();
    }
  }
  _toggleClasses(element, cssClasses, isAdd) {
    const classes = coerceArray(cssClasses || []).filter((c) => !!c);
    if (classes.length) {
      isAdd ? element.classList.add(...classes) : element.classList.remove(...classes);
    }
  }
  _detachContentWhenEmpty() {
    let rethrow = false;
    try {
      this._detachContentAfterRenderRef = afterNextRender(() => {
        rethrow = true;
        this._detachContent();
      }, {
        injector: this._injector
      });
    } catch (e) {
      if (rethrow) {
        throw e;
      }
      this._detachContent();
    }
    if (globalThis.MutationObserver && this._pane) {
      this._detachContentMutationObserver ||= new globalThis.MutationObserver(() => {
        this._detachContent();
      });
      this._detachContentMutationObserver.observe(this._pane, {
        childList: true
      });
    }
  }
  _detachContent() {
    if (!this._pane || !this._host || this._pane.children.length === 0) {
      if (this._pane && this._config.panelClass) {
        this._toggleClasses(this._pane, this._config.panelClass, false);
      }
      if (this._host && this._host.parentElement) {
        this._previousHostParent = this._host.parentElement;
        this._host.remove();
      }
      this._completeDetachContent();
    }
  }
  _completeDetachContent() {
    this._detachContentAfterRenderRef?.destroy();
    this._detachContentAfterRenderRef = void 0;
    this._detachContentMutationObserver?.disconnect();
  }
  _disposeScrollStrategy() {
    const scrollStrategy = this._scrollStrategy;
    scrollStrategy?.disable();
    scrollStrategy?.detach?.();
  }
};
var boundingBoxClass = "cdk-overlay-connected-position-bounding-box";
var cssUnitPattern = /([A-Za-z%]+)$/;
function createFlexibleConnectedPositionStrategy(injector, origin) {
  return new FlexibleConnectedPositionStrategy(origin, injector.get(ViewportRuler), injector.get(DOCUMENT), injector.get(Platform), injector.get(OverlayContainer));
}
var FlexibleConnectedPositionStrategy = class {
  _viewportRuler;
  _document;
  _platform;
  _overlayContainer;
  _overlayRef;
  _isInitialRender;
  _lastBoundingBoxSize = {
    width: 0,
    height: 0
  };
  _isPushed = false;
  _canPush = true;
  _growAfterOpen = false;
  _hasFlexibleDimensions = true;
  _positionLocked = false;
  _originRect;
  _overlayRect;
  _viewportRect;
  _containerRect;
  _viewportMargin = 0;
  _scrollables = [];
  _preferredPositions = [];
  _origin;
  _pane;
  _isDisposed;
  _boundingBox;
  _lastPosition;
  _lastScrollVisibility;
  _positionChanges = new Subject();
  _resizeSubscription = Subscription.EMPTY;
  _offsetX = 0;
  _offsetY = 0;
  _transformOriginSelector;
  _appliedPanelClasses = [];
  _previousPushAmount;
  _popoverLocation = "global";
  positionChanges = this._positionChanges;
  get positions() {
    return this._preferredPositions;
  }
  constructor(connectedTo, _viewportRuler, _document2, _platform, _overlayContainer) {
    this._viewportRuler = _viewportRuler;
    this._document = _document2;
    this._platform = _platform;
    this._overlayContainer = _overlayContainer;
    this.setOrigin(connectedTo);
  }
  attach(overlayRef) {
    if (this._overlayRef && overlayRef !== this._overlayRef && (typeof ngDevMode === "undefined" || ngDevMode)) {
      throw Error("This position strategy is already attached to an overlay");
    }
    this._validatePositions();
    overlayRef.hostElement.classList.add(boundingBoxClass);
    this._overlayRef = overlayRef;
    this._boundingBox = overlayRef.hostElement;
    this._pane = overlayRef.overlayElement;
    this._isDisposed = false;
    this._isInitialRender = true;
    this._lastPosition = null;
    this._resizeSubscription.unsubscribe();
    this._resizeSubscription = this._viewportRuler.change().subscribe(() => {
      this._isInitialRender = true;
      this.apply();
    });
  }
  apply() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    if (!this._isInitialRender && this._positionLocked && this._lastPosition) {
      this.reapplyLastPosition();
      return;
    }
    this._clearPanelClasses();
    this._resetOverlayElementStyles();
    this._resetBoundingBoxStyles();
    this._viewportRect = this._getNarrowedViewportRect();
    this._originRect = this._getOriginRect();
    this._overlayRect = this._pane.getBoundingClientRect();
    this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
    const originRect = this._originRect;
    const overlayRect = this._overlayRect;
    const viewportRect = this._viewportRect;
    const containerRect = this._containerRect;
    const flexibleFits = [];
    let fallback;
    for (let pos of this._preferredPositions) {
      let originPoint = this._getOriginPoint(originRect, containerRect, pos);
      let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);
      let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);
      if (overlayFit.isCompletelyWithinViewport) {
        this._isPushed = false;
        this._applyPosition(pos, originPoint);
        return;
      }
      if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {
        flexibleFits.push({
          position: pos,
          origin: originPoint,
          overlayRect,
          boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)
        });
        continue;
      }
      if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {
        fallback = {
          overlayFit,
          overlayPoint,
          originPoint,
          position: pos,
          overlayRect
        };
      }
    }
    if (flexibleFits.length) {
      let bestFit = null;
      let bestScore = -1;
      for (const fit of flexibleFits) {
        const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);
        if (score > bestScore) {
          bestScore = score;
          bestFit = fit;
        }
      }
      this._isPushed = false;
      this._applyPosition(bestFit.position, bestFit.origin);
      return;
    }
    if (this._canPush) {
      this._isPushed = true;
      this._applyPosition(fallback.position, fallback.originPoint);
      return;
    }
    this._applyPosition(fallback.position, fallback.originPoint);
  }
  detach() {
    this._clearPanelClasses();
    this._lastPosition = null;
    this._previousPushAmount = null;
    this._resizeSubscription.unsubscribe();
  }
  dispose() {
    if (this._isDisposed) {
      return;
    }
    if (this._boundingBox) {
      extendStyles(this._boundingBox.style, {
        top: "",
        left: "",
        right: "",
        bottom: "",
        height: "",
        width: "",
        alignItems: "",
        justifyContent: ""
      });
    }
    if (this._pane) {
      this._resetOverlayElementStyles();
    }
    if (this._overlayRef) {
      this._overlayRef.hostElement.classList.remove(boundingBoxClass);
    }
    this.detach();
    this._positionChanges.complete();
    this._overlayRef = this._boundingBox = null;
    this._isDisposed = true;
  }
  reapplyLastPosition() {
    if (this._isDisposed || !this._platform.isBrowser) {
      return;
    }
    const lastPosition = this._lastPosition;
    if (lastPosition) {
      this._originRect = this._getOriginRect();
      this._overlayRect = this._pane.getBoundingClientRect();
      this._viewportRect = this._getNarrowedViewportRect();
      this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect();
      const originPoint = this._getOriginPoint(this._originRect, this._containerRect, lastPosition);
      this._applyPosition(lastPosition, originPoint);
    } else {
      this.apply();
    }
  }
  withScrollableContainers(scrollables) {
    this._scrollables = scrollables;
    return this;
  }
  withPositions(positions) {
    this._preferredPositions = positions;
    if (positions.indexOf(this._lastPosition) === -1) {
      this._lastPosition = null;
    }
    this._validatePositions();
    return this;
  }
  withViewportMargin(margin) {
    this._viewportMargin = margin;
    return this;
  }
  withFlexibleDimensions(flexibleDimensions = true) {
    this._hasFlexibleDimensions = flexibleDimensions;
    return this;
  }
  withGrowAfterOpen(growAfterOpen = true) {
    this._growAfterOpen = growAfterOpen;
    return this;
  }
  withPush(canPush = true) {
    this._canPush = canPush;
    return this;
  }
  withLockedPosition(isLocked = true) {
    this._positionLocked = isLocked;
    return this;
  }
  setOrigin(origin) {
    this._origin = origin;
    return this;
  }
  withDefaultOffsetX(offset) {
    this._offsetX = offset;
    return this;
  }
  withDefaultOffsetY(offset) {
    this._offsetY = offset;
    return this;
  }
  withTransformOriginOn(selector) {
    this._transformOriginSelector = selector;
    return this;
  }
  withPopoverLocation(location2) {
    this._popoverLocation = location2;
    return this;
  }
  getPopoverInsertionPoint() {
    if (this._popoverLocation === "global") {
      return null;
    } else if (this._popoverLocation !== "inline") {
      return this._popoverLocation;
    }
    if (this._origin instanceof ElementRef) {
      return this._origin.nativeElement;
    } else if (isElement(this._origin)) {
      return this._origin;
    } else {
      return null;
    }
  }
  _getOriginPoint(originRect, containerRect, pos) {
    let x;
    if (pos.originX == "center") {
      x = originRect.left + originRect.width / 2;
    } else {
      const startX = this._isRtl() ? originRect.right : originRect.left;
      const endX = this._isRtl() ? originRect.left : originRect.right;
      x = pos.originX == "start" ? startX : endX;
    }
    if (containerRect.left < 0) {
      x -= containerRect.left;
    }
    let y;
    if (pos.originY == "center") {
      y = originRect.top + originRect.height / 2;
    } else {
      y = pos.originY == "top" ? originRect.top : originRect.bottom;
    }
    if (containerRect.top < 0) {
      y -= containerRect.top;
    }
    return {
      x,
      y
    };
  }
  _getOverlayPoint(originPoint, overlayRect, pos) {
    let overlayStartX;
    if (pos.overlayX == "center") {
      overlayStartX = -overlayRect.width / 2;
    } else if (pos.overlayX === "start") {
      overlayStartX = this._isRtl() ? -overlayRect.width : 0;
    } else {
      overlayStartX = this._isRtl() ? 0 : -overlayRect.width;
    }
    let overlayStartY;
    if (pos.overlayY == "center") {
      overlayStartY = -overlayRect.height / 2;
    } else {
      overlayStartY = pos.overlayY == "top" ? 0 : -overlayRect.height;
    }
    return {
      x: originPoint.x + overlayStartX,
      y: originPoint.y + overlayStartY
    };
  }
  _getOverlayFit(point, rawOverlayRect, viewport, position) {
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    let {
      x,
      y
    } = point;
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      x += offsetX;
    }
    if (offsetY) {
      y += offsetY;
    }
    let leftOverflow = 0 - x;
    let rightOverflow = x + overlay.width - viewport.width;
    let topOverflow = 0 - y;
    let bottomOverflow = y + overlay.height - viewport.height;
    let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);
    let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);
    let visibleArea = visibleWidth * visibleHeight;
    return {
      visibleArea,
      isCompletelyWithinViewport: overlay.width * overlay.height === visibleArea,
      fitsInViewportVertically: visibleHeight === overlay.height,
      fitsInViewportHorizontally: visibleWidth == overlay.width
    };
  }
  _canFitWithFlexibleDimensions(fit, point, viewport) {
    if (this._hasFlexibleDimensions) {
      const availableHeight = viewport.bottom - point.y;
      const availableWidth = viewport.right - point.x;
      const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);
      const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);
      const verticalFit = fit.fitsInViewportVertically || minHeight != null && minHeight <= availableHeight;
      const horizontalFit = fit.fitsInViewportHorizontally || minWidth != null && minWidth <= availableWidth;
      return verticalFit && horizontalFit;
    }
    return false;
  }
  _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {
    if (this._previousPushAmount && this._positionLocked) {
      return {
        x: start.x + this._previousPushAmount.x,
        y: start.y + this._previousPushAmount.y
      };
    }
    const overlay = getRoundedBoundingClientRect(rawOverlayRect);
    const viewport = this._viewportRect;
    const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);
    const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);
    const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);
    const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);
    let pushX = 0;
    let pushY = 0;
    if (overlay.width <= viewport.width) {
      pushX = overflowLeft || -overflowRight;
    } else {
      pushX = start.x < this._getViewportMarginStart() ? viewport.left - scrollPosition.left - start.x : 0;
    }
    if (overlay.height <= viewport.height) {
      pushY = overflowTop || -overflowBottom;
    } else {
      pushY = start.y < this._getViewportMarginTop() ? viewport.top - scrollPosition.top - start.y : 0;
    }
    this._previousPushAmount = {
      x: pushX,
      y: pushY
    };
    return {
      x: start.x + pushX,
      y: start.y + pushY
    };
  }
  _applyPosition(position, originPoint) {
    this._setTransformOrigin(position);
    this._setOverlayElementStyles(originPoint, position);
    this._setBoundingBoxStyles(originPoint, position);
    if (position.panelClass) {
      this._addPanelClasses(position.panelClass);
    }
    if (this._positionChanges.observers.length) {
      const scrollVisibility = this._getScrollVisibility();
      if (position !== this._lastPosition || !this._lastScrollVisibility || !compareScrollVisibility(this._lastScrollVisibility, scrollVisibility)) {
        const changeEvent = new ConnectedOverlayPositionChange(position, scrollVisibility);
        this._positionChanges.next(changeEvent);
      }
      this._lastScrollVisibility = scrollVisibility;
    }
    this._lastPosition = position;
    this._isInitialRender = false;
  }
  _setTransformOrigin(position) {
    if (!this._transformOriginSelector) {
      return;
    }
    const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);
    let xOrigin;
    let yOrigin = position.overlayY;
    if (position.overlayX === "center") {
      xOrigin = "center";
    } else if (this._isRtl()) {
      xOrigin = position.overlayX === "start" ? "right" : "left";
    } else {
      xOrigin = position.overlayX === "start" ? "left" : "right";
    }
    for (let i = 0; i < elements.length; i++) {
      elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;
    }
  }
  _calculateBoundingBoxRect(origin, position) {
    const viewport = this._viewportRect;
    const isRtl = this._isRtl();
    let height, top, bottom;
    if (position.overlayY === "top") {
      top = origin.y;
      height = viewport.height - top + this._getViewportMarginBottom();
    } else if (position.overlayY === "bottom") {
      bottom = viewport.height - origin.y + this._getViewportMarginTop() + this._getViewportMarginBottom();
      height = viewport.height - bottom + this._getViewportMarginTop();
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);
      const previousHeight = this._lastBoundingBoxSize.height;
      height = smallestDistanceToViewportEdge * 2;
      top = origin.y - smallestDistanceToViewportEdge;
      if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {
        top = origin.y - previousHeight / 2;
      }
    }
    const isBoundedByRightViewportEdge = position.overlayX === "start" && !isRtl || position.overlayX === "end" && isRtl;
    const isBoundedByLeftViewportEdge = position.overlayX === "end" && !isRtl || position.overlayX === "start" && isRtl;
    let width, left, right;
    if (isBoundedByLeftViewportEdge) {
      right = viewport.width - origin.x + this._getViewportMarginStart() + this._getViewportMarginEnd();
      width = origin.x - this._getViewportMarginStart();
    } else if (isBoundedByRightViewportEdge) {
      left = origin.x;
      width = viewport.right - origin.x - this._getViewportMarginEnd();
    } else {
      const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);
      const previousWidth = this._lastBoundingBoxSize.width;
      width = smallestDistanceToViewportEdge * 2;
      left = origin.x - smallestDistanceToViewportEdge;
      if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {
        left = origin.x - previousWidth / 2;
      }
    }
    return {
      top,
      left,
      bottom,
      right,
      width,
      height
    };
  }
  _setBoundingBoxStyles(origin, position) {
    const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);
    if (!this._isInitialRender && !this._growAfterOpen) {
      boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);
      boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);
    }
    const styles = {};
    if (this._hasExactPosition()) {
      styles.top = styles.left = "0";
      styles.bottom = styles.right = "auto";
      styles.maxHeight = styles.maxWidth = "";
      styles.width = styles.height = "100%";
    } else {
      const maxHeight = this._overlayRef.getConfig().maxHeight;
      const maxWidth = this._overlayRef.getConfig().maxWidth;
      styles.width = coerceCssPixelValue(boundingBoxRect.width);
      styles.height = coerceCssPixelValue(boundingBoxRect.height);
      styles.top = coerceCssPixelValue(boundingBoxRect.top) || "auto";
      styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom) || "auto";
      styles.left = coerceCssPixelValue(boundingBoxRect.left) || "auto";
      styles.right = coerceCssPixelValue(boundingBoxRect.right) || "auto";
      if (position.overlayX === "center") {
        styles.alignItems = "center";
      } else {
        styles.alignItems = position.overlayX === "end" ? "flex-end" : "flex-start";
      }
      if (position.overlayY === "center") {
        styles.justifyContent = "center";
      } else {
        styles.justifyContent = position.overlayY === "bottom" ? "flex-end" : "flex-start";
      }
      if (maxHeight) {
        styles.maxHeight = coerceCssPixelValue(maxHeight);
      }
      if (maxWidth) {
        styles.maxWidth = coerceCssPixelValue(maxWidth);
      }
    }
    this._lastBoundingBoxSize = boundingBoxRect;
    extendStyles(this._boundingBox.style, styles);
  }
  _resetBoundingBoxStyles() {
    extendStyles(this._boundingBox.style, {
      top: "0",
      left: "0",
      right: "0",
      bottom: "0",
      height: "",
      width: "",
      alignItems: "",
      justifyContent: ""
    });
  }
  _resetOverlayElementStyles() {
    extendStyles(this._pane.style, {
      top: "",
      left: "",
      bottom: "",
      right: "",
      position: "",
      transform: ""
    });
  }
  _setOverlayElementStyles(originPoint, position) {
    const styles = {};
    const hasExactPosition = this._hasExactPosition();
    const hasFlexibleDimensions = this._hasFlexibleDimensions;
    const config2 = this._overlayRef.getConfig();
    if (hasExactPosition) {
      const scrollPosition = this._viewportRuler.getViewportScrollPosition();
      extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));
      extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));
    } else {
      styles.position = "static";
    }
    let transformString = "";
    let offsetX = this._getOffset(position, "x");
    let offsetY = this._getOffset(position, "y");
    if (offsetX) {
      transformString += `translateX(${offsetX}px) `;
    }
    if (offsetY) {
      transformString += `translateY(${offsetY}px)`;
    }
    styles.transform = transformString.trim();
    if (config2.maxHeight) {
      if (hasExactPosition) {
        styles.maxHeight = coerceCssPixelValue(config2.maxHeight);
      } else if (hasFlexibleDimensions) {
        styles.maxHeight = "";
      }
    }
    if (config2.maxWidth) {
      if (hasExactPosition) {
        styles.maxWidth = coerceCssPixelValue(config2.maxWidth);
      } else if (hasFlexibleDimensions) {
        styles.maxWidth = "";
      }
    }
    extendStyles(this._pane.style, styles);
  }
  _getExactOverlayY(position, originPoint, scrollPosition) {
    let styles = {
      top: "",
      bottom: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    if (position.overlayY === "bottom") {
      const documentHeight = this._document.documentElement.clientHeight;
      styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;
    } else {
      styles.top = coerceCssPixelValue(overlayPoint.y);
    }
    return styles;
  }
  _getExactOverlayX(position, originPoint, scrollPosition) {
    let styles = {
      left: "",
      right: ""
    };
    let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);
    if (this._isPushed) {
      overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);
    }
    let horizontalStyleProperty;
    if (this._isRtl()) {
      horizontalStyleProperty = position.overlayX === "end" ? "left" : "right";
    } else {
      horizontalStyleProperty = position.overlayX === "end" ? "right" : "left";
    }
    if (horizontalStyleProperty === "right") {
      const documentWidth = this._document.documentElement.clientWidth;
      styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;
    } else {
      styles.left = coerceCssPixelValue(overlayPoint.x);
    }
    return styles;
  }
  _getScrollVisibility() {
    const originBounds = this._getOriginRect();
    const overlayBounds = this._pane.getBoundingClientRect();
    const scrollContainerBounds = this._scrollables.map((scrollable) => {
      return scrollable.getElementRef().nativeElement.getBoundingClientRect();
    });
    return {
      isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),
      isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),
      isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),
      isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds)
    };
  }
  _subtractOverflows(length, ...overflows) {
    return overflows.reduce((currentValue, currentOverflow) => {
      return currentValue - Math.max(currentOverflow, 0);
    }, length);
  }
  _getNarrowedViewportRect() {
    const width = this._document.documentElement.clientWidth;
    const height = this._document.documentElement.clientHeight;
    const scrollPosition = this._viewportRuler.getViewportScrollPosition();
    return {
      top: scrollPosition.top + this._getViewportMarginTop(),
      left: scrollPosition.left + this._getViewportMarginStart(),
      right: scrollPosition.left + width - this._getViewportMarginEnd(),
      bottom: scrollPosition.top + height - this._getViewportMarginBottom(),
      width: width - this._getViewportMarginStart() - this._getViewportMarginEnd(),
      height: height - this._getViewportMarginTop() - this._getViewportMarginBottom()
    };
  }
  _isRtl() {
    return this._overlayRef.getDirection() === "rtl";
  }
  _hasExactPosition() {
    return !this._hasFlexibleDimensions || this._isPushed;
  }
  _getOffset(position, axis) {
    if (axis === "x") {
      return position.offsetX == null ? this._offsetX : position.offsetX;
    }
    return position.offsetY == null ? this._offsetY : position.offsetY;
  }
  _validatePositions() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!this._preferredPositions.length) {
        throw Error("FlexibleConnectedPositionStrategy: At least one position is required.");
      }
      this._preferredPositions.forEach((pair) => {
        validateHorizontalPosition("originX", pair.originX);
        validateVerticalPosition("originY", pair.originY);
        validateHorizontalPosition("overlayX", pair.overlayX);
        validateVerticalPosition("overlayY", pair.overlayY);
      });
    }
  }
  _addPanelClasses(cssClasses) {
    if (this._pane) {
      coerceArray(cssClasses).forEach((cssClass) => {
        if (cssClass !== "" && this._appliedPanelClasses.indexOf(cssClass) === -1) {
          this._appliedPanelClasses.push(cssClass);
          this._pane.classList.add(cssClass);
        }
      });
    }
  }
  _clearPanelClasses() {
    if (this._pane) {
      this._appliedPanelClasses.forEach((cssClass) => {
        this._pane.classList.remove(cssClass);
      });
      this._appliedPanelClasses = [];
    }
  }
  _getViewportMarginStart() {
    if (typeof this._viewportMargin === "number") return this._viewportMargin;
    return this._viewportMargin?.start ?? 0;
  }
  _getViewportMarginEnd() {
    if (typeof this._viewportMargin === "number") return this._viewportMargin;
    return this._viewportMargin?.end ?? 0;
  }
  _getViewportMarginTop() {
    if (typeof this._viewportMargin === "number") return this._viewportMargin;
    return this._viewportMargin?.top ?? 0;
  }
  _getViewportMarginBottom() {
    if (typeof this._viewportMargin === "number") return this._viewportMargin;
    return this._viewportMargin?.bottom ?? 0;
  }
  _getOriginRect() {
    const origin = this._origin;
    if (origin instanceof ElementRef) {
      return origin.nativeElement.getBoundingClientRect();
    }
    if (origin instanceof Element) {
      return origin.getBoundingClientRect();
    }
    const width = origin.width || 0;
    const height = origin.height || 0;
    return {
      top: origin.y,
      bottom: origin.y + height,
      left: origin.x,
      right: origin.x + width,
      height,
      width
    };
  }
};
function extendStyles(destination, source) {
  for (let key in source) {
    if (source.hasOwnProperty(key)) {
      destination[key] = source[key];
    }
  }
  return destination;
}
function getPixelValue(input2) {
  if (typeof input2 !== "number" && input2 != null) {
    const [value, units] = input2.split(cssUnitPattern);
    return !units || units === "px" ? parseFloat(value) : null;
  }
  return input2 || null;
}
function getRoundedBoundingClientRect(clientRect) {
  return {
    top: Math.floor(clientRect.top),
    right: Math.floor(clientRect.right),
    bottom: Math.floor(clientRect.bottom),
    left: Math.floor(clientRect.left),
    width: Math.floor(clientRect.width),
    height: Math.floor(clientRect.height)
  };
}
function compareScrollVisibility(a, b) {
  if (a === b) {
    return true;
  }
  return a.isOriginClipped === b.isOriginClipped && a.isOriginOutsideView === b.isOriginOutsideView && a.isOverlayClipped === b.isOverlayClipped && a.isOverlayOutsideView === b.isOverlayOutsideView;
}
var wrapperClass = "cdk-global-overlay-wrapper";
function createGlobalPositionStrategy(_injector) {
  return new GlobalPositionStrategy();
}
var GlobalPositionStrategy = class {
  _overlayRef;
  _cssPosition = "static";
  _topOffset = "";
  _bottomOffset = "";
  _alignItems = "";
  _xPosition = "";
  _xOffset = "";
  _width = "";
  _height = "";
  _isDisposed = false;
  attach(overlayRef) {
    const config2 = overlayRef.getConfig();
    this._overlayRef = overlayRef;
    if (this._width && !config2.width) {
      overlayRef.updateSize({
        width: this._width
      });
    }
    if (this._height && !config2.height) {
      overlayRef.updateSize({
        height: this._height
      });
    }
    overlayRef.hostElement.classList.add(wrapperClass);
    this._isDisposed = false;
  }
  top(value = "") {
    this._bottomOffset = "";
    this._topOffset = value;
    this._alignItems = "flex-start";
    return this;
  }
  left(value = "") {
    this._xOffset = value;
    this._xPosition = "left";
    return this;
  }
  bottom(value = "") {
    this._topOffset = "";
    this._bottomOffset = value;
    this._alignItems = "flex-end";
    return this;
  }
  right(value = "") {
    this._xOffset = value;
    this._xPosition = "right";
    return this;
  }
  start(value = "") {
    this._xOffset = value;
    this._xPosition = "start";
    return this;
  }
  end(value = "") {
    this._xOffset = value;
    this._xPosition = "end";
    return this;
  }
  width(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        width: value
      });
    } else {
      this._width = value;
    }
    return this;
  }
  height(value = "") {
    if (this._overlayRef) {
      this._overlayRef.updateSize({
        height: value
      });
    } else {
      this._height = value;
    }
    return this;
  }
  centerHorizontally(offset = "") {
    this.left(offset);
    this._xPosition = "center";
    return this;
  }
  centerVertically(offset = "") {
    this.top(offset);
    this._alignItems = "center";
    return this;
  }
  apply() {
    if (!this._overlayRef || !this._overlayRef.hasAttached()) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parentStyles = this._overlayRef.hostElement.style;
    const config2 = this._overlayRef.getConfig();
    const {
      width,
      height,
      maxWidth,
      maxHeight
    } = config2;
    const shouldBeFlushHorizontally = (width === "100%" || width === "100vw") && (!maxWidth || maxWidth === "100%" || maxWidth === "100vw");
    const shouldBeFlushVertically = (height === "100%" || height === "100vh") && (!maxHeight || maxHeight === "100%" || maxHeight === "100vh");
    const xPosition = this._xPosition;
    const xOffset = this._xOffset;
    const isRtl = this._overlayRef.getConfig().direction === "rtl";
    let marginLeft = "";
    let marginRight = "";
    let justifyContent = "";
    if (shouldBeFlushHorizontally) {
      justifyContent = "flex-start";
    } else if (xPosition === "center") {
      justifyContent = "center";
      if (isRtl) {
        marginRight = xOffset;
      } else {
        marginLeft = xOffset;
      }
    } else if (isRtl) {
      if (xPosition === "left" || xPosition === "end") {
        justifyContent = "flex-end";
        marginLeft = xOffset;
      } else if (xPosition === "right" || xPosition === "start") {
        justifyContent = "flex-start";
        marginRight = xOffset;
      }
    } else if (xPosition === "left" || xPosition === "start") {
      justifyContent = "flex-start";
      marginLeft = xOffset;
    } else if (xPosition === "right" || xPosition === "end") {
      justifyContent = "flex-end";
      marginRight = xOffset;
    }
    styles.position = this._cssPosition;
    styles.marginLeft = shouldBeFlushHorizontally ? "0" : marginLeft;
    styles.marginTop = shouldBeFlushVertically ? "0" : this._topOffset;
    styles.marginBottom = this._bottomOffset;
    styles.marginRight = shouldBeFlushHorizontally ? "0" : marginRight;
    parentStyles.justifyContent = justifyContent;
    parentStyles.alignItems = shouldBeFlushVertically ? "flex-start" : this._alignItems;
  }
  dispose() {
    if (this._isDisposed || !this._overlayRef) {
      return;
    }
    const styles = this._overlayRef.overlayElement.style;
    const parent = this._overlayRef.hostElement;
    const parentStyles = parent.style;
    parent.classList.remove(wrapperClass);
    parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop = styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = "";
    this._overlayRef = null;
    this._isDisposed = true;
  }
};
var OverlayPositionBuilder = class _OverlayPositionBuilder {
  _injector = inject(Injector);
  constructor() {
  }
  global() {
    return createGlobalPositionStrategy();
  }
  flexibleConnectedTo(origin) {
    return createFlexibleConnectedPositionStrategy(this._injector, origin);
  }
  static \u0275fac = function OverlayPositionBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayPositionBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _OverlayPositionBuilder,
    factory: _OverlayPositionBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayPositionBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var OVERLAY_DEFAULT_CONFIG = new InjectionToken("OVERLAY_DEFAULT_CONFIG");
function createOverlayRef(injector, config2) {
  injector.get(_CdkPrivateStyleLoader).load(_CdkOverlayStyleLoader);
  const overlayContainer = injector.get(OverlayContainer);
  const doc = injector.get(DOCUMENT);
  const idGenerator = injector.get(_IdGenerator);
  const appRef = injector.get(ApplicationRef);
  const directionality = injector.get(Directionality);
  const renderer = injector.get(Renderer2, null, {
    optional: true
  }) || injector.get(RendererFactory2).createRenderer(null, null);
  const overlayConfig = new OverlayConfig(config2);
  const defaultUsePopover = injector.get(OVERLAY_DEFAULT_CONFIG, null, {
    optional: true
  })?.usePopover ?? true;
  overlayConfig.direction = overlayConfig.direction || directionality.value;
  if (!("showPopover" in doc.body)) {
    overlayConfig.usePopover = false;
  } else {
    overlayConfig.usePopover = config2?.usePopover ?? defaultUsePopover;
  }
  const pane = doc.createElement("div");
  const host = doc.createElement("div");
  pane.id = idGenerator.getId("cdk-overlay-");
  pane.classList.add("cdk-overlay-pane");
  host.appendChild(pane);
  if (overlayConfig.usePopover) {
    host.setAttribute("popover", "manual");
    host.classList.add("cdk-overlay-popover");
  }
  const customInsertionPoint = overlayConfig.usePopover ? overlayConfig.positionStrategy?.getPopoverInsertionPoint?.() : null;
  overlayContainer.getContainerElement().appendChild(host);
  if (isElement(customInsertionPoint)) {
    customInsertionPoint.after(host);
  } else if (customInsertionPoint?.type === "parent") {
    customInsertionPoint.element.appendChild(host);
  }
  return new OverlayRef(new DomPortalOutlet(pane, appRef, injector), host, pane, overlayConfig, injector.get(NgZone), injector.get(OverlayKeyboardDispatcher), doc, injector.get(Location), injector.get(OverlayOutsideClickDispatcher), config2?.disableAnimations ?? injector.get(ANIMATION_MODULE_TYPE, null, {
    optional: true
  }) === "NoopAnimations", injector.get(EnvironmentInjector), renderer);
}
var Overlay = class _Overlay {
  scrollStrategies = inject(ScrollStrategyOptions);
  _positionBuilder = inject(OverlayPositionBuilder);
  _injector = inject(Injector);
  constructor() {
  }
  create(config2) {
    return createOverlayRef(this._injector, config2);
  }
  position() {
    return this._positionBuilder;
  }
  static \u0275fac = function Overlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Overlay)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Overlay,
    factory: _Overlay.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Overlay, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var defaultPositionList = [{
  originX: "start",
  originY: "bottom",
  overlayX: "start",
  overlayY: "top"
}, {
  originX: "start",
  originY: "top",
  overlayX: "start",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "top",
  overlayX: "end",
  overlayY: "bottom"
}, {
  originX: "end",
  originY: "bottom",
  overlayX: "end",
  overlayY: "top"
}];
var CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = new InjectionToken("cdk-connected-overlay-scroll-strategy", {
  providedIn: "root",
  factory: () => {
    const injector = inject(Injector);
    return () => createRepositionScrollStrategy(injector);
  }
});
var CdkOverlayOrigin = class _CdkOverlayOrigin {
  elementRef = inject(ElementRef);
  constructor() {
  }
  static \u0275fac = function CdkOverlayOrigin_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkOverlayOrigin)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkOverlayOrigin,
    selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]],
    exportAs: ["cdkOverlayOrigin"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkOverlayOrigin, [{
    type: Directive,
    args: [{
      selector: "[cdk-overlay-origin], [overlay-origin], [cdkOverlayOrigin]",
      exportAs: "cdkOverlayOrigin"
    }]
  }], () => [], null);
})();
var CDK_CONNECTED_OVERLAY_DEFAULT_CONFIG = new InjectionToken("cdk-connected-overlay-default-config");
var CdkConnectedOverlay = class _CdkConnectedOverlay {
  _dir = inject(Directionality, {
    optional: true
  });
  _injector = inject(Injector);
  _overlayRef;
  _templatePortal;
  _backdropSubscription = Subscription.EMPTY;
  _attachSubscription = Subscription.EMPTY;
  _detachSubscription = Subscription.EMPTY;
  _positionSubscription = Subscription.EMPTY;
  _offsetX;
  _offsetY;
  _position;
  _scrollStrategyFactory = inject(CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY);
  _ngZone = inject(NgZone);
  origin;
  positions;
  positionStrategy;
  get offsetX() {
    return this._offsetX;
  }
  set offsetX(offsetX) {
    this._offsetX = offsetX;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  get offsetY() {
    return this._offsetY;
  }
  set offsetY(offsetY) {
    this._offsetY = offsetY;
    if (this._position) {
      this._updatePositionStrategy(this._position);
    }
  }
  width;
  height;
  minWidth;
  minHeight;
  backdropClass;
  panelClass;
  viewportMargin = 0;
  scrollStrategy;
  open = false;
  disableClose = false;
  transformOriginSelector;
  hasBackdrop = false;
  lockPosition = false;
  flexibleDimensions = false;
  growAfterOpen = false;
  push = false;
  disposeOnNavigation = false;
  usePopover;
  matchWidth = false;
  set _config(value) {
    if (typeof value !== "string") {
      this._assignConfig(value);
    }
  }
  backdropClick = new EventEmitter();
  positionChange = new EventEmitter();
  attach = new EventEmitter();
  detach = new EventEmitter();
  overlayKeydown = new EventEmitter();
  overlayOutsideClick = new EventEmitter();
  constructor() {
    const templateRef = inject(TemplateRef);
    const viewContainerRef = inject(ViewContainerRef);
    const defaultConfig2 = inject(CDK_CONNECTED_OVERLAY_DEFAULT_CONFIG, {
      optional: true
    });
    const globalConfig = inject(OVERLAY_DEFAULT_CONFIG, {
      optional: true
    });
    this.usePopover = globalConfig?.usePopover === false ? null : "global";
    this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);
    this.scrollStrategy = this._scrollStrategyFactory();
    if (defaultConfig2) {
      this._assignConfig(defaultConfig2);
    }
  }
  get overlayRef() {
    return this._overlayRef;
  }
  get dir() {
    return this._dir ? this._dir.value : "ltr";
  }
  ngOnDestroy() {
    this._attachSubscription.unsubscribe();
    this._detachSubscription.unsubscribe();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    this._overlayRef?.dispose();
  }
  ngOnChanges(changes) {
    if (this._position) {
      this._updatePositionStrategy(this._position);
      this._overlayRef?.updateSize({
        width: this._getWidth(),
        minWidth: this.minWidth,
        height: this.height,
        minHeight: this.minHeight
      });
      if (changes["origin"] && this.open) {
        this._position.apply();
      }
    }
    if (changes["open"]) {
      this.open ? this.attachOverlay() : this.detachOverlay();
    }
  }
  _createOverlay() {
    if (!this.positions || !this.positions.length) {
      this.positions = defaultPositionList;
    }
    const overlayRef = this._overlayRef = createOverlayRef(this._injector, this._buildConfig());
    this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());
    this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());
    overlayRef.keydownEvents().subscribe((event) => {
      this.overlayKeydown.next(event);
      if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {
        event.preventDefault();
        this.detachOverlay();
      }
    });
    this._overlayRef.outsidePointerEvents().subscribe((event) => {
      const origin = this._getOriginElement();
      const target = _getEventTarget(event);
      if (!origin || origin !== target && !origin.contains(target)) {
        this.overlayOutsideClick.next(event);
      }
    });
  }
  _buildConfig() {
    const positionStrategy = this._position = this.positionStrategy || this._createPositionStrategy();
    const overlayConfig = new OverlayConfig({
      direction: this._dir || "ltr",
      positionStrategy,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.hasBackdrop,
      disposeOnNavigation: this.disposeOnNavigation,
      usePopover: !!this.usePopover
    });
    if (this.height || this.height === 0) {
      overlayConfig.height = this.height;
    }
    if (this.minWidth || this.minWidth === 0) {
      overlayConfig.minWidth = this.minWidth;
    }
    if (this.minHeight || this.minHeight === 0) {
      overlayConfig.minHeight = this.minHeight;
    }
    if (this.backdropClass) {
      overlayConfig.backdropClass = this.backdropClass;
    }
    if (this.panelClass) {
      overlayConfig.panelClass = this.panelClass;
    }
    return overlayConfig;
  }
  _updatePositionStrategy(positionStrategy) {
    const positions = this.positions.map((currentPosition) => ({
      originX: currentPosition.originX,
      originY: currentPosition.originY,
      overlayX: currentPosition.overlayX,
      overlayY: currentPosition.overlayY,
      offsetX: currentPosition.offsetX || this.offsetX,
      offsetY: currentPosition.offsetY || this.offsetY,
      panelClass: currentPosition.panelClass || void 0
    }));
    return positionStrategy.setOrigin(this._getOrigin()).withPositions(positions).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector).withPopoverLocation(this.usePopover === null ? "global" : this.usePopover);
  }
  _createPositionStrategy() {
    const strategy = createFlexibleConnectedPositionStrategy(this._injector, this._getOrigin());
    this._updatePositionStrategy(strategy);
    return strategy;
  }
  _getOrigin() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef;
    } else {
      return this.origin;
    }
  }
  _getOriginElement() {
    if (this.origin instanceof CdkOverlayOrigin) {
      return this.origin.elementRef.nativeElement;
    }
    if (this.origin instanceof ElementRef) {
      return this.origin.nativeElement;
    }
    if (typeof Element !== "undefined" && this.origin instanceof Element) {
      return this.origin;
    }
    return null;
  }
  _getWidth() {
    if (this.width) {
      return this.width;
    }
    return this.matchWidth ? this._getOriginElement()?.getBoundingClientRect?.().width : void 0;
  }
  attachOverlay() {
    if (!this._overlayRef) {
      this._createOverlay();
    }
    const ref = this._overlayRef;
    ref.getConfig().hasBackdrop = this.hasBackdrop;
    ref.updateSize({
      width: this._getWidth()
    });
    if (!ref.hasAttached()) {
      ref.attach(this._templatePortal);
    }
    if (this.hasBackdrop) {
      this._backdropSubscription = ref.backdropClick().subscribe((event) => this.backdropClick.emit(event));
    } else {
      this._backdropSubscription.unsubscribe();
    }
    this._positionSubscription.unsubscribe();
    if (this.positionChange.observers.length > 0) {
      this._positionSubscription = this._position.positionChanges.pipe(takeWhile(() => this.positionChange.observers.length > 0)).subscribe((position) => {
        this._ngZone.run(() => this.positionChange.emit(position));
        if (this.positionChange.observers.length === 0) {
          this._positionSubscription.unsubscribe();
        }
      });
    }
    this.open = true;
  }
  detachOverlay() {
    this._overlayRef?.detach();
    this._backdropSubscription.unsubscribe();
    this._positionSubscription.unsubscribe();
    this.open = false;
  }
  _assignConfig(config2) {
    this.origin = config2.origin ?? this.origin;
    this.positions = config2.positions ?? this.positions;
    this.positionStrategy = config2.positionStrategy ?? this.positionStrategy;
    this.offsetX = config2.offsetX ?? this.offsetX;
    this.offsetY = config2.offsetY ?? this.offsetY;
    this.width = config2.width ?? this.width;
    this.height = config2.height ?? this.height;
    this.minWidth = config2.minWidth ?? this.minWidth;
    this.minHeight = config2.minHeight ?? this.minHeight;
    this.backdropClass = config2.backdropClass ?? this.backdropClass;
    this.panelClass = config2.panelClass ?? this.panelClass;
    this.viewportMargin = config2.viewportMargin ?? this.viewportMargin;
    this.scrollStrategy = config2.scrollStrategy ?? this.scrollStrategy;
    this.disableClose = config2.disableClose ?? this.disableClose;
    this.transformOriginSelector = config2.transformOriginSelector ?? this.transformOriginSelector;
    this.hasBackdrop = config2.hasBackdrop ?? this.hasBackdrop;
    this.lockPosition = config2.lockPosition ?? this.lockPosition;
    this.flexibleDimensions = config2.flexibleDimensions ?? this.flexibleDimensions;
    this.growAfterOpen = config2.growAfterOpen ?? this.growAfterOpen;
    this.push = config2.push ?? this.push;
    this.disposeOnNavigation = config2.disposeOnNavigation ?? this.disposeOnNavigation;
    this.usePopover = config2.usePopover ?? this.usePopover;
    this.matchWidth = config2.matchWidth ?? this.matchWidth;
  }
  static \u0275fac = function CdkConnectedOverlay_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkConnectedOverlay)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkConnectedOverlay,
    selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]],
    inputs: {
      origin: [0, "cdkConnectedOverlayOrigin", "origin"],
      positions: [0, "cdkConnectedOverlayPositions", "positions"],
      positionStrategy: [0, "cdkConnectedOverlayPositionStrategy", "positionStrategy"],
      offsetX: [0, "cdkConnectedOverlayOffsetX", "offsetX"],
      offsetY: [0, "cdkConnectedOverlayOffsetY", "offsetY"],
      width: [0, "cdkConnectedOverlayWidth", "width"],
      height: [0, "cdkConnectedOverlayHeight", "height"],
      minWidth: [0, "cdkConnectedOverlayMinWidth", "minWidth"],
      minHeight: [0, "cdkConnectedOverlayMinHeight", "minHeight"],
      backdropClass: [0, "cdkConnectedOverlayBackdropClass", "backdropClass"],
      panelClass: [0, "cdkConnectedOverlayPanelClass", "panelClass"],
      viewportMargin: [0, "cdkConnectedOverlayViewportMargin", "viewportMargin"],
      scrollStrategy: [0, "cdkConnectedOverlayScrollStrategy", "scrollStrategy"],
      open: [0, "cdkConnectedOverlayOpen", "open"],
      disableClose: [0, "cdkConnectedOverlayDisableClose", "disableClose"],
      transformOriginSelector: [0, "cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"],
      hasBackdrop: [2, "cdkConnectedOverlayHasBackdrop", "hasBackdrop", booleanAttribute],
      lockPosition: [2, "cdkConnectedOverlayLockPosition", "lockPosition", booleanAttribute],
      flexibleDimensions: [2, "cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions", booleanAttribute],
      growAfterOpen: [2, "cdkConnectedOverlayGrowAfterOpen", "growAfterOpen", booleanAttribute],
      push: [2, "cdkConnectedOverlayPush", "push", booleanAttribute],
      disposeOnNavigation: [2, "cdkConnectedOverlayDisposeOnNavigation", "disposeOnNavigation", booleanAttribute],
      usePopover: [0, "cdkConnectedOverlayUsePopover", "usePopover"],
      matchWidth: [2, "cdkConnectedOverlayMatchWidth", "matchWidth", booleanAttribute],
      _config: [0, "cdkConnectedOverlay", "_config"]
    },
    outputs: {
      backdropClick: "backdropClick",
      positionChange: "positionChange",
      attach: "attach",
      detach: "detach",
      overlayKeydown: "overlayKeydown",
      overlayOutsideClick: "overlayOutsideClick"
    },
    exportAs: ["cdkConnectedOverlay"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkConnectedOverlay, [{
    type: Directive,
    args: [{
      selector: "[cdk-connected-overlay], [connected-overlay], [cdkConnectedOverlay]",
      exportAs: "cdkConnectedOverlay"
    }]
  }], () => [], {
    origin: [{
      type: Input,
      args: ["cdkConnectedOverlayOrigin"]
    }],
    positions: [{
      type: Input,
      args: ["cdkConnectedOverlayPositions"]
    }],
    positionStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayPositionStrategy"]
    }],
    offsetX: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetX"]
    }],
    offsetY: [{
      type: Input,
      args: ["cdkConnectedOverlayOffsetY"]
    }],
    width: [{
      type: Input,
      args: ["cdkConnectedOverlayWidth"]
    }],
    height: [{
      type: Input,
      args: ["cdkConnectedOverlayHeight"]
    }],
    minWidth: [{
      type: Input,
      args: ["cdkConnectedOverlayMinWidth"]
    }],
    minHeight: [{
      type: Input,
      args: ["cdkConnectedOverlayMinHeight"]
    }],
    backdropClass: [{
      type: Input,
      args: ["cdkConnectedOverlayBackdropClass"]
    }],
    panelClass: [{
      type: Input,
      args: ["cdkConnectedOverlayPanelClass"]
    }],
    viewportMargin: [{
      type: Input,
      args: ["cdkConnectedOverlayViewportMargin"]
    }],
    scrollStrategy: [{
      type: Input,
      args: ["cdkConnectedOverlayScrollStrategy"]
    }],
    open: [{
      type: Input,
      args: ["cdkConnectedOverlayOpen"]
    }],
    disableClose: [{
      type: Input,
      args: ["cdkConnectedOverlayDisableClose"]
    }],
    transformOriginSelector: [{
      type: Input,
      args: ["cdkConnectedOverlayTransformOriginOn"]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayHasBackdrop",
        transform: booleanAttribute
      }]
    }],
    lockPosition: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayLockPosition",
        transform: booleanAttribute
      }]
    }],
    flexibleDimensions: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayFlexibleDimensions",
        transform: booleanAttribute
      }]
    }],
    growAfterOpen: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayGrowAfterOpen",
        transform: booleanAttribute
      }]
    }],
    push: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayPush",
        transform: booleanAttribute
      }]
    }],
    disposeOnNavigation: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayDisposeOnNavigation",
        transform: booleanAttribute
      }]
    }],
    usePopover: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayUsePopover"
      }]
    }],
    matchWidth: [{
      type: Input,
      args: [{
        alias: "cdkConnectedOverlayMatchWidth",
        transform: booleanAttribute
      }]
    }],
    _config: [{
      type: Input,
      args: ["cdkConnectedOverlay"]
    }],
    backdropClick: [{
      type: Output
    }],
    positionChange: [{
      type: Output
    }],
    attach: [{
      type: Output
    }],
    detach: [{
      type: Output
    }],
    overlayKeydown: [{
      type: Output
    }],
    overlayOutsideClick: [{
      type: Output
    }]
  });
})();
var OverlayModule = class _OverlayModule {
  static \u0275fac = function OverlayModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _OverlayModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _OverlayModule,
    imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
    exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [Overlay],
    imports: [BidiModule, PortalModule, ScrollingModule, ScrollingModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(OverlayModule, [{
    type: NgModule,
    args: [{
      imports: [BidiModule, PortalModule, ScrollingModule, CdkConnectedOverlay, CdkOverlayOrigin],
      exports: [CdkConnectedOverlay, CdkOverlayOrigin, ScrollingModule],
      providers: [Overlay]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/overlay.mjs
var FullscreenOverlayContainer = class _FullscreenOverlayContainer extends OverlayContainer {
  _renderer = inject(RendererFactory2).createRenderer(null, null);
  _fullScreenEventName;
  _cleanupFullScreenListener;
  constructor() {
    super();
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    this._cleanupFullScreenListener?.();
  }
  _createContainer() {
    const eventName = this._getEventName();
    super._createContainer();
    this._adjustParentForFullscreenChange();
    if (eventName) {
      this._cleanupFullScreenListener?.();
      this._cleanupFullScreenListener = this._renderer.listen("document", eventName, () => {
        this._adjustParentForFullscreenChange();
      });
    }
  }
  _adjustParentForFullscreenChange() {
    if (this._containerElement) {
      const fullscreenElement = this.getFullscreenElement();
      const parent = fullscreenElement || this._document.body;
      parent.appendChild(this._containerElement);
    }
  }
  _getEventName() {
    if (!this._fullScreenEventName) {
      const _document2 = this._document;
      if (_document2.fullscreenEnabled) {
        this._fullScreenEventName = "fullscreenchange";
      } else if (_document2.webkitFullscreenEnabled) {
        this._fullScreenEventName = "webkitfullscreenchange";
      } else if (_document2.mozFullScreenEnabled) {
        this._fullScreenEventName = "mozfullscreenchange";
      } else if (_document2.msFullscreenEnabled) {
        this._fullScreenEventName = "MSFullscreenChange";
      }
    }
    return this._fullScreenEventName;
  }
  getFullscreenElement() {
    const _document2 = this._document;
    return _document2.fullscreenElement || _document2.webkitFullscreenElement || _document2.mozFullScreenElement || _document2.msFullscreenElement || null;
  }
  static \u0275fac = function FullscreenOverlayContainer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FullscreenOverlayContainer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FullscreenOverlayContainer,
    factory: _FullscreenOverlayContainer.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FullscreenOverlayContainer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/_focus-monitor-chunk.mjs
var INPUT_MODALITY_DETECTOR_OPTIONS = new InjectionToken("cdk-input-modality-detector-options");
var INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS = {
  ignoreKeys: [ALT, CONTROL, MAC_META, META, SHIFT]
};
var TOUCH_BUFFER_MS = 650;
var modalityEventListenerOptions = {
  passive: true,
  capture: true
};
var InputModalityDetector = class _InputModalityDetector {
  _platform = inject(Platform);
  _listenerCleanups;
  modalityDetected;
  modalityChanged;
  get mostRecentModality() {
    return this._modality.value;
  }
  _mostRecentTarget = null;
  _modality = new BehaviorSubject(null);
  _options;
  _lastTouchMs = 0;
  _onKeydown = (event) => {
    if (this._options?.ignoreKeys?.some((keyCode) => keyCode === event.keyCode)) {
      return;
    }
    this._modality.next("keyboard");
    this._mostRecentTarget = _getEventTarget(event);
  };
  _onMousedown = (event) => {
    if (Date.now() - this._lastTouchMs < TOUCH_BUFFER_MS) {
      return;
    }
    this._modality.next(isFakeMousedownFromScreenReader(event) ? "keyboard" : "mouse");
    this._mostRecentTarget = _getEventTarget(event);
  };
  _onTouchstart = (event) => {
    if (isFakeTouchstartFromScreenReader(event)) {
      this._modality.next("keyboard");
      return;
    }
    this._lastTouchMs = Date.now();
    this._modality.next("touch");
    this._mostRecentTarget = _getEventTarget(event);
  };
  constructor() {
    const ngZone = inject(NgZone);
    const document2 = inject(DOCUMENT);
    const options = inject(INPUT_MODALITY_DETECTOR_OPTIONS, {
      optional: true
    });
    this._options = __spreadValues(__spreadValues({}, INPUT_MODALITY_DETECTOR_DEFAULT_OPTIONS), options);
    this.modalityDetected = this._modality.pipe(skip(1));
    this.modalityChanged = this.modalityDetected.pipe(distinctUntilChanged());
    if (this._platform.isBrowser) {
      const renderer = inject(RendererFactory2).createRenderer(null, null);
      this._listenerCleanups = ngZone.runOutsideAngular(() => {
        return [renderer.listen(document2, "keydown", this._onKeydown, modalityEventListenerOptions), renderer.listen(document2, "mousedown", this._onMousedown, modalityEventListenerOptions), renderer.listen(document2, "touchstart", this._onTouchstart, modalityEventListenerOptions)];
      });
    }
  }
  ngOnDestroy() {
    this._modality.complete();
    this._listenerCleanups?.forEach((cleanup) => cleanup());
  }
  static \u0275fac = function InputModalityDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InputModalityDetector)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InputModalityDetector,
    factory: _InputModalityDetector.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InputModalityDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var FocusMonitorDetectionMode;
(function(FocusMonitorDetectionMode2) {
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["IMMEDIATE"] = 0] = "IMMEDIATE";
  FocusMonitorDetectionMode2[FocusMonitorDetectionMode2["EVENTUAL"] = 1] = "EVENTUAL";
})(FocusMonitorDetectionMode || (FocusMonitorDetectionMode = {}));
var FOCUS_MONITOR_DEFAULT_OPTIONS = new InjectionToken("cdk-focus-monitor-default-options");
var captureEventListenerOptions = normalizePassiveListenerOptions({
  passive: true,
  capture: true
});
var FocusMonitor = class _FocusMonitor {
  _ngZone = inject(NgZone);
  _platform = inject(Platform);
  _inputModalityDetector = inject(InputModalityDetector);
  _origin = null;
  _lastFocusOrigin;
  _windowFocused = false;
  _windowFocusTimeoutId;
  _originTimeoutId;
  _originFromTouchInteraction = false;
  _elementInfo = /* @__PURE__ */ new Map();
  _monitoredElementCount = 0;
  _rootNodeFocusListenerCount = /* @__PURE__ */ new Map();
  _detectionMode;
  _windowFocusListener = () => {
    this._windowFocused = true;
    this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);
  };
  _document = inject(DOCUMENT);
  _stopInputModalityDetector = new Subject();
  constructor() {
    const options = inject(FOCUS_MONITOR_DEFAULT_OPTIONS, {
      optional: true
    });
    this._detectionMode = options?.detectionMode || FocusMonitorDetectionMode.IMMEDIATE;
  }
  _rootNodeFocusAndBlurListener = (event) => {
    const target = _getEventTarget(event);
    for (let element = target; element; element = element.parentElement) {
      if (event.type === "focus") {
        this._onFocus(event, element);
      } else {
        this._onBlur(event, element);
      }
    }
  };
  monitor(element, checkChildren = false) {
    const nativeElement = coerceElement(element);
    if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {
      return of();
    }
    const rootNode = _getShadowRoot(nativeElement) || this._document;
    const cachedInfo = this._elementInfo.get(nativeElement);
    if (cachedInfo) {
      if (checkChildren) {
        cachedInfo.checkChildren = true;
      }
      return cachedInfo.subject;
    }
    const info = {
      checkChildren,
      subject: new Subject(),
      rootNode
    };
    this._elementInfo.set(nativeElement, info);
    this._registerGlobalListeners(info);
    return info.subject;
  }
  stopMonitoring(element) {
    const nativeElement = coerceElement(element);
    const elementInfo = this._elementInfo.get(nativeElement);
    if (elementInfo) {
      elementInfo.subject.complete();
      this._setClasses(nativeElement);
      this._elementInfo.delete(nativeElement);
      this._removeGlobalListeners(elementInfo);
    }
  }
  focusVia(element, origin, options) {
    const nativeElement = coerceElement(element);
    const focusedElement = this._document.activeElement;
    if (nativeElement === focusedElement) {
      this._getClosestElementsInfo(nativeElement).forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));
    } else {
      this._setOrigin(origin);
      if (typeof nativeElement.focus === "function") {
        nativeElement.focus(options);
      }
    }
  }
  ngOnDestroy() {
    this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));
  }
  _getWindow() {
    return this._document.defaultView || window;
  }
  _getFocusOrigin(focusEventTarget) {
    if (this._origin) {
      if (this._originFromTouchInteraction) {
        return this._shouldBeAttributedToTouch(focusEventTarget) ? "touch" : "program";
      } else {
        return this._origin;
      }
    }
    if (this._windowFocused && this._lastFocusOrigin) {
      return this._lastFocusOrigin;
    }
    if (focusEventTarget && this._isLastInteractionFromInputLabel(focusEventTarget)) {
      return "mouse";
    }
    return "program";
  }
  _shouldBeAttributedToTouch(focusEventTarget) {
    return this._detectionMode === FocusMonitorDetectionMode.EVENTUAL || !!focusEventTarget?.contains(this._inputModalityDetector._mostRecentTarget);
  }
  _setClasses(element, origin) {
    element.classList.toggle("cdk-focused", !!origin);
    element.classList.toggle("cdk-touch-focused", origin === "touch");
    element.classList.toggle("cdk-keyboard-focused", origin === "keyboard");
    element.classList.toggle("cdk-mouse-focused", origin === "mouse");
    element.classList.toggle("cdk-program-focused", origin === "program");
  }
  _setOrigin(origin, isFromInteraction = false) {
    this._ngZone.runOutsideAngular(() => {
      this._origin = origin;
      this._originFromTouchInteraction = origin === "touch" && isFromInteraction;
      if (this._detectionMode === FocusMonitorDetectionMode.IMMEDIATE) {
        clearTimeout(this._originTimeoutId);
        const ms = this._originFromTouchInteraction ? TOUCH_BUFFER_MS : 1;
        this._originTimeoutId = setTimeout(() => this._origin = null, ms);
      }
    });
  }
  _onFocus(event, element) {
    const elementInfo = this._elementInfo.get(element);
    const focusEventTarget = _getEventTarget(event);
    if (!elementInfo || !elementInfo.checkChildren && element !== focusEventTarget) {
      return;
    }
    this._originChanged(element, this._getFocusOrigin(focusEventTarget), elementInfo);
  }
  _onBlur(event, element) {
    const elementInfo = this._elementInfo.get(element);
    if (!elementInfo || elementInfo.checkChildren && event.relatedTarget instanceof Node && element.contains(event.relatedTarget)) {
      return;
    }
    this._setClasses(element);
    this._emitOrigin(elementInfo, null);
  }
  _emitOrigin(info, origin) {
    if (info.subject.observers.length) {
      this._ngZone.run(() => info.subject.next(origin));
    }
  }
  _registerGlobalListeners(elementInfo) {
    if (!this._platform.isBrowser) {
      return;
    }
    const rootNode = elementInfo.rootNode;
    const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;
    if (!rootNodeFocusListeners) {
      this._ngZone.runOutsideAngular(() => {
        rootNode.addEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.addEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
      });
    }
    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);
    if (++this._monitoredElementCount === 1) {
      this._ngZone.runOutsideAngular(() => {
        const window2 = this._getWindow();
        window2.addEventListener("focus", this._windowFocusListener);
      });
      this._inputModalityDetector.modalityDetected.pipe(takeUntil(this._stopInputModalityDetector)).subscribe((modality) => {
        this._setOrigin(modality, true);
      });
    }
  }
  _removeGlobalListeners(elementInfo) {
    const rootNode = elementInfo.rootNode;
    if (this._rootNodeFocusListenerCount.has(rootNode)) {
      const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);
      if (rootNodeFocusListeners > 1) {
        this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);
      } else {
        rootNode.removeEventListener("focus", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        rootNode.removeEventListener("blur", this._rootNodeFocusAndBlurListener, captureEventListenerOptions);
        this._rootNodeFocusListenerCount.delete(rootNode);
      }
    }
    if (!--this._monitoredElementCount) {
      const window2 = this._getWindow();
      window2.removeEventListener("focus", this._windowFocusListener);
      this._stopInputModalityDetector.next();
      clearTimeout(this._windowFocusTimeoutId);
      clearTimeout(this._originTimeoutId);
    }
  }
  _originChanged(element, origin, elementInfo) {
    this._setClasses(element, origin);
    this._emitOrigin(elementInfo, origin);
    this._lastFocusOrigin = origin;
  }
  _getClosestElementsInfo(element) {
    const results = [];
    this._elementInfo.forEach((info, currentElement) => {
      if (currentElement === element || info.checkChildren && currentElement.contains(element)) {
        results.push([currentElement, info]);
      }
    });
    return results;
  }
  _isLastInteractionFromInputLabel(focusEventTarget) {
    const {
      _mostRecentTarget: mostRecentTarget,
      mostRecentModality
    } = this._inputModalityDetector;
    if (mostRecentModality !== "mouse" || !mostRecentTarget || mostRecentTarget === focusEventTarget || focusEventTarget.nodeName !== "INPUT" && focusEventTarget.nodeName !== "TEXTAREA" || focusEventTarget.disabled) {
      return false;
    }
    const labels = focusEventTarget.labels;
    if (labels) {
      for (let i = 0; i < labels.length; i++) {
        if (labels[i].contains(mostRecentTarget)) {
          return true;
        }
      }
    }
    return false;
  }
  static \u0275fac = function FocusMonitor_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusMonitor)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FocusMonitor,
    factory: _FocusMonitor.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusMonitor, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkMonitorFocus = class _CdkMonitorFocus {
  _elementRef = inject(ElementRef);
  _focusMonitor = inject(FocusMonitor);
  _monitorSubscription;
  _focusOrigin = null;
  cdkFocusChange = new EventEmitter();
  constructor() {
  }
  get focusOrigin() {
    return this._focusOrigin;
  }
  ngAfterViewInit() {
    const element = this._elementRef.nativeElement;
    this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute("cdkMonitorSubtreeFocus")).subscribe((origin) => {
      this._focusOrigin = origin;
      this.cdkFocusChange.emit(origin);
    });
  }
  ngOnDestroy() {
    this._focusMonitor.stopMonitoring(this._elementRef);
    if (this._monitorSubscription) {
      this._monitorSubscription.unsubscribe();
    }
  }
  static \u0275fac = function CdkMonitorFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkMonitorFocus)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkMonitorFocus,
    selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]],
    outputs: {
      cdkFocusChange: "cdkFocusChange"
    },
    exportAs: ["cdkMonitorFocus"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkMonitorFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkMonitorElementFocus], [cdkMonitorSubtreeFocus]",
      exportAs: "cdkMonitorFocus"
    }]
  }], () => [], {
    cdkFocusChange: [{
      type: Output
    }]
  });
})();

// node_modules/@angular/cdk/fesm2022/_visually-hidden-chunk.mjs
var _VisuallyHiddenLoader = class __VisuallyHiddenLoader {
  static \u0275fac = function _VisuallyHiddenLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || __VisuallyHiddenLoader)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: __VisuallyHiddenLoader,
    selectors: [["ng-component"]],
    exportAs: ["cdkVisuallyHidden"],
    decls: 0,
    vars: 0,
    template: function _VisuallyHiddenLoader_Template(rf, ctx) {
    },
    styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"],
    encapsulation: 2,
    changeDetection: 0
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(_VisuallyHiddenLoader, [{
    type: Component,
    args: [{
      exportAs: "cdkVisuallyHidden",
      encapsulation: ViewEncapsulation.None,
      template: "",
      changeDetection: ChangeDetectionStrategy.OnPush,
      styles: [".cdk-visually-hidden{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px;white-space:nowrap;outline:0;-webkit-appearance:none;-moz-appearance:none;left:0}[dir=rtl] .cdk-visually-hidden{left:auto;right:0}\n"]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_breakpoints-observer-chunk.mjs
var mediaQueriesForWebkitCompatibility = /* @__PURE__ */ new Set();
var mediaQueryStyleNode;
var MediaMatcher = class _MediaMatcher {
  _platform = inject(Platform);
  _nonce = inject(CSP_NONCE, {
    optional: true
  });
  _matchMedia;
  constructor() {
    this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : noopMatchMedia;
  }
  matchMedia(query2) {
    if (this._platform.WEBKIT || this._platform.BLINK) {
      createEmptyStyleRule(query2, this._nonce);
    }
    return this._matchMedia(query2);
  }
  static \u0275fac = function MediaMatcher_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MediaMatcher)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _MediaMatcher,
    factory: _MediaMatcher.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MediaMatcher, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function createEmptyStyleRule(query2, nonce) {
  if (mediaQueriesForWebkitCompatibility.has(query2)) {
    return;
  }
  try {
    if (!mediaQueryStyleNode) {
      mediaQueryStyleNode = document.createElement("style");
      if (nonce) {
        mediaQueryStyleNode.setAttribute("nonce", nonce);
      }
      mediaQueryStyleNode.setAttribute("type", "text/css");
      document.head.appendChild(mediaQueryStyleNode);
    }
    if (mediaQueryStyleNode.sheet) {
      mediaQueryStyleNode.sheet.insertRule(`@media ${query2} {body{ }}`, 0);
      mediaQueriesForWebkitCompatibility.add(query2);
    }
  } catch (e) {
    console.error(e);
  }
}
function noopMatchMedia(query2) {
  return {
    matches: query2 === "all" || query2 === "",
    media: query2,
    addListener: () => {
    },
    removeListener: () => {
    }
  };
}
var BreakpointObserver = class _BreakpointObserver {
  _mediaMatcher = inject(MediaMatcher);
  _zone = inject(NgZone);
  _queries = /* @__PURE__ */ new Map();
  _destroySubject = new Subject();
  constructor() {
  }
  ngOnDestroy() {
    this._destroySubject.next();
    this._destroySubject.complete();
  }
  isMatched(value) {
    const queries = splitQueries(coerceArray(value));
    return queries.some((mediaQuery) => this._registerQuery(mediaQuery).mql.matches);
  }
  observe(value) {
    const queries = splitQueries(coerceArray(value));
    const observables = queries.map((query2) => this._registerQuery(query2).observable);
    let stateObservable = combineLatest(observables);
    stateObservable = concat(stateObservable.pipe(take(1)), stateObservable.pipe(skip(1), debounceTime(0)));
    return stateObservable.pipe(map((breakpointStates) => {
      const response = {
        matches: false,
        breakpoints: {}
      };
      breakpointStates.forEach(({
        matches,
        query: query2
      }) => {
        response.matches = response.matches || matches;
        response.breakpoints[query2] = matches;
      });
      return response;
    }));
  }
  _registerQuery(query2) {
    if (this._queries.has(query2)) {
      return this._queries.get(query2);
    }
    const mql = this._mediaMatcher.matchMedia(query2);
    const queryObservable = new Observable((observer) => {
      const handler = (e) => this._zone.run(() => observer.next(e));
      mql.addListener(handler);
      return () => {
        mql.removeListener(handler);
      };
    }).pipe(startWith(mql), map(({
      matches
    }) => ({
      query: query2,
      matches
    })), takeUntil(this._destroySubject));
    const output2 = {
      observable: queryObservable,
      mql
    };
    this._queries.set(query2, output2);
    return output2;
  }
  static \u0275fac = function BreakpointObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BreakpointObserver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BreakpointObserver,
    factory: _BreakpointObserver.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BreakpointObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function splitQueries(queries) {
  return queries.map((query2) => query2.split(",")).reduce((a1, a2) => a1.concat(a2)).map((query2) => query2.trim());
}

// node_modules/@angular/cdk/fesm2022/observers.mjs
function shouldIgnoreRecord(record2) {
  if (record2.type === "characterData" && record2.target instanceof Comment) {
    return true;
  }
  if (record2.type === "childList") {
    for (let i = 0; i < record2.addedNodes.length; i++) {
      if (!(record2.addedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    for (let i = 0; i < record2.removedNodes.length; i++) {
      if (!(record2.removedNodes[i] instanceof Comment)) {
        return false;
      }
    }
    return true;
  }
  return false;
}
var MutationObserverFactory = class _MutationObserverFactory {
  create(callback) {
    return typeof MutationObserver === "undefined" ? null : new MutationObserver(callback);
  }
  static \u0275fac = function MutationObserverFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _MutationObserverFactory)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _MutationObserverFactory,
    factory: _MutationObserverFactory.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MutationObserverFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ContentObserver = class _ContentObserver {
  _mutationObserverFactory = inject(MutationObserverFactory);
  _observedElements = /* @__PURE__ */ new Map();
  _ngZone = inject(NgZone);
  constructor() {
  }
  ngOnDestroy() {
    this._observedElements.forEach((_, element) => this._cleanupObserver(element));
  }
  observe(elementOrRef) {
    const element = coerceElement(elementOrRef);
    return new Observable((observer) => {
      const stream = this._observeElement(element);
      const subscription = stream.pipe(map((records) => records.filter((record2) => !shouldIgnoreRecord(record2))), filter((records) => !!records.length)).subscribe((records) => {
        this._ngZone.run(() => {
          observer.next(records);
        });
      });
      return () => {
        subscription.unsubscribe();
        this._unobserveElement(element);
      };
    });
  }
  _observeElement(element) {
    return this._ngZone.runOutsideAngular(() => {
      if (!this._observedElements.has(element)) {
        const stream = new Subject();
        const observer = this._mutationObserverFactory.create((mutations) => stream.next(mutations));
        if (observer) {
          observer.observe(element, {
            characterData: true,
            childList: true,
            subtree: true
          });
        }
        this._observedElements.set(element, {
          observer,
          stream,
          count: 1
        });
      } else {
        this._observedElements.get(element).count++;
      }
      return this._observedElements.get(element).stream;
    });
  }
  _unobserveElement(element) {
    if (this._observedElements.has(element)) {
      this._observedElements.get(element).count--;
      if (!this._observedElements.get(element).count) {
        this._cleanupObserver(element);
      }
    }
  }
  _cleanupObserver(element) {
    if (this._observedElements.has(element)) {
      const {
        observer,
        stream
      } = this._observedElements.get(element);
      if (observer) {
        observer.disconnect();
      }
      stream.complete();
      this._observedElements.delete(element);
    }
  }
  static \u0275fac = function ContentObserver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ContentObserver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ContentObserver,
    factory: _ContentObserver.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentObserver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkObserveContent = class _CdkObserveContent {
  _contentObserver = inject(ContentObserver);
  _elementRef = inject(ElementRef);
  event = new EventEmitter();
  get disabled() {
    return this._disabled;
  }
  set disabled(value) {
    this._disabled = value;
    this._disabled ? this._unsubscribe() : this._subscribe();
  }
  _disabled = false;
  get debounce() {
    return this._debounce;
  }
  set debounce(value) {
    this._debounce = coerceNumberProperty(value);
    this._subscribe();
  }
  _debounce;
  _currentSubscription = null;
  constructor() {
  }
  ngAfterContentInit() {
    if (!this._currentSubscription && !this.disabled) {
      this._subscribe();
    }
  }
  ngOnDestroy() {
    this._unsubscribe();
  }
  _subscribe() {
    this._unsubscribe();
    const stream = this._contentObserver.observe(this._elementRef);
    this._currentSubscription = (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);
  }
  _unsubscribe() {
    this._currentSubscription?.unsubscribe();
  }
  static \u0275fac = function CdkObserveContent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkObserveContent)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkObserveContent,
    selectors: [["", "cdkObserveContent", ""]],
    inputs: {
      disabled: [2, "cdkObserveContentDisabled", "disabled", booleanAttribute],
      debounce: "debounce"
    },
    outputs: {
      event: "cdkObserveContent"
    },
    exportAs: ["cdkObserveContent"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkObserveContent, [{
    type: Directive,
    args: [{
      selector: "[cdkObserveContent]",
      exportAs: "cdkObserveContent"
    }]
  }], () => [], {
    event: [{
      type: Output,
      args: ["cdkObserveContent"]
    }],
    disabled: [{
      type: Input,
      args: [{
        alias: "cdkObserveContentDisabled",
        transform: booleanAttribute
      }]
    }],
    debounce: [{
      type: Input
    }]
  });
})();
var ObserversModule = class _ObserversModule {
  static \u0275fac = function ObserversModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ObserversModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _ObserversModule,
    imports: [CdkObserveContent],
    exports: [CdkObserveContent]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: [MutationObserverFactory]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ObserversModule, [{
    type: NgModule,
    args: [{
      imports: [CdkObserveContent],
      exports: [CdkObserveContent],
      providers: [MutationObserverFactory]
    }]
  }], null, null);
})();

// node_modules/@angular/cdk/fesm2022/_a11y-module-chunk.mjs
var InteractivityChecker = class _InteractivityChecker {
  _platform = inject(Platform);
  constructor() {
  }
  isDisabled(element) {
    return element.hasAttribute("disabled");
  }
  isVisible(element) {
    return hasGeometry(element) && getComputedStyle(element).visibility === "visible";
  }
  isTabbable(element) {
    if (!this._platform.isBrowser) {
      return false;
    }
    const frameElement = getFrameElement(getWindow2(element));
    if (frameElement) {
      if (getTabIndexValue(frameElement) === -1) {
        return false;
      }
      if (!this.isVisible(frameElement)) {
        return false;
      }
    }
    let nodeName = element.nodeName.toLowerCase();
    let tabIndexValue = getTabIndexValue(element);
    if (element.hasAttribute("contenteditable")) {
      return tabIndexValue !== -1;
    }
    if (nodeName === "iframe" || nodeName === "object") {
      return false;
    }
    if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {
      return false;
    }
    if (nodeName === "audio") {
      if (!element.hasAttribute("controls")) {
        return false;
      }
      return tabIndexValue !== -1;
    }
    if (nodeName === "video") {
      if (tabIndexValue === -1) {
        return false;
      }
      if (tabIndexValue !== null) {
        return true;
      }
      return this._platform.FIREFOX || element.hasAttribute("controls");
    }
    return element.tabIndex >= 0;
  }
  isFocusable(element, config2) {
    return isPotentiallyFocusable(element) && !this.isDisabled(element) && (config2?.ignoreVisibility || this.isVisible(element));
  }
  static \u0275fac = function InteractivityChecker_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InteractivityChecker)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InteractivityChecker,
    factory: _InteractivityChecker.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InteractivityChecker, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getFrameElement(window2) {
  try {
    return window2.frameElement;
  } catch {
    return null;
  }
}
function hasGeometry(element) {
  return !!(element.offsetWidth || element.offsetHeight || typeof element.getClientRects === "function" && element.getClientRects().length);
}
function isNativeFormElement(element) {
  let nodeName = element.nodeName.toLowerCase();
  return nodeName === "input" || nodeName === "select" || nodeName === "button" || nodeName === "textarea";
}
function isHiddenInput(element) {
  return isInputElement(element) && element.type == "hidden";
}
function isAnchorWithHref(element) {
  return isAnchorElement(element) && element.hasAttribute("href");
}
function isInputElement(element) {
  return element.nodeName.toLowerCase() == "input";
}
function isAnchorElement(element) {
  return element.nodeName.toLowerCase() == "a";
}
function hasValidTabIndex(element) {
  if (!element.hasAttribute("tabindex") || element.tabIndex === void 0) {
    return false;
  }
  let tabIndex = element.getAttribute("tabindex");
  return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));
}
function getTabIndexValue(element) {
  if (!hasValidTabIndex(element)) {
    return null;
  }
  const tabIndex = parseInt(element.getAttribute("tabindex") || "", 10);
  return isNaN(tabIndex) ? -1 : tabIndex;
}
function isPotentiallyTabbableIOS(element) {
  let nodeName = element.nodeName.toLowerCase();
  let inputType = nodeName === "input" && element.type;
  return inputType === "text" || inputType === "password" || nodeName === "select" || nodeName === "textarea";
}
function isPotentiallyFocusable(element) {
  if (isHiddenInput(element)) {
    return false;
  }
  return isNativeFormElement(element) || isAnchorWithHref(element) || element.hasAttribute("contenteditable") || hasValidTabIndex(element);
}
function getWindow2(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || window;
}
var FocusTrap = class {
  _element;
  _checker;
  _ngZone;
  _document;
  _injector;
  _startAnchor;
  _endAnchor;
  _hasAttached = false;
  startAnchorListener = () => this.focusLastTabbableElement();
  endAnchorListener = () => this.focusFirstTabbableElement();
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(value, this._startAnchor);
      this._toggleAnchorTabIndex(value, this._endAnchor);
    }
  }
  _enabled = true;
  constructor(_element, _checker, _ngZone, _document2, deferAnchors = false, _injector) {
    this._element = _element;
    this._checker = _checker;
    this._ngZone = _ngZone;
    this._document = _document2;
    this._injector = _injector;
    if (!deferAnchors) {
      this.attachAnchors();
    }
  }
  destroy() {
    const startAnchor = this._startAnchor;
    const endAnchor = this._endAnchor;
    if (startAnchor) {
      startAnchor.removeEventListener("focus", this.startAnchorListener);
      startAnchor.remove();
    }
    if (endAnchor) {
      endAnchor.removeEventListener("focus", this.endAnchorListener);
      endAnchor.remove();
    }
    this._startAnchor = this._endAnchor = null;
    this._hasAttached = false;
  }
  attachAnchors() {
    if (this._hasAttached) {
      return true;
    }
    this._ngZone.runOutsideAngular(() => {
      if (!this._startAnchor) {
        this._startAnchor = this._createAnchor();
        this._startAnchor.addEventListener("focus", this.startAnchorListener);
      }
      if (!this._endAnchor) {
        this._endAnchor = this._createAnchor();
        this._endAnchor.addEventListener("focus", this.endAnchorListener);
      }
    });
    if (this._element.parentNode) {
      this._element.parentNode.insertBefore(this._startAnchor, this._element);
      this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);
      this._hasAttached = true;
    }
    return this._hasAttached;
  }
  focusInitialElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusInitialElement(options)));
    });
  }
  focusFirstTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusFirstTabbableElement(options)));
    });
  }
  focusLastTabbableElementWhenReady(options) {
    return new Promise((resolve) => {
      this._executeOnStable(() => resolve(this.focusLastTabbableElement(options)));
    });
  }
  _getRegionBoundary(bound) {
    const markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], [cdkFocusRegion${bound}], [cdk-focus-${bound}]`);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      for (let i = 0; i < markers.length; i++) {
        if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        } else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {
          console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', use 'cdkFocusRegion${bound}' instead. The deprecated attribute will be removed in 8.0.0.`, markers[i]);
        }
      }
    }
    if (bound == "start") {
      return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);
    }
    return markers.length ? markers[markers.length - 1] : this._getLastTabbableElement(this._element);
  }
  focusInitialElement(options) {
    const redirectToElement = this._element.querySelector(`[cdk-focus-initial], [cdkFocusInitial]`);
    if (redirectToElement) {
      if ((typeof ngDevMode === "undefined" || ngDevMode) && redirectToElement.hasAttribute(`cdk-focus-initial`)) {
        console.warn(`Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0`, redirectToElement);
      }
      if ((typeof ngDevMode === "undefined" || ngDevMode) && !this._checker.isFocusable(redirectToElement)) {
        console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);
      }
      if (!this._checker.isFocusable(redirectToElement)) {
        const focusableChild = this._getFirstTabbableElement(redirectToElement);
        focusableChild?.focus(options);
        return !!focusableChild;
      }
      redirectToElement.focus(options);
      return true;
    }
    return this.focusFirstTabbableElement(options);
  }
  focusFirstTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("start");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  focusLastTabbableElement(options) {
    const redirectToElement = this._getRegionBoundary("end");
    if (redirectToElement) {
      redirectToElement.focus(options);
    }
    return !!redirectToElement;
  }
  hasAttached() {
    return this._hasAttached;
  }
  _getFirstTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = 0; i < children.length; i++) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  _getLastTabbableElement(root) {
    if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {
      return root;
    }
    const children = root.children;
    for (let i = children.length - 1; i >= 0; i--) {
      const tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(children[i]) : null;
      if (tabbableChild) {
        return tabbableChild;
      }
    }
    return null;
  }
  _createAnchor() {
    const anchor = this._document.createElement("div");
    this._toggleAnchorTabIndex(this._enabled, anchor);
    anchor.classList.add("cdk-visually-hidden");
    anchor.classList.add("cdk-focus-trap-anchor");
    anchor.setAttribute("aria-hidden", "true");
    return anchor;
  }
  _toggleAnchorTabIndex(isEnabled, anchor) {
    isEnabled ? anchor.setAttribute("tabindex", "0") : anchor.removeAttribute("tabindex");
  }
  toggleAnchors(enabled) {
    if (this._startAnchor && this._endAnchor) {
      this._toggleAnchorTabIndex(enabled, this._startAnchor);
      this._toggleAnchorTabIndex(enabled, this._endAnchor);
    }
  }
  _executeOnStable(fn) {
    if (this._injector) {
      afterNextRender(fn, {
        injector: this._injector
      });
    } else {
      setTimeout(fn);
    }
  }
};
var FocusTrapFactory = class _FocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _document = inject(DOCUMENT);
  _injector = inject(Injector);
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  create(element, deferCaptureElements = false) {
    return new FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements, this._injector);
  }
  static \u0275fac = function FocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapFactory)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FocusTrapFactory,
    factory: _FocusTrapFactory.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkTrapFocus = class _CdkTrapFocus {
  _elementRef = inject(ElementRef);
  _focusTrapFactory = inject(FocusTrapFactory);
  focusTrap;
  _previouslyFocusedElement = null;
  get enabled() {
    return this.focusTrap?.enabled || false;
  }
  set enabled(value) {
    if (this.focusTrap) {
      this.focusTrap.enabled = value;
    }
  }
  autoCapture;
  constructor() {
    const platform = inject(Platform);
    if (platform.isBrowser) {
      this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);
    }
  }
  ngOnDestroy() {
    this.focusTrap?.destroy();
    if (this._previouslyFocusedElement) {
      this._previouslyFocusedElement.focus();
      this._previouslyFocusedElement = null;
    }
  }
  ngAfterContentInit() {
    this.focusTrap?.attachAnchors();
    if (this.autoCapture) {
      this._captureFocus();
    }
  }
  ngDoCheck() {
    if (this.focusTrap && !this.focusTrap.hasAttached()) {
      this.focusTrap.attachAnchors();
    }
  }
  ngOnChanges(changes) {
    const autoCaptureChange = changes["autoCapture"];
    if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture && this.focusTrap?.hasAttached()) {
      this._captureFocus();
    }
  }
  _captureFocus() {
    this._previouslyFocusedElement = _getFocusedElementPierceShadowDom();
    this.focusTrap?.focusInitialElementWhenReady();
  }
  static \u0275fac = function CdkTrapFocus_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkTrapFocus)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkTrapFocus,
    selectors: [["", "cdkTrapFocus", ""]],
    inputs: {
      enabled: [2, "cdkTrapFocus", "enabled", booleanAttribute],
      autoCapture: [2, "cdkTrapFocusAutoCapture", "autoCapture", booleanAttribute]
    },
    exportAs: ["cdkTrapFocus"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkTrapFocus, [{
    type: Directive,
    args: [{
      selector: "[cdkTrapFocus]",
      exportAs: "cdkTrapFocus"
    }]
  }], () => [], {
    enabled: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocus",
        transform: booleanAttribute
      }]
    }],
    autoCapture: [{
      type: Input,
      args: [{
        alias: "cdkTrapFocusAutoCapture",
        transform: booleanAttribute
      }]
    }]
  });
})();
var LIVE_ANNOUNCER_ELEMENT_TOKEN = new InjectionToken("liveAnnouncerElement", {
  providedIn: "root",
  factory: () => null
});
var LIVE_ANNOUNCER_DEFAULT_OPTIONS = new InjectionToken("LIVE_ANNOUNCER_DEFAULT_OPTIONS");
var uniqueIds = 0;
var LiveAnnouncer = class _LiveAnnouncer {
  _ngZone = inject(NgZone);
  _defaultOptions = inject(LIVE_ANNOUNCER_DEFAULT_OPTIONS, {
    optional: true
  });
  _liveElement;
  _document = inject(DOCUMENT);
  _previousTimeout;
  _currentPromise;
  _currentResolve;
  constructor() {
    const elementToken = inject(LIVE_ANNOUNCER_ELEMENT_TOKEN, {
      optional: true
    });
    this._liveElement = elementToken || this._createLiveElement();
  }
  announce(message, ...args) {
    const defaultOptions = this._defaultOptions;
    let politeness;
    let duration;
    if (args.length === 1 && typeof args[0] === "number") {
      duration = args[0];
    } else {
      [politeness, duration] = args;
    }
    this.clear();
    clearTimeout(this._previousTimeout);
    if (!politeness) {
      politeness = defaultOptions && defaultOptions.politeness ? defaultOptions.politeness : "polite";
    }
    if (duration == null && defaultOptions) {
      duration = defaultOptions.duration;
    }
    this._liveElement.setAttribute("aria-live", politeness);
    if (this._liveElement.id) {
      this._exposeAnnouncerToModals(this._liveElement.id);
    }
    return this._ngZone.runOutsideAngular(() => {
      if (!this._currentPromise) {
        this._currentPromise = new Promise((resolve) => this._currentResolve = resolve);
      }
      clearTimeout(this._previousTimeout);
      this._previousTimeout = setTimeout(() => {
        this._liveElement.textContent = message;
        if (typeof duration === "number") {
          this._previousTimeout = setTimeout(() => this.clear(), duration);
        }
        this._currentResolve?.();
        this._currentPromise = this._currentResolve = void 0;
      }, 100);
      return this._currentPromise;
    });
  }
  clear() {
    if (this._liveElement) {
      this._liveElement.textContent = "";
    }
  }
  ngOnDestroy() {
    clearTimeout(this._previousTimeout);
    this._liveElement?.remove();
    this._liveElement = null;
    this._currentResolve?.();
    this._currentPromise = this._currentResolve = void 0;
  }
  _createLiveElement() {
    const elementClass = "cdk-live-announcer-element";
    const previousElements = this._document.getElementsByClassName(elementClass);
    const liveEl = this._document.createElement("div");
    for (let i = 0; i < previousElements.length; i++) {
      previousElements[i].remove();
    }
    liveEl.classList.add(elementClass);
    liveEl.classList.add("cdk-visually-hidden");
    liveEl.setAttribute("aria-atomic", "true");
    liveEl.setAttribute("aria-live", "polite");
    liveEl.id = `cdk-live-announcer-${uniqueIds++}`;
    this._document.body.appendChild(liveEl);
    return liveEl;
  }
  _exposeAnnouncerToModals(id) {
    const modals = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]');
    for (let i = 0; i < modals.length; i++) {
      const modal = modals[i];
      const ariaOwns = modal.getAttribute("aria-owns");
      if (!ariaOwns) {
        modal.setAttribute("aria-owns", id);
      } else if (ariaOwns.indexOf(id) === -1) {
        modal.setAttribute("aria-owns", ariaOwns + " " + id);
      }
    }
  }
  static \u0275fac = function LiveAnnouncer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _LiveAnnouncer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _LiveAnnouncer,
    factory: _LiveAnnouncer.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LiveAnnouncer, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var CdkAriaLive = class _CdkAriaLive {
  _elementRef = inject(ElementRef);
  _liveAnnouncer = inject(LiveAnnouncer);
  _contentObserver = inject(ContentObserver);
  _ngZone = inject(NgZone);
  get politeness() {
    return this._politeness;
  }
  set politeness(value) {
    this._politeness = value === "off" || value === "assertive" ? value : "polite";
    if (this._politeness === "off") {
      if (this._subscription) {
        this._subscription.unsubscribe();
        this._subscription = null;
      }
    } else if (!this._subscription) {
      this._subscription = this._ngZone.runOutsideAngular(() => {
        return this._contentObserver.observe(this._elementRef).subscribe(() => {
          const elementText = this._elementRef.nativeElement.textContent;
          if (elementText !== this._previousAnnouncedText) {
            this._liveAnnouncer.announce(elementText, this._politeness, this.duration);
            this._previousAnnouncedText = elementText;
          }
        });
      });
    }
  }
  _politeness = "polite";
  duration;
  _previousAnnouncedText;
  _subscription;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
  }
  ngOnDestroy() {
    if (this._subscription) {
      this._subscription.unsubscribe();
    }
  }
  static \u0275fac = function CdkAriaLive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _CdkAriaLive)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _CdkAriaLive,
    selectors: [["", "cdkAriaLive", ""]],
    inputs: {
      politeness: [0, "cdkAriaLive", "politeness"],
      duration: [0, "cdkAriaLiveDuration", "duration"]
    },
    exportAs: ["cdkAriaLive"]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CdkAriaLive, [{
    type: Directive,
    args: [{
      selector: "[cdkAriaLive]",
      exportAs: "cdkAriaLive"
    }]
  }], () => [], {
    politeness: [{
      type: Input,
      args: ["cdkAriaLive"]
    }],
    duration: [{
      type: Input,
      args: ["cdkAriaLiveDuration"]
    }]
  });
})();
var HighContrastMode;
(function(HighContrastMode2) {
  HighContrastMode2[HighContrastMode2["NONE"] = 0] = "NONE";
  HighContrastMode2[HighContrastMode2["BLACK_ON_WHITE"] = 1] = "BLACK_ON_WHITE";
  HighContrastMode2[HighContrastMode2["WHITE_ON_BLACK"] = 2] = "WHITE_ON_BLACK";
})(HighContrastMode || (HighContrastMode = {}));
var BLACK_ON_WHITE_CSS_CLASS = "cdk-high-contrast-black-on-white";
var WHITE_ON_BLACK_CSS_CLASS = "cdk-high-contrast-white-on-black";
var HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = "cdk-high-contrast-active";
var HighContrastModeDetector = class _HighContrastModeDetector {
  _platform = inject(Platform);
  _hasCheckedHighContrastMode;
  _document = inject(DOCUMENT);
  _breakpointSubscription;
  constructor() {
    this._breakpointSubscription = inject(BreakpointObserver).observe("(forced-colors: active)").subscribe(() => {
      if (this._hasCheckedHighContrastMode) {
        this._hasCheckedHighContrastMode = false;
        this._applyBodyHighContrastModeCssClasses();
      }
    });
  }
  getHighContrastMode() {
    if (!this._platform.isBrowser) {
      return HighContrastMode.NONE;
    }
    const testElement = this._document.createElement("div");
    testElement.style.backgroundColor = "rgb(1,2,3)";
    testElement.style.position = "absolute";
    this._document.body.appendChild(testElement);
    const documentWindow = this._document.defaultView || window;
    const computedStyle = documentWindow && documentWindow.getComputedStyle ? documentWindow.getComputedStyle(testElement) : null;
    const computedColor = (computedStyle && computedStyle.backgroundColor || "").replace(/ /g, "");
    testElement.remove();
    switch (computedColor) {
      case "rgb(0,0,0)":
      case "rgb(45,50,54)":
      case "rgb(32,32,32)":
        return HighContrastMode.WHITE_ON_BLACK;
      case "rgb(255,255,255)":
      case "rgb(255,250,239)":
        return HighContrastMode.BLACK_ON_WHITE;
    }
    return HighContrastMode.NONE;
  }
  ngOnDestroy() {
    this._breakpointSubscription.unsubscribe();
  }
  _applyBodyHighContrastModeCssClasses() {
    if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) {
      const bodyClasses = this._document.body.classList;
      bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      this._hasCheckedHighContrastMode = true;
      const mode = this.getHighContrastMode();
      if (mode === HighContrastMode.BLACK_ON_WHITE) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, BLACK_ON_WHITE_CSS_CLASS);
      } else if (mode === HighContrastMode.WHITE_ON_BLACK) {
        bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS, WHITE_ON_BLACK_CSS_CLASS);
      }
    }
  }
  static \u0275fac = function HighContrastModeDetector_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _HighContrastModeDetector)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HighContrastModeDetector,
    factory: _HighContrastModeDetector.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighContrastModeDetector, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var A11yModule = class _A11yModule {
  constructor() {
    inject(HighContrastModeDetector)._applyBodyHighContrastModeCssClasses();
  }
  static \u0275fac = function A11yModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _A11yModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _A11yModule,
    imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
    exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    imports: [ObserversModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(A11yModule, [{
    type: NgModule,
    args: [{
      imports: [ObserversModule, CdkAriaLive, CdkTrapFocus, CdkMonitorFocus],
      exports: [CdkAriaLive, CdkTrapFocus, CdkMonitorFocus]
    }]
  }], () => [], null);
})();

// node_modules/@angular/cdk/fesm2022/a11y.mjs
var ID_DELIMITER = " ";
function addAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  if (ids.some((existingId) => existingId.trim() === id)) {
    return;
  }
  ids.push(id);
  el.setAttribute(attr, ids.join(ID_DELIMITER));
}
function removeAriaReferencedId(el, attr, id) {
  const ids = getAriaReferenceIds(el, attr);
  id = id.trim();
  const filteredIds = ids.filter((val) => val !== id);
  if (filteredIds.length) {
    el.setAttribute(attr, filteredIds.join(ID_DELIMITER));
  } else {
    el.removeAttribute(attr);
  }
}
function getAriaReferenceIds(el, attr) {
  const attrValue = el.getAttribute(attr);
  return attrValue?.match(/\S+/g) ?? [];
}
var CDK_DESCRIBEDBY_ID_PREFIX = "cdk-describedby-message";
var CDK_DESCRIBEDBY_HOST_ATTRIBUTE = "cdk-describedby-host";
var nextId = 0;
var AriaDescriber = class _AriaDescriber {
  _platform = inject(Platform);
  _document = inject(DOCUMENT);
  _messageRegistry = /* @__PURE__ */ new Map();
  _messagesContainer = null;
  _id = `${nextId++}`;
  constructor() {
    inject(_CdkPrivateStyleLoader).load(_VisuallyHiddenLoader);
    this._id = inject(APP_ID) + "-" + nextId++;
  }
  describe(hostElement, message, role) {
    if (!this._canBeDescribed(hostElement, message)) {
      return;
    }
    const key = getKey(message, role);
    if (typeof message !== "string") {
      setMessageId(message, this._id);
      this._messageRegistry.set(key, {
        messageElement: message,
        referenceCount: 0
      });
    } else if (!this._messageRegistry.has(key)) {
      this._createMessageElement(message, role);
    }
    if (!this._isElementDescribedByMessage(hostElement, key)) {
      this._addMessageReference(hostElement, key);
    }
  }
  removeDescription(hostElement, message, role) {
    if (!message || !this._isElementNode(hostElement)) {
      return;
    }
    const key = getKey(message, role);
    if (this._isElementDescribedByMessage(hostElement, key)) {
      this._removeMessageReference(hostElement, key);
    }
    if (typeof message === "string") {
      const registeredMessage = this._messageRegistry.get(key);
      if (registeredMessage && registeredMessage.referenceCount === 0) {
        this._deleteMessageElement(key);
      }
    }
    if (this._messagesContainer?.childNodes.length === 0) {
      this._messagesContainer.remove();
      this._messagesContainer = null;
    }
  }
  ngOnDestroy() {
    const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}="${this._id}"]`);
    for (let i = 0; i < describedElements.length; i++) {
      this._removeCdkDescribedByReferenceIds(describedElements[i]);
      describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
    }
    this._messagesContainer?.remove();
    this._messagesContainer = null;
    this._messageRegistry.clear();
  }
  _createMessageElement(message, role) {
    const messageElement = this._document.createElement("div");
    setMessageId(messageElement, this._id);
    messageElement.textContent = message;
    if (role) {
      messageElement.setAttribute("role", role);
    }
    this._createMessagesContainer();
    this._messagesContainer.appendChild(messageElement);
    this._messageRegistry.set(getKey(message, role), {
      messageElement,
      referenceCount: 0
    });
  }
  _deleteMessageElement(key) {
    this._messageRegistry.get(key)?.messageElement?.remove();
    this._messageRegistry.delete(key);
  }
  _createMessagesContainer() {
    if (this._messagesContainer) {
      return;
    }
    const containerClassName = "cdk-describedby-message-container";
    const serverContainers = this._document.querySelectorAll(`.${containerClassName}[platform="server"]`);
    for (let i = 0; i < serverContainers.length; i++) {
      serverContainers[i].remove();
    }
    const messagesContainer = this._document.createElement("div");
    messagesContainer.style.visibility = "hidden";
    messagesContainer.classList.add(containerClassName);
    messagesContainer.classList.add("cdk-visually-hidden");
    if (!this._platform.isBrowser) {
      messagesContainer.setAttribute("platform", "server");
    }
    this._document.body.appendChild(messagesContainer);
    this._messagesContainer = messagesContainer;
  }
  _removeCdkDescribedByReferenceIds(element) {
    const originalReferenceIds = getAriaReferenceIds(element, "aria-describedby").filter((id) => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);
    element.setAttribute("aria-describedby", originalReferenceIds.join(" "));
  }
  _addMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    addAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, this._id);
    registeredMessage.referenceCount++;
  }
  _removeMessageReference(element, key) {
    const registeredMessage = this._messageRegistry.get(key);
    registeredMessage.referenceCount--;
    removeAriaReferencedId(element, "aria-describedby", registeredMessage.messageElement.id);
    element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);
  }
  _isElementDescribedByMessage(element, key) {
    const referenceIds = getAriaReferenceIds(element, "aria-describedby");
    const registeredMessage = this._messageRegistry.get(key);
    const messageId = registeredMessage && registeredMessage.messageElement.id;
    return !!messageId && referenceIds.indexOf(messageId) != -1;
  }
  _canBeDescribed(element, message) {
    if (!this._isElementNode(element)) {
      return false;
    }
    if (message && typeof message === "object") {
      return true;
    }
    const trimmedMessage = message == null ? "" : `${message}`.trim();
    const ariaLabel = element.getAttribute("aria-label");
    return trimmedMessage ? !ariaLabel || ariaLabel.trim() !== trimmedMessage : false;
  }
  _isElementNode(element) {
    return element.nodeType === this._document.ELEMENT_NODE;
  }
  static \u0275fac = function AriaDescriber_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AriaDescriber)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _AriaDescriber,
    factory: _AriaDescriber.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AriaDescriber, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function getKey(message, role) {
  return typeof message === "string" ? `${role || ""}/${message}` : message;
}
function setMessageId(element, serviceId) {
  if (!element.id) {
    element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${serviceId}-${nextId++}`;
  }
}
var ConfigurableFocusTrap = class extends FocusTrap {
  _focusTrapManager;
  _inertStrategy;
  get enabled() {
    return this._enabled;
  }
  set enabled(value) {
    this._enabled = value;
    if (this._enabled) {
      this._focusTrapManager.register(this);
    } else {
      this._focusTrapManager.deregister(this);
    }
  }
  constructor(_element, _checker, _ngZone, _document2, _focusTrapManager, _inertStrategy, config2, injector) {
    super(_element, _checker, _ngZone, _document2, config2.defer, injector);
    this._focusTrapManager = _focusTrapManager;
    this._inertStrategy = _inertStrategy;
    this._focusTrapManager.register(this);
  }
  destroy() {
    this._focusTrapManager.deregister(this);
    super.destroy();
  }
  _enable() {
    this._inertStrategy.preventFocus(this);
    this.toggleAnchors(true);
  }
  _disable() {
    this._inertStrategy.allowFocus(this);
    this.toggleAnchors(false);
  }
};
var EventListenerFocusTrapInertStrategy = class {
  _listener = null;
  preventFocus(focusTrap) {
    if (this._listener) {
      focusTrap._document.removeEventListener("focus", this._listener, true);
    }
    this._listener = (e) => this._trapFocus(focusTrap, e);
    focusTrap._ngZone.runOutsideAngular(() => {
      focusTrap._document.addEventListener("focus", this._listener, true);
    });
  }
  allowFocus(focusTrap) {
    if (!this._listener) {
      return;
    }
    focusTrap._document.removeEventListener("focus", this._listener, true);
    this._listener = null;
  }
  _trapFocus(focusTrap, event) {
    const target = event.target;
    const focusTrapRoot = focusTrap._element;
    if (target && !focusTrapRoot.contains(target) && !target.closest?.("div.cdk-overlay-pane")) {
      setTimeout(() => {
        if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {
          focusTrap.focusFirstTabbableElement();
        }
      });
    }
  }
};
var FOCUS_TRAP_INERT_STRATEGY = new InjectionToken("FOCUS_TRAP_INERT_STRATEGY");
var FocusTrapManager = class _FocusTrapManager {
  _focusTrapStack = [];
  register(focusTrap) {
    this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);
    let stack = this._focusTrapStack;
    if (stack.length) {
      stack[stack.length - 1]._disable();
    }
    stack.push(focusTrap);
    focusTrap._enable();
  }
  deregister(focusTrap) {
    focusTrap._disable();
    const stack = this._focusTrapStack;
    const i = stack.indexOf(focusTrap);
    if (i !== -1) {
      stack.splice(i, 1);
      if (stack.length) {
        stack[stack.length - 1]._enable();
      }
    }
  }
  static \u0275fac = function FocusTrapManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _FocusTrapManager)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _FocusTrapManager,
    factory: _FocusTrapManager.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FocusTrapManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ConfigurableFocusTrapFactory = class _ConfigurableFocusTrapFactory {
  _checker = inject(InteractivityChecker);
  _ngZone = inject(NgZone);
  _focusTrapManager = inject(FocusTrapManager);
  _document = inject(DOCUMENT);
  _inertStrategy;
  _injector = inject(Injector);
  constructor() {
    const inertStrategy = inject(FOCUS_TRAP_INERT_STRATEGY, {
      optional: true
    });
    this._inertStrategy = inertStrategy || new EventListenerFocusTrapInertStrategy();
  }
  create(element, config2 = {
    defer: false
  }) {
    let configObject;
    if (typeof config2 === "boolean") {
      configObject = {
        defer: config2
      };
    } else {
      configObject = config2;
    }
    return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject, this._injector);
  }
  static \u0275fac = function ConfigurableFocusTrapFactory_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ConfigurableFocusTrapFactory)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ConfigurableFocusTrapFactory,
    factory: _ConfigurableFocusTrapFactory.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ConfigurableFocusTrapFactory, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/animations/fesm2022/_private_export-chunk.mjs
var AnimationMetadataType;
(function(AnimationMetadataType2) {
  AnimationMetadataType2[AnimationMetadataType2["State"] = 0] = "State";
  AnimationMetadataType2[AnimationMetadataType2["Transition"] = 1] = "Transition";
  AnimationMetadataType2[AnimationMetadataType2["Sequence"] = 2] = "Sequence";
  AnimationMetadataType2[AnimationMetadataType2["Group"] = 3] = "Group";
  AnimationMetadataType2[AnimationMetadataType2["Animate"] = 4] = "Animate";
  AnimationMetadataType2[AnimationMetadataType2["Keyframes"] = 5] = "Keyframes";
  AnimationMetadataType2[AnimationMetadataType2["Style"] = 6] = "Style";
  AnimationMetadataType2[AnimationMetadataType2["Trigger"] = 7] = "Trigger";
  AnimationMetadataType2[AnimationMetadataType2["Reference"] = 8] = "Reference";
  AnimationMetadataType2[AnimationMetadataType2["AnimateChild"] = 9] = "AnimateChild";
  AnimationMetadataType2[AnimationMetadataType2["AnimateRef"] = 10] = "AnimateRef";
  AnimationMetadataType2[AnimationMetadataType2["Query"] = 11] = "Query";
  AnimationMetadataType2[AnimationMetadataType2["Stagger"] = 12] = "Stagger";
})(AnimationMetadataType || (AnimationMetadataType = {}));
var AUTO_STYLE = "*";
function trigger(name, definitions) {
  return {
    type: AnimationMetadataType.Trigger,
    name,
    definitions,
    options: {}
  };
}
function animate(timings, styles = null) {
  return {
    type: AnimationMetadataType.Animate,
    styles,
    timings
  };
}
function sequence(steps, options = null) {
  return {
    type: AnimationMetadataType.Sequence,
    steps,
    options
  };
}
function style(tokens) {
  return {
    type: AnimationMetadataType.Style,
    styles: tokens,
    offset: null
  };
}
function state(name, styles, options) {
  return {
    type: AnimationMetadataType.State,
    name,
    styles,
    options
  };
}
function transition(stateChangeExpr, steps, options = null) {
  return {
    type: AnimationMetadataType.Transition,
    expr: stateChangeExpr,
    animation: steps,
    options
  };
}
var NoopAnimationPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  _started = false;
  _destroyed = false;
  _finished = false;
  _position = 0;
  parentPlayer = null;
  totalTime;
  constructor(duration = 0, delay2 = 0) {
    this.totalTime = duration + delay2;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  init() {
  }
  play() {
    if (!this.hasStarted()) {
      this._onStart();
      this.triggerMicrotask();
    }
    this._started = true;
  }
  triggerMicrotask() {
    queueMicrotask(() => this._onFinish());
  }
  _onStart() {
    this._onStartFns.forEach((fn) => fn());
    this._onStartFns = [];
  }
  pause() {
  }
  restart() {
  }
  finish() {
    this._onFinish();
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      if (!this.hasStarted()) {
        this._onStart();
      }
      this.finish();
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this._started = false;
    this._finished = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  setPosition(position) {
    this._position = this.totalTime ? position * this.totalTime : 1;
  }
  getPosition() {
    return this.totalTime ? this._position / this.totalTime : 1;
  }
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var AnimationGroupPlayer = class {
  _onDoneFns = [];
  _onStartFns = [];
  _finished = false;
  _started = false;
  _destroyed = false;
  _onDestroyFns = [];
  parentPlayer = null;
  totalTime = 0;
  players;
  constructor(_players) {
    this.players = _players;
    let doneCount = 0;
    let destroyCount = 0;
    let startCount = 0;
    const total = this.players.length;
    if (total == 0) {
      queueMicrotask(() => this._onFinish());
    } else {
      this.players.forEach((player) => {
        player.onDone(() => {
          if (++doneCount == total) {
            this._onFinish();
          }
        });
        player.onDestroy(() => {
          if (++destroyCount == total) {
            this._onDestroy();
          }
        });
        player.onStart(() => {
          if (++startCount == total) {
            this._onStart();
          }
        });
      });
    }
    this.totalTime = this.players.reduce((time, player) => Math.max(time, player.totalTime), 0);
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    this.players.forEach((player) => player.init());
  }
  onStart(fn) {
    this._onStartFns.push(fn);
  }
  _onStart() {
    if (!this.hasStarted()) {
      this._started = true;
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
    }
  }
  onDone(fn) {
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  hasStarted() {
    return this._started;
  }
  play() {
    if (!this.parentPlayer) {
      this.init();
    }
    this._onStart();
    this.players.forEach((player) => player.play());
  }
  pause() {
    this.players.forEach((player) => player.pause());
  }
  restart() {
    this.players.forEach((player) => player.restart());
  }
  finish() {
    this._onFinish();
    this.players.forEach((player) => player.finish());
  }
  destroy() {
    this._onDestroy();
  }
  _onDestroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._onFinish();
      this.players.forEach((player) => player.destroy());
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  reset() {
    this.players.forEach((player) => player.reset());
    this._destroyed = false;
    this._finished = false;
    this._started = false;
  }
  setPosition(p) {
    const timeAtPosition = p * this.totalTime;
    this.players.forEach((player) => {
      const position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
      player.setPosition(position);
    });
  }
  getPosition() {
    const longestPlayer = this.players.reduce((longestSoFar, player) => {
      const newPlayerIsLongest = longestSoFar === null || player.totalTime > longestSoFar.totalTime;
      return newPlayerIsLongest ? player : longestSoFar;
    }, null);
    return longestPlayer != null ? longestPlayer.getPosition() : 0;
  }
  beforeDestroy() {
    this.players.forEach((player) => {
      if (player.beforeDestroy) {
        player.beforeDestroy();
      }
    });
  }
  triggerCallback(phaseName) {
    const methods = phaseName == "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var \u0275PRE_STYLE = "!";

// node_modules/@angular/animations/fesm2022/animations.mjs
var AnimationBuilder = class _AnimationBuilder {
  static \u0275fac = function AnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _AnimationBuilder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _AnimationBuilder,
    factory: () => (() => inject(BrowserAnimationBuilder))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(BrowserAnimationBuilder)
    }]
  }], null, null);
})();
var AnimationFactory = class {
};
var BrowserAnimationBuilder = class _BrowserAnimationBuilder extends AnimationBuilder {
  animationModuleType = inject(ANIMATION_MODULE_TYPE, {
    optional: true
  });
  _nextAnimationId = 0;
  _renderer;
  constructor(rootRenderer, doc) {
    super();
    const typeData = {
      id: "0",
      encapsulation: ViewEncapsulation.None,
      styles: [],
      data: {
        animation: []
      }
    };
    this._renderer = rootRenderer.createRenderer(doc.body, typeData);
    if (this.animationModuleType === null && !isAnimationRenderer(this._renderer)) {
      throw new RuntimeError(3600, (typeof ngDevMode === "undefined" || ngDevMode) && "Angular detected that the `AnimationBuilder` was injected, but animation support was not enabled. Please make sure that you enable animations in your application by calling `provideAnimations()` or `provideAnimationsAsync()` function.");
    }
  }
  build(animation2) {
    const id = this._nextAnimationId;
    this._nextAnimationId++;
    const entry = Array.isArray(animation2) ? sequence(animation2) : animation2;
    issueAnimationCommand(this._renderer, null, id, "register", [entry]);
    return new BrowserAnimationFactory(id, this._renderer);
  }
  static \u0275fac = function BrowserAnimationBuilder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationBuilder)(\u0275\u0275inject(RendererFactory2), \u0275\u0275inject(DOCUMENT));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _BrowserAnimationBuilder,
    factory: _BrowserAnimationBuilder.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationBuilder, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: RendererFactory2
  }, {
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var BrowserAnimationFactory = class extends AnimationFactory {
  _id;
  _renderer;
  constructor(_id, _renderer) {
    super();
    this._id = _id;
    this._renderer = _renderer;
  }
  create(element, options) {
    return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);
  }
};
var RendererAnimationPlayer = class {
  id;
  element;
  _renderer;
  parentPlayer = null;
  _started = false;
  constructor(id, element, options, _renderer) {
    this.id = id;
    this.element = element;
    this._renderer = _renderer;
    this._command("create", options);
  }
  _listen(eventName, callback) {
    return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);
  }
  _command(command, ...args) {
    issueAnimationCommand(this._renderer, this.element, this.id, command, args);
  }
  onDone(fn) {
    this._listen("done", fn);
  }
  onStart(fn) {
    this._listen("start", fn);
  }
  onDestroy(fn) {
    this._listen("destroy", fn);
  }
  init() {
    this._command("init");
  }
  hasStarted() {
    return this._started;
  }
  play() {
    this._command("play");
    this._started = true;
  }
  pause() {
    this._command("pause");
  }
  restart() {
    this._command("restart");
  }
  finish() {
    this._command("finish");
  }
  destroy() {
    this._command("destroy");
  }
  reset() {
    this._command("reset");
    this._started = false;
  }
  setPosition(p) {
    this._command("setPosition", p);
  }
  getPosition() {
    return unwrapAnimationRenderer(this._renderer)?.engine?.players[this.id]?.getPosition() ?? 0;
  }
  totalTime = 0;
};
function issueAnimationCommand(renderer, element, id, command, args) {
  renderer.setProperty(element, `@@${id}:${command}`, args);
}
function unwrapAnimationRenderer(renderer) {
  const type = renderer.\u0275type;
  if (type === 0) {
    return renderer;
  } else if (type === 1) {
    return renderer.animationRenderer;
  }
  return null;
}
function isAnimationRenderer(renderer) {
  const type = renderer.\u0275type;
  return type === 0 || type === 1;
}

// node_modules/ngx-tethys/fesm2022/ngx-tethys-core.mjs
var MixinBase = class {
};
function mixinDisabled(base) {
  return class extends base {
    get thyDisabled() {
      return this._thyDisabled;
    }
    set thyDisabled(value) {
      this._thyDisabled = coerceBooleanProperty(value);
    }
    constructor(...args) {
      super(...args);
      this._thyDisabled = false;
    }
  };
}
function mixinInitialized(base) {
  return class Mixin extends base {
    constructor(...args) {
      super(...args);
      this.initialized = false;
    }
    ngOnInit() {
      this.initialized = true;
    }
  };
}
function mixinTabIndex(base, defaultTabIndex = 0) {
  return class extends base {
    get tabIndex() {
      return this.thyDisabled ? -1 : this._tabIndex;
    }
    set tabIndex(value) {
      this._tabIndex = value != null ? coerceNumberProperty(value) : this.defaultTabIndex;
    }
    constructor(...args) {
      super(...args);
      this._tabIndex = defaultTabIndex;
      this.defaultTabIndex = defaultTabIndex;
    }
  };
}
var TabIndexMixinBase = mixinTabIndex(mixinDisabled(MixinBase));
var AbstractControlValueAccessor = class {
  constructor() {
    this.onChangeFn = () => {
    };
    this.onTouchedFn = () => {
    };
    this.__onBlurValidation = () => {
    };
  }
  registerOnChange(fn) {
    this.onChangeFn = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedFn = () => {
      fn();
      this.__onBlurValidation();
    };
  }
};
var HostFocusControl = class {
  constructor(checkChildren = true, element) {
    this.ngUnsubscribe$ = new Subject();
    this.elementRef = inject(ElementRef);
    this.focusMonitor = inject(FocusMonitor);
    this.focusChanged = () => {
    };
    this.monitorElement = element || this.elementRef.nativeElement;
    this.focusMonitor.monitor(this.monitorElement, checkChildren).pipe(takeUntil(this.ngUnsubscribe$)).subscribe((origin) => {
      this.focusChanged(origin);
    });
  }
  focusVia(element, origin, options) {
    this.focusMonitor.focusVia(element, origin, options);
  }
  destroy() {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
    this.focusMonitor.stopMonitoring(this.monitorElement);
  }
};
function useHostFocusControl(checkChildren, element) {
  return new HostFocusControl(checkChildren, element);
}
var TabIndexDisabledControlValueAccessorMixin = mixinTabIndex(mixinDisabled(AbstractControlValueAccessor));
var ThyClickPositioner = class _ThyClickPositioner {
  constructor() {
    this.clickDispatcher = inject(ThyClickDispatcher);
    this.lastPosition = void 0;
    this.initialized = false;
  }
  get lastClickPosition() {
    return this.lastPosition;
  }
  runTaskUseLastPosition(task) {
    setTimeout(() => {
      task(this.lastClickPosition);
    });
  }
  initialize() {
    if (this.initialized) {
      return;
    }
    this.initialized = true;
    this.clickDispatcher.clicked(0).subscribe((event) => {
      this.lastPosition = {
        x: event.clientX,
        y: event.clientY
      };
    });
  }
  static {
    this.\u0275fac = function ThyClickPositioner_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyClickPositioner)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyClickPositioner,
      factory: _ThyClickPositioner.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyClickPositioner, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var availablePrefixes = ["moz", "ms", "webkit"];
function requestAnimationFramePolyfill() {
  let lastTime = 0;
  return function(callback) {
    const currTime = new TinyDate().getTime();
    const timeToCall = Math.max(0, 16 - (currTime - lastTime));
    const id = setTimeout(() => {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}
function getRequestAnimationFrame() {
  if (typeof window === "undefined") {
    return () => 0;
  }
  if (window.requestAnimationFrame) {
    return window.requestAnimationFrame.bind(window);
  }
  const prefix = availablePrefixes.filter((key) => `${key}RequestAnimationFrame` in window)[0];
  return prefix ? window[`${prefix}RequestAnimationFrame`] : requestAnimationFramePolyfill();
}
var reqAnimFrame = getRequestAnimationFrame();
function easeInOutCubic(t, b, c, d) {
  const cc = c - b;
  let tt = t / (d / 2);
  if (tt < 1) {
    return cc / 2 * tt * tt * tt + b;
  } else {
    return cc / 2 * ((tt -= 2) * tt * tt + 2) + b;
  }
}
var ThyScrollService = class _ThyScrollService {
  constructor() {
    this.ngZone = inject(NgZone);
    const document2 = inject(DOCUMENT);
    this.document = document2;
  }
  /** Set the position of the scroll bar of `element`. */
  setScrollTop(element, topValue = 0) {
    if (element === window) {
      this.document.body.scrollTop = topValue;
      this.document.documentElement.scrollTop = topValue;
    } else {
      element.scrollTop = topValue;
    }
  }
  /** Get the position of the scoll bar of `element`. */
  getScroll(element, top = true) {
    const target = element ? element : window;
    const prop = top ? "pageYOffset" : "pageXOffset";
    const method = top ? "scrollTop" : "scrollLeft";
    const isWindow = target === window;
    let ret = isWindow ? target[prop] : target[method];
    if (isWindow && typeof ret !== "number") {
      ret = this.document.documentElement[method];
    }
    return ret;
  }
  /**
   * Scroll `element` to some position with animation.
   *
   * @param container container, `window` by default
   * @param topValue Scroll to `top`, 0 by default
   * @param easing Transition curve, `easeInOutCubic` by default
   * @param callback callback invoked when transition is done
   */
  scrollTo(container, topValue = 0, easing, callback) {
    const target = container ? container : window;
    const scrollTop = this.getScroll(target);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      this.setScrollTop(target, (easing || easeInOutCubic)(time, scrollTop, topValue, 450));
      if (time < 450) {
        this.ngZone.runOutsideAngular(() => reqAnimFrame(frameFunc));
      } else {
        if (callback) {
          this.ngZone.run(() => callback());
        }
      }
    };
    this.ngZone.runOutsideAngular(() => reqAnimFrame(frameFunc));
  }
  static {
    this.\u0275fac = function ThyScrollService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyScrollService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyScrollService,
      factory: _ThyScrollService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyScrollService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var AnimationDuration = class {
  static {
    this.SLOW = "0.3s";
  }
  static {
    this.BASE = "0.2s";
  }
  static {
    this.FAST = "0.1s";
  }
  // Tooltip
};
var AnimationCurves = class {
  static {
    this.EASE_BASE_OUT = "cubic-bezier(0.7, 0.3, 0.1, 1)";
  }
  static {
    this.EASE_BASE_IN = "cubic-bezier(0.9, 0, 0.3, 0.7)";
  }
  static {
    this.EASE_OUT = "cubic-bezier(0.215, 0.61, 0.355, 1)";
  }
  static {
    this.EASE_IN = "cubic-bezier(0.55, 0.055, 0.675, 0.19)";
  }
  static {
    this.EASE_IN_OUT = "cubic-bezier(0.645, 0.045, 0.355, 1)";
  }
  static {
    this.EASE_OUT_BACK = "cubic-bezier(0.12, 0.4, 0.29, 1.46)";
  }
  static {
    this.EASE_IN_BACK = "cubic-bezier(0.71, -0.46, 0.88, 0.6)";
  }
  static {
    this.EASE_IN_OUT_BACK = "cubic-bezier(0.71, -0.46, 0.29, 1.46)";
  }
  static {
    this.EASE_OUT_CIRC = "cubic-bezier(0.08, 0.82, 0.17, 1)";
  }
  static {
    this.EASE_IN_CIRC = "cubic-bezier(0.6, 0.04, 0.98, 0.34)";
  }
  static {
    this.EASE_IN_OUT_CIRC = "cubic-bezier(0.78, 0.14, 0.15, 0.86)";
  }
  static {
    this.EASE_OUT_QUINT = "cubic-bezier(0.23, 1, 0.32, 1)";
  }
  static {
    this.EASE_IN_QUINT = "cubic-bezier(0.755, 0.05, 0.855, 0.06)";
  }
  static {
    this.EASE_IN_OUT_QUINT = "cubic-bezier(0.86, 0, 0.07, 1)";
  }
  static {
    this.EASE_IN_OUT_STANDARD = "cubic-bezier(0.34, 0.69, 0.1, 1)";
  }
};
var fadeMotion = trigger("fadeMotion", [transition(":enter", [style({
  opacity: 0
}), animate(`${AnimationDuration.BASE}`, style({
  opacity: 1
}))]), transition(":leave", [style({
  opacity: 1
}), animate(`${AnimationDuration.BASE}`, style({
  opacity: 0
}))])]);
var collapseMotion = trigger("collapseMotion", [state("expanded", style({
  height: "*"
})), state("collapsed", style({
  height: 0,
  overflow: "hidden"
})), state("hidden", style({
  height: 0,
  overflow: "hidden",
  borderTopWidth: "0"
})), transition("expanded => collapsed", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)), transition("expanded => hidden", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)), transition("collapsed => expanded", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`)), transition("hidden => expanded", animate(`150ms ${AnimationCurves.EASE_IN_OUT}`))]);
var thumbMotion = trigger("thumbMotion", [state("from", style({
  transform: "translateX({{ transform }}px)",
  width: "{{ width }}px"
}), {
  params: {
    transform: 0,
    width: 0
  }
}), state("to", style({
  transform: "translateX({{ transform }}px)",
  width: "{{ width }}px"
}), {
  params: {
    transform: 100,
    width: 0
  }
}), transition("from => to", animate(`300ms ${AnimationCurves.EASE_IN_OUT}`))]);
var scaleXMotion = trigger("scaleXMotion", [transition("* => enter", [style({
  opacity: 0,
  transform: "scaleX(0.9)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 1,
  transform: "scaleX(1)"
}))]), transition("enter => *", [style({
  opacity: 1,
  transform: "scaleX(1)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 0,
  transform: "scaleX(0.9)"
}))])]);
var scaleYMotion = trigger("scaleYMotion", [transition("* => enter", [style({
  opacity: 0,
  transform: "scaleY(0.9)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 1,
  transform: "scaleY(1)"
}))]), transition("enter => *", [style({
  opacity: 1,
  transform: "scaleY(1)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 0,
  transform: "scaleY(0.9)"
}))])]);
var scaleMotion = trigger("scaleMotion", [transition("* => enter", [style({
  opacity: 0,
  transform: "scale(0.9, 0.9)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 1,
  transform: "scale(1, 1)"
}))]), transition("enter => *", [style({
  opacity: 1,
  transform: "scale(1, 1)"
}), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
  opacity: 0,
  transform: "scale(0.9, 0.9)"
}))])]);
var ThyThemeStore = class _ThyThemeStore {
  constructor() {
    this.theme = signal("light", ...ngDevMode ? [{
      debugName: "theme"
    }] : []);
    this.isDark = computed(() => {
      const theme = this.theme();
      return theme === "dark" || theme === "system" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
    }, ...ngDevMode ? [{
      debugName: "isDark"
    }] : []);
  }
  setTheme(theme) {
    this.theme.set(theme);
  }
  normalizeColor(color) {
    if (typeof color === "string") {
      return color;
    }
    if (Array.isArray(color)) {
      if (color.length === 1) {
        return color[0];
      }
      if (color.length > 1) {
        if (this.isDark()) {
          return color[1];
        } else {
          return color[0];
        }
      }
    }
  }
  static {
    this.\u0275fac = function ThyThemeStore_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyThemeStore)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyThemeStore,
      factory: _ThyThemeStore.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyThemeStore, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var POSITION_MAP = {
  top: {
    originX: "center",
    originY: "top",
    overlayX: "center",
    overlayY: "bottom"
  },
  topCenter: {
    originX: "center",
    originY: "top",
    overlayX: "center",
    overlayY: "bottom"
  },
  topLeft: {
    originX: "start",
    originY: "top",
    overlayX: "start",
    overlayY: "bottom"
  },
  topRight: {
    originX: "end",
    originY: "top",
    overlayX: "end",
    overlayY: "bottom"
  },
  right: {
    originX: "end",
    originY: "center",
    overlayX: "start",
    overlayY: "center"
  },
  rightTop: {
    originX: "end",
    originY: "top",
    overlayX: "start",
    overlayY: "top"
  },
  rightBottom: {
    originX: "end",
    originY: "bottom",
    overlayX: "start",
    overlayY: "bottom"
  },
  bottom: {
    originX: "center",
    originY: "bottom",
    overlayX: "center",
    overlayY: "top"
  },
  bottomCenter: {
    originX: "center",
    originY: "bottom",
    overlayX: "center",
    overlayY: "top"
  },
  bottomLeft: {
    originX: "start",
    originY: "bottom",
    overlayX: "start",
    overlayY: "top"
  },
  bottomRight: {
    originX: "end",
    originY: "bottom",
    overlayX: "end",
    overlayY: "top"
  },
  left: {
    originX: "start",
    originY: "center",
    overlayX: "end",
    overlayY: "center"
  },
  leftTop: {
    originX: "start",
    originY: "top",
    overlayX: "end",
    overlayY: "top"
  },
  leftBottom: {
    originX: "start",
    originY: "bottom",
    overlayX: "end",
    overlayY: "bottom"
  }
};
var EXPANDED_DROPDOWN_POSITIONS = [POSITION_MAP.bottomLeft, POSITION_MAP.bottomRight, POSITION_MAP.topLeft, POSITION_MAP.topRight];
var connectionFallbackPositionsMap = {
  top: ["topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"],
  topLeft: ["top", "topRight", "bottomLeft", "bottom", "bottomRight"],
  topRight: ["top", "topLeft", "bottomRight", "bottom", "bottomLeft"],
  bottom: ["bottomLeft", "bottomRight", "top", "topLeft", "topRight"],
  bottomLeft: ["bottom", "bottomRight", "topLeft", "top", "topRight"],
  bottomRight: ["bottom", "bottomLeft", "topRight", "top", "topLeft"],
  left: ["leftTop", "leftBottom", "right", "rightTop", "rightBottom"],
  leftTop: ["left", "leftBottom", "rightTop", "right", "rightBottom"],
  leftBottom: ["left", "leftTop", "rightBottom", "right", "rightTop"],
  right: ["rightTop", "rightBottom", "left", "leftTop", "leftBottom"],
  rightTop: ["right", "rightBottom", "leftTop", "left", "leftBottom"],
  rightBottom: ["right", "rightTop", "leftBottom", "left", "leftTop"]
};
function buildConnectedPositionOffset(placement, offset) {
  const connectedPositionOffset = {};
  if (placement.startsWith("top")) {
    connectedPositionOffset.offsetY = -offset;
  } else if (placement.startsWith("bottom")) {
    connectedPositionOffset.offsetY = offset;
  } else if (placement.startsWith("left")) {
    connectedPositionOffset.offsetX = -offset;
  } else if (placement.startsWith("right")) {
    connectedPositionOffset.offsetX = offset;
  } else {
  }
  return connectedPositionOffset;
}
function buildConnectedPositionPair(placement, offset, panelClassPrefix) {
  const position = __spreadValues(__spreadValues({}, POSITION_MAP[placement]), offset ? buildConnectedPositionOffset(placement, offset) : null);
  if (panelClassPrefix) {
    position.panelClass = `${panelClassPrefix}-${placement}`;
  }
  return position;
}
function getFallbackPlacements(placement) {
  return connectionFallbackPositionsMap[placement] || [];
}
function getFlexiblePositions(placement, offset, panelClassPrefix) {
  const fallbackPlacements = getFallbackPlacements(placement);
  return [placement, ...fallbackPlacements].map((placementName) => {
    return buildConnectedPositionPair(placementName, offset, panelClassPrefix);
  });
}
var passiveEventListenerOptions2 = normalizePassiveListenerOptions({
  passive: true
});
var longPressTime = 500;
var ThyOverlayDirectiveBase = class {
  get trigger() {
    return this._trigger;
  }
  set trigger(value) {
    this._trigger = value;
    if (this.initialized) {
      this.clearEventListeners();
      this.initialize();
    }
  }
  clearEventListeners() {
    this.manualListeners.forEach((listener, event) => {
      this.elementRef.nativeElement.removeEventListener(event, listener);
    });
    this.manualListeners.clear();
    this.focusMonitor.stopMonitoring(this.elementRef);
  }
  clearTimer() {
    if (this.showTimeoutId) {
      clearTimeout(this.showTimeoutId);
    }
    if (this.hideTimeoutId) {
      clearTimeout(this.hideTimeoutId);
    }
    if (this.longPressTimeoutId) {
      clearTimeout(this.longPressTimeoutId);
    }
  }
  constructor(elementRef, platform, focusMonitor, ngZone, overlayPin, changeDetectorRef) {
    this.initialized = false;
    this._trigger = "click";
    this.manualListeners = /* @__PURE__ */ new Map();
    this.ngUnsubscribe$ = new Subject();
    this.showDelay = 100;
    this.hideDelay = 100;
    this.touchendHideDelay = 0;
    this.disabled = false;
    this.isAutoCloseOnMobileTouch = false;
    this.isTouchMoving = false;
    this.elementRef = elementRef;
    this.platform = platform;
    this.focusMonitor = focusMonitor;
    this.ngZone = ngZone;
    this.overlayPin = overlayPin;
    this.changeDetectorRef = changeDetectorRef;
  }
  initialize() {
    this.initialized = true;
    const element = this.elementRef.nativeElement;
    if (!this.platform.IOS && !this.platform.ANDROID) {
      if (this.trigger === "hover") {
        this.manualListeners.set("mouseenter", () => {
          this.show();
        }).set("mouseleave", (event) => {
          this.hide();
          const overlayElement = this.overlayRef && this.overlayRef.overlayElement;
          if (overlayElement && this.overlayPin) {
            fromEvent(overlayElement, "mouseenter").pipe(take(1)).subscribe(() => {
              this.clearTimer();
              fromEvent(overlayElement, "mouseleave").pipe(take(1)).subscribe(() => {
                this.hide();
              });
            });
          }
          if (!this.overlayRef) {
            this.clearTimer();
          }
        });
      } else if (this.trigger === "focus") {
        this.focusMonitor.monitor(this.elementRef).pipe(takeUntil(this.ngUnsubscribe$)).subscribe((origin) => {
          if (!origin) {
            this.ngZone.run(() => this.hide(0));
          } else {
            this.ngZone.run(() => this.show());
          }
        });
      } else if (this.trigger === "click") {
        this.manualListeners.set("click", () => {
          this.show();
        });
      } else if (typeof ngDevMode === "undefined" || ngDevMode) {
        throw new Error(`${this.trigger} is not supporteed, possible values are: hover | focus | click.`);
      }
    } else {
      const touchendListener = () => {
        const touchEndTime = Date.now();
        const touchDuration = touchEndTime - this.touchStartTime;
        if (touchDuration < longPressTime && !this.isTouchMoving) {
          this.handleTouch();
        }
        clearTimeout(this.longPressTimeoutId);
        this.isTouchMoving = false;
      };
      this.manualListeners.set("touchend", touchendListener).set("touchcancel", touchendListener).set("touchmove", () => {
        this.isTouchMoving = true;
        clearTimeout(this.longPressTimeoutId);
      }).set("touchstart", () => {
        this.touchStartTime = Date.now();
        this.isTouchMoving = false;
        this.longPressTimeoutId = setTimeout(() => {
          if (!this.isTouchMoving) {
            this.handleTouch();
          }
        }, longPressTime);
      });
    }
    this.manualListeners.forEach((listener, event) => (
      // Note: since Chrome 56 defaults document level `touchstart` listener to passive.
      // Element touch listeners are not passive by default.
      // We never call `preventDefault()` on events, so we're safe making them passive.
      element.addEventListener(event, listener, passiveEventListenerOptions2)
    ));
  }
  handleTouch() {
    this.show();
    if (this.isAutoCloseOnMobileTouch) {
      setTimeout(() => {
        this.hide(0);
      }, this.touchendHideDelay + (isNumber2(this.showDelay) ? this.showDelay : 0));
    }
  }
  /**
   * Marks that the overlay needs to be checked in the next change detection run.
   * Mainly used for rendering before positioning a overlay, which
   * can be problematic in components with OnPush change detection.
   */
  markForCheck() {
    this.changeDetectorRef?.markForCheck();
  }
  dispose() {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
    if (this.overlayRef) {
      this.overlayRef.dispose();
    }
    this.clearEventListeners();
    this.clearTimer();
  }
};
var ThyAbstractOverlayRef = class {
};
var uniqueIdMap = {};
function getUniqueId(name) {
  if (uniqueIdMap[name] !== void 0) {
    uniqueIdMap[name] = uniqueIdMap[name] + 1;
  } else {
    uniqueIdMap[name] = 0;
  }
  return uniqueIdMap[name];
}
var ThyAbstractInternalOverlayRef = class extends ThyAbstractOverlayRef {
  /** Fetches the position strategy object from the overlay ref. */
  getPositionStrategy() {
    return this.overlayRef.getConfig().positionStrategy;
  }
  constructor() {
    super();
    this._afterOpened = new Subject();
    this._afterClosed = new Subject();
    this._beforeClosed = new Subject();
  }
  initialize(overlayRef, containerInstance, config2, ...args) {
    this.overlayRef = overlayRef;
    this.containerInstance = containerInstance;
    this.config = config2;
    this.backdropClosable = config2.backdropClosable;
    this.disableClose = config2.disableClose;
    this.id = containerInstance.id = config2.id ? config2.id : `thy-${this.options.name}-${getUniqueId(this.options.name)}`;
    containerInstance.animationOpeningDone.pipe(take(1)).subscribe(() => {
      this._afterOpened.next();
      if (this.options.disposeWhenClose) {
        this._afterOpened.complete();
      }
    });
    containerInstance.animationClosingDone.pipe(take(1)).subscribe(() => {
      if (this.options.disposeWhenClose) {
        this.overlayRef.dispose();
      }
    });
    containerInstance.containerDestroy.pipe(take(1)).subscribe(() => {
      if (this.options.disposeWhenClose) {
        Promise.resolve().then(() => {
          this.overlayRef.dispose();
        });
      }
    });
    this.overlayRef.detachments().pipe(finalize(() => {
      this.overlayRef.dispose();
    })).subscribe(() => {
      this._beforeClosed.next(this._result);
      this._beforeClosed.complete();
      this._afterClosed.next(this._result);
      this._afterClosed.complete();
      this.componentInstance = null;
    });
    this.overlayRef.keydownEvents().pipe(filter((event) => event.keyCode === ESCAPE)).subscribe(() => {
      if (this.disableClose !== void 0 && !this.disableClose || this.backdropClosable) {
        this.close();
      }
    });
  }
  /**
   * Close the overlay.
   * @param overlayResult Optional result to return to the dialog opener.
   */
  close(overlayResult, force) {
    if (force || !this.config.canClose || !!this.config.canClose(overlayResult)) {
      this._result = overlayResult;
      this._beforeClosed.next(overlayResult);
      if (this.options.disposeWhenClose) {
        this._beforeClosed.complete();
      }
      this.overlayRef.detachBackdrop();
      this.containerInstance.startExitAnimation();
    }
  }
  /**
   * Gets an observable that is notified when the dialog is finished opening.
   */
  afterOpened() {
    return this._afterOpened.asObservable();
  }
  /**
   * Gets an observable that is notified when the dialog is finished closing.
   */
  afterClosed() {
    return this._afterClosed.asObservable();
  }
  /**
   * Gets an observable that is notified when the dialog has started closing.
   */
  beforeClosed() {
    return this._beforeClosed.asObservable();
  }
  /**
   * Gets an observable that emits when the overlay's backdrop has been clicked.
   */
  backdropClick() {
    return this.overlayRef.backdropClick();
  }
  /**
   * Gets an observable that emits when keydown events are targeted on the overlay.
   */
  keydownEvents() {
    return this.overlayRef.keydownEvents();
  }
  /** Get overlay ref */
  getOverlayRef() {
    return this.overlayRef;
  }
  /**
   * Updates the overlay's position when is GlobalPositionStrategy
   * @param position New overlay position.
   */
  updateGlobalPosition(position) {
    const strategy = this.getPositionStrategy();
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !(strategy instanceof GlobalPositionStrategy)) {
      throw new Error(`current strategy is not GlobalPositionStrategy`);
    }
    if (position && (position.left || position.right)) {
      position.left ? strategy.left(position.left) : strategy.right(position.right);
    } else {
      strategy.centerHorizontally();
    }
    if (position && (position.top || position.bottom)) {
      position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);
    } else {
      strategy.centerVertically();
    }
    this.overlayRef.updatePosition();
    return this;
  }
};
var ThyAbstractOverlayConfig = class {
  constructor() {
    this.panelClass = "";
    this.hasBackdrop = true;
    this.backdropClass = "";
    this.backdropClosable = true;
    this.disableClose = false;
    this.width = "";
    this.height = "";
    this.initialState = null;
    this.ariaDescribedBy = null;
    this.ariaLabel = null;
    this.autoFocus = true;
    this.restoreFocus = true;
    this.restoreFocusOptions = {
      preventScroll: true
    };
    this.closeOnNavigation = true;
    this.canPush = true;
  }
};
function throwPopoverContentAlreadyAttachedError(name) {
  throw Error(`Attempting to attach ${name} content after content is already attached`);
}
var ThyAbstractOverlayContainer = class {
  /** Before detach content*/
  beforeDetachPortal() {
  }
  constructor(options, changeDetectorRef) {
    this.options = options;
    this.changeDetectorRef = changeDetectorRef;
    this.animationStateChanged = new EventEmitter();
    this.containerDestroy = new Subject();
  }
  /**
   * Attach a TemplatePortal as content to this overlay container.
   * @param portal Portal to be attached as the overlay content.
   */
  attachTemplatePortal(portal) {
    if (this.portalOutlet.hasAttached()) {
      throwPopoverContentAlreadyAttachedError(this.options.name);
    }
    this.beforeAttachPortal();
    return this.portalOutlet.attachTemplatePortal(portal);
  }
  /**
   * Attach a ComponentPortal as content to this overlay container.
   * @param portal Portal to be attached as the overlay content.
   */
  attachComponentPortal(portal) {
    if (this.portalOutlet.hasAttached()) {
      throwPopoverContentAlreadyAttachedError(this.options.name);
    }
    this.beforeAttachPortal();
    return this.portalOutlet.attachComponentPortal(portal);
  }
  startExitAnimation() {
    if (this.options.animationEnabled) {
      this.animationState = "exit";
    } else {
    }
    this.beforeDetachPortal();
    this.changeDetectorRef.markForCheck();
  }
  destroy() {
    this.containerDestroy.next();
  }
};
var ThyAbstractOverlayService = class {
  constructor(options, overlay, injector, defaultConfig2, scrollStrategy) {
    this.options = options;
    this.overlay = overlay;
    this.injector = injector;
    this.defaultConfig = defaultConfig2;
    this.scrollStrategy = scrollStrategy;
    this.openedOverlays = [];
    this._afterAllClosed = new Subject();
    this._afterOpened = new Subject();
  }
  /** Attach component or template ref to overlay container */
  attachOverlayContent(componentOrTemplateRef, containerInstance, overlayRef, config2) {
    const abstractOverlayRef = this.createAbstractOverlayRef(overlayRef, containerInstance, config2);
    if (config2.hasBackdrop) {
      overlayRef.backdropClick().subscribe(() => {
        if (abstractOverlayRef.disableClose !== void 0 && !abstractOverlayRef.disableClose || abstractOverlayRef.backdropClosable) {
          this.close();
        }
      });
    }
    if (componentOrTemplateRef instanceof TemplateRef) {
      containerInstance.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, {
        $implicit: config2.initialState,
        [`${this.options.name}Ref`]: abstractOverlayRef
      }));
    } else {
      const injector = this.createInjector(config2, abstractOverlayRef, containerInstance);
      const contentRef = containerInstance.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config2.viewContainerRef, injector, config2.projectableNodes));
      if (config2.initialState) {
        const metadata = reflectComponentType(componentOrTemplateRef);
        const inputsByTemplateName = keyBy2(metadata?.inputs, "templateName");
        const inputsByPropName = keyBy2(metadata?.inputs, "propName");
        Object.keys(config2.initialState).forEach((key) => {
          const value = config2.initialState[key];
          const input2 = inputsByTemplateName[key] || inputsByPropName[key];
          if (input2) {
            contentRef.setInput(input2.templateName, value);
          } else {
            contentRef.instance[key] = value;
          }
        });
      }
      if (config2.hostClass) {
        const hostClass = coerceArray2(config2.hostClass);
        contentRef.location.nativeElement.classList.add(...hostClass);
      }
      abstractOverlayRef.componentInstance = contentRef.instance;
    }
    return abstractOverlayRef;
  }
  removeOpenedOverlay(overlayRef) {
    const index2 = this.openedOverlays.indexOf(overlayRef);
    if (index2 > -1) {
      this.openedOverlays.splice(index2, 1);
      if (!this.openedOverlays.length) {
        this._afterAllClosed.next();
      }
    }
  }
  getAbstractOverlayById(id) {
    return this.openedOverlays.find((overlay) => overlay.id === id);
  }
  getAbstractOverlays() {
    return this.openedOverlays;
  }
  buildBaseOverlayConfig(config2, defaultPanelClass) {
    const overlayConfig = new OverlayConfig({
      positionStrategy: this.overlay.position().global(),
      hasBackdrop: config2.hasBackdrop,
      direction: config2.direction,
      width: config2.width,
      height: config2.height,
      minWidth: config2.minWidth,
      minHeight: config2.minHeight,
      maxWidth: config2.maxWidth,
      maxHeight: config2.maxHeight,
      disposeOnNavigation: config2.closeOnNavigation
    });
    if (config2.backdropClass) {
      overlayConfig.backdropClass = config2.backdropClass;
    }
    overlayConfig.panelClass = concatArray(config2.panelClass, defaultPanelClass);
    return overlayConfig;
  }
  openOverlay(componentOrTemplateRef, config2) {
    config2 = __spreadValues(__spreadValues({}, this.defaultConfig), config2);
    if (config2.id && this.getAbstractOverlayById(config2.id)) {
      throw Error(`${this.options.name} with id ${config2.id} exists already. The ${this.options.name} id must be unique.`);
    }
    const overlayConfig = this.buildOverlayConfig(config2);
    const overlayRef = this.overlay.create(overlayConfig);
    const overlayContainer = this.attachOverlayContainer(overlayRef, config2);
    const abstractOverlayRef = this.attachOverlayContent(componentOrTemplateRef, overlayContainer, overlayRef, config2);
    this.openedOverlays.push(abstractOverlayRef);
    abstractOverlayRef.afterClosed().subscribe(() => {
      this.removeOpenedOverlay(abstractOverlayRef);
    });
    this._afterOpened.next(abstractOverlayRef);
    return abstractOverlayRef;
  }
  /**
   * 所有弹出框完全关闭后的回调
   * @returns
   */
  afterAllClosed() {
    return this._afterAllClosed;
  }
  /**
   * 打开弹出框之后的回调
   * @returns
   */
  afterOpened() {
    return this._afterOpened;
  }
  /**
   * 关闭弹出框，若force为true，则canClose无效，强制关闭
   * @param result
   * @param force
   */
  close(result, force) {
    if (this.openedOverlays.length > 0) {
      const lastOverlayRef = this.openedOverlays[this.openedOverlays.length - 1];
      if (lastOverlayRef) {
        lastOverlayRef.close(result, force);
      }
    }
  }
  /**
   * 关闭所有打开的弹出框
   */
  closeAll() {
    let i = this.openedOverlays.length;
    while (i--) {
      this.openedOverlays[i].close();
    }
  }
  dispose() {
    this.closeAll();
    this._afterAllClosed.complete();
    this._afterOpened.complete();
  }
};
var ThyPortalOutlet = class _ThyPortalOutlet extends CdkPortalOutlet {
  /**
   * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.
   *
   * @param portal Portal to be attached to the portal outlet.
   * @returns Reference to the created component.
   */
  attachComponentPortal(portal) {
    portal.setAttachedHost(this);
    const viewContainerRef = portal.viewContainerRef != null ? portal.viewContainerRef : this["_viewContainerRef"];
    const ref = viewContainerRef.createComponent(portal.component, {
      index: viewContainerRef.length,
      injector: portal.injector || viewContainerRef.injector,
      projectableNodes: portal.projectableNodes || void 0
    });
    if (viewContainerRef !== this["_viewContainerRef"]) {
      this["_getRootNode"]().appendChild(ref.hostView.rootNodes[0]);
    }
    super.setDisposeFn(() => ref.destroy());
    this._attachedPortal = portal;
    this["_attachedRef"] = ref;
    this.attached.emit(ref);
    return ref;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyPortalOutlet_BaseFactory;
      return function ThyPortalOutlet_Factory(__ngFactoryType__) {
        return (\u0275ThyPortalOutlet_BaseFactory || (\u0275ThyPortalOutlet_BaseFactory = \u0275\u0275getInheritedFactory(_ThyPortalOutlet)))(__ngFactoryType__ || _ThyPortalOutlet);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyPortalOutlet,
      selectors: [["", "thyPortalOutlet", ""]],
      inputs: {
        portal: [0, "thyPortalOutlet", "portal"]
      },
      exportAs: ["thyPortalOutlet"],
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPortalOutlet, [{
    type: Directive,
    args: [{
      selector: "[thyPortalOutlet]",
      exportAs: "thyPortalOutlet",
      inputs: ["portal: thyPortalOutlet"]
    }]
  }], null, null);
})();
var UpdateHostClassService = class _UpdateHostClassService {
  constructor() {
    this.renderer = inject(Renderer2);
    this._classNames = [];
  }
  initializeElement(element) {
    if (element instanceof ElementRef) {
      this._hostElement = element.nativeElement;
    } else {
      this._hostElement = element;
    }
    return this;
  }
  updateClass(classNames) {
    if (this._classNames) {
      this._classNames.forEach((className) => {
        if (classNames.indexOf(className) < 0) {
          this.removeClass(className);
        }
      });
    }
    const newClasses = [];
    classNames.forEach((className) => {
      if (className) {
        newClasses.push(className);
        if (this._classNames.indexOf(className) < 0) {
          this.addClass(className);
        }
      }
    });
    this._classNames = newClasses;
    return this;
  }
  updateClassByMap(classMap) {
    const newClasses = [];
    for (const key in classMap) {
      if (classMap.hasOwnProperty(key) && classMap[key]) {
        newClasses.push(key);
      }
    }
    this.updateClass(newClasses);
  }
  addClass(className) {
    this.renderer.addClass(this._hostElement, className);
    return this;
  }
  removeClass(className) {
    this.renderer.removeClass(this._hostElement, className);
    return this;
  }
  static {
    this.\u0275fac = function UpdateHostClassService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _UpdateHostClassService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _UpdateHostClassService,
      factory: _UpdateHostClassService.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UpdateHostClassService, [{
    type: Injectable
  }], null, null);
})();
var ThyTranslate = class _ThyTranslate {
  instant(key, interpolateParams2) {
    return key;
  }
  get(key, interpolateParams2) {
    return new Observable((observer) => {
      observer.next(key);
    });
  }
  static {
    this.\u0275fac = function ThyTranslate_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTranslate)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyTranslate,
      factory: _ThyTranslate.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTranslate, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var META_KEY = "__THY_META__";
var ROOT_STATE_TOKEN = new InjectionToken("ROOT_STATE_TOKEN");
var FEATURE_STATE_TOKEN = new InjectionToken("FEATURE_STATE_TOKEN");
function findAndCreateStoreMetadata(target) {
  if (!target.hasOwnProperty(META_KEY)) {
    const defaultMetadata = {
      actions: {},
      path: null,
      children: [],
      instance: null
    };
    target[META_KEY] = defaultMetadata;
  }
  return target[META_KEY];
}
var MiniActionState = class {
  static {
    this.actionName = "";
  }
  static changeAction(actionName) {
    this.actionName = actionName;
  }
  static getActionName() {
    return this.actionName;
  }
};
function MiniAction() {
  return function(target, name, descriptor) {
    const meta = findAndCreateStoreMetadata(target);
    let action;
    if (!action) {
      action = {
        type: name
      };
    }
    const type = action.type;
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !action.type) {
      throw new Error(`Action ${action.type} is missing a static "type" property`);
    }
    const originalFn = descriptor.value;
    meta.actions[type] = {
      fn: name,
      originalFn,
      type
    };
    descriptor.value = function(...args) {
      MiniActionState.changeAction(`${target.constructor.name}-${name}`);
      let result = originalFn.call(this, ...args);
      if (result instanceof Observable) {
        result = result.pipe(catchError((error) => {
          return of({
            status: "ERRORED",
            action,
            error
          });
        }), shareReplay(), exhaustMap((result2) => {
          if (result2 && result2.status === "ERRORED") {
            return throwError(result2.error);
          } else {
            return of(result2);
          }
        }));
        result.subscribe();
      }
      return result;
    };
  };
}
var MiniStore = class _MiniStore {
  constructor() {
    this.reduxToolEnabled = isDevMode();
    this._defaultStoreInstanceId = null;
  }
  initialize(initialState2) {
    this._defaultStoreInstanceId = this._getClassName();
    this.state$ = new BehaviorSubject(initialState2);
    this.initialStateCache = __spreadValues({}, initialState2);
  }
  get snapshot() {
    return this.state$.getValue();
  }
  dispatch(type, payload) {
    MiniActionState.changeAction(`${this._defaultStoreInstanceId}-${type}`);
    const result = this._dispatch({
      type,
      payload
    });
    result.subscribe();
    return result;
  }
  _dispatch(action) {
    const meta = this[META_KEY];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !meta) {
      throw new Error(`${META_KEY} is not found, current store has not action`);
    }
    const actionMeta = meta.actions[action.type];
    if ((typeof ngDevMode === "undefined" || ngDevMode) && !actionMeta) {
      throw new Error(`${action.type} is not found`);
    }
    let result = actionMeta.originalFn.call(this, this.snapshot, action.payload);
    if (result instanceof Promise) {
      result = from(result);
    }
    if (result instanceof Observable) {
      result = result.pipe(map((r) => r));
    } else {
      result = new Observable((observer) => {
        observer.next({});
      });
    }
    return result.pipe(shareReplay());
  }
  select(selector) {
    return this.state$.pipe(map(selector), distinctUntilChanged());
  }
  next(state2) {
    this.state$.next(state2);
  }
  error(error) {
    this.state$.error(error);
  }
  complete() {
    this.state$.complete();
  }
  subscribe(next, error, complete) {
    return this.state$.subscribe(next, error, complete);
  }
  /**
   * set store new state
   *
   * @example
   * this.setState(newState);
   * this.setState({ users: produce(this.snapshot.users).add(user) });
   * this.setState((state) => {
   *    return {
   *        users: produce(state.users).add(user)
   *    }
   * });
   * @param fn
   */
  setState(fn) {
    if (index.isFunction(fn)) {
      this.next(__spreadValues(__spreadValues({}, this.snapshot), fn(this.snapshot)));
    } else {
      this.next(__spreadValues(__spreadValues({}, this.snapshot), fn));
    }
  }
  getState() {
    return this.snapshot;
  }
  clearState() {
    this.setState(this.initialStateCache);
  }
  ngOnDestroy() {
  }
  /**
   * You can override this method if you want to give your container instance a custom id.
   * The returned id must be unique in the application.
   */
  getStoreInstanceId() {
    return this._defaultStoreInstanceId;
  }
  _getClassName() {
    const name = this.constructor.name || /function (.+)\(/.exec(`${this.constructor}`)[1];
    return name;
  }
  static {
    this.\u0275fac = function MiniStore_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MiniStore)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _MiniStore
    });
  }
};
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", []), __metadata("design:returntype", void 0)], MiniStore.prototype, "clearState", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MiniStore, [{
    type: Directive
  }], null, {
    clearState: []
  });
})();
var presetThemeColors = ["primary", "success", "info", "warning", "danger", "default", "light"];
function isThemeColor(color) {
  return presetThemeColors.includes(color);
}
var presetTextColors = [...presetThemeColors, "secondary", "muted", "desc", "placeholder", "white", "body"];
var presetBgColors = [...presetThemeColors, "secondary", "dark", "lighter", "bright", "content", "white", "transparent"];

// node_modules/ngx-tethys/fesm2022/ngx-tethys-tooltip.mjs
var _c03 = (a0) => ({
  $implicit: a0
});
function ThyTooltip_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyTooltip_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyTooltip_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.content)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c03, ctx_r0.data));
  }
}
function ThyTooltip_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275textInterpolate1(" ", ctx_r0.content, " ");
  }
}
var thyTooltipAnimations = {
  tooltipState: trigger("state", [state("initial, void, hidden", style({
    opacity: 0,
    transform: "scale(0)"
  })), state("visible", style({
    transform: "scale(1)"
  })), transition("* => visible", [style({
    opacity: 0,
    transform: "scale(0.9, 0.9)"
  }), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
    opacity: 1,
    transform: "scale(1, 1)"
  }))]), transition("visible => *", [style({
    opacity: 1,
    transform: "scale(1, 1)"
  }), animate(`${AnimationDuration.BASE} ${AnimationCurves.EASE_IN_OUT_STANDARD}`, style({
    opacity: 0,
    transform: "scale(0.9, 0.9)"
  }))])])
};
var ThyTooltip = class _ThyTooltip {
  constructor() {
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this.addTooltipContainerClass = true;
    this.onHide = new Subject();
    this.closeOnInteraction = false;
    this.hostRenderer = useHostRenderer();
    this.visibility = "initial";
    this.tooltipClasses = [];
    this.isTemplateRef = false;
  }
  get content() {
    return this._content;
  }
  set content(value) {
    this._content = value;
    this.isTemplateRef = value instanceof TemplateRef;
  }
  updateClasses() {
    let classes = [];
    if (this.tooltipClasses) {
      classes = classes.concat(this.tooltipClasses);
    }
    this.hostRenderer.updateClass(classes);
  }
  ngOnInit() {
  }
  markForCheck() {
    this.changeDetectorRef.markForCheck();
  }
  isVisible() {
    return this.visibility === "visible";
  }
  show(delay2) {
    if (this.hideTimeoutId) {
      clearTimeout(this.hideTimeoutId);
      this.hideTimeoutId = null;
    }
    this.closeOnInteraction = true;
    this.showTimeoutId = setTimeout(() => {
      this.visibility = "visible";
      this.showTimeoutId = null;
      this.markForCheck();
    }, delay2);
  }
  hide(delay2) {
    if (this.showTimeoutId) {
      clearTimeout(this.showTimeoutId);
      this.showTimeoutId = null;
    }
    this.hideTimeoutId = setTimeout(() => {
      this.visibility = "hidden";
      this.hideTimeoutId = null;
      this.markForCheck();
    }, delay2);
  }
  animationStart() {
    this.closeOnInteraction = false;
  }
  animationDone(event) {
    const toState = event.toState;
    if (toState === "hidden" && !this.isVisible()) {
      this.onHide.next();
    }
    if (toState === "visible" || toState === "hidden") {
      this.closeOnInteraction = true;
    }
  }
  afterHidden() {
    return this.onHide.asObservable();
  }
  setTooltipClass(classes) {
    this.tooltipClasses = coerceArray2(classes);
    this.updateClasses();
  }
  static {
    this.\u0275fac = function ThyTooltip_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTooltip)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyTooltip,
      selectors: [["thy-tooltip"]],
      hostVars: 3,
      hostBindings: function ThyTooltip_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275syntheticHostListener("@state.start", function ThyTooltip_animation_state_start_HostBindingHandler() {
            return ctx.animationStart();
          })("@state.done", function ThyTooltip_animation_state_done_HostBindingHandler($event) {
            return ctx.animationDone($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275syntheticHostProperty("@state", ctx.visibility);
          \u0275\u0275classProp("thy-tooltip", ctx.addTooltipContainerClass);
        }
      },
      decls: 4,
      vars: 1,
      consts: [[1, "thy-tooltip-arrow"], [1, "thy-tooltip-content"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
      template: function ThyTooltip_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "div", 0);
          \u0275\u0275elementStart(1, "div", 1);
          \u0275\u0275conditionalCreate(2, ThyTooltip_Conditional_2_Template, 1, 4, "ng-container")(3, ThyTooltip_Conditional_3_Template, 1, 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isTemplateRef ? 2 : 3);
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2,
      data: {
        animation: [thyTooltipAnimations.tooltipState]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTooltip, [{
    type: Component,
    args: [{
      selector: "thy-tooltip",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      animations: [thyTooltipAnimations.tooltipState],
      host: {
        "[@state]": "visibility",
        "(@state.start)": "animationStart()",
        "(@state.done)": "animationDone($event)"
      },
      imports: [NgTemplateOutlet],
      template: '<div class="thy-tooltip-arrow"></div>\n<div class="thy-tooltip-content">\n  @if (isTemplateRef) {\n    <ng-container *ngTemplateOutlet="content; context: { $implicit: data }"></ng-container>\n  } @else {\n    {{ content }}\n  }\n</div>\n'
    }]
  }], null, {
    addTooltipContainerClass: [{
      type: HostBinding,
      args: [`class.thy-tooltip`]
    }]
  });
})();
var ThyTooltipRef = class {
  constructor(host, config2, overlay, scrollDispatcher, ngZone) {
    this.host = host;
    this.config = config2;
    this.overlay = overlay;
    this.scrollDispatcher = scrollDispatcher;
    this.ngZone = ngZone;
    this.tooltipInstance = null;
    this.dispose$ = new Subject();
    this.scrollStrategy = overlay.scrollStrategies.reposition({
      scrollThrottle: this.config.scrollThrottleSeconds
    });
  }
  /** Create the overlay config and position strategy */
  createOverlay() {
    if (this.overlayRef) {
      return this.overlayRef;
    }
    const scrollableAncestors = this.scrollDispatcher.getAncestorScrollContainers(this.host);
    const strategy = this.overlay.position().flexibleConnectedTo(this.host).withTransformOriginOn(".thy-tooltip-content").withFlexibleDimensions(false).withViewportMargin(8);
    strategy.withScrollableContainers(scrollableAncestors);
    strategy.positionChanges.pipe(takeUntil(this.dispose$)).subscribe((change) => {
      if (this.tooltipInstance) {
        if (change.scrollableViewProperties.isOverlayClipped && this.tooltipInstance.isVisible()) {
          this.ngZone.run(() => this.hide(0));
        }
      }
    });
    this.overlayRef = this.overlay.create({
      positionStrategy: strategy,
      panelClass: this.config.panelClass,
      scrollStrategy: this.scrollStrategy,
      hasBackdrop: this.config.hasBackdrop,
      backdropClass: "thy-tooltip-backdrop"
    });
    this.updatePosition();
    this.overlayRef.detachments().pipe(takeUntil(this.dispose$)).subscribe(() => this.detach());
    this.overlayRef.backdropClick().pipe(takeUntil(this.dispose$)).subscribe(() => {
      this.overlayRef.detachBackdrop();
      this.hide(0);
    });
    return this.overlayRef;
  }
  /** Updates the position of the current tooltip. */
  updatePosition() {
    const position = this.overlayRef.getConfig().positionStrategy;
    const connectionPositions = getFlexiblePositions(this.config.placement, this.config.offset, "thy-tooltip");
    position.withPositions(connectionPositions);
  }
  detach() {
    if (this.overlayRef && this.overlayRef.hasAttached()) {
      this.overlayRef.detach();
    }
    this.tooltipInstance = null;
  }
  show(content, dataOrDelay, delay2) {
    if (!content || this.isTooltipVisible() && !this.tooltipInstance?.showTimeoutId && !this.tooltipInstance?.hideTimeoutId) {
      return;
    }
    let showDelay = null;
    let initialState2 = null;
    if (isNumber2(dataOrDelay)) {
      showDelay = dataOrDelay;
    } else {
      initialState2 = dataOrDelay;
      showDelay = delay2;
    }
    const overlayRef = this.createOverlay();
    this.detach();
    this.portal = this.portal || new ComponentPortal(ThyTooltip, this.config.viewContainerRef);
    this.tooltipInstance = overlayRef.attach(this.portal).instance;
    this.tooltipInstance.afterHidden().pipe(takeUntil(this.dispose$)).subscribe(() => this.detach());
    this.updateTooltipContent(content, initialState2);
    this.setTooltipClass(this.config.contentClass);
    this.tooltipInstance.show(!isUndefinedOrNull2(showDelay) ? showDelay : this.config.showDelay);
  }
  hide(delay2 = 0) {
    if (this.overlayRef && this.overlayRef["_scrollStrategy"]) {
      this.overlayRef["_scrollStrategy"].disable();
    }
    if (this.tooltipInstance) {
      this.tooltipInstance.hide(!isUndefinedOrNull2(delay2) ? delay2 : this.config.hideDelay);
    }
  }
  getOverlayRef() {
    return this.overlayRef;
  }
  setTooltipClass(tooltipClass) {
    if (this.tooltipInstance) {
      this.tooltipInstance.setTooltipClass(tooltipClass);
    }
  }
  updateTooltipContent(content, data) {
    if (this.tooltipInstance) {
      this.tooltipInstance.content = content;
      this.tooltipInstance.data = data;
      this.tooltipInstance.markForCheck();
      this.ngZone.onMicrotaskEmpty.asObservable().pipe(take(1), takeUntil(this.dispose$)).subscribe(() => {
        if (this.tooltipInstance) {
          this.overlayRef.updatePosition();
        }
      });
    }
  }
  isTooltipVisible() {
    return !!this.tooltipInstance && this.tooltipInstance.isVisible();
  }
  dispose() {
    this.dispose$.next();
    this.dispose$.complete();
    this.hide(0);
    if (this.overlayRef) {
      this.overlayRef.dispose();
      this.tooltipInstance = null;
    }
  }
};
var THY_TOOLTIP_DEFAULT_CONFIG_TOKEN = new InjectionToken("thy-tooltip-default-config");
var thyTooltipDefaultConfig = {
  placement: "top",
  showDelay: 200,
  hideDelay: 100,
  touchendHideDelay: 1500,
  offset: 4,
  panelClass: "thy-tooltip-panel",
  tooltipPin: false,
  scrollThrottleSeconds: 20
};
var THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER = {
  provide: THY_TOOLTIP_DEFAULT_CONFIG_TOKEN,
  useValue: thyTooltipDefaultConfig
};
var ThyTooltipService = class _ThyTooltipService {
  constructor() {
    this.overlay = inject(Overlay);
    this.scrollDispatcher = inject(ScrollDispatcher);
    this.ngZone = inject(NgZone);
    this.defaultTooltipConfig = inject(THY_TOOLTIP_DEFAULT_CONFIG_TOKEN);
  }
  /**
   * 创建一个 Tooltip
   */
  create(host, config2 = {}) {
    config2 = Object.assign({}, this.defaultTooltipConfig, config2);
    const tooltipRef = new ThyTooltipRef(host, config2, this.overlay, this.scrollDispatcher, this.ngZone);
    return tooltipRef;
  }
  static {
    this.\u0275fac = function ThyTooltipService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTooltipService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyTooltipService,
      factory: _ThyTooltipService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTooltipService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var ThyTooltipDirective = class _ThyTooltipDirective extends ThyOverlayDirectiveBase {
  getValidContent(value) {
    const validValue = value && isString(value) ? `${value}`.trim() : value;
    return validValue;
  }
  setDisabled(disabled) {
    this.toolTipDisabled.set(disabled);
  }
  setContent(content) {
    const validValue = this.getValidContent(content);
    this.content.set(validValue);
  }
  setOffset(offset) {
    this.tooltipOffset.set(offset);
  }
  setPlacement(placement) {
    this.placement.set(placement);
  }
  constructor() {
    const elementRef = inject(ElementRef);
    const ngZone = inject(NgZone);
    const platform = inject(Platform);
    const focusMonitor = inject(FocusMonitor);
    super(elementRef, platform, focusMonitor, ngZone);
    this.viewContainerRef = inject(ViewContainerRef);
    this.thyTooltipService = inject(ThyTooltipService);
    this.touchendHideDelay = 1500;
    this.isAutoCloseOnMobileTouch = true;
    this.thyTooltipContent = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipContent",
      alias: "thyTooltip"
    }] : [{
      alias: "thyTooltip"
    }]);
    this.content = linkedSignal(() => {
      const value = this.thyTooltipContent();
      return this.getValidContent(value);
    }, ...ngDevMode ? [{
      debugName: "content"
    }] : []);
    this.thyPlacement = input("top", ...ngDevMode ? [{
      debugName: "thyPlacement",
      alias: "thyTooltipPlacement"
    }] : [{
      alias: "thyTooltipPlacement"
    }]);
    this.placement = linkedSignal(() => {
      return this.thyPlacement();
    }, ...ngDevMode ? [{
      debugName: "placement"
    }] : []);
    this.thyTooltipClass = input(...ngDevMode ? [void 0, {
      debugName: "thyTooltipClass"
    }] : []);
    this.thyTooltipShowDelay = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipShowDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyTooltipHideDelay = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipHideDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyTooltipTrigger = input("hover", ...ngDevMode ? [{
      debugName: "thyTooltipTrigger"
    }] : []);
    this.thyTooltipDisabled = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.toolTipDisabled = linkedSignal(() => {
      return this.thyTooltipDisabled();
    }, ...ngDevMode ? [{
      debugName: "toolTipDisabled"
    }] : []);
    this.data = input(void 0, ...ngDevMode ? [{
      debugName: "data",
      alias: "thyTooltipTemplateContext"
    }] : [{
      alias: "thyTooltipTemplateContext"
    }]);
    this.thyTooltipOffset = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipOffset",
      alias: "thyTooltipOffset",
      transform: numberAttribute
    }] : [{
      alias: "thyTooltipOffset",
      transform: numberAttribute
    }]);
    this.tooltipOffset = linkedSignal(() => {
      return this.thyTooltipOffset();
    }, ...ngDevMode ? [{
      debugName: "tooltipOffset"
    }] : []);
    this.tooltipPin = input(void 0, ...ngDevMode ? [{
      debugName: "tooltipPin",
      alias: "thyTooltipPin",
      transform: coerceBooleanProperty2
    }] : [{
      alias: "thyTooltipPin",
      transform: coerceBooleanProperty2
    }]);
    effect(() => {
      const value = this.content();
      const data = this.data();
      const isTooltipVisible = this.tooltipRef?.isTooltipVisible();
      if (!value && isTooltipVisible) {
        this.tooltipRef.hide(0);
      } else if (value && isTooltipVisible) {
        this.tooltipRef?.updateTooltipContent(value, data);
      }
    });
    effect(() => {
      const trigger2 = this.thyTooltipTrigger();
      this.trigger = trigger2;
    });
    effect(() => {
      const overlayPin = this.tooltipPin();
      this.overlayPin = overlayPin;
    });
    effect(() => {
      const disabled = this.toolTipDisabled();
      this.disabled = !!disabled;
      if (disabled && this.tooltipRef?.isTooltipVisible()) {
        this.hide(0);
      }
    });
    effect(() => {
      const tooltipClass = this.thyTooltipClass();
      if (this.tooltipRef && tooltipClass) {
        this.tooltipRef.setTooltipClass(tooltipClass);
      }
    });
    afterNextRender(() => {
      this.initialize();
    });
  }
  ngOnInit() {
  }
  /** Shows the tooltip after the delay in ms, defaults to tooltip-delay-show 200ms */
  show(delay2 = this.thyTooltipShowDelay()) {
    if (this.disabled) {
      return;
    }
    if (!this.tooltipRef) {
      this.tooltipRef = this.thyTooltipService.create(this.elementRef, {
        viewContainerRef: this.viewContainerRef,
        placement: this.placement(),
        contentClass: this.thyTooltipClass(),
        offset: this.tooltipOffset(),
        tooltipPin: this.tooltipPin(),
        hasBackdrop: this.trigger === "click"
      });
    }
    this.tooltipRef.show(this.content(), this.data(), delay2);
  }
  /** Hides the tooltip after the delay in ms, defaults to tooltip-delay-hide 100ms */
  hide(delay2 = this.thyTooltipHideDelay()) {
    this.tooltipRef?.hide(delay2);
  }
  ngOnDestroy() {
    this.tooltipRef?.dispose();
    this.dispose?.();
  }
  static {
    this.\u0275fac = function ThyTooltipDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTooltipDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyTooltipDirective,
      selectors: [["", "thyTooltip", ""], ["", "thy-tooltip", ""]],
      inputs: {
        thyTooltipContent: [1, "thyTooltip", "thyTooltipContent"],
        thyPlacement: [1, "thyTooltipPlacement", "thyPlacement"],
        thyTooltipClass: [1, "thyTooltipClass"],
        thyTooltipShowDelay: [1, "thyTooltipShowDelay"],
        thyTooltipHideDelay: [1, "thyTooltipHideDelay"],
        thyTooltipTrigger: [1, "thyTooltipTrigger"],
        thyTooltipDisabled: [1, "thyTooltipDisabled"],
        data: [1, "thyTooltipTemplateContext", "data"],
        thyTooltipOffset: [1, "thyTooltipOffset"],
        tooltipPin: [1, "thyTooltipPin", "tooltipPin"]
      },
      exportAs: ["thyTooltip"],
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTooltipDirective, [{
    type: Directive,
    args: [{
      selector: "[thyTooltip],[thy-tooltip]",
      exportAs: "thyTooltip"
    }]
  }], () => [], {
    thyTooltipContent: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltip",
        required: false
      }]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipPlacement",
        required: false
      }]
    }],
    thyTooltipClass: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipClass",
        required: false
      }]
    }],
    thyTooltipShowDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipShowDelay",
        required: false
      }]
    }],
    thyTooltipHideDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipHideDelay",
        required: false
      }]
    }],
    thyTooltipTrigger: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipTrigger",
        required: false
      }]
    }],
    thyTooltipDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipDisabled",
        required: false
      }]
    }],
    data: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipTemplateContext",
        required: false
      }]
    }],
    thyTooltipOffset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipOffset",
        required: false
      }]
    }],
    tooltipPin: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipPin",
        required: false
      }]
    }]
  });
})();
var ThyTooltipModule = class _ThyTooltipModule {
  static {
    this.\u0275fac = function ThyTooltipModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTooltipModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyTooltipModule,
      imports: [A11yModule, CommonModule, OverlayModule, ThyTooltipDirective, ThyTooltip],
      exports: [ThyTooltipDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER],
      imports: [A11yModule, CommonModule, OverlayModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTooltipModule, [{
    type: NgModule,
    args: [{
      imports: [A11yModule, CommonModule, OverlayModule, ThyTooltipDirective, ThyTooltip],
      exports: [ThyTooltipDirective],
      providers: [THY_TOOLTIP_DEFAULT_CONFIG_PROVIDER]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-layout.mjs
var _c04 = ["*"];
var _c1 = ["headerTitle"];
var _c2 = ["headerContent"];
var _c3 = ["headerOperation"];
function ThyHeader_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function ThyHeader_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyHeader_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.titleTemplateRef());
  }
}
function ThyHeader_Conditional_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 4);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("thyIconName", ctx_r0.svgIconName());
  }
}
function ThyHeader_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngClass", ctx_r0.iconClass());
  }
}
function ThyHeader_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyHeader_Conditional_2_Conditional_1_Conditional_0_Template, 1, 1, "i", 6);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275conditional(ctx_r0.iconClass() ? 0 : -1);
  }
}
function ThyHeader_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyHeader_Conditional_2_Conditional_0_Template, 1, 1, "thy-icon", 4)(1, ThyHeader_Conditional_2_Conditional_1_Template, 1, 1);
    \u0275\u0275elementStart(2, "span", 5);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r0.svgIconName() ? 0 : 1);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r0.thyTitle());
  }
}
function ThyHeader_ng_template_4_Template(rf, ctx) {
}
function ThyHeader_ng_template_6_Template(rf, ctx) {
}
var _c4 = (a0, a1) => ({
  "collapse-visible": a0,
  "collapse-hidden": a1
});
function ThySidebar_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-resize-handle", 4);
    \u0275\u0275listener("mouseenter", function ThySidebar_Conditional_1_Conditional_1_Template_thy_resize_handle_mouseenter_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleResizable($event, "enter"));
    })("mouseleave", function ThySidebar_Conditional_1_Conditional_1_Template_thy_resize_handle_mouseleave_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleResizable($event, "leave"));
    })("dblclick", function ThySidebar_Conditional_1_Conditional_1_Template_thy_resize_handle_dblclick_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.restoreToDefaultWidth());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("thyDirection", ctx_r1.sidebarDirective.thyDirection() === "right" ? "left" : "right");
  }
}
function ThySidebar_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275listener("thyResize", function ThySidebar_Conditional_1_Template_div_thyResize_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.resizeHandler($event));
    })("thyResizeStart", function ThySidebar_Conditional_1_Template_div_thyResizeStart_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.resizeStart());
    })("thyResizeEnd", function ThySidebar_Conditional_1_Template_div_thyResizeEnd_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.resizeEnd());
    });
    \u0275\u0275conditionalCreate(1, ThySidebar_Conditional_1_Conditional_1_Template, 1, 1, "thy-resize-handle", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("display", !ctx_r1.isResizable() ? "contents" : null);
    \u0275\u0275property("thyMaxWidth", ctx_r1.thyDragMaxWidth())("thyMinWidth", ctx_r1.dragMinWidth());
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.collapsed() ? 1 : -1);
  }
}
function ThySidebar_Conditional_2_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function ThySidebar_Conditional_2_Conditional_1_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("thyIconName", ctx_r1.collapsed() ? "indent" : "outdent");
  }
}
function ThySidebar_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275listener("click", function ThySidebar_Conditional_2_Conditional_1_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.toggleCollapse($event));
    });
    \u0275\u0275template(1, ThySidebar_Conditional_2_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 8)(2, ThySidebar_Conditional_2_Conditional_1_ng_template_2_Template, 1, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const defaultTrigger_r5 = \u0275\u0275reference(3);
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(3, _c4, ctx_r1.collapseVisible(), ctx_r1.collapseHidden()))("thyTooltip", !ctx_r1.thyTrigger() && ctx_r1.collapseTip());
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.thyTrigger() || defaultTrigger_r5);
  }
}
function ThySidebar_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 5);
    \u0275\u0275conditionalCreate(1, ThySidebar_Conditional_2_Conditional_1_Template, 4, 6, "div", 6);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.thyTrigger() !== null ? 1 : -1);
  }
}
function ThySidebarHeader_Conditional_0_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function ThySidebarHeader_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThySidebarHeader_Conditional_0_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.titleTemplateRef());
  }
}
function ThySidebarHeader_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r0.thyTitle(), " ");
  }
}
function ThySidebarHeader_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275conditionalCreate(1, ThySidebarHeader_Conditional_0_Conditional_1_Template, 1, 1, null, 2)(2, ThySidebarHeader_Conditional_0_Conditional_2_Template, 1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.titleTemplateRef() ? 1 : 2);
  }
}
function ThySidebarHeader_ng_template_3_Template(rf, ctx) {
}
var ThyLayoutDirective = class _ThyLayoutDirective {
  constructor() {
    this.sidebarDirection = signal(null, ...ngDevMode ? [{
      debugName: "sidebarDirection"
    }] : []);
    this.isSidebarRight = computed(() => {
      return this.sidebarDirection() === "right";
    }, ...ngDevMode ? [{
      debugName: "isSidebarRight"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyLayoutDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyLayoutDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyLayoutDirective,
      selectors: [["", "thyLayout", "", 3, "thyForm", "", 5, "thy-form", 5, "thy-radio-group", 5, "thy-properties", 5, "thy-selection-list", 5, "thy-vote", 3, "thyVote", ""]],
      hostAttrs: [1, "thy-layout"],
      hostVars: 4,
      hostBindings: function ThyLayoutDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-layout--has-sidebar", ctx.sidebarDirection())("thy-layout--is-sidebar-right", ctx.isSidebarRight());
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyLayoutDirective, [{
    type: Directive,
    args: [{
      selector: "[thyLayout]:not([thyForm]):not(thy-form):not(thy-radio-group):not(thy-properties):not(thy-selection-list):not(thy-vote):not([thyVote])",
      host: {
        class: "thy-layout",
        "[class.thy-layout--has-sidebar]": "sidebarDirection()",
        "[class.thy-layout--is-sidebar-right]": "isSidebarRight()"
      }
    }]
  }], null, null);
})();
var ThyLayout = class _ThyLayout {
  static {
    this.\u0275fac = function ThyLayout_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyLayout)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyLayout,
      selectors: [["thy-layout"]],
      features: [\u0275\u0275HostDirectivesFeature([ThyLayoutDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThyLayout_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyLayout, [{
    type: Component,
    args: [{
      selector: "thy-layout",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThyLayoutDirective]
    }]
  }], null, null);
})();
var ThyHeaderDirective = class _ThyHeaderDirective {
  constructor() {
    this.thySize = input("md", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.thyShadow = input(false, ...ngDevMode ? [{
      debugName: "thyShadow",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDivided = input(false, ...ngDevMode ? [{
      debugName: "thyDivided",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyHasBorder = input(false, ...ngDevMode ? [{
      debugName: "thyHasBorder",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.divided = computed(() => {
      const value = this.thyDivided();
      if (value !== void 0) {
        return value;
      }
      return this.thyHasBorder();
    }, ...ngDevMode ? [{
      debugName: "divided"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyHeaderDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyHeaderDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyHeaderDirective,
      selectors: [["", "thyHeader", ""]],
      hostAttrs: [1, "thy-layout-header"],
      hostVars: 10,
      hostBindings: function ThyHeaderDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-layout-header-sm", ctx.thySize() === "sm")("thy-layout-header-lg", ctx.thySize() === "lg")("thy-layout-header-xlg", ctx.thySize() === "xlg")("thy-layout-header-shadow", ctx.thyShadow())("thy-layout-header-divided", ctx.divided());
        }
      },
      inputs: {
        thySize: [1, "thySize"],
        thyShadow: [1, "thyShadow"],
        thyDivided: [1, "thyDivided"],
        thyHasBorder: [1, "thyHasBorder"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyHeaderDirective, [{
    type: Directive,
    args: [{
      selector: "[thyHeader]",
      host: {
        class: `thy-layout-header`,
        "[class.thy-layout-header-sm]": `thySize() === 'sm'`,
        "[class.thy-layout-header-lg]": `thySize() === 'lg'`,
        "[class.thy-layout-header-xlg]": `thySize() === 'xlg'`,
        "[class.thy-layout-header-shadow]": `thyShadow()`,
        "[class.thy-layout-header-divided]": `divided()`
      }
    }]
  }], null, {
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyShadow: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShadow",
        required: false
      }]
    }],
    thyDivided: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDivided",
        required: false
      }]
    }],
    thyHasBorder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHasBorder",
        required: false
      }]
    }]
  });
})();
var ThyHeader = class _ThyHeader {
  constructor() {
    this.thyTitle = input(...ngDevMode ? [void 0, {
      debugName: "thyTitle"
    }] : []);
    this.thyIconPrefix = input("wtf", ...ngDevMode ? [{
      debugName: "thyIconPrefix"
    }] : []);
    this.thyIcon = input(...ngDevMode ? [void 0, {
      debugName: "thyIcon"
    }] : []);
    this.svgIconName = computed(() => {
      const icon = this.thyIcon();
      if (icon && !icon.includes("wtf")) {
        return icon;
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "svgIconName"
    }] : []);
    this.iconClass = computed(() => {
      const icon = this.svgIconName();
      if (icon) {
        return null;
      } else {
        const icon2 = this.thyIcon();
        if (icon2 && icon2.includes("wtf")) {
          return `${this.thyIconPrefix()} ${icon2}`;
        }
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "iconClass"
    }] : []);
    this.titleTemplateRef = contentChild("headerTitle", ...ngDevMode ? [{
      debugName: "titleTemplateRef"
    }] : []);
    this.contentTemplateRef = contentChild("headerContent", ...ngDevMode ? [{
      debugName: "contentTemplateRef"
    }] : []);
    this.operationTemplateRef = contentChild("headerOperation", ...ngDevMode ? [{
      debugName: "operationTemplateRef"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyHeader_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyHeader)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyHeader,
      selectors: [["thy-header"]],
      contentQueries: function ThyHeader_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.titleTemplateRef, _c1, 5)(dirIndex, ctx.contentTemplateRef, _c2, 5)(dirIndex, ctx.operationTemplateRef, _c3, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(3);
        }
      },
      inputs: {
        thyTitle: [1, "thyTitle"],
        thyIconPrefix: [1, "thyIconPrefix"],
        thyIcon: [1, "thyIcon"]
      },
      features: [\u0275\u0275HostDirectivesFeature([{
        directive: ThyHeaderDirective,
        inputs: ["thySize", "thySize", "thyShadow", "thyShadow", "thyHasBorder", "thyHasBorder", "thyDivided", "thyDivided"]
      }])],
      decls: 7,
      vars: 3,
      consts: [[1, "layout-header-title"], [3, "ngTemplateOutlet"], [1, "layout-header-content"], [1, "layout-header-operation"], [1, "prefix-icon", 3, "thyIconName"], [1, "title-name"], [1, "prefix-icon", 3, "ngClass"]],
      template: function ThyHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275conditionalCreate(1, ThyHeader_Conditional_1_Template, 1, 1, null, 1)(2, ThyHeader_Conditional_2_Template, 4, 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(3, "div", 2);
          \u0275\u0275template(4, ThyHeader_ng_template_4_Template, 0, 0, "ng-template", 1);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(5, "div", 3);
          \u0275\u0275template(6, ThyHeader_ng_template_6_Template, 0, 0, "ng-template", 1);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.titleTemplateRef() ? 1 : 2);
          \u0275\u0275advance(3);
          \u0275\u0275property("ngTemplateOutlet", ctx.contentTemplateRef());
          \u0275\u0275advance(2);
          \u0275\u0275property("ngTemplateOutlet", ctx.operationTemplateRef());
        }
      },
      dependencies: [NgTemplateOutlet, ThyIcon, NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyHeader, [{
    type: Component,
    args: [{
      selector: "thy-header",
      preserveWhitespaces: false,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [{
        directive: ThyHeaderDirective,
        inputs: ["thySize", "thyShadow", "thyHasBorder", "thyDivided"]
      }],
      imports: [NgTemplateOutlet, ThyIcon, NgClass],
      template: '<div class="layout-header-title">\n  @if (titleTemplateRef()) {\n    <ng-template [ngTemplateOutlet]="titleTemplateRef()"></ng-template>\n  } @else {\n    @if (svgIconName()) {\n      <thy-icon class="prefix-icon" [thyIconName]="svgIconName()"></thy-icon>\n    } @else {\n      @if (iconClass()) {\n        <i class="prefix-icon" [ngClass]="iconClass()"></i>\n      }\n    }\n    <span class="title-name">{{ thyTitle() }}</span>\n  }\n</div>\n<div class="layout-header-content">\n  <ng-template [ngTemplateOutlet]="contentTemplateRef()"></ng-template>\n</div>\n<div class="layout-header-operation">\n  <ng-template [ngTemplateOutlet]="operationTemplateRef()"></ng-template>\n</div>\n'
    }]
  }], null, {
    thyTitle: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTitle",
        required: false
      }]
    }],
    thyIconPrefix: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconPrefix",
        required: false
      }]
    }],
    thyIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIcon",
        required: false
      }]
    }],
    titleTemplateRef: [{
      type: ContentChild,
      args: ["headerTitle", {
        isSignal: true
      }]
    }],
    contentTemplateRef: [{
      type: ContentChild,
      args: ["headerContent", {
        isSignal: true
      }]
    }],
    operationTemplateRef: [{
      type: ContentChild,
      args: ["headerOperation", {
        isSignal: true
      }]
    }]
  });
})();
var ThyContentDirective = class _ThyContentDirective {
  static {
    this.\u0275fac = function ThyContentDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContentDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyContentDirective,
      selectors: [["", "thyContent", "", 5, "thy-badge", 3, "thyBadge", ""]],
      hostAttrs: [1, "thy-layout-content"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContentDirective, [{
    type: Directive,
    args: [{
      selector: "[thyContent]:not(thy-badge):not([thyBadge])",
      host: {
        class: "thy-layout-content"
      }
    }]
  }], null, null);
})();
var ThyContent = class _ThyContent {
  static {
    this.\u0275fac = function ThyContent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyContent,
      selectors: [["thy-content"]],
      features: [\u0275\u0275HostDirectivesFeature([ThyContentDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThyContent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContent, [{
    type: Component,
    args: [{
      selector: "thy-content",
      preserveWhitespaces: false,
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThyContentDirective]
    }]
  }], null, null);
})();
var LG_WIDTH = 300;
var SIDEBAR_DEFAULT_WIDTH = 240;
var SIDEBAR_COLLAPSED_WIDTH = 20;
var ThySidebarDirective = class _ThySidebarDirective {
  constructor() {
    this.thyLayoutDirective = inject(ThyLayoutDirective, {
      optional: true,
      host: true
    });
    this.thyDirection = input("left", ...ngDevMode ? [{
      debugName: "thyDirection"
    }] : []);
    this.thyTheme = input(...ngDevMode ? [void 0, {
      debugName: "thyTheme"
    }] : []);
    this.thyWidth = input(SIDEBAR_DEFAULT_WIDTH, ...ngDevMode ? [{
      debugName: "thyWidth",
      transform: (value) => {
        if (value === "lg") {
          return LG_WIDTH;
        }
        return value || SIDEBAR_DEFAULT_WIDTH;
      }
    }] : [{
      transform: (value) => {
        if (value === "lg") {
          return LG_WIDTH;
        }
        return value || SIDEBAR_DEFAULT_WIDTH;
      }
    }]);
    this.sidebarWidth = linkedSignal(() => {
      return this.thyWidth();
    }, ...ngDevMode ? [{
      debugName: "sidebarWidth"
    }] : []);
    this.thyIsolated = input(false, ...ngDevMode ? [{
      debugName: "thyIsolated",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDivided = input(true, ...ngDevMode ? [{
      debugName: "thyDivided",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  ngOnInit() {
    if (this.thyLayoutDirective) {
      this.thyLayoutDirective.sidebarDirection.set(this.thyDirection());
    }
  }
  static {
    this.\u0275fac = function ThySidebarDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThySidebarDirective,
      selectors: [["", "thySidebar", ""]],
      hostAttrs: [1, "thy-layout-sidebar"],
      hostVars: 14,
      hostBindings: function ThySidebarDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.sidebarWidth(), "px");
          \u0275\u0275classProp("thy-layout-sidebar-right", ctx.thyDirection() === "right")("thy-layout-sidebar--clear-border-right", ctx.thyDirection() === "left" && !ctx.thyDivided())("thy-layout-sidebar--clear-border-left", ctx.thyDirection() === "right" && !ctx.thyDivided())("sidebar-theme-light", ctx.thyTheme() === "light")("sidebar-theme-dark", ctx.thyTheme() === "dark")("thy-layout-sidebar-isolated", ctx.thyIsolated());
        }
      },
      inputs: {
        thyDirection: [1, "thyDirection"],
        thyTheme: [1, "thyTheme"],
        thyWidth: [1, "thyWidth"],
        thyIsolated: [1, "thyIsolated"],
        thyDivided: [1, "thyDivided"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarDirective, [{
    type: Directive,
    args: [{
      selector: "[thySidebar]",
      host: {
        class: "thy-layout-sidebar",
        "[class.thy-layout-sidebar-right]": 'thyDirection() === "right"',
        "[class.thy-layout-sidebar--clear-border-right]": 'thyDirection() === "left" && !thyDivided()',
        "[class.thy-layout-sidebar--clear-border-left]": 'thyDirection() === "right" && !thyDivided()',
        "[class.sidebar-theme-light]": 'thyTheme() === "light"',
        "[class.sidebar-theme-dark]": 'thyTheme() === "dark"',
        "[class.thy-layout-sidebar-isolated]": "thyIsolated()",
        "[style.width.px]": "sidebarWidth()"
      }
    }]
  }], null, {
    thyDirection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDirection",
        required: false
      }]
    }],
    thyTheme: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTheme",
        required: false
      }]
    }],
    thyWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyWidth",
        required: false
      }]
    }],
    thyIsolated: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIsolated",
        required: false
      }]
    }],
    thyDivided: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDivided",
        required: false
      }]
    }]
  });
})();
var ThySidebar = class _ThySidebar {
  mouseenter($event) {
    this.isMouseEnter.set(true);
  }
  mouseleave($event) {
    this.isMouseEnter.set(false);
  }
  constructor() {
    this.locale = injectLocale("layout");
    this.elementRef = inject(ElementRef);
    this.hotkeyDispatcher = inject(ThyHotkeyDispatcher);
    this.sidebarDirective = inject(ThySidebarDirective);
    this.isMouseEnter = signal(false, ...ngDevMode ? [{
      debugName: "isMouseEnter"
    }] : []);
    this.sidebarWidth = computed(() => {
      if (this.thyCollapsible() && this.collapsed()) {
        return this.thyCollapsedWidth();
      } else {
        return this.sidebarDirective.sidebarWidth();
      }
    }, ...ngDevMode ? [{
      debugName: "sidebarWidth"
    }] : []);
    this.thyDraggable = input(false, ...ngDevMode ? [{
      debugName: "thyDraggable",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDragMaxWidth = input(void 0, ...ngDevMode ? [{
      debugName: "thyDragMaxWidth",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyDragMinWidth = input(void 0, ...ngDevMode ? [{
      debugName: "thyDragMinWidth",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyTrigger = input(void 0, ...ngDevMode ? [{
      debugName: "thyTrigger"
    }] : []);
    this.thyCollapsedChange = output();
    this.thyDragWidthChange = output();
    this.thyCollapsible = input(false, ...ngDevMode ? [{
      debugName: "thyCollapsible",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyCollapsed = input(false, ...ngDevMode ? [{
      debugName: "thyCollapsed",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.collapsed = linkedSignal(() => this.thyCollapsed(), ...ngDevMode ? [{
      debugName: "collapsed"
    }] : []);
    this.collapseVisible = computed(() => {
      return this.isMouseEnter() && !this.collapsed() ? true : false;
    }, ...ngDevMode ? [{
      debugName: "collapseVisible"
    }] : []);
    this.thyCollapsedWidth = input(SIDEBAR_COLLAPSED_WIDTH, ...ngDevMode ? [{
      debugName: "thyCollapsedWidth",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyDefaultWidth = input(void 0, ...ngDevMode ? [{
      debugName: "thyDefaultWidth",
      transform: (value) => {
        if (value === "lg") {
          return LG_WIDTH;
        }
        return value;
      }
    }] : [{
      transform: (value) => {
        if (value === "lg") {
          return LG_WIDTH;
        }
        return value;
      }
    }]);
    this.collapseTip = computed(() => {
      const collapseTip = this.collapsed() ? this.locale().expand : this.locale().collapse;
      return collapseTip + (isMacPlatform() ? `\uFF08\u2318 + /)` : `\uFF08Ctrl + /)`);
    }, ...ngDevMode ? [{
      debugName: "collapseTip"
    }] : []);
    this.originWidth = SIDEBAR_DEFAULT_WIDTH;
    this.collapseHidden = signal(false, ...ngDevMode ? [{
      debugName: "collapseHidden"
    }] : []);
    this.isRemoveTransition = signal(false, ...ngDevMode ? [{
      debugName: "isRemoveTransition"
    }] : []);
    this.isResizable = signal(false, ...ngDevMode ? [{
      debugName: "isResizable"
    }] : []);
    this.dragMinWidth = computed(() => {
      return this.thyDragMinWidth() || this.thyCollapsedWidth();
    }, ...ngDevMode ? [{
      debugName: "dragMinWidth"
    }] : []);
    effect(() => {
      const collapsible = this.thyCollapsible();
      if (collapsible) {
        this.subscribeHotkeyEvent();
      } else {
        this.hotkeySubscription?.unsubscribe();
      }
    });
  }
  ngOnInit() {
  }
  subscribeHotkeyEvent() {
    this.hotkeySubscription = this.hotkeyDispatcher.keydown(["Control+/", "Meta+/"]).subscribe((event) => {
      this.toggleCollapse();
    });
  }
  resizeHandler({
    width
  }) {
    if (width === this.sidebarDirective.sidebarWidth()) {
      return;
    }
    if (this.thyCollapsible() && width < this.thyCollapsedWidth()) {
      return;
    }
    if (this.thyCollapsible() && width === this.thyCollapsedWidth()) {
      this.collapsed.set(true);
      this.thyCollapsedChange.emit(this.collapsed());
      this.sidebarDirective.sidebarWidth.set(this.originWidth);
      this.isMouseEnter.set(false);
      return;
    }
    this.sidebarDirective.sidebarWidth.set(width);
    this.thyDragWidthChange.emit(width);
  }
  resizeStart() {
    this.originWidth = this.sidebarDirective.sidebarWidth();
    this.collapseHidden.set(true);
    this.isRemoveTransition.set(true);
  }
  resizeEnd() {
    this.collapseHidden.set(false);
    this.isRemoveTransition.set(false);
  }
  toggleCollapse(event) {
    this.collapsed.update((value) => {
      return !value;
    });
    this.thyCollapsedChange.emit(this.collapsed());
  }
  toggleResizable(event, type) {
    this.isResizable.set(type === "enter" ? true : false);
  }
  restoreToDefaultWidth() {
    const thyDefaultWidth = this.thyDefaultWidth();
    this.sidebarDirective.sidebarWidth.set(thyDefaultWidth || SIDEBAR_DEFAULT_WIDTH);
    this.thyDragWidthChange.emit(this.sidebarDirective.sidebarWidth());
  }
  ngOnDestroy() {
    this.hotkeySubscription?.unsubscribe();
  }
  static {
    this.\u0275fac = function ThySidebar_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebar)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySidebar,
      selectors: [["thy-sidebar"]],
      hostVars: 6,
      hostBindings: function ThySidebar_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function ThySidebar_mouseenter_HostBindingHandler($event) {
            return ctx.mouseenter($event);
          })("mouseleave", function ThySidebar_mouseleave_HostBindingHandler($event) {
            return ctx.mouseleave($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.sidebarWidth(), "px");
          \u0275\u0275classProp("sidebar-collapse-show", ctx.collapsed())("remove-transition", ctx.isRemoveTransition());
        }
      },
      inputs: {
        thyDraggable: [1, "thyDraggable"],
        thyDragMaxWidth: [1, "thyDragMaxWidth"],
        thyDragMinWidth: [1, "thyDragMinWidth"],
        thyTrigger: [1, "thyTrigger"],
        thyCollapsible: [1, "thyCollapsible"],
        thyCollapsed: [1, "thyCollapsed"],
        thyCollapsedWidth: [1, "thyCollapsedWidth"],
        thyDefaultWidth: [1, "thyDefaultWidth"]
      },
      outputs: {
        thyCollapsedChange: "thyCollapsedChange",
        thyDragWidthChange: "thyDragWidthChange"
      },
      features: [\u0275\u0275HostDirectivesFeature([{
        directive: ThySidebarDirective,
        inputs: ["thyTheme", "thyTheme", "thyDirection", "thyDirection", "thyWidth", "thyWidth", "thyIsolated", "thyIsolated", "thyDivided", "thyDivided"]
      }])],
      ngContentSelectors: _c04,
      decls: 3,
      vars: 2,
      consts: [["defaultTrigger", ""], ["thyResizable", "", "thyBounds", "window", 1, "sidebar-drag", 3, "thyMaxWidth", "thyMinWidth", "display"], ["thyResizable", "", "thyBounds", "window", 1, "sidebar-drag", 3, "thyResize", "thyResizeStart", "thyResizeEnd", "thyMaxWidth", "thyMinWidth"], ["thyLine", "true", 1, "sidebar-resize-handle", 3, "thyDirection"], ["thyLine", "true", 1, "sidebar-resize-handle", 3, "mouseenter", "mouseleave", "dblclick", "thyDirection"], [1, "sidebar-collapse-line"], [1, "sidebar-collapse", 3, "ngClass", "thyTooltip"], [1, "sidebar-collapse", 3, "click", "ngClass", "thyTooltip"], [3, "ngTemplateOutlet"], [1, "sidebar-collapse-icon", 3, "thyIconName"]],
      template: function ThySidebar_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
          \u0275\u0275conditionalCreate(1, ThySidebar_Conditional_1_Template, 2, 5, "div", 1);
          \u0275\u0275conditionalCreate(2, ThySidebar_Conditional_2_Template, 2, 1);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyDraggable() ? 1 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyCollapsible() ? 2 : -1);
        }
      },
      dependencies: [NgTemplateOutlet, ThyResizeHandle, ThyResizableDirective, ThyIcon, ThyTooltipDirective, NgClass],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebar, [{
    type: Component,
    args: [{
      selector: "thy-sidebar",
      preserveWhitespaces: false,
      template: `
        <ng-content></ng-content>
        @if (thyDraggable()) {
            <div
                thyResizable
                class="sidebar-drag"
                thyBounds="window"
                [thyMaxWidth]="thyDragMaxWidth()"
                [thyMinWidth]="dragMinWidth()"
                (thyResize)="resizeHandler($event)"
                (thyResizeStart)="resizeStart()"
                (thyResizeEnd)="resizeEnd()"
                [style.display]="!isResizable() ? 'contents' : null">
                @if (!collapsed()) {
                    <thy-resize-handle
                        [thyDirection]="sidebarDirective.thyDirection() === 'right' ? 'left' : 'right'"
                        class="sidebar-resize-handle"
                        thyLine="true"
                        (mouseenter)="toggleResizable($event, 'enter')"
                        (mouseleave)="toggleResizable($event, 'leave')"
                        (dblclick)="restoreToDefaultWidth()">
                    </thy-resize-handle>
                }
            </div>
        }
        @if (thyCollapsible()) {
            <div class="sidebar-collapse-line"></div>

            @if (thyTrigger() !== null) {
                <div
                    class="sidebar-collapse"
                    [ngClass]="{ 'collapse-visible': collapseVisible(), 'collapse-hidden': collapseHidden() }"
                    (click)="toggleCollapse($event)"
                    [thyTooltip]="!thyTrigger() && collapseTip()">
                    <ng-template [ngTemplateOutlet]="thyTrigger() || defaultTrigger"></ng-template>
                    <ng-template #defaultTrigger>
                        <thy-icon class="sidebar-collapse-icon" [thyIconName]="collapsed() ? 'indent' : 'outdent'"></thy-icon>
                    </ng-template>
                </div>
            }
        }
    `,
      hostDirectives: [{
        directive: ThySidebarDirective,
        inputs: ["thyTheme", "thyDirection", "thyWidth", "thyIsolated", "thyDivided"]
      }],
      imports: [NgTemplateOutlet, ThyResizeHandle, ThyResizableDirective, ThyIcon, ThyTooltipDirective, NgClass],
      host: {
        "[class.sidebar-collapse-show]": "collapsed()",
        "[class.remove-transition]": "isRemoveTransition()",
        "[style.width.px]": "sidebarWidth()"
      }
    }]
  }], () => [], {
    mouseenter: [{
      type: HostListener,
      args: ["mouseenter", ["$event"]]
    }],
    mouseleave: [{
      type: HostListener,
      args: ["mouseleave", ["$event"]]
    }],
    thyDraggable: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDraggable",
        required: false
      }]
    }],
    thyDragMaxWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDragMaxWidth",
        required: false
      }]
    }],
    thyDragMinWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDragMinWidth",
        required: false
      }]
    }],
    thyTrigger: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTrigger",
        required: false
      }]
    }],
    thyCollapsedChange: [{
      type: Output,
      args: ["thyCollapsedChange"]
    }],
    thyDragWidthChange: [{
      type: Output,
      args: ["thyDragWidthChange"]
    }],
    thyCollapsible: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyCollapsible",
        required: false
      }]
    }],
    thyCollapsed: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyCollapsed",
        required: false
      }]
    }],
    thyCollapsedWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyCollapsedWidth",
        required: false
      }]
    }],
    thyDefaultWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDefaultWidth",
        required: false
      }]
    }]
  });
})();
var ThyContentSectionDirective = class _ThyContentSectionDirective {
  static {
    this.\u0275fac = function ThyContentSectionDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContentSectionDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyContentSectionDirective,
      selectors: [["", "thyContentSection", ""]],
      hostAttrs: [1, "thy-layout-content-section"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContentSectionDirective, [{
    type: Directive,
    args: [{
      selector: "[thyContentSection]",
      host: {
        class: "thy-layout-content-section"
      }
    }]
  }], null, null);
})();
var ThyContentSection = class _ThyContentSection {
  static {
    this.\u0275fac = function ThyContentSection_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContentSection)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyContentSection,
      selectors: [["thy-content-section"]],
      features: [\u0275\u0275HostDirectivesFeature([ThyContentSectionDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThyContentSection_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContentSection, [{
    type: Component,
    args: [{
      selector: "thy-content-section",
      preserveWhitespaces: false,
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThyContentSectionDirective]
    }]
  }], null, null);
})();
var ThyContentMainDirective = class _ThyContentMainDirective {
  static {
    this.\u0275fac = function ThyContentMainDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContentMainDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyContentMainDirective,
      selectors: [["", "thyContentMain", ""]],
      hostAttrs: [1, "thy-layout-content-main"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContentMainDirective, [{
    type: Directive,
    args: [{
      selector: "[thyContentMain]",
      host: {
        class: "thy-layout-content-main"
      }
    }]
  }], null, null);
})();
var ThyContentMain = class _ThyContentMain {
  static {
    this.\u0275fac = function ThyContentMain_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContentMain)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyContentMain,
      selectors: [["thy-content-main"]],
      features: [\u0275\u0275HostDirectivesFeature([ThyContentMainDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThyContentMain_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContentMain, [{
    type: Component,
    args: [{
      selector: "thy-content-main",
      preserveWhitespaces: false,
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThyContentMainDirective]
    }]
  }], null, null);
})();
var ThySidebarHeaderDirective = class _ThySidebarHeaderDirective {
  constructor() {
    this.thyDivided = input(false, ...ngDevMode ? [{
      debugName: "thyDivided",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThySidebarHeaderDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarHeaderDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThySidebarHeaderDirective,
      selectors: [["", "thySidebarHeader", ""]],
      hostAttrs: [1, "sidebar-header"],
      hostVars: 2,
      hostBindings: function ThySidebarHeaderDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("sidebar-header-divided", ctx.thyDivided());
        }
      },
      inputs: {
        thyDivided: [1, "thyDivided"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarHeaderDirective, [{
    type: Directive,
    args: [{
      selector: "[thySidebarHeader]",
      host: {
        class: "sidebar-header",
        "[class.sidebar-header-divided]": "thyDivided()"
      }
    }]
  }], () => [], {
    thyDivided: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDivided",
        required: false
      }]
    }]
  });
})();
var ThySidebarHeader = class _ThySidebarHeader {
  constructor() {
    this.thyTitle = input(...ngDevMode ? [void 0, {
      debugName: "thyTitle"
    }] : []);
    this.operationTemplateRef = contentChild("headerOperation", ...ngDevMode ? [{
      debugName: "operationTemplateRef"
    }] : []);
    this.titleTemplateRef = contentChild("headerTitle", ...ngDevMode ? [{
      debugName: "titleTemplateRef"
    }] : []);
  }
  static {
    this.\u0275fac = function ThySidebarHeader_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarHeader)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySidebarHeader,
      selectors: [["thy-sidebar-header"]],
      contentQueries: function ThySidebarHeader_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.operationTemplateRef, _c3, 5)(dirIndex, ctx.titleTemplateRef, _c1, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      inputs: {
        thyTitle: [1, "thyTitle"]
      },
      features: [\u0275\u0275HostDirectivesFeature([{
        directive: ThySidebarHeaderDirective,
        inputs: ["thyDivided", "thyDivided"]
      }])],
      ngContentSelectors: _c04,
      decls: 4,
      vars: 2,
      consts: [[1, "title"], [1, "operation"], [3, "ngTemplateOutlet"]],
      template: function ThySidebarHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275conditionalCreate(0, ThySidebarHeader_Conditional_0_Template, 3, 1, "span", 0);
          \u0275\u0275projection(1);
          \u0275\u0275elementStart(2, "div", 1);
          \u0275\u0275template(3, ThySidebarHeader_ng_template_3_Template, 0, 0, "ng-template", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.thyTitle() || ctx.titleTemplateRef() ? 0 : -1);
          \u0275\u0275advance(3);
          \u0275\u0275property("ngTemplateOutlet", ctx.operationTemplateRef());
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarHeader, [{
    type: Component,
    args: [{
      selector: "thy-sidebar-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [{
        directive: ThySidebarHeaderDirective,
        inputs: ["thyDivided"]
      }],
      imports: [NgTemplateOutlet],
      template: '@if (thyTitle() || titleTemplateRef()) {\n  <span class="title">\n    @if (titleTemplateRef()) {\n      <ng-template [ngTemplateOutlet]="titleTemplateRef()"></ng-template>\n    } @else {\n      {{ thyTitle() }}\n    }\n  </span>\n}\n<ng-content></ng-content>\n<div class="operation">\n  <ng-template [ngTemplateOutlet]="operationTemplateRef()"></ng-template>\n</div>\n'
    }]
  }], null, {
    thyTitle: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTitle",
        required: false
      }]
    }],
    operationTemplateRef: [{
      type: ContentChild,
      args: ["headerOperation", {
        isSignal: true
      }]
    }],
    titleTemplateRef: [{
      type: ContentChild,
      args: ["headerTitle", {
        isSignal: true
      }]
    }]
  });
})();
var ThySidebarFooterDirective = class _ThySidebarFooterDirective {
  static {
    this.\u0275fac = function ThySidebarFooterDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarFooterDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThySidebarFooterDirective,
      selectors: [["", "thySidebarFooter", ""]],
      hostAttrs: [1, "sidebar-footer"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarFooterDirective, [{
    type: Directive,
    args: [{
      selector: "[thySidebarFooter]",
      host: {
        class: "sidebar-footer"
      }
    }]
  }], null, null);
})();
var ThySidebarFooter = class _ThySidebarFooter {
  static {
    this.\u0275fac = function ThySidebarFooter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarFooter)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySidebarFooter,
      selectors: [["thy-sidebar-footer"]],
      features: [\u0275\u0275HostDirectivesFeature([ThySidebarFooterDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThySidebarFooter_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarFooter, [{
    type: Component,
    args: [{
      selector: "thy-sidebar-footer",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThySidebarFooterDirective]
    }]
  }], null, null);
})();
var ThySidebarContentDirective = class _ThySidebarContentDirective {
  static {
    this.\u0275fac = function ThySidebarContentDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarContentDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThySidebarContentDirective,
      selectors: [["", "thySidebarContent", ""]],
      hostAttrs: [1, "sidebar-content"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarContentDirective, [{
    type: Directive,
    args: [{
      selector: "[thySidebarContent]",
      host: {
        class: "sidebar-content"
      }
    }]
  }], null, null);
})();
var ThySidebarContent = class _ThySidebarContent {
  static {
    this.\u0275fac = function ThySidebarContent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySidebarContent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySidebarContent,
      selectors: [["thy-sidebar-content"]],
      features: [\u0275\u0275HostDirectivesFeature([ThySidebarContentDirective])],
      ngContentSelectors: _c04,
      decls: 1,
      vars: 0,
      template: function ThySidebarContent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySidebarContent, [{
    type: Component,
    args: [{
      selector: "thy-sidebar-content",
      template: ` <ng-content></ng-content> `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [ThySidebarContentDirective]
    }]
  }], null, null);
})();
var ThyLayoutModule = class _ThyLayoutModule {
  static {
    this.\u0275fac = function ThyLayoutModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyLayoutModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyLayoutModule,
      imports: [CommonModule, DragDropModule, ThyIconModule, ThyTooltipModule, ThyResizableModule, ThyHotkeyModule, ThyLayout, ThyHeader, ThyContent, ThySidebar, ThySidebarHeader, ThySidebarContent, ThySidebarFooter, ThyContentSection, ThyContentMain, ThyLayoutDirective, ThyHeaderDirective, ThyContentDirective, ThySidebarDirective, ThySidebarHeaderDirective, ThySidebarContentDirective, ThySidebarFooterDirective, ThyContentSectionDirective, ThyContentMainDirective],
      exports: [ThyLayout, ThyHeader, ThyContent, ThySidebar, ThySidebarHeader, ThySidebarContent, ThySidebarFooter, ThyContentSection, ThyContentMain, ThyLayoutDirective, ThyHeaderDirective, ThyContentDirective, ThySidebarDirective, ThySidebarHeaderDirective, ThySidebarContentDirective, ThySidebarFooterDirective, ThyContentSectionDirective, ThyContentMainDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, DragDropModule, ThyIconModule, ThyTooltipModule, ThyResizableModule, ThyHotkeyModule, ThyHeader, ThySidebar]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyLayoutModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, DragDropModule, ThyIconModule, ThyTooltipModule, ThyResizableModule, ThyHotkeyModule, ThyLayout, ThyHeader, ThyContent, ThySidebar, ThySidebarHeader, ThySidebarContent, ThySidebarFooter, ThyContentSection, ThyContentMain, ThyLayoutDirective, ThyHeaderDirective, ThyContentDirective, ThySidebarDirective, ThySidebarHeaderDirective, ThySidebarContentDirective, ThySidebarFooterDirective, ThyContentSectionDirective, ThyContentMainDirective],
      exports: [ThyLayout, ThyHeader, ThyContent, ThySidebar, ThySidebarHeader, ThySidebarContent, ThySidebarFooter, ThyContentSection, ThyContentMain, ThyLayoutDirective, ThyHeaderDirective, ThyContentDirective, ThySidebarDirective, ThySidebarHeaderDirective, ThySidebarContentDirective, ThySidebarFooterDirective, ThyContentSectionDirective, ThyContentMainDirective]
    }]
  }], null, null);
})();

// node_modules/@angular/router/fesm2022/_router-chunk.mjs
var PRIMARY_OUTLET = "primary";
var RouteTitleKey = /* @__PURE__ */ Symbol("RouteTitle");
var ParamsAsMap = class {
  params;
  constructor(params) {
    this.params = params || {};
  }
  has(name) {
    return Object.prototype.hasOwnProperty.call(this.params, name);
  }
  get(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v[0] : v;
    }
    return null;
  }
  getAll(name) {
    if (this.has(name)) {
      const v = this.params[name];
      return Array.isArray(v) ? v : [v];
    }
    return [];
  }
  get keys() {
    return Object.keys(this.params);
  }
};
function convertToParamMap(params) {
  return new ParamsAsMap(params);
}
function defaultUrlMatcher(segments, segmentGroup, route) {
  const parts = route.path.split("/");
  if (parts.length > segments.length) {
    return null;
  }
  if (route.pathMatch === "full" && (segmentGroup.hasChildren() || parts.length < segments.length)) {
    return null;
  }
  const posParams = {};
  for (let index2 = 0; index2 < parts.length; index2++) {
    const part = parts[index2];
    const segment = segments[index2];
    const isParameter = part[0] === ":";
    if (isParameter) {
      posParams[part.substring(1)] = segment;
    } else if (part !== segment.path) {
      return null;
    }
  }
  return {
    consumed: segments.slice(0, parts.length),
    posParams
  };
}
function firstValueFrom(source) {
  return new Promise((resolve, reject) => {
    source.pipe(first()).subscribe({
      next: (value) => resolve(value),
      error: (err) => reject(err)
    });
  });
}
function shallowEqualArrays(a, b) {
  if (a.length !== b.length) return false;
  for (let i = 0; i < a.length; ++i) {
    if (!shallowEqual2(a[i], b[i])) return false;
  }
  return true;
}
function shallowEqual2(a, b) {
  const k1 = a ? getDataKeys(a) : void 0;
  const k2 = b ? getDataKeys(b) : void 0;
  if (!k1 || !k2 || k1.length != k2.length) {
    return false;
  }
  let key;
  for (let i = 0; i < k1.length; i++) {
    key = k1[i];
    if (!equalArraysOrString(a[key], b[key])) {
      return false;
    }
  }
  return true;
}
function getDataKeys(obj) {
  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];
}
function equalArraysOrString(a, b) {
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    const aSorted = [...a].sort();
    const bSorted = [...b].sort();
    return aSorted.every((val, index2) => bSorted[index2] === val);
  } else {
    return a === b;
  }
}
function last2(a) {
  return a.length > 0 ? a[a.length - 1] : null;
}
function wrapIntoObservable(value) {
  if (isObservable(value)) {
    return value;
  }
  if (isPromise(value)) {
    return from(Promise.resolve(value));
  }
  return of(value);
}
function wrapIntoPromise(value) {
  if (isObservable(value)) {
    return firstValueFrom(value);
  }
  return Promise.resolve(value);
}
var pathCompareMap = {
  "exact": equalSegmentGroups,
  "subset": containsSegmentGroup
};
var paramCompareMap = {
  "exact": equalParams,
  "subset": containsParams,
  "ignored": () => true
};
function containsTree(container, containee, options) {
  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === "exact" && container.fragment !== containee.fragment);
}
function equalParams(container, containee) {
  return shallowEqual2(container, containee);
}
function equalSegmentGroups(container, containee, matrixParams) {
  if (!equalPath(container.segments, containee.segments)) return false;
  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {
    return false;
  }
  if (container.numberOfChildren !== containee.numberOfChildren) return false;
  for (const c in containee.children) {
    if (!container.children[c]) return false;
    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;
  }
  return true;
}
function containsParams(container, containee) {
  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));
}
function containsSegmentGroup(container, containee, matrixParams) {
  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);
}
function containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {
  if (container.segments.length > containeePaths.length) {
    const current = container.segments.slice(0, containeePaths.length);
    if (!equalPath(current, containeePaths)) return false;
    if (containee.hasChildren()) return false;
    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;
    return true;
  } else if (container.segments.length === containeePaths.length) {
    if (!equalPath(container.segments, containeePaths)) return false;
    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;
    for (const c in containee.children) {
      if (!container.children[c]) return false;
      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {
        return false;
      }
    }
    return true;
  } else {
    const current = containeePaths.slice(0, container.segments.length);
    const next = containeePaths.slice(container.segments.length);
    if (!equalPath(container.segments, current)) return false;
    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;
    if (!container.children[PRIMARY_OUTLET]) return false;
    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);
  }
}
function matrixParamsMatch(containerPaths, containeePaths, options) {
  return containeePaths.every((containeeSegment, i) => {
    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);
  });
}
var UrlTree = class {
  root;
  queryParams;
  fragment;
  _queryParamMap;
  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {
    this.root = root;
    this.queryParams = queryParams;
    this.fragment = fragment;
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (root.segments.length > 0) {
        throw new RuntimeError(4015, "The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.");
      }
    }
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    return DEFAULT_SERIALIZER.serialize(this);
  }
};
var UrlSegmentGroup = class {
  segments;
  children;
  parent = null;
  constructor(segments, children) {
    this.segments = segments;
    this.children = children;
    Object.values(children).forEach((v) => v.parent = this);
  }
  hasChildren() {
    return this.numberOfChildren > 0;
  }
  get numberOfChildren() {
    return Object.keys(this.children).length;
  }
  toString() {
    return serializePaths(this);
  }
};
var UrlSegment = class {
  path;
  parameters;
  _parameterMap;
  constructor(path, parameters) {
    this.path = path;
    this.parameters = parameters;
  }
  get parameterMap() {
    this._parameterMap ??= convertToParamMap(this.parameters);
    return this._parameterMap;
  }
  toString() {
    return serializePath(this);
  }
};
function equalSegments(as, bs) {
  return equalPath(as, bs) && as.every((a, i) => shallowEqual2(a.parameters, bs[i].parameters));
}
function equalPath(as, bs) {
  if (as.length !== bs.length) return false;
  return as.every((a, i) => a.path === bs[i].path);
}
function mapChildrenIntoArray(segment, fn) {
  let res = [];
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet === PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  Object.entries(segment.children).forEach(([childOutlet, child]) => {
    if (childOutlet !== PRIMARY_OUTLET) {
      res = res.concat(fn(child, childOutlet));
    }
  });
  return res;
}
var UrlSerializer = class _UrlSerializer {
  static \u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlSerializer)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlSerializer,
    factory: () => (() => new DefaultUrlSerializer())(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlSerializer, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => new DefaultUrlSerializer()
    }]
  }], null, null);
})();
var DefaultUrlSerializer = class {
  parse(url) {
    const p = new UrlParser(url);
    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
  }
  serialize(tree2) {
    const segment = `/${serializeSegment(tree2.root, true)}`;
    const query2 = serializeQueryParams(tree2.queryParams);
    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : "";
    return `${segment}${query2}${fragment}`;
  }
};
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
  return segment.segments.map((p) => serializePath(p)).join("/");
}
function serializeSegment(segment, root) {
  if (!segment.hasChildren()) {
    return serializePaths(segment);
  }
  if (root) {
    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : "";
    const children = [];
    Object.entries(segment.children).forEach(([k, v]) => {
      if (k !== PRIMARY_OUTLET) {
        children.push(`${k}:${serializeSegment(v, false)}`);
      }
    });
    return children.length > 0 ? `${primary}(${children.join("//")})` : primary;
  } else {
    const children = mapChildrenIntoArray(segment, (v, k) => {
      if (k === PRIMARY_OUTLET) {
        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
      }
      return [`${k}:${serializeSegment(v, false)}`];
    });
    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {
      return `${serializePaths(segment)}/${children[0]}`;
    }
    return `${serializePaths(segment)}/(${children.join("//")})`;
  }
}
function encodeUriString(s) {
  return encodeURIComponent(s).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",");
}
function encodeUriQuery(s) {
  return encodeUriString(s).replace(/%3B/gi, ";");
}
function encodeUriFragment(s) {
  return encodeURI(s);
}
function encodeUriSegment(s) {
  return encodeUriString(s).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&");
}
function decode(s) {
  return decodeURIComponent(s);
}
function decodeQuery(s) {
  return decode(s.replace(/\+/g, "%20"));
}
function serializePath(path) {
  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;
}
function serializeMatrixParams(params) {
  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join("");
}
function serializeQueryParams(params) {
  const strParams = Object.entries(params).map(([name, value]) => {
    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join("&") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;
  }).filter((s) => s);
  return strParams.length ? `?${strParams.join("&")}` : "";
}
var SEGMENT_RE = /^[^\/()?;#]+/;
function matchSegments(str) {
  const match5 = str.match(SEGMENT_RE);
  return match5 ? match5[0] : "";
}
var MATRIX_PARAM_SEGMENT_RE = /^[^\/()?;=#]+/;
function matchMatrixKeySegments(str) {
  const match5 = str.match(MATRIX_PARAM_SEGMENT_RE);
  return match5 ? match5[0] : "";
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
function matchQueryParams(str) {
  const match5 = str.match(QUERY_PARAM_RE);
  return match5 ? match5[0] : "";
}
var QUERY_PARAM_VALUE_RE = /^[^&#]+/;
function matchUrlQueryParamValue(str) {
  const match5 = str.match(QUERY_PARAM_VALUE_RE);
  return match5 ? match5[0] : "";
}
var UrlParser = class {
  url;
  remaining;
  constructor(url) {
    this.url = url;
    this.remaining = url;
  }
  parseRootSegment() {
    this.consumeOptional("/");
    if (this.remaining === "" || this.peekStartsWith("?") || this.peekStartsWith("#")) {
      return new UrlSegmentGroup([], {});
    }
    return new UrlSegmentGroup([], this.parseChildren());
  }
  parseQueryParams() {
    const params = {};
    if (this.consumeOptional("?")) {
      do {
        this.parseQueryParam(params);
      } while (this.consumeOptional("&"));
    }
    return params;
  }
  parseFragment() {
    return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null;
  }
  parseChildren() {
    if (this.remaining === "") {
      return {};
    }
    this.consumeOptional("/");
    const segments = [];
    if (!this.peekStartsWith("(")) {
      segments.push(this.parseSegment());
    }
    while (this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(")) {
      this.capture("/");
      segments.push(this.parseSegment());
    }
    let children = {};
    if (this.peekStartsWith("/(")) {
      this.capture("/");
      children = this.parseParens(true);
    }
    let res = {};
    if (this.peekStartsWith("(")) {
      res = this.parseParens(false);
    }
    if (segments.length > 0 || Object.keys(children).length > 0) {
      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
    }
    return res;
  }
  parseSegment() {
    const path = matchSegments(this.remaining);
    if (path === "" && this.peekStartsWith(";")) {
      throw new RuntimeError(4009, (typeof ngDevMode === "undefined" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);
    }
    this.capture(path);
    return new UrlSegment(decode(path), this.parseMatrixParams());
  }
  parseMatrixParams() {
    const params = {};
    while (this.consumeOptional(";")) {
      this.parseParam(params);
    }
    return params;
  }
  parseParam(params) {
    const key = matchMatrixKeySegments(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchSegments(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    params[decode(key)] = decode(value);
  }
  parseQueryParam(params) {
    const key = matchQueryParams(this.remaining);
    if (!key) {
      return;
    }
    this.capture(key);
    let value = "";
    if (this.consumeOptional("=")) {
      const valueMatch = matchUrlQueryParamValue(this.remaining);
      if (valueMatch) {
        value = valueMatch;
        this.capture(value);
      }
    }
    const decodedKey = decodeQuery(key);
    const decodedVal = decodeQuery(value);
    if (params.hasOwnProperty(decodedKey)) {
      let currentVal = params[decodedKey];
      if (!Array.isArray(currentVal)) {
        currentVal = [currentVal];
        params[decodedKey] = currentVal;
      }
      currentVal.push(decodedVal);
    } else {
      params[decodedKey] = decodedVal;
    }
  }
  parseParens(allowPrimary) {
    const segments = {};
    this.capture("(");
    while (!this.consumeOptional(")") && this.remaining.length > 0) {
      const path = matchSegments(this.remaining);
      const next = this.remaining[path.length];
      if (next !== "/" && next !== ")" && next !== ";") {
        throw new RuntimeError(4010, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot parse url '${this.url}'`);
      }
      let outletName;
      if (path.indexOf(":") > -1) {
        outletName = path.slice(0, path.indexOf(":"));
        this.capture(outletName);
        this.capture(":");
      } else if (allowPrimary) {
        outletName = PRIMARY_OUTLET;
      }
      const children = this.parseChildren();
      segments[outletName ?? PRIMARY_OUTLET] = Object.keys(children).length === 1 && children[PRIMARY_OUTLET] ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);
      this.consumeOptional("//");
    }
    return segments;
  }
  peekStartsWith(str) {
    return this.remaining.startsWith(str);
  }
  consumeOptional(str) {
    if (this.peekStartsWith(str)) {
      this.remaining = this.remaining.substring(str.length);
      return true;
    }
    return false;
  }
  capture(str) {
    if (!this.consumeOptional(str)) {
      throw new RuntimeError(4011, (typeof ngDevMode === "undefined" || ngDevMode) && `Expected "${str}".`);
    }
  }
};
function createRoot(rootCandidate) {
  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {
    [PRIMARY_OUTLET]: rootCandidate
  }) : rootCandidate;
}
function squashSegmentGroup(segmentGroup) {
  const newChildren = {};
  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {
    const childCandidate = squashSegmentGroup(child);
    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {
      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {
        newChildren[grandChildOutlet] = grandChild;
      }
    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {
      newChildren[childOutlet] = childCandidate;
    }
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);
  return mergeTrivialChildren(s);
}
function mergeTrivialChildren(s) {
  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
    const c = s.children[PRIMARY_OUTLET];
    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
  }
  return s;
}
function isUrlTree(v) {
  return v instanceof UrlTree;
}
function createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null, urlSerializer = new DefaultUrlSerializer()) {
  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);
  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment, urlSerializer);
}
function createSegmentGroupFromRoute(route) {
  let targetGroup;
  function createSegmentGroupFromRouteRecursive(currentRoute) {
    const childOutlets = {};
    for (const childSnapshot of currentRoute.children) {
      const root = createSegmentGroupFromRouteRecursive(childSnapshot);
      childOutlets[childSnapshot.outlet] = root;
    }
    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);
    if (currentRoute === route) {
      targetGroup = segmentGroup;
    }
    return segmentGroup;
  }
  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);
  const rootSegmentGroup = createRoot(rootCandidate);
  return targetGroup ?? rootSegmentGroup;
}
function createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment, urlSerializer) {
  let root = relativeTo;
  while (root.parent) {
    root = root.parent;
  }
  if (commands.length === 0) {
    return tree(root, root, root, queryParams, fragment, urlSerializer);
  }
  const nav = computeNavigation(commands);
  if (nav.toRoot()) {
    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment, urlSerializer);
  }
  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);
  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);
  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer);
}
function isMatrixParams(command) {
  return typeof command === "object" && command != null && !command.outlets && !command.segmentPath;
}
function isCommandWithOutlets(command) {
  return typeof command === "object" && command != null && command.outlets;
}
function normalizeQueryParams(k, v, urlSerializer) {
  k ||= "\u0275";
  const tree2 = new UrlTree();
  tree2.queryParams = {
    [k]: v
  };
  return urlSerializer.parse(urlSerializer.serialize(tree2)).queryParams[k];
}
function tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment, urlSerializer) {
  const qp = {};
  for (const [key, value] of Object.entries(queryParams ?? {})) {
    qp[key] = Array.isArray(value) ? value.map((v) => normalizeQueryParams(key, v, urlSerializer)) : normalizeQueryParams(key, value, urlSerializer);
  }
  let rootCandidate;
  if (oldRoot === oldSegmentGroup) {
    rootCandidate = newSegmentGroup;
  } else {
    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);
  }
  const newRoot = createRoot(squashSegmentGroup(rootCandidate));
  return new UrlTree(newRoot, qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
  const children = {};
  Object.entries(current.children).forEach(([outletName, c]) => {
    if (c === oldSegment) {
      children[outletName] = newSegment;
    } else {
      children[outletName] = replaceSegment(c, oldSegment, newSegment);
    }
  });
  return new UrlSegmentGroup(current.segments, children);
}
var Navigation = class {
  isAbsolute;
  numberOfDoubleDots;
  commands;
  constructor(isAbsolute, numberOfDoubleDots, commands) {
    this.isAbsolute = isAbsolute;
    this.numberOfDoubleDots = numberOfDoubleDots;
    this.commands = commands;
    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
      throw new RuntimeError(4003, (typeof ngDevMode === "undefined" || ngDevMode) && "Root segment cannot have matrix parameters");
    }
    const cmdWithOutlet = commands.find(isCommandWithOutlets);
    if (cmdWithOutlet && cmdWithOutlet !== last2(commands)) {
      throw new RuntimeError(4004, (typeof ngDevMode === "undefined" || ngDevMode) && "{outlets:{}} has to be the last command");
    }
  }
  toRoot() {
    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == "/";
  }
};
function computeNavigation(commands) {
  if (typeof commands[0] === "string" && commands.length === 1 && commands[0] === "/") {
    return new Navigation(true, 0, commands);
  }
  let numberOfDoubleDots = 0;
  let isAbsolute = false;
  const res = commands.reduce((res2, cmd, cmdIdx) => {
    if (typeof cmd === "object" && cmd != null) {
      if (cmd.outlets) {
        const outlets = {};
        Object.entries(cmd.outlets).forEach(([name, commands2]) => {
          outlets[name] = typeof commands2 === "string" ? commands2.split("/") : commands2;
        });
        return [...res2, {
          outlets
        }];
      }
      if (cmd.segmentPath) {
        return [...res2, cmd.segmentPath];
      }
    }
    if (!(typeof cmd === "string")) {
      return [...res2, cmd];
    }
    if (cmdIdx === 0) {
      cmd.split("/").forEach((urlPart, partIndex) => {
        if (partIndex == 0 && urlPart === ".") ;
        else if (partIndex == 0 && urlPart === "") {
          isAbsolute = true;
        } else if (urlPart === "..") {
          numberOfDoubleDots++;
        } else if (urlPart != "") {
          res2.push(urlPart);
        }
      });
      return res2;
    }
    return [...res2, cmd];
  }, []);
  return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = class {
  segmentGroup;
  processChildren;
  index;
  constructor(segmentGroup, processChildren, index2) {
    this.segmentGroup = segmentGroup;
    this.processChildren = processChildren;
    this.index = index2;
  }
};
function findStartingPositionForTargetGroup(nav, root, target) {
  if (nav.isAbsolute) {
    return new Position(root, true, 0);
  }
  if (!target) {
    return new Position(root, false, NaN);
  }
  if (target.parent === null) {
    return new Position(target, true, 0);
  }
  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
  const index2 = target.segments.length - 1 + modifier;
  return createPositionApplyingDoubleDots(target, index2, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group2, index2, numberOfDoubleDots) {
  let g = group2;
  let ci = index2;
  let dd = numberOfDoubleDots;
  while (dd > ci) {
    dd -= ci;
    g = g.parent;
    if (!g) {
      throw new RuntimeError(4005, (typeof ngDevMode === "undefined" || ngDevMode) && "Invalid number of '../'");
    }
    ci = g.segments.length;
  }
  return new Position(g, false, ci - dd);
}
function getOutlets(commands) {
  if (isCommandWithOutlets(commands[0])) {
    return commands[0].outlets;
  }
  return {
    [PRIMARY_OUTLET]: commands
  };
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
  segmentGroup ??= new UrlSegmentGroup([], {});
  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
  }
  const m = prefixedWith(segmentGroup, startIndex, commands);
  const slicedCommands = commands.slice(m.commandIndex);
  if (m.match && m.pathIndex < segmentGroup.segments.length) {
    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
    return updateSegmentGroupChildren(g, 0, slicedCommands);
  } else if (m.match && slicedCommands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else if (m.match && !segmentGroup.hasChildren()) {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  } else if (m.match) {
    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
  } else {
    return createNewSegmentGroup(segmentGroup, startIndex, commands);
  }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
  if (commands.length === 0) {
    return new UrlSegmentGroup(segmentGroup.segments, {});
  } else {
    const outlets = getOutlets(commands);
    const children = {};
    if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {
      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);
      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);
    }
    Object.entries(outlets).forEach(([outlet, commands2]) => {
      if (typeof commands2 === "string") {
        commands2 = [commands2];
      }
      if (commands2 !== null) {
        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);
      }
    });
    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {
      if (outlets[childOutlet] === void 0) {
        children[childOutlet] = child;
      }
    });
    return new UrlSegmentGroup(segmentGroup.segments, children);
  }
}
function prefixedWith(segmentGroup, startIndex, commands) {
  let currentCommandIndex = 0;
  let currentPathIndex = startIndex;
  const noMatch = {
    match: false,
    pathIndex: 0,
    commandIndex: 0
  };
  while (currentPathIndex < segmentGroup.segments.length) {
    if (currentCommandIndex >= commands.length) return noMatch;
    const path = segmentGroup.segments[currentPathIndex];
    const command = commands[currentCommandIndex];
    if (isCommandWithOutlets(command)) {
      break;
    }
    const curr = `${command}`;
    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
    if (currentPathIndex > 0 && curr === void 0) break;
    if (curr && next && typeof next === "object" && next.outlets === void 0) {
      if (!compare(curr, next, path)) return noMatch;
      currentCommandIndex += 2;
    } else {
      if (!compare(curr, {}, path)) return noMatch;
      currentCommandIndex++;
    }
    currentPathIndex++;
  }
  return {
    match: true,
    pathIndex: currentPathIndex,
    commandIndex: currentCommandIndex
  };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
  const paths = segmentGroup.segments.slice(0, startIndex);
  let i = 0;
  while (i < commands.length) {
    const command = commands[i];
    if (isCommandWithOutlets(command)) {
      const children = createNewSegmentChildren(command.outlets);
      return new UrlSegmentGroup(paths, children);
    }
    if (i === 0 && isMatrixParams(commands[0])) {
      const p = segmentGroup.segments[startIndex];
      paths.push(new UrlSegment(p.path, stringify(commands[0])));
      i++;
      continue;
    }
    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;
    const next = i < commands.length - 1 ? commands[i + 1] : null;
    if (curr && next && isMatrixParams(next)) {
      paths.push(new UrlSegment(curr, stringify(next)));
      i += 2;
    } else {
      paths.push(new UrlSegment(curr, {}));
      i++;
    }
  }
  return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
  const children = {};
  Object.entries(outlets).forEach(([outlet, commands]) => {
    if (typeof commands === "string") {
      commands = [commands];
    }
    if (commands !== null) {
      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
    }
  });
  return children;
}
function stringify(params) {
  const res = {};
  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);
  return res;
}
function compare(path, params, segment) {
  return path == segment.path && shallowEqual2(params, segment.parameters);
}
var IMPERATIVE_NAVIGATION = "imperative";
var EventType;
(function(EventType2) {
  EventType2[EventType2["NavigationStart"] = 0] = "NavigationStart";
  EventType2[EventType2["NavigationEnd"] = 1] = "NavigationEnd";
  EventType2[EventType2["NavigationCancel"] = 2] = "NavigationCancel";
  EventType2[EventType2["NavigationError"] = 3] = "NavigationError";
  EventType2[EventType2["RoutesRecognized"] = 4] = "RoutesRecognized";
  EventType2[EventType2["ResolveStart"] = 5] = "ResolveStart";
  EventType2[EventType2["ResolveEnd"] = 6] = "ResolveEnd";
  EventType2[EventType2["GuardsCheckStart"] = 7] = "GuardsCheckStart";
  EventType2[EventType2["GuardsCheckEnd"] = 8] = "GuardsCheckEnd";
  EventType2[EventType2["RouteConfigLoadStart"] = 9] = "RouteConfigLoadStart";
  EventType2[EventType2["RouteConfigLoadEnd"] = 10] = "RouteConfigLoadEnd";
  EventType2[EventType2["ChildActivationStart"] = 11] = "ChildActivationStart";
  EventType2[EventType2["ChildActivationEnd"] = 12] = "ChildActivationEnd";
  EventType2[EventType2["ActivationStart"] = 13] = "ActivationStart";
  EventType2[EventType2["ActivationEnd"] = 14] = "ActivationEnd";
  EventType2[EventType2["Scroll"] = 15] = "Scroll";
  EventType2[EventType2["NavigationSkipped"] = 16] = "NavigationSkipped";
})(EventType || (EventType = {}));
var RouterEvent = class {
  id;
  url;
  constructor(id, url) {
    this.id = id;
    this.url = url;
  }
};
var NavigationStart = class extends RouterEvent {
  type = EventType.NavigationStart;
  navigationTrigger;
  restoredState;
  constructor(id, url, navigationTrigger = "imperative", restoredState = null) {
    super(id, url);
    this.navigationTrigger = navigationTrigger;
    this.restoredState = restoredState;
  }
  toString() {
    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationEnd = class extends RouterEvent {
  urlAfterRedirects;
  type = EventType.NavigationEnd;
  constructor(id, url, urlAfterRedirects) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
  }
  toString() {
    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
  }
};
var NavigationCancellationCode;
(function(NavigationCancellationCode2) {
  NavigationCancellationCode2[NavigationCancellationCode2["Redirect"] = 0] = "Redirect";
  NavigationCancellationCode2[NavigationCancellationCode2["SupersededByNewNavigation"] = 1] = "SupersededByNewNavigation";
  NavigationCancellationCode2[NavigationCancellationCode2["NoDataFromResolver"] = 2] = "NoDataFromResolver";
  NavigationCancellationCode2[NavigationCancellationCode2["GuardRejected"] = 3] = "GuardRejected";
  NavigationCancellationCode2[NavigationCancellationCode2["Aborted"] = 4] = "Aborted";
})(NavigationCancellationCode || (NavigationCancellationCode = {}));
var NavigationSkippedCode;
(function(NavigationSkippedCode2) {
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredSameUrlNavigation"] = 0] = "IgnoredSameUrlNavigation";
  NavigationSkippedCode2[NavigationSkippedCode2["IgnoredByUrlHandlingStrategy"] = 1] = "IgnoredByUrlHandlingStrategy";
})(NavigationSkippedCode || (NavigationSkippedCode = {}));
var NavigationCancel = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationCancel;
  constructor(id, url, reason, code2) {
    super(id, url);
    this.reason = reason;
    this.code = code2;
  }
  toString() {
    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
  }
};
var NavigationSkipped = class extends RouterEvent {
  reason;
  code;
  type = EventType.NavigationSkipped;
  constructor(id, url, reason, code2) {
    super(id, url);
    this.reason = reason;
    this.code = code2;
  }
};
var NavigationError = class extends RouterEvent {
  error;
  target;
  type = EventType.NavigationError;
  constructor(id, url, error, target) {
    super(id, url);
    this.error = error;
    this.target = target;
  }
  toString() {
    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
  }
};
var RoutesRecognized = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.RoutesRecognized;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.GuardsCheckStart;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var GuardsCheckEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  shouldActivate;
  type = EventType.GuardsCheckEnd;
  constructor(id, url, urlAfterRedirects, state2, shouldActivate) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
    this.shouldActivate = shouldActivate;
  }
  toString() {
    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
  }
};
var ResolveStart = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveStart;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var ResolveEnd = class extends RouterEvent {
  urlAfterRedirects;
  state;
  type = EventType.ResolveEnd;
  constructor(id, url, urlAfterRedirects, state2) {
    super(id, url);
    this.urlAfterRedirects = urlAfterRedirects;
    this.state = state2;
  }
  toString() {
    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
  }
};
var RouteConfigLoadStart = class {
  route;
  type = EventType.RouteConfigLoadStart;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadStart(path: ${this.route.path})`;
  }
};
var RouteConfigLoadEnd = class {
  route;
  type = EventType.RouteConfigLoadEnd;
  constructor(route) {
    this.route = route;
  }
  toString() {
    return `RouteConfigLoadEnd(path: ${this.route.path})`;
  }
};
var ChildActivationStart = class {
  snapshot;
  type = EventType.ChildActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationStart(path: '${path}')`;
  }
};
var ChildActivationEnd = class {
  snapshot;
  type = EventType.ChildActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ChildActivationEnd(path: '${path}')`;
  }
};
var ActivationStart = class {
  snapshot;
  type = EventType.ActivationStart;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationStart(path: '${path}')`;
  }
};
var ActivationEnd = class {
  snapshot;
  type = EventType.ActivationEnd;
  constructor(snapshot) {
    this.snapshot = snapshot;
  }
  toString() {
    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || "";
    return `ActivationEnd(path: '${path}')`;
  }
};
var Scroll = class {
  routerEvent;
  position;
  anchor;
  type = EventType.Scroll;
  constructor(routerEvent, position, anchor) {
    this.routerEvent = routerEvent;
    this.position = position;
    this.anchor = anchor;
  }
  toString() {
    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;
    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;
  }
};
var BeforeActivateRoutes = class {
};
var RedirectRequest = class {
  url;
  navigationBehaviorOptions;
  constructor(url, navigationBehaviorOptions) {
    this.url = url;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
function isPublicRouterEvent(e) {
  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);
}
function stringifyEvent(routerEvent) {
  switch (routerEvent.type) {
    case EventType.ActivationEnd:
      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ActivationStart:
      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationEnd:
      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.ChildActivationStart:
      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || ""}')`;
    case EventType.GuardsCheckEnd:
      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;
    case EventType.GuardsCheckStart:
      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.NavigationCancel:
      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationSkipped:
      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.NavigationEnd:
      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;
    case EventType.NavigationError:
      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;
    case EventType.NavigationStart:
      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;
    case EventType.ResolveEnd:
      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.ResolveStart:
      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.RouteConfigLoadEnd:
      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;
    case EventType.RouteConfigLoadStart:
      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;
    case EventType.RoutesRecognized:
      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;
    case EventType.Scroll:
      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;
      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;
  }
}
function getOrCreateRouteInjectorIfNeeded(route, currentInjector) {
  if (route.providers && !route._injector) {
    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);
  }
  return route._injector ?? currentInjector;
}
function validateConfig(config2, parentPath = "", requireStandaloneComponents = false) {
  for (let i = 0; i < config2.length; i++) {
    const route = config2[i];
    const fullPath = getFullPath(parentPath, route);
    validateNode(route, fullPath, requireStandaloneComponents);
  }
}
function assertStandalone(fullPath, component) {
  if (component && isNgModule(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);
  } else if (component && !isStandalone(component)) {
    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);
  }
}
function validateNode(route, fullPath, requireStandaloneComponents) {
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    if (!route) {
      throw new RuntimeError(4014, `
      Invalid configuration of route '${fullPath}': Encountered undefined route.
      The reason might be an extra comma.

      Example:
      const routes: Routes = [
        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },
        { path: 'dashboard',  component: DashboardComponent },, << two commas
        { path: 'detail/:id', component: HeroDetailComponent }
      ];
    `);
    }
    if (Array.isArray(route)) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);
    }
    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);
    }
    if (route.redirectTo && route.children) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);
    }
    if (route.redirectTo && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);
    }
    if (route.children && route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);
    }
    if (route.component && route.loadComponent) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);
    }
    if (route.redirectTo) {
      if (route.component || route.loadComponent) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);
      }
      if (route.canMatch || route.canActivate) {
        throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and ${route.canMatch ? "canMatch" : "canActivate"} cannot be used together.Redirects happen before guards are executed.`);
      }
    }
    if (route.path && route.matcher) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);
    }
    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);
    }
    if (route.path === void 0 && route.matcher === void 0) {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);
    }
    if (typeof route.path === "string" && route.path.charAt(0) === "/") {
      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);
    }
    if (route.path === "" && route.redirectTo !== void 0 && route.pathMatch === void 0) {
      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;
      throw new RuntimeError(4014, `Invalid configuration of route '{path: "${fullPath}", redirectTo: "${route.redirectTo}"}': please provide 'pathMatch'. ${exp}`);
    }
    if (requireStandaloneComponents) {
      assertStandalone(fullPath, route.component);
    }
  }
  if (route.children) {
    validateConfig(route.children, fullPath, requireStandaloneComponents);
  }
}
function getFullPath(parentPath, currentRoute) {
  if (!currentRoute) {
    return parentPath;
  }
  if (!parentPath && !currentRoute.path) {
    return "";
  } else if (parentPath && !currentRoute.path) {
    return `${parentPath}/`;
  } else if (!parentPath && currentRoute.path) {
    return currentRoute.path;
  } else {
    return `${parentPath}/${currentRoute.path}`;
  }
}
function getOutlet(route) {
  return route.outlet || PRIMARY_OUTLET;
}
function sortByMatchingOutlets(routes3, outletName) {
  const sortedConfig = routes3.filter((r) => getOutlet(r) === outletName);
  sortedConfig.push(...routes3.filter((r) => getOutlet(r) !== outletName));
  return sortedConfig;
}
function getClosestRouteInjector(snapshot) {
  if (!snapshot) return null;
  if (snapshot.routeConfig?._injector) {
    return snapshot.routeConfig._injector;
  }
  for (let s = snapshot.parent; s; s = s.parent) {
    const route = s.routeConfig;
    if (route?._loadedInjector) return route._loadedInjector;
    if (route?._injector) return route._injector;
  }
  return null;
}
var OutletContext = class {
  rootInjector;
  outlet = null;
  route = null;
  children;
  attachRef = null;
  get injector() {
    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;
  }
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
    this.children = new ChildrenOutletContexts(this.rootInjector);
  }
};
var ChildrenOutletContexts = class _ChildrenOutletContexts {
  rootInjector;
  contexts = /* @__PURE__ */ new Map();
  constructor(rootInjector) {
    this.rootInjector = rootInjector;
  }
  onChildOutletCreated(childName, outlet) {
    const context = this.getOrCreateContext(childName);
    context.outlet = outlet;
    this.contexts.set(childName, context);
  }
  onChildOutletDestroyed(childName) {
    const context = this.getContext(childName);
    if (context) {
      context.outlet = null;
      context.attachRef = null;
    }
  }
  onOutletDeactivated() {
    const contexts = this.contexts;
    this.contexts = /* @__PURE__ */ new Map();
    return contexts;
  }
  onOutletReAttached(contexts) {
    this.contexts = contexts;
  }
  getOrCreateContext(childName) {
    let context = this.getContext(childName);
    if (!context) {
      context = new OutletContext(this.rootInjector);
      this.contexts.set(childName, context);
    }
    return context;
  }
  getContext(childName) {
    return this.contexts.get(childName) || null;
  }
  static \u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _ChildrenOutletContexts)(\u0275\u0275inject(EnvironmentInjector));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _ChildrenOutletContexts,
    factory: _ChildrenOutletContexts.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: EnvironmentInjector
  }], null);
})();
var Tree = class {
  _root;
  constructor(root) {
    this._root = root;
  }
  get root() {
    return this._root.value;
  }
  parent(t) {
    const p = this.pathFromRoot(t);
    return p.length > 1 ? p[p.length - 2] : null;
  }
  children(t) {
    const n = findNode(t, this._root);
    return n ? n.children.map((t2) => t2.value) : [];
  }
  firstChild(t) {
    const n = findNode(t, this._root);
    return n && n.children.length > 0 ? n.children[0].value : null;
  }
  siblings(t) {
    const p = findPath(t, this._root);
    if (p.length < 2) return [];
    const c = p[p.length - 2].children.map((c2) => c2.value);
    return c.filter((cc) => cc !== t);
  }
  pathFromRoot(t) {
    return findPath(t, this._root).map((s) => s.value);
  }
};
function findNode(value, node) {
  if (value === node.value) return node;
  for (const child of node.children) {
    const node2 = findNode(value, child);
    if (node2) return node2;
  }
  return null;
}
function findPath(value, node) {
  if (value === node.value) return [node];
  for (const child of node.children) {
    const path = findPath(value, child);
    if (path.length) {
      path.unshift(node);
      return path;
    }
  }
  return [];
}
var TreeNode = class {
  value;
  children;
  constructor(value, children) {
    this.value = value;
    this.children = children;
  }
  toString() {
    return `TreeNode(${this.value})`;
  }
};
function nodeChildrenAsMap(node) {
  const map2 = {};
  if (node) {
    node.children.forEach((child) => map2[child.value.outlet] = child);
  }
  return map2;
}
var RouterState = class extends Tree {
  snapshot;
  constructor(root, snapshot) {
    super(root);
    this.snapshot = snapshot;
    setRouterState(this, root);
  }
  toString() {
    return this.snapshot.toString();
  }
};
function createEmptyState(rootComponent) {
  const snapshot = createEmptyStateSnapshot(rootComponent);
  const emptyUrl = new BehaviorSubject([new UrlSegment("", {})]);
  const emptyParams = new BehaviorSubject({});
  const emptyData = new BehaviorSubject({});
  const emptyQueryParams = new BehaviorSubject({});
  const fragment = new BehaviorSubject("");
  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
  activated.snapshot = snapshot.root;
  return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(rootComponent) {
  const emptyParams = {};
  const emptyData = {};
  const emptyQueryParams = {};
  const fragment = "";
  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});
  return new RouterStateSnapshot("", new TreeNode(activated, []));
}
var ActivatedRoute = class {
  urlSubject;
  paramsSubject;
  queryParamsSubject;
  fragmentSubject;
  dataSubject;
  outlet;
  component;
  snapshot;
  _futureSnapshot;
  _routerState;
  _paramMap;
  _queryParamMap;
  title;
  url;
  params;
  queryParams;
  fragment;
  data;
  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {
    this.urlSubject = urlSubject;
    this.paramsSubject = paramsSubject;
    this.queryParamsSubject = queryParamsSubject;
    this.fragmentSubject = fragmentSubject;
    this.dataSubject = dataSubject;
    this.outlet = outlet;
    this.component = component;
    this._futureSnapshot = futureSnapshot;
    this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(void 0);
    this.url = urlSubject;
    this.params = paramsSubject;
    this.queryParams = queryParamsSubject;
    this.fragment = fragmentSubject;
    this.data = dataSubject;
  }
  get routeConfig() {
    return this._futureSnapshot.routeConfig;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));
    return this._queryParamMap;
  }
  toString() {
    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;
  }
};
function getInherited(route, parent, paramsInheritanceStrategy = "emptyOnly") {
  let inherited;
  const {
    routeConfig
  } = route;
  if (parent !== null && (paramsInheritanceStrategy === "always" || routeConfig?.path === "" || !parent.component && !parent.routeConfig?.loadComponent)) {
    inherited = {
      params: __spreadValues(__spreadValues({}, parent.params), route.params),
      data: __spreadValues(__spreadValues({}, parent.data), route.data),
      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)
    };
  } else {
    inherited = {
      params: __spreadValues({}, route.params),
      data: __spreadValues({}, route.data),
      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})
    };
  }
  if (routeConfig && hasStaticTitle(routeConfig)) {
    inherited.resolve[RouteTitleKey] = routeConfig.title;
  }
  return inherited;
}
var ActivatedRouteSnapshot = class {
  url;
  params;
  queryParams;
  fragment;
  data;
  outlet;
  component;
  routeConfig;
  _resolve;
  _resolvedData;
  _routerState;
  _paramMap;
  _queryParamMap;
  get title() {
    return this.data?.[RouteTitleKey];
  }
  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {
    this.url = url;
    this.params = params;
    this.queryParams = queryParams;
    this.fragment = fragment;
    this.data = data;
    this.outlet = outlet;
    this.component = component;
    this.routeConfig = routeConfig;
    this._resolve = resolve;
  }
  get root() {
    return this._routerState.root;
  }
  get parent() {
    return this._routerState.parent(this);
  }
  get firstChild() {
    return this._routerState.firstChild(this);
  }
  get children() {
    return this._routerState.children(this);
  }
  get pathFromRoot() {
    return this._routerState.pathFromRoot(this);
  }
  get paramMap() {
    this._paramMap ??= convertToParamMap(this.params);
    return this._paramMap;
  }
  get queryParamMap() {
    this._queryParamMap ??= convertToParamMap(this.queryParams);
    return this._queryParamMap;
  }
  toString() {
    const url = this.url.map((segment) => segment.toString()).join("/");
    const matched = this.routeConfig ? this.routeConfig.path : "";
    return `Route(url:'${url}', path:'${matched}')`;
  }
};
var RouterStateSnapshot = class extends Tree {
  url;
  constructor(url, root) {
    super(root);
    this.url = url;
    setRouterState(this, root);
  }
  toString() {
    return serializeNode(this._root);
  }
};
function setRouterState(state2, node) {
  node.value._routerState = state2;
  node.children.forEach((c) => setRouterState(state2, c));
}
function serializeNode(node) {
  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(", ")} } ` : "";
  return `${node.value}${c}`;
}
function advanceActivatedRoute(route) {
  if (route.snapshot) {
    const currentSnapshot = route.snapshot;
    const nextSnapshot = route._futureSnapshot;
    route.snapshot = nextSnapshot;
    if (!shallowEqual2(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
      route.queryParamsSubject.next(nextSnapshot.queryParams);
    }
    if (currentSnapshot.fragment !== nextSnapshot.fragment) {
      route.fragmentSubject.next(nextSnapshot.fragment);
    }
    if (!shallowEqual2(currentSnapshot.params, nextSnapshot.params)) {
      route.paramsSubject.next(nextSnapshot.params);
    }
    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
      route.urlSubject.next(nextSnapshot.url);
    }
    if (!shallowEqual2(currentSnapshot.data, nextSnapshot.data)) {
      route.dataSubject.next(nextSnapshot.data);
    }
  } else {
    route.snapshot = route._futureSnapshot;
    route.dataSubject.next(route._futureSnapshot.data);
  }
}
function equalParamsAndUrlSegments(a, b) {
  const equalUrlParams = shallowEqual2(a.params, b.params) && equalSegments(a.url, b.url);
  const parentsMismatch = !a.parent !== !b.parent;
  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}
function hasStaticTitle(config2) {
  return typeof config2.title === "string" || config2.title === null;
}
var ROUTER_OUTLET_DATA = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "RouterOutlet data" : "");
var RouterOutlet = class _RouterOutlet {
  activated = null;
  get activatedComponentRef() {
    return this.activated;
  }
  _activatedRoute = null;
  name = PRIMARY_OUTLET;
  activateEvents = new EventEmitter();
  deactivateEvents = new EventEmitter();
  attachEvents = new EventEmitter();
  detachEvents = new EventEmitter();
  routerOutletData = input(...ngDevMode ? [void 0, {
    debugName: "routerOutletData"
  }] : []);
  parentContexts = inject(ChildrenOutletContexts);
  location = inject(ViewContainerRef);
  changeDetector = inject(ChangeDetectorRef);
  inputBinder = inject(INPUT_BINDER, {
    optional: true
  });
  supportsBindingToComponentInputs = true;
  ngOnChanges(changes) {
    if (changes["name"]) {
      const {
        firstChange,
        previousValue
      } = changes["name"];
      if (firstChange) {
        return;
      }
      if (this.isTrackedInParentContexts(previousValue)) {
        this.deactivate();
        this.parentContexts.onChildOutletDestroyed(previousValue);
      }
      this.initializeOutletWithName();
    }
  }
  ngOnDestroy() {
    if (this.isTrackedInParentContexts(this.name)) {
      this.parentContexts.onChildOutletDestroyed(this.name);
    }
    this.inputBinder?.unsubscribeFromRouteData(this);
  }
  isTrackedInParentContexts(outletName) {
    return this.parentContexts.getContext(outletName)?.outlet === this;
  }
  ngOnInit() {
    this.initializeOutletWithName();
  }
  initializeOutletWithName() {
    this.parentContexts.onChildOutletCreated(this.name, this);
    if (this.activated) {
      return;
    }
    const context = this.parentContexts.getContext(this.name);
    if (context?.route) {
      if (context.attachRef) {
        this.attach(context.attachRef, context.route);
      } else {
        this.activateWith(context.route, context.injector);
      }
    }
  }
  get isActivated() {
    return !!this.activated;
  }
  get component() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this.activated.instance;
  }
  get activatedRoute() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    return this._activatedRoute;
  }
  get activatedRouteData() {
    if (this._activatedRoute) {
      return this._activatedRoute.snapshot.data;
    }
    return {};
  }
  detach() {
    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === "undefined" || ngDevMode) && "Outlet is not activated");
    this.location.detach();
    const cmp = this.activated;
    this.activated = null;
    this._activatedRoute = null;
    this.detachEvents.emit(cmp.instance);
    return cmp;
  }
  attach(ref, activatedRoute) {
    this.activated = ref;
    this._activatedRoute = activatedRoute;
    this.location.insert(ref.hostView);
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.attachEvents.emit(ref.instance);
  }
  deactivate() {
    if (this.activated) {
      const c = this.component;
      this.activated.destroy();
      this.activated = null;
      this._activatedRoute = null;
      this.deactivateEvents.emit(c);
    }
  }
  activateWith(activatedRoute, environmentInjector) {
    if (this.isActivated) {
      throw new RuntimeError(4013, (typeof ngDevMode === "undefined" || ngDevMode) && "Cannot activate an already activated outlet");
    }
    this._activatedRoute = activatedRoute;
    const location2 = this.location;
    const snapshot = activatedRoute.snapshot;
    const component = snapshot.component;
    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;
    const injector = new OutletInjector(activatedRoute, childContexts, location2.injector, this.routerOutletData);
    this.activated = location2.createComponent(component, {
      index: location2.length,
      injector,
      environmentInjector
    });
    this.changeDetector.markForCheck();
    this.inputBinder?.bindActivatedRouteToOutletComponent(this);
    this.activateEvents.emit(this.activated.instance);
  }
  static \u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterOutlet)();
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterOutlet,
    selectors: [["router-outlet"]],
    inputs: {
      name: "name",
      routerOutletData: [1, "routerOutletData"]
    },
    outputs: {
      activateEvents: "activate",
      deactivateEvents: "deactivate",
      attachEvents: "attach",
      detachEvents: "detach"
    },
    exportAs: ["outlet"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterOutlet, [{
    type: Directive,
    args: [{
      selector: "router-outlet",
      exportAs: "outlet"
    }]
  }], null, {
    name: [{
      type: Input
    }],
    activateEvents: [{
      type: Output,
      args: ["activate"]
    }],
    deactivateEvents: [{
      type: Output,
      args: ["deactivate"]
    }],
    attachEvents: [{
      type: Output,
      args: ["attach"]
    }],
    detachEvents: [{
      type: Output,
      args: ["detach"]
    }],
    routerOutletData: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "routerOutletData",
        required: false
      }]
    }]
  });
})();
var OutletInjector = class {
  route;
  childContexts;
  parent;
  outletData;
  constructor(route, childContexts, parent, outletData) {
    this.route = route;
    this.childContexts = childContexts;
    this.parent = parent;
    this.outletData = outletData;
  }
  get(token, notFoundValue) {
    if (token === ActivatedRoute) {
      return this.route;
    }
    if (token === ChildrenOutletContexts) {
      return this.childContexts;
    }
    if (token === ROUTER_OUTLET_DATA) {
      return this.outletData;
    }
    return this.parent.get(token, notFoundValue);
  }
};
var INPUT_BINDER = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "Router Input Binder" : "");
var RoutedComponentInputBinder = class _RoutedComponentInputBinder {
  outletDataSubscriptions = /* @__PURE__ */ new Map();
  bindActivatedRouteToOutletComponent(outlet) {
    this.unsubscribeFromRouteData(outlet);
    this.subscribeToRouteData(outlet);
  }
  unsubscribeFromRouteData(outlet) {
    this.outletDataSubscriptions.get(outlet)?.unsubscribe();
    this.outletDataSubscriptions.delete(outlet);
  }
  subscribeToRouteData(outlet) {
    const {
      activatedRoute
    } = outlet;
    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index2) => {
      data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);
      if (index2 === 0) {
        return of(data);
      }
      return Promise.resolve(data);
    })).subscribe((data) => {
      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      const mirror = reflectComponentType(activatedRoute.component);
      if (!mirror) {
        this.unsubscribeFromRouteData(outlet);
        return;
      }
      for (const {
        templateName
      } of mirror.inputs) {
        outlet.activatedComponentRef.setInput(templateName, data[templateName]);
      }
    });
    this.outletDataSubscriptions.set(outlet, dataSubscription);
  }
  static \u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RoutedComponentInputBinder)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RoutedComponentInputBinder,
    factory: _RoutedComponentInputBinder.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{
    type: Injectable
  }], null, null);
})();
var \u0275EmptyOutletComponent = class _\u0275EmptyOutletComponent {
  static \u0275fac = function \u0275EmptyOutletComponent_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _\u0275EmptyOutletComponent)();
  };
  static \u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
    type: _\u0275EmptyOutletComponent,
    selectors: [["ng-component"]],
    exportAs: ["emptyRouterOutlet"],
    decls: 1,
    vars: 0,
    template: function _EmptyOutletComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "router-outlet");
      }
    },
    dependencies: [RouterOutlet],
    encapsulation: 2
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(\u0275EmptyOutletComponent, [{
    type: Component,
    args: [{
      template: `<router-outlet />`,
      imports: [RouterOutlet],
      exportAs: "emptyRouterOutlet"
    }]
  }], null, null);
})();
function standardizeConfig(r) {
  const children = r.children && r.children.map(standardizeConfig);
  const c = children ? __spreadProps(__spreadValues({}, r), {
    children
  }) : __spreadValues({}, r);
  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {
    c.component = \u0275EmptyOutletComponent;
  }
  return c;
}
function createRouterState(routeReuseStrategy, curr, prevState) {
  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);
  return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
    const value = prevState.value;
    value._futureSnapshot = curr.value;
    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
    return new TreeNode(value, children);
  } else {
    if (routeReuseStrategy.shouldAttach(curr.value)) {
      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
      if (detachedRouteHandle !== null) {
        const tree2 = detachedRouteHandle.route;
        tree2.value._futureSnapshot = curr.value;
        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));
        return tree2;
      }
    }
    const value = createActivatedRoute(curr.value);
    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));
    return new TreeNode(value, children);
  }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
  return curr.children.map((child) => {
    for (const p of prevState.children) {
      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {
        return createNode(routeReuseStrategy, child, p);
      }
    }
    return createNode(routeReuseStrategy, child);
  });
}
function createActivatedRoute(c) {
  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
}
var RedirectCommand = class {
  redirectTo;
  navigationBehaviorOptions;
  constructor(redirectTo, navigationBehaviorOptions) {
    this.redirectTo = redirectTo;
    this.navigationBehaviorOptions = navigationBehaviorOptions;
  }
};
var NAVIGATION_CANCELING_ERROR = "ngNavigationCancelingError";
function redirectingNavigationError(urlSerializer, redirect) {
  const {
    redirectTo,
    navigationBehaviorOptions
  } = isUrlTree(redirect) ? {
    redirectTo: redirect,
    navigationBehaviorOptions: void 0
  } : redirect;
  const error = navigationCancelingError(ngDevMode && `Redirecting to "${urlSerializer.serialize(redirectTo)}"`, NavigationCancellationCode.Redirect);
  error.url = redirectTo;
  error.navigationBehaviorOptions = navigationBehaviorOptions;
  return error;
}
function navigationCancelingError(message, code2) {
  const error = new Error(`NavigationCancelingError: ${message || ""}`);
  error[NAVIGATION_CANCELING_ERROR] = true;
  error.cancellationCode = code2;
  return error;
}
function isRedirectingNavigationCancelingError(error) {
  return isNavigationCancelingError(error) && isUrlTree(error.url);
}
function isNavigationCancelingError(error) {
  return !!error && error[NAVIGATION_CANCELING_ERROR];
}
var warnedAboutUnsupportedInputBinding = false;
var activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {
  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);
  return t;
});
var ActivateRoutes = class {
  routeReuseStrategy;
  futureState;
  currState;
  forwardEvent;
  inputBindingEnabled;
  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {
    this.routeReuseStrategy = routeReuseStrategy;
    this.futureState = futureState;
    this.currState = currState;
    this.forwardEvent = forwardEvent;
    this.inputBindingEnabled = inputBindingEnabled;
  }
  activate(parentContexts) {
    const futureRoot = this.futureState._root;
    const currRoot = this.currState ? this.currState._root : null;
    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
    advanceActivatedRoute(this.futureState.root);
    this.activateChildRoutes(futureRoot, currRoot, parentContexts);
  }
  deactivateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((futureChild) => {
      const childOutletName = futureChild.value.outlet;
      this.deactivateRoutes(futureChild, children[childOutletName], contexts);
      delete children[childOutletName];
    });
    Object.values(children).forEach((v) => {
      this.deactivateRouteAndItsChildren(v, contexts);
    });
  }
  deactivateRoutes(futureNode, currNode, parentContext) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    if (future === curr) {
      if (future.component) {
        const context = parentContext.getContext(future.outlet);
        if (context) {
          this.deactivateChildRoutes(futureNode, currNode, context.children);
        }
      } else {
        this.deactivateChildRoutes(futureNode, currNode, parentContext);
      }
    } else {
      if (curr) {
        this.deactivateRouteAndItsChildren(currNode, parentContext);
      }
    }
  }
  deactivateRouteAndItsChildren(route, parentContexts) {
    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
      this.detachAndStoreRouteSubtree(route, parentContexts);
    } else {
      this.deactivateRouteAndOutlet(route, parentContexts);
    }
  }
  detachAndStoreRouteSubtree(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context && context.outlet) {
      const componentRef = context.outlet.detach();
      const contexts2 = context.children.onOutletDeactivated();
      this.routeReuseStrategy.store(route.value.snapshot, {
        componentRef,
        route,
        contexts: contexts2
      });
    }
  }
  deactivateRouteAndOutlet(route, parentContexts) {
    const context = parentContexts.getContext(route.value.outlet);
    const contexts = context && route.value.component ? context.children : parentContexts;
    const children = nodeChildrenAsMap(route);
    for (const treeNode of Object.values(children)) {
      this.deactivateRouteAndItsChildren(treeNode, contexts);
    }
    if (context) {
      if (context.outlet) {
        context.outlet.deactivate();
        context.children.onOutletDeactivated();
      }
      context.attachRef = null;
      context.route = null;
    }
  }
  activateChildRoutes(futureNode, currNode, contexts) {
    const children = nodeChildrenAsMap(currNode);
    futureNode.children.forEach((c) => {
      this.activateRoutes(c, children[c.value.outlet], contexts);
      this.forwardEvent(new ActivationEnd(c.value.snapshot));
    });
    if (futureNode.children.length) {
      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
    }
  }
  activateRoutes(futureNode, currNode, parentContexts) {
    const future = futureNode.value;
    const curr = currNode ? currNode.value : null;
    advanceActivatedRoute(future);
    if (future === curr) {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        this.activateChildRoutes(futureNode, currNode, context.children);
      } else {
        this.activateChildRoutes(futureNode, currNode, parentContexts);
      }
    } else {
      if (future.component) {
        const context = parentContexts.getOrCreateContext(future.outlet);
        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
          const stored = this.routeReuseStrategy.retrieve(future.snapshot);
          this.routeReuseStrategy.store(future.snapshot, null);
          context.children.onOutletReAttached(stored.contexts);
          context.attachRef = stored.componentRef;
          context.route = stored.route.value;
          if (context.outlet) {
            context.outlet.attach(stored.componentRef, stored.route.value);
          }
          advanceActivatedRoute(stored.route.value);
          this.activateChildRoutes(futureNode, null, context.children);
        } else {
          context.attachRef = null;
          context.route = future;
          if (context.outlet) {
            context.outlet.activateWith(future, context.injector);
          }
          this.activateChildRoutes(futureNode, null, context.children);
        }
      } else {
        this.activateChildRoutes(futureNode, null, parentContexts);
      }
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const context = parentContexts.getOrCreateContext(future.outlet);
      const outlet = context.outlet;
      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {
        console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);
        warnedAboutUnsupportedInputBinding = true;
      }
    }
  }
};
var CanActivate = class {
  path;
  route;
  constructor(path) {
    this.path = path;
    this.route = this.path[this.path.length - 1];
  }
};
var CanDeactivate = class {
  component;
  route;
  constructor(component, route) {
    this.component = component;
    this.route = route;
  }
};
function getAllRouteGuards(future, curr, parentContexts) {
  const futureRoot = future._root;
  const currRoot = curr ? curr._root : null;
  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
  if (!canActivateChild || canActivateChild.length === 0) return null;
  return {
    node: p,
    guards: canActivateChild
  };
}
function getTokenOrFunctionIdentity(tokenOrFunction, injector) {
  const NOT_FOUND = Symbol();
  const result = injector.get(tokenOrFunction, NOT_FOUND);
  if (result === NOT_FOUND) {
    if (typeof tokenOrFunction === "function" && !isInjectable(tokenOrFunction)) {
      return tokenOrFunction;
    } else {
      return injector.get(tokenOrFunction);
    }
  }
  return result;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const prevChildren = nodeChildrenAsMap(currNode);
  futureNode.children.forEach((c) => {
    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
    delete prevChildren[c.value.outlet];
  });
  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));
  return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {
  canDeactivateChecks: [],
  canActivateChecks: []
}) {
  const future = futureNode.value;
  const curr = currNode ? currNode.value : null;
  const context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
  if (curr && future.routeConfig === curr.routeConfig) {
    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
    if (shouldRun) {
      checks.canActivateChecks.push(new CanActivate(futurePath));
    } else {
      future.data = curr.data;
      future._resolvedData = curr._resolvedData;
    }
    if (future.component) {
      getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
    }
    if (shouldRun && context && context.outlet && context.outlet.isActivated) {
      checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, curr));
    }
  } else {
    if (curr) {
      deactivateRouteAndItsChildren(currNode, context, checks);
    }
    checks.canActivateChecks.push(new CanActivate(futurePath));
    if (future.component) {
      getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
    } else {
      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
    }
  }
  return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
  if (typeof mode === "function") {
    return mode(curr, future);
  }
  switch (mode) {
    case "pathParamsChange":
      return !equalPath(curr.url, future.url);
    case "pathParamsOrQueryParamsChange":
      return !equalPath(curr.url, future.url) || !shallowEqual2(curr.queryParams, future.queryParams);
    case "always":
      return true;
    case "paramsOrQueryParamsChange":
      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual2(curr.queryParams, future.queryParams);
    case "paramsChange":
    default:
      return !equalParamsAndUrlSegments(curr, future);
  }
}
function deactivateRouteAndItsChildren(route, context, checks) {
  const children = nodeChildrenAsMap(route);
  const r = route.value;
  Object.entries(children).forEach(([childName, node]) => {
    if (!r.component) {
      deactivateRouteAndItsChildren(node, context, checks);
    } else if (context) {
      deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
    } else {
      deactivateRouteAndItsChildren(node, null, checks);
    }
  });
  if (!r.component) {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  } else if (context && context.outlet && context.outlet.isActivated) {
    checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
  } else {
    checks.canDeactivateChecks.push(new CanDeactivate(null, r));
  }
}
function isFunction2(v) {
  return typeof v === "function";
}
function isBoolean2(v) {
  return typeof v === "boolean";
}
function isCanLoad(guard) {
  return guard && isFunction2(guard.canLoad);
}
function isCanActivate(guard) {
  return guard && isFunction2(guard.canActivate);
}
function isCanActivateChild(guard) {
  return guard && isFunction2(guard.canActivateChild);
}
function isCanDeactivate(guard) {
  return guard && isFunction2(guard.canDeactivate);
}
function isCanMatch(guard) {
  return guard && isFunction2(guard.canMatch);
}
function isEmptyError(e) {
  return e instanceof EmptyError || e?.name === "EmptyError";
}
var INITIAL_VALUE = /* @__PURE__ */ Symbol("INITIAL_VALUE");
function prioritizedGuardValue() {
  return switchMap((obs) => {
    return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {
      for (const result of results) {
        if (result === true) {
          continue;
        } else if (result === INITIAL_VALUE) {
          return INITIAL_VALUE;
        } else if (result === false || isRedirect(result)) {
          return result;
        }
      }
      return true;
    }), filter((item) => item !== INITIAL_VALUE), take(1));
  });
}
function isRedirect(val) {
  return isUrlTree(val) || val instanceof RedirectCommand;
}
function abortSignalToObservable(signal2) {
  if (signal2.aborted) {
    return of(void 0).pipe(take(1));
  }
  return new Observable((subscriber) => {
    const handler = () => {
      subscriber.next();
      subscriber.complete();
    };
    signal2.addEventListener("abort", handler);
    return () => signal2.removeEventListener("abort", handler);
  });
}
function takeUntilAbort(signal2) {
  return takeUntil(abortSignalToObservable(signal2));
}
function checkGuards(injector, forwardEvent) {
  return mergeMap((t) => {
    const {
      targetSnapshot,
      currentSnapshot,
      guards: {
        canActivateChecks,
        canDeactivateChecks
      }
    } = t;
    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
      return of(__spreadProps(__spreadValues({}, t), {
        guardsResult: true
      }));
    }
    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {
      return canDeactivate && isBoolean2(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);
    }), map((guardsResult) => __spreadProps(__spreadValues({}, t), {
      guardsResult
    })));
  });
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {
  return from(checks).pipe(mergeMap((check2) => runCanDeactivate(check2.component, check2.route, currRSS, futureRSS, injector)), first((result) => {
    return result !== true;
  }, true));
}
function runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {
  return from(checks).pipe(concatMap((check2) => {
    return concat(fireChildActivationStart(check2.route.parent, forwardEvent), fireActivationStart(check2.route, forwardEvent), runCanActivateChild(futureSnapshot, check2.path, injector), runCanActivate(futureSnapshot, check2.route, injector));
  }), first((result) => {
    return result !== true;
  }, true));
}
function fireActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ActivationStart(snapshot));
  }
  return of(true);
}
function fireChildActivationStart(snapshot, forwardEvent) {
  if (snapshot !== null && forwardEvent) {
    forwardEvent(new ChildActivationStart(snapshot));
  }
  return of(true);
}
function runCanActivate(futureRSS, futureARS, injector) {
  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
  if (!canActivate || canActivate.length === 0) return of(true);
  const canActivateObservables = canActivate.map((canActivate2) => {
    return defer(() => {
      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);
      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
      return wrapIntoObservable(guardVal).pipe(first());
    });
  });
  return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, injector) {
  const futureARS = path[path.length - 1];
  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);
  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {
    return defer(() => {
      const guardsMapped = d.guards.map((canActivateChild) => {
        const closestInjector = getClosestRouteInjector(d.node) ?? injector;
        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);
        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));
        return wrapIntoObservable(guardVal).pipe(first());
      });
      return of(guardsMapped).pipe(prioritizedGuardValue());
    });
  });
  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {
  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
  if (!canDeactivate || canDeactivate.length === 0) return of(true);
  const canDeactivateObservables = canDeactivate.map((c) => {
    const closestInjector = getClosestRouteInjector(currARS) ?? injector;
    const guard = getTokenOrFunctionIdentity(c, closestInjector);
    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));
    return wrapIntoObservable(guardVal).pipe(first());
  });
  return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}
function runCanLoadGuards(injector, route, segments, urlSerializer, abortSignal) {
  const canLoad = route.canLoad;
  if (canLoad === void 0 || canLoad.length === 0) {
    return of(true);
  }
  const canLoadObservables = canLoad.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    const obs$ = wrapIntoObservable(guardVal);
    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;
  });
  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
function redirectIfUrlTree(urlSerializer) {
  return pipe(tap((result) => {
    if (typeof result === "boolean") return;
    throw redirectingNavigationError(urlSerializer, result);
  }), map((result) => result === true));
}
function runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal) {
  const canMatch = route.canMatch;
  if (!canMatch || canMatch.length === 0) return of(true);
  const canMatchObservables = canMatch.map((injectionToken) => {
    const guard = getTokenOrFunctionIdentity(injectionToken, injector);
    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));
    let obs$ = wrapIntoObservable(guardVal);
    return abortSignal ? obs$.pipe(takeUntilAbort(abortSignal)) : obs$;
  });
  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));
}
var NoMatch$1 = class NoMatch extends Error {
  segmentGroup;
  constructor(segmentGroup) {
    super();
    this.segmentGroup = segmentGroup || null;
    Object.setPrototypeOf(this, NoMatch.prototype);
  }
};
var AbsoluteRedirect$1 = class AbsoluteRedirect extends Error {
  urlTree;
  constructor(urlTree) {
    super();
    this.urlTree = urlTree;
    Object.setPrototypeOf(this, AbsoluteRedirect.prototype);
  }
};
function namedOutletsRedirect$1(redirectTo) {
  throw new RuntimeError(4e3, (typeof ngDevMode === "undefined" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`);
}
function canLoadFails$1(route) {
  throw navigationCancelingError((typeof ngDevMode === "undefined" || ngDevMode) && `Cannot load children because the guard of the route "path: '${route.path}'" returned false`, NavigationCancellationCode.GuardRejected);
}
var ApplyRedirects$1 = class ApplyRedirects {
  urlSerializer;
  urlTree;
  constructor(urlSerializer, urlTree) {
    this.urlSerializer = urlSerializer;
    this.urlTree = urlTree;
  }
  lineralizeSegments(route, urlTree) {
    return __async(this, null, function* () {
      let res = [];
      let c = urlTree.root;
      while (true) {
        res = res.concat(c.segments);
        if (c.numberOfChildren === 0) {
          return res;
        }
        if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
          throw namedOutletsRedirect$1(`${route.redirectTo}`);
        }
        c = c.children[PRIMARY_OUTLET];
      }
    });
  }
  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {
    return __async(this, null, function* () {
      const redirect = yield getRedirectResult$1(redirectTo, currentSnapshot, injector);
      if (redirect instanceof UrlTree) {
        throw new AbsoluteRedirect$1(redirect);
      }
      const newTree = this.applyRedirectCreateUrlTree(redirect, this.urlSerializer.parse(redirect), segments, posParams);
      if (redirect[0] === "/") {
        throw new AbsoluteRedirect$1(newTree);
      }
      return newTree;
    });
  }
  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {
    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
  }
  createQueryParams(redirectToParams, actualParams) {
    const res = {};
    Object.entries(redirectToParams).forEach(([k, v]) => {
      const copySourceValue = typeof v === "string" && v[0] === ":";
      if (copySourceValue) {
        const sourceName = v.substring(1);
        res[k] = actualParams[sourceName];
      } else {
        res[k] = v;
      }
    });
    return res;
  }
  createSegmentGroup(redirectTo, group2, segments, posParams) {
    const updatedSegments = this.createSegments(redirectTo, group2.segments, segments, posParams);
    let children = {};
    Object.entries(group2.children).forEach(([name, child]) => {
      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);
    });
    return new UrlSegmentGroup(updatedSegments, children);
  }
  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {
    return redirectToSegments.map((s) => s.path[0] === ":" ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));
  }
  findPosParam(redirectTo, redirectToUrlSegment, posParams) {
    const pos = posParams[redirectToUrlSegment.path.substring(1)];
    if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === "undefined" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);
    return pos;
  }
  findOrReturn(redirectToUrlSegment, actualSegments) {
    let idx = 0;
    for (const s of actualSegments) {
      if (s.path === redirectToUrlSegment.path) {
        actualSegments.splice(idx);
        return s;
      }
      idx++;
    }
    return redirectToUrlSegment;
  }
};
function getRedirectResult$1(redirectTo, currentSnapshot, injector) {
  if (typeof redirectTo === "string") {
    return Promise.resolve(redirectTo);
  }
  const redirectToFn = redirectTo;
  const {
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    params,
    data,
    title
  } = currentSnapshot;
  return firstValueFrom(wrapIntoObservable(runInInjectionContext(injector, () => redirectToFn({
    params,
    data,
    queryParams,
    fragment,
    routeConfig,
    url,
    outlet,
    title
  }))));
}
var noMatch$1 = {
  matched: false,
  consumedSegments: [],
  remainingSegments: [],
  parameters: {},
  positionalParamSegments: {}
};
function matchWithChecks(segmentGroup, route, segments, injector, urlSerializer, abortSignal) {
  const result = match4(segmentGroup, route, segments);
  if (!result.matched) {
    return of(result);
  }
  injector = getOrCreateRouteInjectorIfNeeded(route, injector);
  return runCanMatchGuards(injector, route, segments, urlSerializer, abortSignal).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch$1)));
}
function match4(segmentGroup, route, segments) {
  if (route.path === "**") {
    return createWildcardMatchResult(segments);
  }
  if (route.path === "") {
    if (route.pathMatch === "full" && (segmentGroup.hasChildren() || segments.length > 0)) {
      return __spreadValues({}, noMatch$1);
    }
    return {
      matched: true,
      consumedSegments: [],
      remainingSegments: segments,
      parameters: {},
      positionalParamSegments: {}
    };
  }
  const matcher = route.matcher || defaultUrlMatcher;
  const res = matcher(segments, segmentGroup, route);
  if (!res) return __spreadValues({}, noMatch$1);
  const posParams = {};
  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {
    posParams[k] = v.path;
  });
  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;
  return {
    matched: true,
    consumedSegments: res.consumed,
    remainingSegments: segments.slice(res.consumed.length),
    parameters,
    positionalParamSegments: res.posParams ?? {}
  };
}
function createWildcardMatchResult(segments) {
  return {
    matched: true,
    parameters: segments.length > 0 ? last2(segments).parameters : {},
    consumedSegments: segments,
    remainingSegments: [],
    positionalParamSegments: {}
  };
}
function split(segmentGroup, consumedSegments, slicedSegments, config2) {
  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {
    const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config2, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
    return {
      segmentGroup: s2,
      slicedSegments: []
    };
  }
  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {
    const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config2, segmentGroup.children));
    return {
      segmentGroup: s2,
      slicedSegments
    };
  }
  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
  return {
    segmentGroup: s,
    slicedSegments
  };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes3, children) {
  const res = {};
  for (const r of routes3) {
    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return __spreadValues(__spreadValues({}, children), res);
}
function createChildrenForEmptyPaths(routes3, primarySegment) {
  const res = {};
  res[PRIMARY_OUTLET] = primarySegment;
  for (const r of routes3) {
    if (r.path === "" && getOutlet(r) !== PRIMARY_OUTLET) {
      const s = new UrlSegmentGroup([], {});
      res[getOutlet(r)] = s;
    }
  }
  return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes3) {
  return routes3.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes3) {
  return routes3.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === "full") {
    return false;
  }
  return r.path === "";
}
function noLeftoversInUrl(segmentGroup, segments, outlet) {
  return segments.length === 0 && !segmentGroup.children[outlet];
}
var NoLeftoversInUrl$1 = class NoLeftoversInUrl {
};
function recognize$2(injector, configLoader, rootComponentType, config2, urlTree, urlSerializer, paramsInheritanceStrategy = "emptyOnly", abortSignal) {
  return __async(this, null, function* () {
    return new Recognizer$1(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal).recognize();
  });
}
var MAX_ALLOWED_REDIRECTS$1 = 31;
var Recognizer$1 = class Recognizer {
  injector;
  configLoader;
  rootComponentType;
  config;
  urlTree;
  paramsInheritanceStrategy;
  urlSerializer;
  abortSignal;
  applyRedirects;
  absoluteRedirectCount = 0;
  allowRedirects = true;
  constructor(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer, abortSignal) {
    this.injector = injector;
    this.configLoader = configLoader;
    this.rootComponentType = rootComponentType;
    this.config = config2;
    this.urlTree = urlTree;
    this.paramsInheritanceStrategy = paramsInheritanceStrategy;
    this.urlSerializer = urlSerializer;
    this.abortSignal = abortSignal;
    this.applyRedirects = new ApplyRedirects$1(this.urlSerializer, this.urlTree);
  }
  noMatchError(e) {
    return new RuntimeError(4002, typeof ngDevMode === "undefined" || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);
  }
  recognize() {
    return __async(this, null, function* () {
      const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;
      const {
        children,
        rootSnapshot
      } = yield this.match(rootSegmentGroup);
      const rootNode = new TreeNode(rootSnapshot, children);
      const routeState = new RouterStateSnapshot("", rootNode);
      const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);
      tree2.queryParams = this.urlTree.queryParams;
      routeState.url = this.urlSerializer.serialize(tree2);
      return {
        state: routeState,
        tree: tree2
      };
    });
  }
  match(rootSegmentGroup) {
    return __async(this, null, function* () {
      const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});
      try {
        const children = yield this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot);
        return {
          children,
          rootSnapshot
        };
      } catch (e) {
        if (e instanceof AbsoluteRedirect$1) {
          this.urlTree = e.urlTree;
          return this.match(e.urlTree.root);
        }
        if (e instanceof NoMatch$1) {
          throw this.noMatchError(e);
        }
        throw e;
      }
    });
  }
  processSegmentGroup(injector, config2, segmentGroup, outlet, parentRoute) {
    return __async(this, null, function* () {
      if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return this.processChildren(injector, config2, segmentGroup, parentRoute);
      }
      const child = yield this.processSegment(injector, config2, segmentGroup, segmentGroup.segments, outlet, true, parentRoute);
      return child instanceof TreeNode ? [child] : [];
    });
  }
  processChildren(injector, config2, segmentGroup, parentRoute) {
    return __async(this, null, function* () {
      const childOutlets = [];
      for (const child of Object.keys(segmentGroup.children)) {
        if (child === "primary") {
          childOutlets.unshift(child);
        } else {
          childOutlets.push(child);
        }
      }
      let children = [];
      for (const childOutlet of childOutlets) {
        const child = segmentGroup.children[childOutlet];
        const sortedConfig = sortByMatchingOutlets(config2, childOutlet);
        const outletChildren = yield this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);
        children.push(...outletChildren);
      }
      const mergedChildren = mergeEmptyPathMatches$1(children);
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        checkOutletNameUniqueness$1(mergedChildren);
      }
      sortActivatedRouteSnapshots$1(mergedChildren);
      return mergedChildren;
    });
  }
  processSegment(injector, routes3, segmentGroup, segments, outlet, allowRedirects, parentRoute) {
    return __async(this, null, function* () {
      for (const r of routes3) {
        try {
          return yield this.processSegmentAgainstRoute(r._injector ?? injector, routes3, r, segmentGroup, segments, outlet, allowRedirects, parentRoute);
        } catch (e) {
          if (e instanceof NoMatch$1 || isEmptyError(e)) {
            continue;
          }
          throw e;
        }
      }
      if (noLeftoversInUrl(segmentGroup, segments, outlet)) {
        return new NoLeftoversInUrl$1();
      }
      throw new NoMatch$1(segmentGroup);
    });
  }
  processSegmentAgainstRoute(injector, routes3, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {
    return __async(this, null, function* () {
      if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {
        throw new NoMatch$1(rawSegment);
      }
      if (route.redirectTo === void 0) {
        return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);
      }
      if (this.allowRedirects && allowRedirects) {
        return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes3, route, segments, outlet, parentRoute);
      }
      throw new NoMatch$1(rawSegment);
    });
  }
  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes3, route, segments, outlet, parentRoute) {
    return __async(this, null, function* () {
      const {
        matched,
        parameters,
        consumedSegments,
        positionalParamSegments,
        remainingSegments
      } = match4(segmentGroup, route, segments);
      if (!matched) throw new NoMatch$1(segmentGroup);
      if (typeof route.redirectTo === "string" && route.redirectTo[0] === "/") {
        this.absoluteRedirectCount++;
        if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS$1) {
          if (ngDevMode) {
            throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.
This is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);
          }
          this.allowRedirects = false;
        }
      }
      const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));
      const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);
      currentSnapshot.params = Object.freeze(inherited.params);
      currentSnapshot.data = Object.freeze(inherited.data);
      if (this.abortSignal.aborted) {
        throw new Error(this.abortSignal.reason);
      }
      const newTree = yield this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);
      const newSegments = yield this.applyRedirects.lineralizeSegments(route, newTree);
      return this.processSegment(injector, routes3, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);
    });
  }
  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {
    return __async(this, null, function* () {
      if (this.abortSignal.aborted) {
        throw new Error(this.abortSignal.reason);
      }
      const result = yield firstValueFrom(matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer, this.abortSignal));
      if (route.path === "**") {
        rawSegment.children = {};
      }
      if (!result?.matched) {
        throw new NoMatch$1(rawSegment);
      }
      injector = route._injector ?? injector;
      const {
        routes: childConfig
      } = yield this.getChildConfig(injector, route, segments);
      const childInjector = route._loadedInjector ?? injector;
      const {
        parameters,
        consumedSegments,
        remainingSegments
      } = result;
      const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData$1(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve$1(route));
      const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);
      snapshot.params = Object.freeze(inherited.params);
      snapshot.data = Object.freeze(inherited.data);
      const {
        segmentGroup,
        slicedSegments
      } = split(rawSegment, consumedSegments, remainingSegments, childConfig);
      if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
        const children = yield this.processChildren(childInjector, childConfig, segmentGroup, snapshot);
        return new TreeNode(snapshot, children);
      }
      if (childConfig.length === 0 && slicedSegments.length === 0) {
        return new TreeNode(snapshot, []);
      }
      const matchedOnOutlet = getOutlet(route) === outlet;
      const child = yield this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot);
      return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);
    });
  }
  getChildConfig(injector, route, segments) {
    return __async(this, null, function* () {
      if (route.children) {
        return {
          routes: route.children,
          injector
        };
      }
      if (route.loadChildren) {
        if (route._loadedRoutes !== void 0) {
          return {
            routes: route._loadedRoutes,
            injector: route._loadedInjector
          };
        }
        if (this.abortSignal.aborted) {
          throw new Error(this.abortSignal.reason);
        }
        const shouldLoadResult = yield firstValueFrom(runCanLoadGuards(injector, route, segments, this.urlSerializer, this.abortSignal));
        if (shouldLoadResult) {
          const cfg = yield this.configLoader.loadChildren(injector, route);
          route._loadedRoutes = cfg.routes;
          route._loadedInjector = cfg.injector;
          return cfg;
        }
        throw canLoadFails$1(route);
      }
      return {
        routes: [],
        injector
      };
    });
  }
};
function sortActivatedRouteSnapshots$1(nodes) {
  nodes.sort((a, b) => {
    if (a.value.outlet === PRIMARY_OUTLET) return -1;
    if (b.value.outlet === PRIMARY_OUTLET) return 1;
    return a.value.outlet.localeCompare(b.value.outlet);
  });
}
function hasEmptyPathConfig$1(node) {
  const config2 = node.value.routeConfig;
  return config2 && config2.path === "";
}
function mergeEmptyPathMatches$1(nodes) {
  const result = [];
  const mergedNodes = /* @__PURE__ */ new Set();
  for (const node of nodes) {
    if (!hasEmptyPathConfig$1(node)) {
      result.push(node);
      continue;
    }
    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);
    if (duplicateEmptyPathNode !== void 0) {
      duplicateEmptyPathNode.children.push(...node.children);
      mergedNodes.add(duplicateEmptyPathNode);
    } else {
      result.push(node);
    }
  }
  for (const mergedNode of mergedNodes) {
    const mergedChildren = mergeEmptyPathMatches$1(mergedNode.children);
    result.push(new TreeNode(mergedNode.value, mergedChildren));
  }
  return result.filter((n) => !mergedNodes.has(n));
}
function checkOutletNameUniqueness$1(nodes) {
  const names = {};
  nodes.forEach((n) => {
    const routeWithSameOutletName = names[n.value.outlet];
    if (routeWithSameOutletName) {
      const p = routeWithSameOutletName.url.map((s) => s.toString()).join("/");
      const c = n.value.url.map((s) => s.toString()).join("/");
      throw new RuntimeError(4006, (typeof ngDevMode === "undefined" || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);
    }
    names[n.value.outlet] = n.value;
  });
}
function getData$1(route) {
  return route.data || {};
}
function getResolve$1(route) {
  return route.resolve || {};
}
var RECOGNIZE_IMPL = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "RECOGNIZE_IMPL" : "", {
  factory: () => {
    return recognize$2;
  }
});
function recognize(injector, configLoader, rootComponentType, config2, serializer, paramsInheritanceStrategy, abortSignal) {
  const recognizeImpl = injector.get(RECOGNIZE_IMPL);
  return mergeMap((t) => of(t).pipe(switchMap((t2) => recognizeImpl(injector, configLoader, rootComponentType, config2, t2.extractedUrl, serializer, paramsInheritanceStrategy, abortSignal)), map(({
    state: targetSnapshot,
    tree: urlAfterRedirects
  }) => {
    return __spreadProps(__spreadValues({}, t), {
      targetSnapshot,
      urlAfterRedirects
    });
  })));
}
function resolveData(paramsInheritanceStrategy, injector) {
  return mergeMap((t) => {
    const {
      targetSnapshot,
      guards: {
        canActivateChecks
      }
    } = t;
    if (!canActivateChecks.length) {
      return of(t);
    }
    const routesWithResolversToRun = new Set(canActivateChecks.map((check2) => check2.route));
    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();
    for (const route of routesWithResolversToRun) {
      if (routesNeedingDataUpdates.has(route)) {
        continue;
      }
      for (const newRoute of flattenRouteTree(route)) {
        routesNeedingDataUpdates.add(newRoute);
      }
    }
    let routesProcessed = 0;
    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {
      if (routesWithResolversToRun.has(route)) {
        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);
      } else {
        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;
        return of(void 0);
      }
    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));
  });
}
function flattenRouteTree(route) {
  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();
  return [route, ...descendants];
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {
  const config2 = futureARS.routeConfig;
  const resolve = futureARS._resolve;
  if (config2?.title !== void 0 && !hasStaticTitle(config2)) {
    resolve[RouteTitleKey] = config2.title;
  }
  return defer(() => {
    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;
    return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {
      futureARS._resolvedData = resolvedData;
      futureARS.data = __spreadValues(__spreadValues({}, futureARS.data), resolvedData);
      return null;
    }));
  });
}
function resolveNode(resolve, futureARS, futureRSS, injector) {
  const keys = getDataKeys(resolve);
  if (keys.length === 0) {
    return of({});
  }
  const data = {};
  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {
    if (value instanceof RedirectCommand) {
      throw redirectingNavigationError(new DefaultUrlSerializer(), value);
    }
    data[key] = value;
  }))), takeLast(1), map(() => data), catchError((e) => isEmptyError(e) ? EMPTY : throwError(e)));
}
function getResolver(injectionToken, futureARS, futureRSS, injector) {
  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;
  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);
  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));
  return wrapIntoObservable(resolverValue);
}
function switchTap(next) {
  return switchMap((v) => {
    const nextResult = next(v);
    if (nextResult) {
      return from(nextResult).pipe(map(() => v));
    }
    return of(v);
  });
}
var TitleStrategy = class _TitleStrategy {
  buildTitle(snapshot) {
    let pageTitle;
    let route = snapshot.root;
    while (route !== void 0) {
      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;
      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);
    }
    return pageTitle;
  }
  getResolvedTitleForRoute(snapshot) {
    return snapshot.data[RouteTitleKey];
  }
  static \u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _TitleStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _TitleStrategy,
    factory: () => (() => inject(DefaultTitleStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultTitleStrategy)
    }]
  }], null, null);
})();
var DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {
  title;
  constructor(title) {
    super();
    this.title = title;
  }
  updateTitle(snapshot) {
    const title = this.buildTitle(snapshot);
    if (title !== void 0) {
      this.title.setTitle(title);
    }
  }
  static \u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultTitleStrategy)(\u0275\u0275inject(Title));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultTitleStrategy,
    factory: _DefaultTitleStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }], null);
})();
var ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router config" : "", {
  factory: () => ({})
});
var ROUTES = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "ROUTES" : "");
var RouterConfigLoader = class _RouterConfigLoader {
  componentLoaders = /* @__PURE__ */ new WeakMap();
  childrenLoaders = /* @__PURE__ */ new WeakMap();
  onLoadStartListener;
  onLoadEndListener;
  compiler = inject(Compiler);
  loadComponent(injector, route) {
    return __async(this, null, function* () {
      if (this.componentLoaders.get(route)) {
        return this.componentLoaders.get(route);
      } else if (route._loadedComponent) {
        return Promise.resolve(route._loadedComponent);
      }
      if (this.onLoadStartListener) {
        this.onLoadStartListener(route);
      }
      const loader = (() => __async(this, null, function* () {
        try {
          const loaded = yield wrapIntoPromise(runInInjectionContext(injector, () => route.loadComponent()));
          const component = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));
          if (this.onLoadEndListener) {
            this.onLoadEndListener(route);
          }
          (typeof ngDevMode === "undefined" || ngDevMode) && assertStandalone(route.path ?? "", component);
          route._loadedComponent = component;
          return component;
        } finally {
          this.componentLoaders.delete(route);
        }
      }))();
      this.componentLoaders.set(route, loader);
      return loader;
    });
  }
  loadChildren(parentInjector, route) {
    if (this.childrenLoaders.get(route)) {
      return this.childrenLoaders.get(route);
    } else if (route._loadedRoutes) {
      return Promise.resolve({
        routes: route._loadedRoutes,
        injector: route._loadedInjector
      });
    }
    if (this.onLoadStartListener) {
      this.onLoadStartListener(route);
    }
    const loader = (() => __async(this, null, function* () {
      try {
        const result = yield loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);
        route._loadedRoutes = result.routes;
        route._loadedInjector = result.injector;
        return result;
      } finally {
        this.childrenLoaders.delete(route);
      }
    }))();
    this.childrenLoaders.set(route, loader);
    return loader;
  }
  static \u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterConfigLoader)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterConfigLoader,
    factory: _RouterConfigLoader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function loadChildren(route, compiler, parentInjector, onLoadEndListener) {
  return __async(this, null, function* () {
    const loaded = yield wrapIntoPromise(runInInjectionContext(parentInjector, () => route.loadChildren()));
    const t = yield maybeResolveResources(maybeUnwrapDefaultExport(loaded));
    let factoryOrRoutes;
    if (t instanceof NgModuleFactory$1 || Array.isArray(t)) {
      factoryOrRoutes = t;
    } else {
      factoryOrRoutes = yield compiler.compileModuleAsync(t);
    }
    if (onLoadEndListener) {
      onLoadEndListener(route);
    }
    let injector;
    let rawRoutes;
    let requireStandaloneComponents = false;
    if (Array.isArray(factoryOrRoutes)) {
      rawRoutes = factoryOrRoutes;
      requireStandaloneComponents = true;
    } else {
      injector = factoryOrRoutes.create(parentInjector).injector;
      rawRoutes = injector.get(ROUTES, [], {
        optional: true,
        self: true
      }).flat();
    }
    const routes3 = rawRoutes.map(standardizeConfig);
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(routes3, route.path, requireStandaloneComponents);
    return {
      routes: routes3,
      injector
    };
  });
}
function isWrappedDefaultExport(value) {
  return value && typeof value === "object" && "default" in value;
}
function maybeUnwrapDefaultExport(input2) {
  return isWrappedDefaultExport(input2) ? input2["default"] : input2;
}
function maybeResolveResources(value) {
  return __async(this, null, function* () {
    if (false) {
      try {
        yield resolveComponentResources(fetch);
      } catch (error) {
        console.error(error);
      }
    }
    return value;
  });
}
var UrlHandlingStrategy = class _UrlHandlingStrategy {
  static \u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _UrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _UrlHandlingStrategy,
    factory: () => (() => inject(DefaultUrlHandlingStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultUrlHandlingStrategy)
    }]
  }], null, null);
})();
var DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {
  shouldProcessUrl(url) {
    return true;
  }
  extract(url) {
    return url;
  }
  merge(newUrlPart, wholeUrl) {
    return newUrlPart;
  }
  static \u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultUrlHandlingStrategy,
    factory: _DefaultUrlHandlingStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CREATE_VIEW_TRANSITION = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "view transition helper" : "");
var VIEW_TRANSITION_OPTIONS = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "view transition options" : "");
function createViewTransition(injector, from2, to) {
  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);
  const document2 = injector.get(DOCUMENT);
  if (!document2.startViewTransition || transitionOptions.skipNextTransition) {
    transitionOptions.skipNextTransition = false;
    return new Promise((resolve) => setTimeout(resolve));
  }
  let resolveViewTransitionStarted;
  const viewTransitionStarted = new Promise((resolve) => {
    resolveViewTransitionStarted = resolve;
  });
  const transition2 = document2.startViewTransition(() => {
    resolveViewTransitionStarted();
    return createRenderPromise(injector);
  });
  transition2.ready.catch((error) => {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(error);
    }
  });
  transition2.finished.catch((error) => {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      console.error(error);
    }
  });
  const {
    onViewTransitionCreated
  } = transitionOptions;
  if (onViewTransitionCreated) {
    runInInjectionContext(injector, () => onViewTransitionCreated({
      transition: transition2,
      from: from2,
      to
    }));
  }
  return viewTransitionStarted;
}
function createRenderPromise(injector) {
  return new Promise((resolve) => {
    afterNextRender({
      read: () => setTimeout(resolve)
    }, {
      injector
    });
  });
}
var noop2 = () => {
};
var NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "navigation error handler" : "");
var NavigationTransitions = class _NavigationTransitions {
  currentNavigation = signal(null, __spreadProps(__spreadValues({}, ngDevMode ? {
    debugName: "currentNavigation"
  } : {}), {
    equal: () => false
  }));
  currentTransition = null;
  lastSuccessfulNavigation = signal(null, ...ngDevMode ? [{
    debugName: "lastSuccessfulNavigation"
  }] : []);
  events = new Subject();
  transitionAbortWithErrorSubject = new Subject();
  configLoader = inject(RouterConfigLoader);
  environmentInjector = inject(EnvironmentInjector);
  destroyRef = inject(DestroyRef);
  urlSerializer = inject(UrlSerializer);
  rootContexts = inject(ChildrenOutletContexts);
  location = inject(Location);
  inputBindingEnabled = inject(INPUT_BINDER, {
    optional: true
  }) !== null;
  titleStrategy = inject(TitleStrategy);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly";
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  createViewTransition = inject(CREATE_VIEW_TRANSITION, {
    optional: true
  });
  navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {
    optional: true
  });
  navigationId = 0;
  get hasRequestedNavigation() {
    return this.navigationId !== 0;
  }
  transitions;
  afterPreactivation = () => of(void 0);
  rootComponentType = null;
  destroyed = false;
  constructor() {
    const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));
    const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));
    this.configLoader.onLoadEndListener = onLoadEnd;
    this.configLoader.onLoadStartListener = onLoadStart;
    this.destroyRef.onDestroy(() => {
      this.destroyed = true;
    });
  }
  complete() {
    this.transitions?.complete();
  }
  handleNavigationRequest(request) {
    const id = ++this.navigationId;
    untracked(() => {
      this.transitions?.next(__spreadProps(__spreadValues({}, request), {
        extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),
        targetSnapshot: null,
        targetRouterState: null,
        guards: {
          canActivateChecks: [],
          canDeactivateChecks: []
        },
        guardsResult: null,
        id
      }));
    });
  }
  setupNavigations(router) {
    this.transitions = new BehaviorSubject(null);
    return this.transitions.pipe(filter((t) => t !== null), switchMap((overallTransitionState) => {
      let completedOrAborted = false;
      const abortController = new AbortController();
      return of(overallTransitionState).pipe(switchMap((t) => {
        if (this.navigationId > overallTransitionState.id) {
          const cancellationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
          this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);
          return EMPTY;
        }
        this.currentTransition = overallTransitionState;
        const lastSuccessfulNavigation = this.lastSuccessfulNavigation();
        this.currentNavigation.set({
          id: t.id,
          initialUrl: t.rawUrl,
          extractedUrl: t.extractedUrl,
          targetBrowserUrl: typeof t.extras.browserUrl === "string" ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,
          trigger: t.source,
          extras: t.extras,
          previousNavigation: !lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, lastSuccessfulNavigation), {
            previousNavigation: null
          }),
          abort: () => abortController.abort()
        });
        const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();
        const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;
        if (!urlTransition && onSameUrlNavigation !== "reload") {
          const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : "";
          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));
          t.resolve(false);
          return EMPTY;
        }
        if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {
          return of(t).pipe(switchMap((t2) => {
            this.events.next(new NavigationStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), t2.source, t2.restoredState));
            if (t2.id !== this.navigationId) {
              return EMPTY;
            }
            return Promise.resolve(t2);
          }), recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy, abortController.signal), tap((t2) => {
            overallTransitionState.targetSnapshot = t2.targetSnapshot;
            overallTransitionState.urlAfterRedirects = t2.urlAfterRedirects;
            this.currentNavigation.update((nav) => {
              nav.finalUrl = t2.urlAfterRedirects;
              return nav;
            });
            const routesRecognized = new RoutesRecognized(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
            this.events.next(routesRecognized);
          }));
        } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {
          const {
            id,
            extractedUrl,
            source,
            restoredState,
            extras
          } = t;
          const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);
          this.events.next(navStart);
          const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;
          this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
            targetSnapshot,
            urlAfterRedirects: extractedUrl,
            extras: __spreadProps(__spreadValues({}, extras), {
              skipLocationChange: false,
              replaceUrl: false
            })
          });
          this.currentNavigation.update((nav) => {
            nav.finalUrl = extractedUrl;
            return nav;
          });
          return of(overallTransitionState);
        } else {
          const reason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : "";
          this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));
          t.resolve(false);
          return EMPTY;
        }
      }), tap((t) => {
        const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);
        this.events.next(guardsStart);
      }), map((t) => {
        this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
          guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)
        });
        return overallTransitionState;
      }), checkGuards(this.environmentInjector, (evt) => this.events.next(evt)), tap((t) => {
        overallTransitionState.guardsResult = t.guardsResult;
        if (t.guardsResult && typeof t.guardsResult !== "boolean") {
          throw redirectingNavigationError(this.urlSerializer, t.guardsResult);
        }
        const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
        this.events.next(guardsEnd);
      }), filter((t) => {
        if (!t.guardsResult) {
          this.cancelNavigationTransition(t, "", NavigationCancellationCode.GuardRejected);
          return false;
        }
        return true;
      }), switchTap((t) => {
        if (t.guards.canActivateChecks.length === 0) {
          return void 0;
        }
        return of(t).pipe(tap((t2) => {
          const resolveStart = new ResolveStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
          this.events.next(resolveStart);
        }), switchMap((t2) => {
          let dataResolved = false;
          return of(t2).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({
            next: () => dataResolved = true,
            complete: () => {
              if (!dataResolved) {
                this.cancelNavigationTransition(t2, typeof ngDevMode === "undefined" || ngDevMode ? `At least one route resolver didn't emit any value.` : "", NavigationCancellationCode.NoDataFromResolver);
              }
            }
          }));
        }), tap((t2) => {
          const resolveEnd = new ResolveEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);
          this.events.next(resolveEnd);
        }));
      }), switchTap((t) => {
        const loadComponents = (route) => {
          const loaders2 = [];
          if (route.routeConfig?._loadedComponent) {
            route.component = route.routeConfig?._loadedComponent;
          } else if (route.routeConfig?.loadComponent) {
            const injector = getClosestRouteInjector(route) ?? this.environmentInjector;
            loaders2.push(this.configLoader.loadComponent(injector, route.routeConfig).then((loadedComponent) => {
              route.component = loadedComponent;
            }));
          }
          for (const child of route.children) {
            loaders2.push(...loadComponents(child));
          }
          return loaders2;
        };
        const loaders = loadComponents(t.targetSnapshot.root);
        return loaders.length === 0 ? of(t) : from(Promise.all(loaders).then(() => t));
      }), switchTap(() => this.afterPreactivation()), switchMap(() => {
        const {
          currentSnapshot,
          targetSnapshot
        } = overallTransitionState;
        const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);
        return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);
      }), map((t) => {
        const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
        this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {
          targetRouterState
        });
        this.currentNavigation.update((nav) => {
          nav.targetRouterState = targetRouterState;
          return nav;
        });
        return overallTransitionState;
      }), tap(() => {
        this.events.next(new BeforeActivateRoutes());
      }), activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled), take(1), takeUntil(abortSignalToObservable(abortController.signal).pipe(filter(() => !completedOrAborted && !overallTransitionState.targetRouterState), tap(() => {
        this.cancelNavigationTransition(overallTransitionState, abortController.signal.reason + "", NavigationCancellationCode.Aborted);
      }))), tap({
        next: (t) => {
          completedOrAborted = true;
          this.currentNavigation.update((nav) => {
            nav.abort = noop2;
            return nav;
          });
          this.lastSuccessfulNavigation.set(untracked(this.currentNavigation));
          this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));
          this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);
          t.resolve(true);
        },
        complete: () => {
          completedOrAborted = true;
        }
      }), takeUntil(this.transitionAbortWithErrorSubject.pipe(tap((err) => {
        throw err;
      }))), finalize(() => {
        abortController.abort();
        if (!completedOrAborted) {
          const cancelationReason = typeof ngDevMode === "undefined" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : "";
          this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);
        }
        if (this.currentTransition?.id === overallTransitionState.id) {
          this.currentNavigation.set(null);
          this.currentTransition = null;
        }
      }), catchError((e) => {
        if (this.destroyed) {
          overallTransitionState.resolve(false);
          return EMPTY;
        }
        completedOrAborted = true;
        if (isNavigationCancelingError(e)) {
          this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));
          if (!isRedirectingNavigationCancelingError(e)) {
            overallTransitionState.resolve(false);
          } else {
            this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));
          }
        } else {
          const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);
          try {
            const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));
            if (navigationErrorHandlerResult instanceof RedirectCommand) {
              const {
                message,
                cancellationCode
              } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);
              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));
              this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));
            } else {
              this.events.next(navigationError);
              throw e;
            }
          } catch (ee) {
            if (this.options.resolveNavigationPromiseOnError) {
              overallTransitionState.resolve(false);
            } else {
              overallTransitionState.reject(ee);
            }
          }
        }
        return EMPTY;
      }));
    }));
  }
  cancelNavigationTransition(t, reason, code2) {
    const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code2);
    this.events.next(navCancel);
    t.resolve(false);
  }
  isUpdatingInternalState() {
    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();
  }
  isUpdatedBrowserUrl() {
    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));
    const currentNavigation = untracked(this.currentNavigation);
    const targetBrowserUrl = currentNavigation?.targetBrowserUrl ?? currentNavigation?.extractedUrl;
    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !currentNavigation?.extras.skipLocationChange;
  }
  static \u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NavigationTransitions)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NavigationTransitions,
    factory: _NavigationTransitions.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationTransitions, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function isBrowserTriggeredNavigation(source) {
  return source !== IMPERATIVE_NAVIGATION;
}
var RouteReuseStrategy = class _RouteReuseStrategy {
  static \u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouteReuseStrategy)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouteReuseStrategy,
    factory: () => (() => inject(DefaultRouteReuseStrategy))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(DefaultRouteReuseStrategy)
    }]
  }], null, null);
})();
var BaseRouteReuseStrategy = class {
  shouldDetach(route) {
    return false;
  }
  store(route, detachedTree) {
  }
  shouldAttach(route) {
    return false;
  }
  retrieve(route) {
    return null;
  }
  shouldReuseRoute(future, curr) {
    return future.routeConfig === curr.routeConfig;
  }
};
var DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275DefaultRouteReuseStrategy_BaseFactory;
    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {
      return (\u0275DefaultRouteReuseStrategy_BaseFactory || (\u0275DefaultRouteReuseStrategy_BaseFactory = \u0275\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _DefaultRouteReuseStrategy,
    factory: _DefaultRouteReuseStrategy.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var StateManager = class _StateManager {
  urlSerializer = inject(UrlSerializer);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  canceledNavigationResolution = this.options.canceledNavigationResolution || "replace";
  location = inject(Location);
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  currentUrlTree = new UrlTree();
  getCurrentUrlTree() {
    return this.currentUrlTree;
  }
  rawUrlTree = this.currentUrlTree;
  getRawUrlTree() {
    return this.rawUrlTree;
  }
  createBrowserPath({
    finalUrl,
    initialUrl,
    targetBrowserUrl
  }) {
    const rawUrl = finalUrl !== void 0 ? this.urlHandlingStrategy.merge(finalUrl, initialUrl) : initialUrl;
    const url = targetBrowserUrl ?? rawUrl;
    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;
    return path;
  }
  commitTransition({
    targetRouterState,
    finalUrl,
    initialUrl
  }) {
    if (finalUrl && targetRouterState) {
      this.currentUrlTree = finalUrl;
      this.rawUrlTree = this.urlHandlingStrategy.merge(finalUrl, initialUrl);
      this.routerState = targetRouterState;
    } else {
      this.rawUrlTree = initialUrl;
    }
  }
  routerState = createEmptyState(null);
  getRouterState() {
    return this.routerState;
  }
  stateMemento = this.createStateMemento();
  updateStateMemento() {
    this.stateMemento = this.createStateMemento();
  }
  createStateMemento() {
    return {
      rawUrlTree: this.rawUrlTree,
      currentUrlTree: this.currentUrlTree,
      routerState: this.routerState
    };
  }
  resetInternalState({
    finalUrl
  }) {
    this.routerState = this.stateMemento.routerState;
    this.currentUrlTree = this.stateMemento.currentUrlTree;
    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, finalUrl ?? this.rawUrlTree);
  }
  static \u0275fac = function StateManager_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _StateManager)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _StateManager,
    factory: () => (() => inject(HistoryStateManager))(),
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: () => inject(HistoryStateManager)
    }]
  }], null, null);
})();
var HistoryStateManager = class _HistoryStateManager extends StateManager {
  currentPageId = 0;
  lastSuccessfulId = -1;
  restoredState() {
    return this.location.getState();
  }
  get browserPageId() {
    if (this.canceledNavigationResolution !== "computed") {
      return this.currentPageId;
    }
    return this.restoredState()?.\u0275routerPageId ?? this.currentPageId;
  }
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe((event) => {
      if (event["type"] === "popstate") {
        setTimeout(() => {
          listener(event["url"], event.state, "popstate");
        });
      }
    });
  }
  handleRouterEvent(e, currentTransition) {
    if (e instanceof NavigationStart) {
      this.updateStateMemento();
    } else if (e instanceof NavigationSkipped) {
      this.commitTransition(currentTransition);
    } else if (e instanceof RoutesRecognized) {
      if (this.urlUpdateStrategy === "eager") {
        if (!currentTransition.extras.skipLocationChange) {
          this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
        }
      }
    } else if (e instanceof BeforeActivateRoutes) {
      this.commitTransition(currentTransition);
      if (this.urlUpdateStrategy === "deferred" && !currentTransition.extras.skipLocationChange) {
        this.setBrowserUrl(this.createBrowserPath(currentTransition), currentTransition);
      }
    } else if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.SupersededByNewNavigation && e.code !== NavigationCancellationCode.Redirect) {
      this.restoreHistory(currentTransition);
    } else if (e instanceof NavigationError) {
      this.restoreHistory(currentTransition, true);
    } else if (e instanceof NavigationEnd) {
      this.lastSuccessfulId = e.id;
      this.currentPageId = this.browserPageId;
    }
  }
  setBrowserUrl(path, {
    extras,
    id
  }) {
    const {
      replaceUrl,
      state: state2
    } = extras;
    if (this.location.isCurrentPathEqualTo(path) || !!replaceUrl) {
      const currentBrowserPageId = this.browserPageId;
      const newState = __spreadValues(__spreadValues({}, state2), this.generateNgRouterState(id, currentBrowserPageId));
      this.location.replaceState(path, "", newState);
    } else {
      const newState = __spreadValues(__spreadValues({}, state2), this.generateNgRouterState(id, this.browserPageId + 1));
      this.location.go(path, "", newState);
    }
  }
  restoreHistory(navigation, restoringFromCaughtError = false) {
    if (this.canceledNavigationResolution === "computed") {
      const currentBrowserPageId = this.browserPageId;
      const targetPagePosition = this.currentPageId - currentBrowserPageId;
      if (targetPagePosition !== 0) {
        this.location.historyGo(targetPagePosition);
      } else if (this.getCurrentUrlTree() === navigation.finalUrl && targetPagePosition === 0) {
        this.resetInternalState(navigation);
        this.resetUrlToCurrentUrlTree();
      } else ;
    } else if (this.canceledNavigationResolution === "replace") {
      if (restoringFromCaughtError) {
        this.resetInternalState(navigation);
      }
      this.resetUrlToCurrentUrlTree();
    }
  }
  resetUrlToCurrentUrlTree() {
    this.location.replaceState(this.urlSerializer.serialize(this.getRawUrlTree()), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));
  }
  generateNgRouterState(navigationId, routerPageId) {
    if (this.canceledNavigationResolution === "computed") {
      return {
        navigationId,
        \u0275routerPageId: routerPageId
      };
    }
    return {
      navigationId
    };
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275HistoryStateManager_BaseFactory;
    return function HistoryStateManager_Factory(__ngFactoryType__) {
      return (\u0275HistoryStateManager_BaseFactory || (\u0275HistoryStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _HistoryStateManager,
    factory: _HistoryStateManager.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HistoryStateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function afterNextNavigation(router, action) {
  router.events.pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map((e) => {
    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {
      return 0;
    }
    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;
    return redirecting ? 2 : 1;
  }), filter((result) => result !== 2), take(1)).subscribe(() => {
    action();
  });
}
var exactMatchOptions = {
  paths: "exact",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "exact"
};
var subsetMatchOptions = {
  paths: "subset",
  fragment: "ignored",
  matrixParams: "ignored",
  queryParams: "subset"
};
var Router = class _Router {
  get currentUrlTree() {
    return this.stateManager.getCurrentUrlTree();
  }
  get rawUrlTree() {
    return this.stateManager.getRawUrlTree();
  }
  disposed = false;
  nonRouterCurrentEntryChangeSubscription;
  console = inject(Console);
  stateManager = inject(StateManager);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  }) || {};
  pendingTasks = inject(PendingTasksInternal);
  urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred";
  navigationTransitions = inject(NavigationTransitions);
  urlSerializer = inject(UrlSerializer);
  location = inject(Location);
  urlHandlingStrategy = inject(UrlHandlingStrategy);
  injector = inject(EnvironmentInjector);
  _events = new Subject();
  get events() {
    return this._events;
  }
  get routerState() {
    return this.stateManager.getRouterState();
  }
  navigated = false;
  routeReuseStrategy = inject(RouteReuseStrategy);
  onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore";
  config = inject(ROUTES, {
    optional: true
  })?.flat() ?? [];
  componentInputBindingEnabled = !!inject(INPUT_BINDER, {
    optional: true
  });
  currentNavigation = this.navigationTransitions.currentNavigation.asReadonly();
  constructor() {
    this.resetConfig(this.config);
    this.navigationTransitions.setupNavigations(this).subscribe({
      error: (e) => {
        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);
      }
    });
    this.subscribeToNavigationEvents();
  }
  eventsSubscription = new Subscription();
  subscribeToNavigationEvents() {
    const subscription = this.navigationTransitions.events.subscribe((e) => {
      try {
        const currentTransition = this.navigationTransitions.currentTransition;
        const currentNavigation = untracked(this.navigationTransitions.currentNavigation);
        if (currentTransition !== null && currentNavigation !== null) {
          this.stateManager.handleRouterEvent(e, currentNavigation);
          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {
            this.navigated = true;
          } else if (e instanceof NavigationEnd) {
            this.navigated = true;
          } else if (e instanceof RedirectRequest) {
            const opts = e.navigationBehaviorOptions;
            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);
            const extras = __spreadValues({
              browserUrl: currentTransition.extras.browserUrl,
              info: currentTransition.extras.info,
              skipLocationChange: currentTransition.extras.skipLocationChange,
              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === "eager" || isBrowserTriggeredNavigation(currentTransition.source)
            }, opts);
            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {
              resolve: currentTransition.resolve,
              reject: currentTransition.reject,
              promise: currentTransition.promise
            });
          }
        }
        if (isPublicRouterEvent(e)) {
          this._events.next(e);
        }
      } catch (e2) {
        this.navigationTransitions.transitionAbortWithErrorSubject.next(e2);
      }
    });
    this.eventsSubscription.add(subscription);
  }
  resetRootComponentType(rootComponentType) {
    this.routerState.root.component = rootComponentType;
    this.navigationTransitions.rootComponentType = rootComponentType;
  }
  initialNavigation() {
    this.setUpLocationChangeListener();
    if (!this.navigationTransitions.hasRequestedNavigation) {
      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());
    }
  }
  setUpLocationChangeListener() {
    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state2, source) => {
      this.navigateToSyncWithBrowser(url, source, state2);
    });
  }
  navigateToSyncWithBrowser(url, source, state2) {
    const extras = {
      replaceUrl: true
    };
    const restoredState = state2?.navigationId ? state2 : null;
    if (state2) {
      const stateCopy = __spreadValues({}, state2);
      delete stateCopy.navigationId;
      delete stateCopy.\u0275routerPageId;
      if (Object.keys(stateCopy).length !== 0) {
        extras.state = stateCopy;
      }
    }
    const urlTree = this.parseUrl(url);
    this.scheduleNavigation(urlTree, source, restoredState, extras).catch((e) => {
      if (this.disposed) {
        return;
      }
      this.injector.get(INTERNAL_APPLICATION_ERROR_HANDLER)(e);
    });
  }
  get url() {
    return this.serializeUrl(this.currentUrlTree);
  }
  getCurrentNavigation() {
    return untracked(this.navigationTransitions.currentNavigation);
  }
  get lastSuccessfulNavigation() {
    return this.navigationTransitions.lastSuccessfulNavigation;
  }
  resetConfig(config2) {
    (typeof ngDevMode === "undefined" || ngDevMode) && validateConfig(config2);
    this.config = config2.map(standardizeConfig);
    this.navigated = false;
  }
  ngOnDestroy() {
    this.dispose();
  }
  dispose() {
    this._events.unsubscribe();
    this.navigationTransitions.complete();
    if (this.nonRouterCurrentEntryChangeSubscription) {
      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();
      this.nonRouterCurrentEntryChangeSubscription = void 0;
    }
    this.disposed = true;
    this.eventsSubscription.unsubscribe();
  }
  createUrlTree(commands, navigationExtras = {}) {
    const {
      relativeTo,
      queryParams,
      fragment,
      queryParamsHandling,
      preserveFragment
    } = navigationExtras;
    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;
    let q = null;
    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {
      case "merge":
        q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);
        break;
      case "preserve":
        q = this.currentUrlTree.queryParams;
        break;
      default:
        q = queryParams || null;
    }
    if (q !== null) {
      q = this.removeEmptyProps(q);
    }
    let relativeToUrlSegmentGroup;
    try {
      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;
      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);
    } catch (e) {
      if (typeof commands[0] !== "string" || commands[0][0] !== "/") {
        commands = [];
      }
      relativeToUrlSegmentGroup = this.currentUrlTree.root;
    }
    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null, this.urlSerializer);
  }
  navigateByUrl(url, extras = {
    skipLocationChange: false
  }) {
    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);
    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);
  }
  navigate(commands, extras = {
    skipLocationChange: false
  }) {
    validateCommands(commands);
    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
  }
  serializeUrl(url) {
    return this.urlSerializer.serialize(url);
  }
  parseUrl(url) {
    try {
      return this.urlSerializer.parse(url);
    } catch (e) {
      this.console.warn(formatRuntimeError(4018, ngDevMode && `Error parsing URL ${url}. Falling back to '/' instead. 
` + e));
      return this.urlSerializer.parse("/");
    }
  }
  isActive(url, matchOptions) {
    let options;
    if (matchOptions === true) {
      options = __spreadValues({}, exactMatchOptions);
    } else if (matchOptions === false) {
      options = __spreadValues({}, subsetMatchOptions);
    } else {
      options = matchOptions;
    }
    if (isUrlTree(url)) {
      return containsTree(this.currentUrlTree, url, options);
    }
    const urlTree = this.parseUrl(url);
    return containsTree(this.currentUrlTree, urlTree, options);
  }
  removeEmptyProps(params) {
    return Object.entries(params).reduce((result, [key, value]) => {
      if (value !== null && value !== void 0) {
        result[key] = value;
      }
      return result;
    }, {});
  }
  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {
    if (this.disposed) {
      return Promise.resolve(false);
    }
    let resolve;
    let reject;
    let promise;
    if (priorPromise) {
      resolve = priorPromise.resolve;
      reject = priorPromise.reject;
      promise = priorPromise.promise;
    } else {
      promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
    }
    const taskId = this.pendingTasks.add();
    afterNextNavigation(this, () => {
      queueMicrotask(() => this.pendingTasks.remove(taskId));
    });
    this.navigationTransitions.handleNavigationRequest({
      source,
      restoredState,
      currentUrlTree: this.currentUrlTree,
      currentRawUrl: this.currentUrlTree,
      rawUrl,
      extras,
      resolve,
      reject,
      promise,
      currentSnapshot: this.routerState.snapshot,
      currentRouterState: this.routerState
    });
    return promise.catch((e) => {
      return Promise.reject(e);
    });
  }
  static \u0275fac = function Router_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _Router)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _Router,
    factory: _Router.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(Router, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function validateCommands(commands) {
  for (let i = 0; i < commands.length; i++) {
    const cmd = commands[i];
    if (cmd == null) {
      throw new RuntimeError(4008, (typeof ngDevMode === "undefined" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);
    }
  }
}

// node_modules/@angular/router/fesm2022/_router_module-chunk.mjs
var RouterLink = class _RouterLink {
  router;
  route;
  tabIndexAttribute;
  renderer;
  el;
  locationStrategy;
  reactiveHref = signal(null, ...ngDevMode ? [{
    debugName: "reactiveHref"
  }] : []);
  get href() {
    return untracked(this.reactiveHref);
  }
  set href(value) {
    this.reactiveHref.set(value);
  }
  target;
  queryParams;
  fragment;
  queryParamsHandling;
  state;
  info;
  relativeTo;
  isAnchorElement;
  subscription;
  onChanges = new Subject();
  applicationErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);
  options = inject(ROUTER_CONFIGURATION, {
    optional: true
  });
  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {
    this.router = router;
    this.route = route;
    this.tabIndexAttribute = tabIndexAttribute;
    this.renderer = renderer;
    this.el = el;
    this.locationStrategy = locationStrategy;
    this.reactiveHref.set(inject(new HostAttributeToken("href"), {
      optional: true
    }));
    const tagName = el.nativeElement.tagName?.toLowerCase();
    this.isAnchorElement = tagName === "a" || tagName === "area" || !!(typeof customElements === "object" && customElements.get(tagName)?.observedAttributes?.includes?.("href"));
    if (!this.isAnchorElement) {
      this.subscribeToNavigationEventsIfNecessary();
    } else {
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  subscribeToNavigationEventsIfNecessary() {
    if (this.subscription !== void 0 || !this.isAnchorElement) {
      return;
    }
    let createSubcription = this.preserveFragment;
    const dependsOnRouterState = (handling) => handling === "merge" || handling === "preserve";
    createSubcription ||= dependsOnRouterState(this.queryParamsHandling);
    createSubcription ||= !this.queryParamsHandling && !dependsOnRouterState(this.options?.defaultQueryParamsHandling);
    if (!createSubcription) {
      return;
    }
    this.subscription = this.router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.updateHref();
      }
    });
  }
  preserveFragment = false;
  skipLocationChange = false;
  replaceUrl = false;
  setTabIndexIfNotOnNativeEl(newTabIndex) {
    if (this.tabIndexAttribute != null || this.isAnchorElement) {
      return;
    }
    this.applyAttributeValue("tabindex", newTabIndex);
  }
  ngOnChanges(changes) {
    if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {
      throw new RuntimeError(4017, "Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.");
    }
    if (this.isAnchorElement) {
      this.updateHref();
      this.subscribeToNavigationEventsIfNecessary();
    }
    this.onChanges.next(this);
  }
  routerLinkInput = null;
  set routerLink(commandsOrUrlTree) {
    if (commandsOrUrlTree == null) {
      this.routerLinkInput = null;
      this.setTabIndexIfNotOnNativeEl(null);
    } else {
      if (isUrlTree(commandsOrUrlTree)) {
        this.routerLinkInput = commandsOrUrlTree;
      } else {
        this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];
      }
      this.setTabIndexIfNotOnNativeEl("0");
    }
  }
  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {
    const urlTree = this.urlTree;
    if (urlTree === null) {
      return true;
    }
    if (this.isAnchorElement) {
      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {
        return true;
      }
      if (typeof this.target === "string" && this.target != "_self") {
        return true;
      }
    }
    const extras = {
      skipLocationChange: this.skipLocationChange,
      replaceUrl: this.replaceUrl,
      state: this.state,
      info: this.info
    };
    this.router.navigateByUrl(urlTree, extras)?.catch((e) => {
      this.applicationErrorHandler(e);
    });
    return !this.isAnchorElement;
  }
  ngOnDestroy() {
    this.subscription?.unsubscribe();
  }
  updateHref() {
    const urlTree = this.urlTree;
    this.reactiveHref.set(urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) ?? "" : null);
  }
  applyAttributeValue(attrName, attrValue) {
    const renderer = this.renderer;
    const nativeElement = this.el.nativeElement;
    if (attrValue !== null) {
      renderer.setAttribute(nativeElement, attrName, attrValue);
    } else {
      renderer.removeAttribute(nativeElement, attrName);
    }
  }
  get urlTree() {
    if (this.routerLinkInput === null) {
      return null;
    } else if (isUrlTree(this.routerLinkInput)) {
      return this.routerLinkInput;
    }
    return this.router.createUrlTree(this.routerLinkInput, {
      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,
      queryParams: this.queryParams,
      fragment: this.fragment,
      queryParamsHandling: this.queryParamsHandling,
      preserveFragment: this.preserveFragment
    });
  }
  static \u0275fac = function RouterLink_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLink)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275injectAttribute("tabindex"), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(LocationStrategy));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLink,
    selectors: [["", "routerLink", ""]],
    hostVars: 2,
    hostBindings: function RouterLink_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("click", function RouterLink_click_HostBindingHandler($event) {
          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);
        });
      }
      if (rf & 2) {
        \u0275\u0275attribute("href", ctx.reactiveHref(), \u0275\u0275sanitizeUrlOrResourceUrl)("target", ctx.target);
      }
    },
    inputs: {
      target: "target",
      queryParams: "queryParams",
      fragment: "fragment",
      queryParamsHandling: "queryParamsHandling",
      state: "state",
      info: "info",
      relativeTo: "relativeTo",
      preserveFragment: [2, "preserveFragment", "preserveFragment", booleanAttribute],
      skipLocationChange: [2, "skipLocationChange", "skipLocationChange", booleanAttribute],
      replaceUrl: [2, "replaceUrl", "replaceUrl", booleanAttribute],
      routerLink: "routerLink"
    },
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLink, [{
    type: Directive,
    args: [{
      selector: "[routerLink]",
      host: {
        "[attr.href]": "reactiveHref()"
      }
    }]
  }], () => [{
    type: Router
  }, {
    type: ActivatedRoute
  }, {
    type: void 0,
    decorators: [{
      type: Attribute,
      args: ["tabindex"]
    }]
  }, {
    type: Renderer2
  }, {
    type: ElementRef
  }, {
    type: LocationStrategy
  }], {
    target: [{
      type: HostBinding,
      args: ["attr.target"]
    }, {
      type: Input
    }],
    queryParams: [{
      type: Input
    }],
    fragment: [{
      type: Input
    }],
    queryParamsHandling: [{
      type: Input
    }],
    state: [{
      type: Input
    }],
    info: [{
      type: Input
    }],
    relativeTo: [{
      type: Input
    }],
    preserveFragment: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    skipLocationChange: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    replaceUrl: [{
      type: Input,
      args: [{
        transform: booleanAttribute
      }]
    }],
    routerLink: [{
      type: Input
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event.button", "$event.ctrlKey", "$event.shiftKey", "$event.altKey", "$event.metaKey"]]
    }]
  });
})();
var RouterLinkActive = class _RouterLinkActive {
  router;
  element;
  renderer;
  cdr;
  links;
  classes = [];
  routerEventsSubscription;
  linkInputChangesSubscription;
  _isActive = false;
  get isActive() {
    return this._isActive;
  }
  routerLinkActiveOptions = {
    exact: false
  };
  ariaCurrentWhenActive;
  isActiveChange = new EventEmitter();
  link = inject(RouterLink, {
    optional: true
  });
  constructor(router, element, renderer, cdr) {
    this.router = router;
    this.element = element;
    this.renderer = renderer;
    this.cdr = cdr;
    this.routerEventsSubscription = router.events.subscribe((s) => {
      if (s instanceof NavigationEnd) {
        this.update();
      }
    });
  }
  ngAfterContentInit() {
    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_) => {
      this.update();
      this.subscribeToEachLinkOnChanges();
    });
  }
  subscribeToEachLinkOnChanges() {
    this.linkInputChangesSubscription?.unsubscribe();
    const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);
    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {
      if (this._isActive !== this.isLinkActive(this.router)(link)) {
        this.update();
      }
    });
  }
  set routerLinkActive(data) {
    const classes = Array.isArray(data) ? data : data.split(" ");
    this.classes = classes.filter((c) => !!c);
  }
  ngOnChanges(changes) {
    this.update();
  }
  ngOnDestroy() {
    this.routerEventsSubscription.unsubscribe();
    this.linkInputChangesSubscription?.unsubscribe();
  }
  update() {
    if (!this.links || !this.router.navigated) return;
    queueMicrotask(() => {
      const hasActiveLinks = this.hasActiveLinks();
      this.classes.forEach((c) => {
        if (hasActiveLinks) {
          this.renderer.addClass(this.element.nativeElement, c);
        } else {
          this.renderer.removeClass(this.element.nativeElement, c);
        }
      });
      if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {
        this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString());
      } else {
        this.renderer.removeAttribute(this.element.nativeElement, "aria-current");
      }
      if (this._isActive !== hasActiveLinks) {
        this._isActive = hasActiveLinks;
        this.cdr.markForCheck();
        this.isActiveChange.emit(hasActiveLinks);
      }
    });
  }
  isLinkActive(router) {
    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || false;
    return (link) => {
      const urlTree = link.urlTree;
      return urlTree ? router.isActive(urlTree, options) : false;
    };
  }
  hasActiveLinks() {
    const isActiveCheckFn = this.isLinkActive(this.router);
    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);
  }
  static \u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterLinkActive)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2), \u0275\u0275directiveInject(ChangeDetectorRef));
  };
  static \u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
    type: _RouterLinkActive,
    selectors: [["", "routerLinkActive", ""]],
    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuery(dirIndex, RouterLink, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
      }
    },
    inputs: {
      routerLinkActiveOptions: "routerLinkActiveOptions",
      ariaCurrentWhenActive: "ariaCurrentWhenActive",
      routerLinkActive: "routerLinkActive"
    },
    outputs: {
      isActiveChange: "isActiveChange"
    },
    exportAs: ["routerLinkActive"],
    features: [\u0275\u0275NgOnChangesFeature]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterLinkActive, [{
    type: Directive,
    args: [{
      selector: "[routerLinkActive]",
      exportAs: "routerLinkActive"
    }]
  }], () => [{
    type: Router
  }, {
    type: ElementRef
  }, {
    type: Renderer2
  }, {
    type: ChangeDetectorRef
  }], {
    links: [{
      type: ContentChildren,
      args: [RouterLink, {
        descendants: true
      }]
    }],
    routerLinkActiveOptions: [{
      type: Input
    }],
    ariaCurrentWhenActive: [{
      type: Input
    }],
    isActiveChange: [{
      type: Output
    }],
    routerLinkActive: [{
      type: Input
    }]
  });
})();
function isActiveMatchOptions(options) {
  return !!options.paths;
}
var PreloadingStrategy = class {
};
var PreloadAllModules = class _PreloadAllModules {
  preload(route, fn) {
    return fn().pipe(catchError(() => of(null)));
  }
  static \u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _PreloadAllModules)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _PreloadAllModules,
    factory: _PreloadAllModules.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PreloadAllModules, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var NoPreloading = class _NoPreloading {
  preload(route, fn) {
    return of(null);
  }
  static \u0275fac = function NoPreloading_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoPreloading)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoPreloading,
    factory: _NoPreloading.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoPreloading, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var RouterPreloader = class _RouterPreloader {
  router;
  injector;
  preloadingStrategy;
  loader;
  subscription;
  constructor(router, injector, preloadingStrategy, loader) {
    this.router = router;
    this.injector = injector;
    this.preloadingStrategy = preloadingStrategy;
    this.loader = loader;
  }
  setUpPreloading() {
    this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {
    });
  }
  preload() {
    return this.processRoutes(this.injector, this.router.config);
  }
  ngOnDestroy() {
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  processRoutes(injector, routes3) {
    const res = [];
    for (const route of routes3) {
      if (route.providers && !route._injector) {
        route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);
      }
      const injectorForCurrentRoute = route._injector ?? injector;
      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;
      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {
        res.push(this.preloadConfig(injectorForCurrentRoute, route));
      }
      if (route.children || route._loadedRoutes) {
        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));
      }
    }
    return from(res).pipe(mergeAll());
  }
  preloadConfig(injector, route) {
    return this.preloadingStrategy.preload(route, () => {
      let loadedChildren$;
      if (route.loadChildren && route.canLoad === void 0) {
        loadedChildren$ = from(this.loader.loadChildren(injector, route));
      } else {
        loadedChildren$ = of(null);
      }
      const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config2) => {
        if (config2 === null) {
          return of(void 0);
        }
        route._loadedRoutes = config2.routes;
        route._loadedInjector = config2.injector;
        return this.processRoutes(config2.injector ?? injector, config2.routes);
      }));
      if (route.loadComponent && !route._loadedComponent) {
        const loadComponent$ = this.loader.loadComponent(injector, route);
        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());
      } else {
        return recursiveLoadChildren$;
      }
    });
  }
  static \u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterPreloader)(\u0275\u0275inject(Router), \u0275\u0275inject(EnvironmentInjector), \u0275\u0275inject(PreloadingStrategy), \u0275\u0275inject(RouterConfigLoader));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterPreloader,
    factory: _RouterPreloader.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterPreloader, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: EnvironmentInjector
  }, {
    type: PreloadingStrategy
  }, {
    type: RouterConfigLoader
  }], null);
})();
var ROUTER_SCROLLER = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "Router Scroller" : "");
var RouterScroller = class _RouterScroller {
  urlSerializer;
  transitions;
  viewportScroller;
  zone;
  options;
  routerEventsSubscription;
  scrollEventsSubscription;
  lastId = 0;
  lastSource = IMPERATIVE_NAVIGATION;
  restoredId = 0;
  store = {};
  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {
    this.urlSerializer = urlSerializer;
    this.transitions = transitions;
    this.viewportScroller = viewportScroller;
    this.zone = zone;
    this.options = options;
    options.scrollPositionRestoration ||= "disabled";
    options.anchorScrolling ||= "disabled";
  }
  init() {
    if (this.options.scrollPositionRestoration !== "disabled") {
      this.viewportScroller.setHistoryScrollRestoration("manual");
    }
    this.routerEventsSubscription = this.createScrollEvents();
    this.scrollEventsSubscription = this.consumeScrollEvents();
  }
  createScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (e instanceof NavigationStart) {
        this.store[this.lastId] = this.viewportScroller.getScrollPosition();
        this.lastSource = e.navigationTrigger;
        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
      } else if (e instanceof NavigationEnd) {
        this.lastId = e.id;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);
      } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {
        this.lastSource = void 0;
        this.restoredId = 0;
        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);
      }
    });
  }
  consumeScrollEvents() {
    return this.transitions.events.subscribe((e) => {
      if (!(e instanceof Scroll)) return;
      const instantScroll = {
        behavior: "instant"
      };
      if (e.position) {
        if (this.options.scrollPositionRestoration === "top") {
          this.viewportScroller.scrollToPosition([0, 0], instantScroll);
        } else if (this.options.scrollPositionRestoration === "enabled") {
          this.viewportScroller.scrollToPosition(e.position, instantScroll);
        }
      } else {
        if (e.anchor && this.options.anchorScrolling === "enabled") {
          this.viewportScroller.scrollToAnchor(e.anchor);
        } else if (this.options.scrollPositionRestoration !== "disabled") {
          this.viewportScroller.scrollToPosition([0, 0]);
        }
      }
    });
  }
  scheduleScrollEvent(routerEvent, anchor) {
    this.zone.runOutsideAngular(() => __async(this, null, function* () {
      yield new Promise((resolve) => {
        setTimeout(resolve);
        if (typeof requestAnimationFrame !== "undefined") {
          requestAnimationFrame(resolve);
        }
      });
      this.zone.run(() => {
        this.transitions.events.next(new Scroll(routerEvent, this.lastSource === "popstate" ? this.store[this.restoredId] : null, anchor));
      });
    }));
  }
  ngOnDestroy() {
    this.routerEventsSubscription?.unsubscribe();
    this.scrollEventsSubscription?.unsubscribe();
  }
  static \u0275fac = function RouterScroller_Factory(__ngFactoryType__) {
    \u0275\u0275invalidFactory();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _RouterScroller,
    factory: _RouterScroller.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterScroller, [{
    type: Injectable
  }], () => [{
    type: UrlSerializer
  }, {
    type: NavigationTransitions
  }, {
    type: ViewportScroller
  }, {
    type: NgZone
  }, {
    type: void 0
  }], null);
})();
var NavigationStateManager = class _NavigationStateManager extends HistoryStateManager {
  navigation = inject(PlatformNavigation);
  registerNonRouterCurrentEntryChangeListener(listener) {
    return this.location.subscribe((event) => {
      if (event["type"] === "popstate") {
        const state2 = this.navigation.currentEntry?.getState();
        listener(event["url"], state2, "popstate");
      }
    });
  }
  static \u0275fac = /* @__PURE__ */ (() => {
    let \u0275NavigationStateManager_BaseFactory;
    return function NavigationStateManager_Factory(__ngFactoryType__) {
      return (\u0275NavigationStateManager_BaseFactory || (\u0275NavigationStateManager_BaseFactory = \u0275\u0275getInheritedFactory(_NavigationStateManager)))(__ngFactoryType__ || _NavigationStateManager);
    };
  })();
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NavigationStateManager,
    factory: _NavigationStateManager.\u0275fac,
    providedIn: "root"
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationStateManager, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function rootRoute() {
  return inject(Router).routerState.root;
}
function routerFeature(kind, providers) {
  return {
    \u0275kind: kind,
    \u0275providers: providers
  };
}
var ROUTER_IS_PROVIDED = new InjectionToken(typeof ngDevMode !== "undefined" && ngDevMode ? "Router is provided" : "", {
  factory: () => false
});
function getBootstrapListener() {
  const injector = inject(Injector);
  return (bootstrappedComponentRef) => {
    const ref = injector.get(ApplicationRef);
    if (bootstrappedComponentRef !== ref.components[0]) {
      return;
    }
    const router = injector.get(Router);
    const bootstrapDone = injector.get(BOOTSTRAP_DONE);
    if (injector.get(INITIAL_NAVIGATION) === 1) {
      router.initialNavigation();
    }
    injector.get(ROUTER_PRELOADER, null, {
      optional: true
    })?.setUpPreloading();
    injector.get(ROUTER_SCROLLER, null, {
      optional: true
    })?.init();
    router.resetRootComponentType(ref.componentTypes[0]);
    if (!bootstrapDone.closed) {
      bootstrapDone.next();
      bootstrapDone.complete();
      bootstrapDone.unsubscribe();
    }
  };
}
var BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "bootstrap done indicator" : "", {
  factory: () => {
    return new Subject();
  }
});
var INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "initial navigation" : "", {
  factory: () => 1
});
function withEnabledBlockingInitialNavigation() {
  const providers = [{
    provide: IS_ENABLED_BLOCKING_INITIAL_NAVIGATION,
    useValue: true
  }, {
    provide: INITIAL_NAVIGATION,
    useValue: 0
  }, provideAppInitializer(() => {
    const injector = inject(Injector);
    const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());
    return locationInitialized.then(() => {
      return new Promise((resolve) => {
        const router = injector.get(Router);
        const bootstrapDone = injector.get(BOOTSTRAP_DONE);
        afterNextNavigation(router, () => {
          resolve(true);
        });
        injector.get(NavigationTransitions).afterPreactivation = () => {
          resolve(true);
          return bootstrapDone.closed ? of(void 0) : bootstrapDone;
        };
        router.initialNavigation();
      });
    });
  })];
  return routerFeature(2, providers);
}
function withDisabledInitialNavigation() {
  const providers = [provideAppInitializer(() => {
    inject(Router).setUpLocationChangeListener();
  }), {
    provide: INITIAL_NAVIGATION,
    useValue: 2
  }];
  return routerFeature(3, providers);
}
function withDebugTracing() {
  let providers = [];
  if (typeof ngDevMode === "undefined" || ngDevMode) {
    providers = [{
      provide: ENVIRONMENT_INITIALIZER,
      multi: true,
      useFactory: () => {
        const router = inject(Router);
        return () => router.events.subscribe((e) => {
          console.group?.(`Router Event: ${e.constructor.name}`);
          console.log(stringifyEvent(e));
          console.log(e);
          console.groupEnd?.();
        });
      }
    }];
  } else {
    providers = [];
  }
  return routerFeature(1, providers);
}
var ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router preloader" : "");
function withPreloading(preloadingStrategy) {
  const providers = [{
    provide: ROUTER_PRELOADER,
    useExisting: RouterPreloader
  }, {
    provide: PreloadingStrategy,
    useExisting: preloadingStrategy
  }];
  return routerFeature(0, providers);
}
function withComponentInputBinding() {
  const providers = [RoutedComponentInputBinder, {
    provide: INPUT_BINDER,
    useExisting: RoutedComponentInputBinder
  }];
  return routerFeature(8, providers);
}
function withViewTransitions(options) {
  performanceMarkFeature("NgRouterViewTransitions");
  const providers = [{
    provide: CREATE_VIEW_TRANSITION,
    useValue: createViewTransition
  }, {
    provide: VIEW_TRANSITION_OPTIONS,
    useValue: __spreadValues({
      skipNextTransition: !!options?.skipInitialTransition
    }, options)
  }];
  return routerFeature(9, providers);
}
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent];
var ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "router duplicate forRoot guard" : "");
var ROUTER_PROVIDERS = [Location, {
  provide: UrlSerializer,
  useClass: DefaultUrlSerializer
}, Router, ChildrenOutletContexts, {
  provide: ActivatedRoute,
  useFactory: rootRoute
}, RouterConfigLoader, typeof ngDevMode === "undefined" || ngDevMode ? {
  provide: ROUTER_IS_PROVIDED,
  useValue: true
} : []];
var RouterModule = class _RouterModule {
  constructor() {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      inject(ROUTER_FORROOT_GUARD, {
        optional: true
      });
    }
  }
  static forRoot(routes3, config2) {
    return {
      ngModule: _RouterModule,
      providers: [ROUTER_PROVIDERS, typeof ngDevMode === "undefined" || ngDevMode ? config2?.enableTracing ? withDebugTracing().\u0275providers : [] : [], {
        provide: ROUTES,
        multi: true,
        useValue: routes3
      }, typeof ngDevMode === "undefined" || ngDevMode ? {
        provide: ROUTER_FORROOT_GUARD,
        useFactory: provideForRootGuard
      } : [], config2?.errorHandler ? {
        provide: NAVIGATION_ERROR_HANDLER,
        useValue: config2.errorHandler
      } : [], {
        provide: ROUTER_CONFIGURATION,
        useValue: config2 ? config2 : {}
      }, config2?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config2?.preloadingStrategy ? withPreloading(config2.preloadingStrategy).\u0275providers : [], config2?.initialNavigation ? provideInitialNavigation(config2) : [], config2?.bindToComponentInputs ? withComponentInputBinding().\u0275providers : [], config2?.enableViewTransitions ? withViewTransitions().\u0275providers : [], provideRouterInitializer()]
    };
  }
  static forChild(routes3) {
    return {
      ngModule: _RouterModule,
      providers: [{
        provide: ROUTES,
        multi: true,
        useValue: routes3
      }]
    };
  }
  static \u0275fac = function RouterModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _RouterModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _RouterModule,
    imports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent],
    exports: [RouterOutlet, RouterLink, RouterLinkActive, \u0275EmptyOutletComponent]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterModule, [{
    type: NgModule,
    args: [{
      imports: ROUTER_DIRECTIVES,
      exports: ROUTER_DIRECTIVES
    }]
  }], () => [], null);
})();
function provideRouterScroller() {
  return {
    provide: ROUTER_SCROLLER,
    useFactory: () => {
      const viewportScroller = inject(ViewportScroller);
      const zone = inject(NgZone);
      const config2 = inject(ROUTER_CONFIGURATION);
      const transitions = inject(NavigationTransitions);
      const urlSerializer = inject(UrlSerializer);
      if (config2.scrollOffset) {
        viewportScroller.setOffset(config2.scrollOffset);
      }
      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config2);
    }
  };
}
function provideHashLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: HashLocationStrategy
  };
}
function providePathLocationStrategy() {
  return {
    provide: LocationStrategy,
    useClass: PathLocationStrategy
  };
}
function provideForRootGuard() {
  const router = inject(Router, {
    optional: true,
    skipSelf: true
  });
  if (router) {
    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);
  }
  return "guarded";
}
function provideInitialNavigation(config2) {
  return [config2.initialNavigation === "disabled" ? withDisabledInitialNavigation().\u0275providers : [], config2.initialNavigation === "enabledBlocking" ? withEnabledBlockingInitialNavigation().\u0275providers : []];
}
var ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === "undefined" || ngDevMode ? "Router Initializer" : "");
function provideRouterInitializer() {
  return [{
    provide: ROUTER_INITIALIZER,
    useFactory: getBootstrapListener
  }, {
    provide: APP_BOOTSTRAP_LISTENER,
    multi: true,
    useExisting: ROUTER_INITIALIZER
  }];
}

// node_modules/ngx-tethys/fesm2022/ngx-tethys-popover.mjs
function ThyPopoverContainer_ng_template_0_Template(rf, ctx) {
}
var _c05 = ["*"];
var _c12 = ["popoverHeader"];
function ThyPopoverHeader_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.headerTemplate());
  }
}
function ThyPopoverHeader_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "h5", 1);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "button", 2);
    \u0275\u0275listener("click", function ThyPopoverHeader_Conditional_1_Template_button_click_2_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.close($event));
    });
    \u0275\u0275element(3, "thy-icon", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.titleSignal());
  }
}
var ThyPopoverConfig = class extends ThyAbstractOverlayConfig {
};
var THY_POPOVER_DEFAULT_CONFIG = new InjectionToken("thy-popover-default-config");
var THY_POPOVER_DEFAULT_CONFIG_VALUE = {
  hasBackdrop: true,
  backdropClass: "thy-popover-backdrop",
  panelClass: "",
  offset: 0,
  backdropClosable: true,
  closeOnNavigation: true,
  placement: "bottom",
  insideClosable: false,
  manualClosure: false,
  originActiveClass: "thy-popover-origin-active",
  autoAdaptive: false,
  minWidth: "240px"
};
var THY_POPOVER_DEFAULT_CONFIG_PROVIDER = {
  provide: THY_POPOVER_DEFAULT_CONFIG,
  useValue: THY_POPOVER_DEFAULT_CONFIG_VALUE
};
var THY_POPOVER_SCROLL_STRATEGY = new InjectionToken("thy-popover-scroll-strategy");
var THY_POPOVER_SCROLL_STRATEGY_FACTORY = (overlay) => {
  return () => overlay.scrollStrategies.block();
};
var THY_POPOVER_SCROLL_STRATEGY_PROVIDER = {
  provide: THY_POPOVER_SCROLL_STRATEGY,
  deps: [Overlay],
  useFactory: THY_POPOVER_SCROLL_STRATEGY_FACTORY
};
var popoverAbstractOverlayOptions = {
  name: "popover",
  animationEnabled: true,
  disposeWhenClose: true
};
var ThyPopoverContainer = class _ThyPopoverContainer extends ThyAbstractOverlayContainer {
  beforeAttachPortal() {
  }
  constructor() {
    const changeDetectorRef = inject(ChangeDetectorRef);
    super(popoverAbstractOverlayOptions, changeDetectorRef);
    this.elementRef = inject(ElementRef);
    this.config = inject(ThyPopoverConfig);
    this.thyClickDispatcher = inject(ThyClickDispatcher);
    this.contentObserver = inject(ContentObserver);
    this.ngZone = inject(NgZone);
    this.animationState = "enter";
    this.animationStateChanged = new EventEmitter();
    this.insideClicked = new EventEmitter();
    this.updatePosition = new EventEmitter();
    this.outsideClicked = new EventEmitter();
    this.animationOpeningDone = this.animationStateChanged.pipe(filter((event) => {
      return event.phaseName === "done" && event.toState === "enter";
    }));
    this.animationClosingDone = this.animationStateChanged.pipe(filter((event) => {
      return event.phaseName === "done" && event.toState === "exit";
    }));
  }
  ngAfterViewInit() {
    if (this.config.outsideClosable && !this.config.hasBackdrop) {
      timer(0).subscribe(() => {
        this.thyClickDispatcher.clicked().pipe(takeUntil(this.animationClosingDone)).subscribe((event) => {
          if (!this.elementRef.nativeElement.contains(event.target)) {
            this.ngZone.run(() => {
              this.outsideClicked.emit();
            });
          }
        });
      });
    }
    if (this.config.autoAdaptive) {
      const onStable$ = this.ngZone.isStable ? from(Promise.resolve()) : this.ngZone.onStable.pipe(take(1));
      this.ngZone.runOutsideAngular(() => {
        onStable$.pipe(takeUntil(this.containerDestroy)).subscribe(() => {
          this.contentObserver.observe(this.elementRef).pipe(takeUntil(this.containerDestroy)).subscribe(() => {
            this.updatePosition.emit();
          });
        });
      });
    }
  }
  /** Callback, invoked whenever an animation on the host completes. */
  onAnimationDone(event) {
    this.animationStateChanged.emit(event);
  }
  /** Callback, invoked when an animation on the host starts. */
  onAnimationStart(event) {
    this.animationStateChanged.emit(event);
  }
  startExitAnimation() {
    this.animationState = "exit";
    this.changeDetectorRef.markForCheck();
  }
  onInsideClick() {
    if (this.config.insideClosable) {
      this.insideClicked.emit();
    }
  }
  ngOnDestroy() {
    super.destroy();
    this.insideClicked.complete();
    this.updatePosition.complete();
    this.outsideClicked.complete();
  }
  static {
    this.\u0275fac = function ThyPopoverContainer_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopoverContainer)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyPopoverContainer,
      selectors: [["thy-popover-container"]],
      viewQuery: function ThyPopoverContainer_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(ThyPortalOutlet, 7);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.portalOutlet = _t.first);
        }
      },
      hostAttrs: ["tabindex", "-1", 1, "thy-popover-container"],
      hostVars: 6,
      hostBindings: function ThyPopoverContainer_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275syntheticHostListener("@scaleXMotion.start", function ThyPopoverContainer_animation_scaleXMotion_start_HostBindingHandler($event) {
            return ctx.onAnimationStart($event);
          })("@scaleXMotion.done", function ThyPopoverContainer_animation_scaleXMotion_done_HostBindingHandler($event) {
            return ctx.onAnimationDone($event);
          })("@scaleYMotion.start", function ThyPopoverContainer_animation_scaleYMotion_start_HostBindingHandler($event) {
            return ctx.onAnimationStart($event);
          })("@scaleYMotion.done", function ThyPopoverContainer_animation_scaleYMotion_done_HostBindingHandler($event) {
            return ctx.onAnimationDone($event);
          })("@scaleMotion.start", function ThyPopoverContainer_animation_scaleMotion_start_HostBindingHandler($event) {
            return ctx.onAnimationStart($event);
          })("@scaleMotion.done", function ThyPopoverContainer_animation_scaleMotion_done_HostBindingHandler($event) {
            return ctx.onAnimationDone($event);
          });
          \u0275\u0275listener("click", function ThyPopoverContainer_click_HostBindingHandler() {
            return ctx.onInsideClick();
          });
        }
        if (rf & 2) {
          \u0275\u0275syntheticHostProperty("@.disabled", !!ctx.config.animationDisabled)("@scaleXMotion", ctx.config.placement === "left" || ctx.config.placement === "right" ? ctx.animationState : "void")("@scaleYMotion", ctx.config.placement === "top" || ctx.config.placement === "bottom" ? ctx.animationState : "void")("@scaleMotion", ctx.config.placement !== "left" && ctx.config.placement !== "right" && ctx.config.placement !== "top" && ctx.config.placement !== "bottom" ? ctx.animationState : "void");
          \u0275\u0275attribute("role", "popover")("id", ctx.id);
        }
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 1,
      vars: 0,
      consts: [["thyPortalOutlet", ""]],
      template: function ThyPopoverContainer_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, ThyPopoverContainer_ng_template_0_Template, 0, 0, "ng-template", 0);
        }
      },
      dependencies: [PortalModule, ThyPortalOutlet],
      encapsulation: 2,
      data: {
        animation: [scaleXMotion, scaleYMotion, scaleMotion]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopoverContainer, [{
    type: Component,
    args: [{
      selector: "thy-popover-container",
      animations: [scaleXMotion, scaleYMotion, scaleMotion],
      host: {
        class: "thy-popover-container",
        tabindex: "-1",
        "[attr.role]": `'popover'`,
        "[attr.id]": "id",
        "[@.disabled]": "!!config.animationDisabled",
        "[@scaleXMotion]": '(config.placement === "left" || config.placement === "right") ? animationState : "void"',
        "(@scaleXMotion.start)": "onAnimationStart($event)",
        "(@scaleXMotion.done)": "onAnimationDone($event)",
        "[@scaleYMotion]": '(config.placement === "top" || config.placement === "bottom") ? animationState : "void"',
        "(@scaleYMotion.start)": "onAnimationStart($event)",
        "(@scaleYMotion.done)": "onAnimationDone($event)",
        "[@scaleMotion]": '(config.placement !== "left" && config.placement !== "right" && config.placement !== "top" && config.placement !== "bottom") ? animationState : "void"',
        "(@scaleMotion.start)": "onAnimationStart($event)",
        "(@scaleMotion.done)": "onAnimationDone($event)"
      },
      imports: [PortalModule, ThyPortalOutlet],
      template: "<ng-template thyPortalOutlet></ng-template>\n"
    }]
  }], () => [], {
    portalOutlet: [{
      type: ViewChild,
      args: [ThyPortalOutlet, {
        static: true
      }]
    }],
    onInsideClick: [{
      type: HostListener,
      args: ["click", []]
    }]
  });
})();
var ThyPopoverRef = class extends ThyAbstractOverlayRef {
};
var ThyInternalPopoverRef = class extends ThyAbstractInternalOverlayRef {
  get options() {
    return popoverAbstractOverlayOptions;
  }
  constructor() {
    super();
  }
  initialize(overlayRef, containerInstance, config2) {
    super.initialize(overlayRef, containerInstance, config2);
    merge(containerInstance.insideClicked, containerInstance.outsideClicked).subscribe(() => this.close());
    containerInstance.updatePosition.subscribe(() => {
      this.updatePosition();
    });
  }
  /**
   * Updates the popover's position.
   * @param position New popover position.
   */
  updatePosition() {
    this.overlayRef.updatePosition();
    return this;
  }
};
var ThyPopover = class _ThyPopover extends ThyAbstractOverlayService {
  buildPositionStrategy(config2) {
    const origin = config2.originPosition ? config2.originPosition : config2.origin;
    const positionStrategy = new FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);
    const positions = getFlexiblePositions(config2.placement, config2.offset, "thy-popover");
    positionStrategy.withPositions(positions);
    positionStrategy.withPush(config2.canPush);
    positionStrategy.withGrowAfterOpen(true);
    positionStrategy.withTransformOriginOn(".thy-popover-container");
    positionStrategy.positionChanges.pipe(takeUntil(this.ngUnsubscribe$)).subscribe((change) => {
      if (change.scrollableViewProperties.isOverlayClipped) {
        this.ngZone.run(() => this.close());
      }
    });
    return positionStrategy;
  }
  buildScrollStrategy(config2) {
    if (config2.scrollStrategy) {
      return config2.scrollStrategy;
    } else if (this.scrollStrategy && isFunction(this.scrollStrategy)) {
      return this.scrollStrategy();
    } else {
      return this.overlay.scrollStrategies.block();
    }
  }
  buildOverlayConfig(config2) {
    const positionStrategy = this.buildPositionStrategy(config2);
    const overlayConfig = this.buildBaseOverlayConfig(config2, "thy-popover-panel");
    overlayConfig.positionStrategy = positionStrategy;
    overlayConfig.scrollStrategy = this.buildScrollStrategy(config2);
    return overlayConfig;
  }
  attachOverlayContainer(overlay, config2) {
    const userInjector = config2 && config2.viewContainerRef && config2.viewContainerRef.injector;
    const injector = Injector.create({
      parent: userInjector || this.injector,
      providers: [{
        provide: ThyPopoverConfig,
        useValue: config2
      }]
    });
    const containerPortal = new ComponentPortal(ThyPopoverContainer, config2.viewContainerRef, injector);
    const containerRef = overlay.attach(containerPortal);
    return containerRef.instance;
  }
  createAbstractOverlayRef(overlayRef, containerInstance, config2) {
    const popoverRef = new ThyInternalPopoverRef();
    popoverRef.initialize(overlayRef, containerInstance, config2);
    return popoverRef;
  }
  createInjector(config2, popoverRef, popoverContainer) {
    const userInjector = config2 && config2.viewContainerRef && config2.viewContainerRef.injector;
    const injectionTokens = [{
      provide: ThyPopoverContainer,
      useValue: popoverContainer
    }, {
      provide: ThyPopoverRef,
      useValue: popoverRef
    }];
    if (config2.direction && (!userInjector || !userInjector.get(Directionality, null))) {
      injectionTokens.push({
        provide: Directionality,
        useValue: {
          value: config2.direction,
          change: of()
        }
      });
    }
    return Injector.create({
      parent: userInjector || this.injector,
      providers: injectionTokens
    });
  }
  originElementAddActiveClass(config2) {
    if (config2.originActiveClass) {
      coerceElement(config2.origin).classList.add(...coerceArray(config2.originActiveClass));
    }
  }
  originElementRemoveActiveClass(config2) {
    if (config2.originActiveClass) {
      coerceElement(config2.origin).classList.remove(...coerceArray(config2.originActiveClass));
    }
  }
  constructor() {
    const overlay = inject(Overlay);
    const injector = inject(Injector);
    const defaultConfig2 = inject(THY_POPOVER_DEFAULT_CONFIG, {
      optional: true
    });
    const scrollStrategy = inject(THY_POPOVER_SCROLL_STRATEGY);
    super(popoverAbstractOverlayOptions, overlay, injector, __spreadValues(__spreadValues({}, THY_POPOVER_DEFAULT_CONFIG_VALUE), defaultConfig2), scrollStrategy);
    this.ngZone = inject(NgZone);
    this._viewportRuler = inject(ViewportRuler);
    this._document = inject(DOCUMENT, {
      optional: true
    });
    this._platform = inject(Platform);
    this._overlayContainer = inject(OverlayContainer);
    this.ngUnsubscribe$ = new Subject();
    this.originInstancesMap = /* @__PURE__ */ new Map();
  }
  ensureCloseClosest(origin) {
    let closeAndEnd = false;
    this.originInstancesMap.forEach((value, key) => {
      if (value.config.manualClosure) {
        if (key === origin) {
          value.popoverRef.close();
          closeAndEnd = true;
        }
      } else {
        if (key === origin) {
          closeAndEnd = true;
        }
        value.popoverRef.close();
      }
    });
    return closeAndEnd;
  }
  /**
   * 打开悬浮层
   */
  open(componentOrTemplateRef, config2) {
    const originElement = coerceElement(config2?.origin);
    if (this.ensureCloseClosest(originElement)) {
      return;
    }
    const popoverRef = this.openOverlay(componentOrTemplateRef, config2);
    config2 = popoverRef.containerInstance.config;
    popoverRef.afterClosed().subscribe(() => {
      this.originElementRemoveActiveClass(config2);
      this.originInstancesMap.delete(originElement);
    });
    this.originElementAddActiveClass(config2);
    this.originInstancesMap.set(originElement, {
      config: config2,
      popoverRef
    });
    return popoverRef;
  }
  /**
   * 根据Id获取打开的悬浮层
   */
  getPopoverById(id) {
    return this.getAbstractOverlayById(id);
  }
  /**
   * 获取已经打开的悬浮层
   */
  getOpenedPopovers() {
    return this.getAbstractOverlays();
  }
  /**
   * @description.en-us Finds the closest ThyPopoverRef to an element by looking at the DOM.
   * @description 通过 Dom 元素查找最近弹出的悬浮层
   */
  getClosestPopover(element) {
    const parent = element.closest(".thy-popover-container");
    if (parent && parent.id) {
      return this.getPopoverById(parent.id);
    }
    return null;
  }
  /**
   * 关闭悬浮层
   */
  close(result, force) {
    super.close(result, force);
  }
  /**
   * @internal
   */
  ngOnDestroy() {
    this.dispose();
  }
  static {
    this.\u0275fac = function ThyPopover_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopover)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyPopover,
      factory: _ThyPopover.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopover, [{
    type: Injectable
  }], () => [], null);
})();
var ThyPopoverBody = class _ThyPopoverBody {
  static {
    this.\u0275fac = function ThyPopoverBody_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopoverBody)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyPopoverBody,
      selectors: [["thy-popover-body"]],
      hostAttrs: [1, "thy-popover-body"],
      exportAs: ["thyPopoverBody"],
      ngContentSelectors: _c05,
      decls: 1,
      vars: 0,
      template: function ThyPopoverBody_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopoverBody, [{
    type: Component,
    args: [{
      selector: "thy-popover-body",
      template: "<ng-content></ng-content>",
      exportAs: "thyPopoverBody",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-popover-body"
      }
    }]
  }], null, null);
})();
var ThyPopoverHeader = class _ThyPopoverHeader {
  constructor() {
    this.translate = inject(ThyTranslate);
    this.thyPopover = inject(ThyPopover);
    this.thyTitle = input(void 0, ...ngDevMode ? [{
      debugName: "thyTitle"
    }] : []);
    this.thyTitleTranslationKey = input(void 0, ...ngDevMode ? [{
      debugName: "thyTitleTranslationKey"
    }] : []);
    this.titleSignal = computed(() => {
      const title = this.thyTitle();
      if (title) {
        return title;
      }
      const titleTranslationKey = this.thyTitleTranslationKey();
      if (titleTranslationKey) {
        return this.translate.instant(titleTranslationKey);
      }
      return "";
    }, ...ngDevMode ? [{
      debugName: "titleSignal"
    }] : []);
    this.headerTemplate = contentChild("popoverHeader", ...ngDevMode ? [{
      debugName: "headerTemplate"
    }] : []);
    this.thyClosed = output();
  }
  /**
   * @internal
   */
  close(event) {
    this.thyClosed.emit(event);
    this.thyPopover.close();
  }
  static {
    this.\u0275fac = function ThyPopoverHeader_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopoverHeader)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyPopoverHeader,
      selectors: [["thy-popover-header"]],
      contentQueries: function ThyPopoverHeader_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.headerTemplate, _c12, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: [1, "thy-popover-header"],
      inputs: {
        thyTitle: [1, "thyTitle"],
        thyTitleTranslationKey: [1, "thyTitleTranslationKey"]
      },
      outputs: {
        thyClosed: "thyClosed"
      },
      exportAs: ["thyPopoverHeader"],
      decls: 2,
      vars: 1,
      consts: [[3, "ngTemplateOutlet"], [1, "thy-popover-title"], ["type", "button", 1, "close", 3, "click"], ["thyIconName", "close"]],
      template: function ThyPopoverHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ThyPopoverHeader_Conditional_0_Template, 1, 1, "template", 0)(1, ThyPopoverHeader_Conditional_1_Template, 4, 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.headerTemplate() ? 0 : 1);
        }
      },
      dependencies: [NgTemplateOutlet, ThyIcon],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopoverHeader, [{
    type: Component,
    args: [{
      selector: "thy-popover-header",
      exportAs: "thyPopoverHeader",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-popover-header"
      },
      imports: [NgTemplateOutlet, ThyIcon],
      template: '@if (headerTemplate()) {\n  <template [ngTemplateOutlet]="headerTemplate()"></template>\n} @else {\n  <h5 class="thy-popover-title">{{ titleSignal() }}</h5>\n  <button type="button" class="close" (click)="close($event)">\n    <thy-icon thyIconName="close"></thy-icon>\n  </button>\n}\n'
    }]
  }], null, {
    thyTitle: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTitle",
        required: false
      }]
    }],
    thyTitleTranslationKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTitleTranslationKey",
        required: false
      }]
    }],
    headerTemplate: [{
      type: ContentChild,
      args: ["popoverHeader", {
        isSignal: true
      }]
    }],
    thyClosed: [{
      type: Output,
      args: ["thyClosed"]
    }]
  });
})();
var ThyPopoverDirective = class _ThyPopoverDirective extends ThyOverlayDirectiveBase {
  /**
   * 是否禁用打开悬浮层
   * @default false
   */
  set thyDisabled(value) {
    this.disabled = value;
  }
  constructor() {
    const elementRef = inject(ElementRef);
    const platform = inject(Platform);
    const focusMonitor = inject(FocusMonitor);
    const ngZone = inject(NgZone);
    super(elementRef, platform, focusMonitor, ngZone, true);
    this.popover = inject(ThyPopover);
    this.viewContainerRef = inject(ViewContainerRef);
    this.cdr = inject(ChangeDetectorRef);
    this.popoverOpened = false;
    this.content = input(void 0, ...ngDevMode ? [{
      debugName: "content",
      alias: "thyPopover"
    }] : [{
      alias: "thyPopover"
    }]);
    this.thyTrigger = input("click", ...ngDevMode ? [{
      debugName: "thyTrigger"
    }] : []);
    this.thyPlacement = input("bottom", ...ngDevMode ? [{
      debugName: "thyPlacement"
    }] : []);
    this.thyOffset = input(0, ...ngDevMode ? [{
      debugName: "thyOffset",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyConfig = input(void 0, ...ngDevMode ? [{
      debugName: "thyConfig"
    }] : []);
    this.thyShowDelay = input(0, ...ngDevMode ? [{
      debugName: "thyShowDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyHideDelay = input(0, ...ngDevMode ? [{
      debugName: "thyHideDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyAutoAdaptive = input(false, ...ngDevMode ? [{
      debugName: "thyAutoAdaptive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.elementRef = elementRef;
    effect(() => {
      this.trigger = this.thyTrigger();
    });
    effect(() => {
      this.showDelay = this.thyShowDelay();
    });
    effect(() => {
      this.hideDelay = this.thyHideDelay();
    });
  }
  ngOnInit() {
    this.initialize();
  }
  createOverlay() {
    const config2 = Object.assign({
      origin: this.elementRef.nativeElement,
      hasBackdrop: this.trigger === "click" || this.trigger === "focus",
      viewContainerRef: this.viewContainerRef,
      placement: this.thyPlacement(),
      offset: this.thyOffset(),
      autoAdaptive: this.thyAutoAdaptive()
    }, this.thyConfig());
    this.popoverRef = this.popover.open(this.content(), config2);
    this.popoverRef.afterClosed().subscribe(() => {
      this.popoverOpened = false;
    });
    return this.popoverRef.getOverlayRef();
  }
  show(delay2 = this.showDelay) {
    if (this.hideTimeoutId) {
      clearTimeout(this.hideTimeoutId);
      this.hideTimeoutId = null;
    }
    if (this.disabled || this.overlayRef && this.overlayRef.hasAttached()) {
      return;
    }
    if (this.trigger !== "hover") {
      delay2 = 0;
    }
    this.showTimeoutId = setTimeout(() => {
      if (!this.disabled) {
        const overlayRef = this.createOverlay();
        this.overlayRef = overlayRef;
        this.popoverOpened = true;
        this.cdr.markForCheck();
      }
      this.showTimeoutId = null;
    }, delay2);
  }
  hide(delay2 = this.hideDelay) {
    if (this.showTimeoutId) {
      clearTimeout(this.showTimeoutId);
      this.showTimeoutId = null;
    }
    this.hideTimeoutId = setTimeout(() => {
      if (this.popoverRef) {
        this.popoverRef.close();
        this.cdr.markForCheck();
      }
      this.hideTimeoutId = null;
    }, delay2);
  }
  ngOnDestroy() {
    this.dispose();
  }
  static {
    this.\u0275fac = function ThyPopoverDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopoverDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyPopoverDirective,
      selectors: [["", "thyPopover", ""]],
      hostVars: 2,
      hostBindings: function ThyPopoverDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-popover-opened", ctx.popoverOpened);
        }
      },
      inputs: {
        content: [1, "thyPopover", "content"],
        thyTrigger: [1, "thyTrigger"],
        thyPlacement: [1, "thyPlacement"],
        thyOffset: [1, "thyOffset"],
        thyConfig: [1, "thyConfig"],
        thyShowDelay: [1, "thyShowDelay"],
        thyHideDelay: [1, "thyHideDelay"],
        thyAutoAdaptive: [1, "thyAutoAdaptive"],
        thyDisabled: [2, "thyDisabled", "thyDisabled", coerceBooleanProperty2]
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopoverDirective, [{
    type: Directive,
    args: [{
      selector: "[thyPopover]"
    }]
  }], () => [], {
    popoverOpened: [{
      type: HostBinding,
      args: [`class.thy-popover-opened`]
    }],
    content: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPopover",
        required: false
      }]
    }],
    thyTrigger: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTrigger",
        required: false
      }]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlacement",
        required: false
      }]
    }],
    thyOffset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyOffset",
        required: false
      }]
    }],
    thyConfig: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyConfig",
        required: false
      }]
    }],
    thyShowDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowDelay",
        required: false
      }]
    }],
    thyHideDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHideDelay",
        required: false
      }]
    }],
    thyAutoAdaptive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutoAdaptive",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        transform: coerceBooleanProperty2
      }]
    }]
  });
})();
var ThyPopoverModule = class _ThyPopoverModule {
  static {
    this.\u0275fac = function ThyPopoverModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPopoverModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyPopoverModule,
      imports: [CommonModule, OverlayModule, PortalModule, ThyIconModule, ThyPopoverContainer, ThyPopoverDirective, ThyPopoverHeader, ThyPopoverBody],
      exports: [ThyPopoverDirective, ThyPopoverHeader, ThyPopoverBody]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_SCROLL_STRATEGY_PROVIDER, ThyPopover],
      imports: [CommonModule, OverlayModule, PortalModule, ThyIconModule, ThyPopoverContainer, ThyPopoverHeader]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPopoverModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OverlayModule, PortalModule, ThyIconModule, ThyPopoverContainer, ThyPopoverDirective, ThyPopoverHeader, ThyPopoverBody],
      exports: [ThyPopoverDirective, ThyPopoverHeader, ThyPopoverBody],
      providers: [THY_POPOVER_DEFAULT_CONFIG_PROVIDER, THY_POPOVER_SCROLL_STRATEGY_PROVIDER, ThyPopover]
    }]
  }], null, null);
})();
var animationBody = [
  // Note: The `enter` animation transitions to `transform: none`, because for some reason
  // specifying the transform explicitly, causes IE both to blur the dialog content and
  // decimate the animation performance. Leaving it as `none` solves both issues. translate(-300px,-100px)
  state("void, exit", style({
    opacity: 0,
    transform: "scale(0.1)"
  })),
  state("enter", style({
    transform: "none"
  }))
  // transition('* => enter', animate('100ms cubic-bezier(0, 0, 0.57, 1)', style({ transform: 'none', opacity: 1 }))),
  // transition(
  //     '* => exit',
  //     animate('150ms cubic-bezier(0.24, 0.18, 0.96, 0.52)', style({ transform: 'scale(0.3)', opacity: 0 }))
  // )
];
var thyPopoverAnimations = {
  popoverContainer: trigger("popoverContainer", animationBody)
};

// node_modules/ngx-tethys/fesm2022/ngx-tethys-dropdown.mjs
var _c06 = ["dropdownMenu"];
var _c13 = ["*"];
function ThyDropdownMenuComponent_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyDropdownMenuComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyDropdownMenuComponent_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 2);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const content_r1 = \u0275\u0275reference(4);
    \u0275\u0275property("ngTemplateOutlet", content_r1);
  }
}
function ThyDropdownMenuComponent_ng_template_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyDropdownMenuComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275template(1, ThyDropdownMenuComponent_ng_template_1_ng_container_1_Template, 1, 0, "ng-container", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const content_r1 = \u0275\u0275reference(4);
    \u0275\u0275styleProp("width", ctx_r1.thyWidth());
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", content_r1);
  }
}
function ThyDropdownMenuComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var _c22 = ["thyDropdownSubmenu", ""];
var THY_DROPDOWN_DEFAULT_WIDTH = "240px";
var ThyDropdownAbstractMenu = class _ThyDropdownAbstractMenu {
  constructor() {
    this.addDropdownMenuClass = true;
  }
  static {
    this.\u0275fac = function ThyDropdownAbstractMenu_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownAbstractMenu)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownAbstractMenu,
      hostVars: 2,
      hostBindings: function ThyDropdownAbstractMenu_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-dropdown-menu", ctx.addDropdownMenuClass);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownAbstractMenu, [{
    type: Directive
  }], null, {
    addDropdownMenuClass: [{
      type: HostBinding,
      args: ["class.thy-dropdown-menu"]
    }]
  });
})();
var ThyDropdownMenuComponent = class _ThyDropdownMenuComponent {
  constructor() {
    this.templateRef = viewChild.required("dropdownMenu");
    this.thyWidth = input(THY_DROPDOWN_DEFAULT_WIDTH, ...ngDevMode ? [{
      debugName: "thyWidth",
      transform: coerceCssPixelValue2
    }] : [{
      transform: coerceCssPixelValue2
    }]);
    this.thyImmediateRender = input(false, ...ngDevMode ? [{
      debugName: "thyImmediateRender",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThyDropdownMenuComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDropdownMenuComponent,
      selectors: [["thy-dropdown-menu"]],
      viewQuery: function ThyDropdownMenuComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.templateRef, _c06, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostVars: 4,
      hostBindings: function ThyDropdownMenuComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275styleProp("width", ctx.thyImmediateRender() ? ctx.thyWidth() : "");
          \u0275\u0275classProp("thy-dropdown-menu", ctx.thyImmediateRender());
        }
      },
      inputs: {
        thyWidth: [1, "thyWidth"],
        thyImmediateRender: [1, "thyImmediateRender"]
      },
      ngContentSelectors: _c13,
      decls: 5,
      vars: 1,
      consts: [["dropdownMenu", ""], ["content", ""], [4, "ngTemplateOutlet"], [1, "thy-dropdown-menu"]],
      template: function ThyDropdownMenuComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275conditionalCreate(0, ThyDropdownMenuComponent_Conditional_0_Template, 1, 1, "ng-container");
          \u0275\u0275template(1, ThyDropdownMenuComponent_ng_template_1_Template, 2, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(3, ThyDropdownMenuComponent_ng_template_3_Template, 1, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.thyImmediateRender() ? 0 : -1);
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuComponent, [{
    type: Component,
    args: [{
      selector: "thy-dropdown-menu",
      template: `
        @if (thyImmediateRender()) {
            <ng-container *ngTemplateOutlet="content"></ng-container>
        }
        <ng-template #dropdownMenu>
            <div class="thy-dropdown-menu" [style.width]="thyWidth()">
                <ng-container *ngTemplateOutlet="content"></ng-container>
            </div>
        </ng-template>
        <ng-template #content>
            <ng-content></ng-content>
        </ng-template>
    `,
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        "[class.thy-dropdown-menu]": "thyImmediateRender()",
        "[style.width]": "thyImmediateRender() ? thyWidth() : ''"
      },
      imports: [NgTemplateOutlet]
    }]
  }], () => [], {
    templateRef: [{
      type: ViewChild,
      args: ["dropdownMenu", {
        isSignal: true
      }]
    }],
    thyWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyWidth",
        required: false
      }]
    }],
    thyImmediateRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyImmediateRender",
        required: false
      }]
    }]
  });
})();
var ThyDropdownMenuGroup = class _ThyDropdownMenuGroup {
  constructor() {
    this.thyTitle = input(...ngDevMode ? [void 0, {
      debugName: "thyTitle"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyDropdownMenuGroup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuGroup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDropdownMenuGroup,
      selectors: [["thy-dropdown-menu-group"]],
      hostAttrs: [1, "dropdown-menu-group"],
      inputs: {
        thyTitle: [1, "thyTitle"]
      },
      ngContentSelectors: _c13,
      decls: 3,
      vars: 1,
      consts: [[1, "dropdown-menu-group-title"]],
      template: function ThyDropdownMenuGroup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275domElementStart(0, "div", 0);
          \u0275\u0275text(1);
          \u0275\u0275domElementEnd();
          \u0275\u0275projection(2);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275textInterpolate(ctx.thyTitle());
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuGroup, [{
    type: Component,
    args: [{
      selector: "thy-dropdown-menu-group",
      template: `
        <div class="dropdown-menu-group-title">{{ thyTitle() }}</div>
        <ng-content></ng-content>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "dropdown-menu-group"
      }
    }]
  }], () => [], {
    thyTitle: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTitle",
        required: false
      }]
    }]
  });
})();
var ThyDropdownMenuDivider = class _ThyDropdownMenuDivider {
  constructor() {
  }
  static {
    this.\u0275fac = function ThyDropdownMenuDivider_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuDivider)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDropdownMenuDivider,
      selectors: [["thy-dropdown-menu-divider"]],
      hostAttrs: [1, "dropdown-menu-divider"],
      decls: 0,
      vars: 0,
      template: function ThyDropdownMenuDivider_Template(rf, ctx) {
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuDivider, [{
    type: Component,
    args: [{
      selector: "thy-dropdown-menu-divider",
      template: ` <!-- <div class="dropdown-menu-divider-title">{{ title }}</div> --> `,
      host: {
        class: "dropdown-menu-divider"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], () => [], null);
})();
var ThyDropdownDirective = class _ThyDropdownDirective extends ThyOverlayDirectiveBase {
  constructor() {
    const elementRef = inject(ElementRef);
    const platform = inject(Platform);
    const focusMonitor = inject(FocusMonitor);
    const ngZone = inject(NgZone);
    const changeDetectorRef = inject(ChangeDetectorRef);
    super(elementRef, platform, focusMonitor, ngZone, true, changeDetectorRef);
    this.viewContainerRef = inject(ViewContainerRef);
    this.popover = inject(ThyPopover);
    this.menu = computed(() => {
      return this.thyDropdownMenu() || this.thyDropdown();
    }, ...ngDevMode ? [{
      debugName: "menu"
    }] : []);
    this.popoverOpened = false;
    this.thyDropdownMenu = input(...ngDevMode ? [void 0, {
      debugName: "thyDropdownMenu"
    }] : []);
    this.thyDropdown = input(...ngDevMode ? [void 0, {
      debugName: "thyDropdown"
    }] : []);
    this.thyTrigger = input("click", ...ngDevMode ? [{
      debugName: "thyTrigger"
    }] : []);
    this.thyShowDelay = input(100, ...ngDevMode ? [{
      debugName: "thyShowDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyHideDelay = input(100, ...ngDevMode ? [{
      debugName: "thyHideDelay",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.thyActiveClass = input("thy-dropdown-origin-active", ...ngDevMode ? [{
      debugName: "thyActiveClass",
      transform: (value) => value || "thy-dropdown-origin-active"
    }] : [{
      transform: (value) => value || "thy-dropdown-origin-active"
    }]);
    this.thyPopoverOptions = input(...ngDevMode ? [void 0, {
      debugName: "thyPopoverOptions"
    }] : []);
    this.thyPlacement = input(...ngDevMode ? [void 0, {
      debugName: "thyPlacement"
    }] : []);
    this.thyMenuInsideClosable = input(void 0, ...ngDevMode ? [{
      debugName: "thyMenuInsideClosable",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPanelClass = input(["thy-dropdown-pane"], ...ngDevMode ? [{
      debugName: "thyPanelClass",
      transform: (value) => !isUndefinedOrNull(value) && ["thy-dropdown-pane"].concat(coerceArray2(value)) || ["thy-dropdown-pane"]
    }] : [{
      transform: (value) => !isUndefinedOrNull(value) && ["thy-dropdown-pane"].concat(coerceArray2(value)) || ["thy-dropdown-pane"]
    }]);
    this.thyActiveChange = output();
    effect(() => {
      this.trigger = this.thyTrigger() || "click";
    });
    effect(() => {
      this.hideDelay = this.thyHideDelay() ?? 100;
    });
    effect(() => {
      this.showDelay = this.thyShowDelay() ?? 100;
    });
  }
  ngOnInit() {
    this.initialize();
  }
  createOverlay() {
    let componentTypeOrTemplateRef;
    const menu = this.menu();
    if (menu && menu instanceof ThyDropdownMenuComponent) {
      componentTypeOrTemplateRef = menu?.templateRef();
    } else if (isFunction(menu) || isTemplateRef(menu)) {
      componentTypeOrTemplateRef = menu;
    }
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (!componentTypeOrTemplateRef) {
        throw new Error(`thyDropdownMenu is required`);
      }
    }
    const {
      placement,
      height,
      insideClosable,
      outsideClosable,
      minWidth
    } = Object.assign({
      placement: "bottomLeft",
      insideClosable: true,
      outsideClosable: true
    }, this.thyPopoverOptions());
    const thyPlacement = this.thyPlacement();
    const thyMenuInsideClosable = this.thyMenuInsideClosable();
    const config2 = {
      origin: this.elementRef.nativeElement,
      hasBackdrop: false,
      viewContainerRef: this.viewContainerRef,
      offset: 0,
      panelClass: this.thyPanelClass(),
      placement: thyPlacement ? thyPlacement : placement,
      height,
      outsideClosable,
      insideClosable: index.isUndefined(thyMenuInsideClosable) ? insideClosable : thyMenuInsideClosable,
      minWidth,
      originActiveClass: this.thyActiveClass()
    };
    this.popoverRef = this.popover.open(componentTypeOrTemplateRef, config2);
    this.popoverRef.afterOpened().subscribe(() => {
      this.thyActiveChange.emit(true);
    });
    this.popoverRef.afterClosed().subscribe(() => {
      this.popoverOpened = false;
      this.thyActiveChange.emit(false);
    });
    return this.popoverRef.getOverlayRef();
  }
  show(delay2 = this.showDelay) {
    if (this.hideTimeoutId) {
      clearTimeout(this.hideTimeoutId);
      this.hideTimeoutId = null;
    }
    if (this.disabled || this.overlayRef && this.overlayRef.hasAttached()) {
      return;
    }
    if (this.trigger !== "hover") {
      delay2 = 0;
    }
    this.showTimeoutId = setTimeout(() => {
      const overlayRef = this.createOverlay();
      this.overlayRef = overlayRef;
      this.popoverOpened = true;
      this.showTimeoutId = null;
      this.markForCheck();
    }, delay2);
  }
  hide(delay2 = this.hideDelay) {
    if (this.showTimeoutId) {
      clearTimeout(this.showTimeoutId);
      this.showTimeoutId = null;
    }
    this.hideTimeoutId = setTimeout(() => {
      if (this.popoverRef) {
        this.popoverRef.close();
      }
      this.hideTimeoutId = null;
      this.markForCheck();
    }, delay2);
  }
  static {
    this.\u0275fac = function ThyDropdownDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownDirective,
      selectors: [["", "thyDropdown", ""]],
      hostAttrs: [1, "thy-dropdown"],
      inputs: {
        thyDropdownMenu: [1, "thyDropdownMenu"],
        thyDropdown: [1, "thyDropdown"],
        thyTrigger: [1, "thyTrigger"],
        thyShowDelay: [1, "thyShowDelay"],
        thyHideDelay: [1, "thyHideDelay"],
        thyActiveClass: [1, "thyActiveClass"],
        thyPopoverOptions: [1, "thyPopoverOptions"],
        thyPlacement: [1, "thyPlacement"],
        thyMenuInsideClosable: [1, "thyMenuInsideClosable"],
        thyPanelClass: [1, "thyPanelClass"]
      },
      outputs: {
        thyActiveChange: "thyActiveChange"
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownDirective, [{
    type: Directive,
    args: [{
      selector: `[thyDropdown]`,
      host: {
        class: "thy-dropdown"
      }
    }]
  }], () => [], {
    thyDropdownMenu: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDropdownMenu",
        required: false
      }]
    }],
    thyDropdown: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDropdown",
        required: false
      }]
    }],
    thyTrigger: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTrigger",
        required: false
      }]
    }],
    thyShowDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowDelay",
        required: false
      }]
    }],
    thyHideDelay: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHideDelay",
        required: false
      }]
    }],
    thyActiveClass: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyActiveClass",
        required: false
      }]
    }],
    thyPopoverOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPopoverOptions",
        required: false
      }]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlacement",
        required: false
      }]
    }],
    thyMenuInsideClosable: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMenuInsideClosable",
        required: false
      }]
    }],
    thyPanelClass: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPanelClass",
        required: false
      }]
    }],
    thyActiveChange: [{
      type: Output,
      args: ["thyActiveChange"]
    }]
  });
})();
var ThyDropdownMenuItemDirective = class _ThyDropdownMenuItemDirective {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.danger = computed(() => this.thyType() === "danger" || false, ...ngDevMode ? [{
      debugName: "danger"
    }] : []);
    this.success = computed(() => this.thyType() === "success" || false, ...ngDevMode ? [{
      debugName: "success"
    }] : []);
    this.thyType = input("default", ...ngDevMode ? [{
      debugName: "thyType"
    }] : []);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.hostRenderer = useHostRenderer();
  }
  onClick(event) {
    if (this.thyDisabled()) {
      event.stopPropagation();
      event.preventDefault();
    }
  }
  ngOnInit() {
  }
  updateClass(classes) {
    this.hostRenderer.updateClass(classes);
  }
  getElement() {
    return this.elementRef.nativeElement;
  }
  bindMouseenterEvent() {
    return fromEvent(this.elementRef.nativeElement, "mouseenter").pipe(debounceTime(100), shareReplay());
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemDirective,
      selectors: [["", "thyDropdownMenuItem", ""]],
      hostAttrs: [1, "dropdown-menu-item"],
      hostVars: 6,
      hostBindings: function ThyDropdownMenuItemDirective_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("click", function ThyDropdownMenuItemDirective_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275classProp("dropdown-menu-item--disabled", ctx.thyDisabled())("dropdown-menu-item--danger", ctx.danger())("dropdown-menu-item--success", ctx.success());
        }
      },
      inputs: {
        thyType: [1, "thyType"],
        thyDisabled: [1, "thyDisabled"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItem]",
      host: {
        class: "dropdown-menu-item",
        "[class.dropdown-menu-item--disabled]": `thyDisabled()`,
        "[class.dropdown-menu-item--danger]": "danger()",
        "[class.dropdown-menu-item--success]": "success()"
      }
    }]
  }], null, {
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var ThyDropdownMenuItemIconDirective = class _ThyDropdownMenuItemIconDirective {
  constructor() {
    this.className = true;
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemIconDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemIconDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemIconDirective,
      selectors: [["", "thyDropdownMenuItemIcon", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemIconDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("icon", ctx.className);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemIconDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemIcon]"
    }]
  }], () => [], {
    className: [{
      type: HostBinding,
      args: ["class.icon"]
    }]
  });
})();
var ThyDropdownMenuItemNameDirective = class _ThyDropdownMenuItemNameDirective {
  constructor() {
    this.className = true;
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemNameDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemNameDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemNameDirective,
      selectors: [["", "thyDropdownMenuItemName", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemNameDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("name", ctx.className);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemNameDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemName]"
    }]
  }], () => [], {
    className: [{
      type: HostBinding,
      args: ["class.name"]
    }]
  });
})();
var ThyDropdownMenuItemMetaDirective = class _ThyDropdownMenuItemMetaDirective {
  constructor() {
    this.className = true;
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemMetaDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemMetaDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemMetaDirective,
      selectors: [["", "thyDropdownMenuItemMeta", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemMetaDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("meta", ctx.className);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemMetaDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemMeta]"
    }]
  }], () => [], {
    className: [{
      type: HostBinding,
      args: ["class.meta"]
    }]
  });
})();
var ThyDropdownMenuItemDescDirective = class _ThyDropdownMenuItemDescDirective {
  constructor() {
    this.className = true;
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemDescDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemDescDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemDescDirective,
      selectors: [["", "thyDropdownMenuItemDesc", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemDescDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("desc", ctx.className);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemDescDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemDesc]"
    }]
  }], () => [], {
    className: [{
      type: HostBinding,
      args: ["class.desc"]
    }]
  });
})();
var ThyDropdownMenuItemExtendIconDirective = class _ThyDropdownMenuItemExtendIconDirective {
  constructor() {
    this.className = true;
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemExtendIconDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemExtendIconDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemExtendIconDirective,
      selectors: [["", "thyDropdownMenuItemExtendIcon", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemExtendIconDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("extend-icon", ctx.className);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemExtendIconDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemExtendIcon]"
    }]
  }], () => [], {
    className: [{
      type: HostBinding,
      args: ["class.extend-icon"]
    }]
  });
})();
var ThyDropdownMenuItemActiveDirective = class _ThyDropdownMenuItemActiveDirective {
  constructor() {
    this.thyDropdownMenuItemActive = input(false, ...ngDevMode ? [{
      debugName: "thyDropdownMenuItemActive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThyDropdownMenuItemActiveDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownMenuItemActiveDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownMenuItemActiveDirective,
      selectors: [["", "thyDropdownMenuItemActive", ""]],
      hostVars: 2,
      hostBindings: function ThyDropdownMenuItemActiveDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("active", ctx.thyDropdownMenuItemActive());
        }
      },
      inputs: {
        thyDropdownMenuItemActive: [1, "thyDropdownMenuItemActive"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownMenuItemActiveDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownMenuItemActive]",
      host: {
        "[class.active]": `thyDropdownMenuItemActive()`
      }
    }]
  }], () => [], {
    thyDropdownMenuItemActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDropdownMenuItemActive",
        required: false
      }]
    }]
  });
})();
var SUBMENU_CLASS_PREFIX = "dropdown-submenu";
var ThyDropdownSubmenu = class _ThyDropdownSubmenu {
  constructor() {
    this.dropdownMenuItem = inject(ThyDropdownMenuItemDirective);
    this.elementRef = inject(ElementRef);
    this.destroyRef = inject(DestroyRef);
    this.thyDirection = input("right", ...ngDevMode ? [{
      debugName: "thyDirection",
      transform: (value) => {
        return value || "right";
      }
    }] : [{
      transform: (value) => {
        return value || "right";
      }
    }]);
  }
  ngOnInit() {
    let direction = this.thyDirection();
    this.updateClassByDirection(direction);
    this.dropdownMenuItem.bindMouseenterEvent().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
      if (this.thyDirection() === "auto") {
        const element = this.dropdownMenuItem.getElement();
        const offset = getElementOffset(element);
        if (document.documentElement.clientWidth < offset.left + offset.width + offset.width) {
          direction = "left";
        } else {
          direction = "right";
        }
        this.updateClassByDirection(direction);
      }
      this.updateVerticalDirection(direction);
    });
  }
  updateClassByDirection(direction) {
    this.dropdownMenuItem.updateClass([`${SUBMENU_CLASS_PREFIX}-${direction}`]);
  }
  updateVerticalDirection(direction) {
    const submenuItems = this.elementRef.nativeElement.querySelectorAll(".dropdown-menu-item");
    if (submenuItems.length) {
      let submenuItemHeight = 0;
      submenuItems.forEach((item) => submenuItemHeight += item.clientHeight);
      if (document.documentElement.clientHeight - this.dropdownMenuItem.getElement().getBoundingClientRect().bottom < submenuItemHeight) {
        direction = direction === "left" ? "leftBottom" : "rightBottom";
        this.updateClassByDirection(direction);
      } else {
        this.updateClassByDirection(direction);
      }
    }
  }
  static {
    this.\u0275fac = function ThyDropdownSubmenu_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownSubmenu)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDropdownSubmenu,
      selectors: [["", "thyDropdownSubmenu", ""], ["thy-dropdown-submenu"]],
      hostAttrs: [1, "dropdown-submenu"],
      inputs: {
        thyDirection: [1, "thyDirection"]
      },
      attrs: _c22,
      ngContentSelectors: _c13,
      decls: 1,
      vars: 0,
      template: function ThyDropdownSubmenu_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownSubmenu, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[thyDropdownSubmenu],thy-dropdown-submenu",
      template: "<ng-content></ng-content>",
      host: {
        class: "dropdown-submenu"
      },
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    thyDirection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDirection",
        required: false
      }]
    }]
  });
})();
var ThyDropdownActiveDirective = class _ThyDropdownActiveDirective {
  constructor() {
    this.trigger = inject(ThyDropdownDirective, {
      optional: true
    });
    this.classes = computed(() => {
      return coerceArray2(this.thyDropdownActive() || []).filter((c) => !!c);
    }, ...ngDevMode ? [{
      debugName: "classes"
    }] : []);
    this.hostRenderer = useHostRenderer();
    this.thyDropdownActive = input(...ngDevMode ? [void 0, {
      debugName: "thyDropdownActive"
    }] : []);
  }
  ngOnInit() {
  }
  ngAfterContentInit() {
    this.triggers.changes.pipe(startWith(this.triggers.toArray()), mergeMap((triggers) => {
      const result = triggers.map((item) => {
        return outputToObservable(item.thyActiveChange);
      });
      this.trigger && result.push(outputToObservable(this.trigger.thyActiveChange));
      return result;
    }), mergeMap((result) => {
      return result;
    })).subscribe((active) => {
      this.update(active);
    });
  }
  update(active) {
    this.classes().forEach((className) => {
      if (active) {
        this.hostRenderer.addClass(className);
      } else {
        this.hostRenderer.removeClass(className);
      }
    });
  }
  static {
    this.\u0275fac = function ThyDropdownActiveDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownActiveDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDropdownActiveDirective,
      selectors: [["", "thyDropdownActive", ""]],
      contentQueries: function ThyDropdownActiveDirective_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, ThyDropdownDirective, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.triggers = _t);
        }
      },
      inputs: {
        thyDropdownActive: [1, "thyDropdownActive"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownActiveDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDropdownActive]"
    }]
  }], null, {
    thyDropdownActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDropdownActive",
        required: false
      }]
    }],
    triggers: [{
      type: ContentChildren,
      args: [ThyDropdownDirective, {
        descendants: true
      }]
    }]
  });
})();
var ThyDropdownModule = class _ThyDropdownModule {
  static {
    this.\u0275fac = function ThyDropdownModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDropdownModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyDropdownModule,
      imports: [CommonModule, ThyPopoverModule, ThyDropdownDirective, ThyDropdownActiveDirective, ThyDropdownMenuComponent, ThyDropdownSubmenu, ThyDropdownMenuGroup, ThyDropdownMenuDivider, ThyDropdownMenuItemDirective, ThyDropdownMenuItemNameDirective, ThyDropdownMenuItemIconDirective, ThyDropdownMenuItemMetaDirective, ThyDropdownMenuItemDescDirective, ThyDropdownMenuItemExtendIconDirective, ThyDropdownMenuItemActiveDirective],
      exports: [ThyDropdownDirective, ThyDropdownActiveDirective, ThyDropdownMenuComponent, ThyDropdownSubmenu, ThyDropdownMenuGroup, ThyDropdownMenuDivider, ThyDropdownMenuItemDirective, ThyDropdownMenuItemNameDirective, ThyDropdownMenuItemIconDirective, ThyDropdownMenuItemMetaDirective, ThyDropdownMenuItemDescDirective, ThyDropdownMenuItemExtendIconDirective, ThyDropdownMenuItemActiveDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyPopoverModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDropdownModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyPopoverModule, ThyDropdownDirective, ThyDropdownActiveDirective, ThyDropdownMenuComponent, ThyDropdownSubmenu, ThyDropdownMenuGroup, ThyDropdownMenuDivider, ThyDropdownMenuItemDirective, ThyDropdownMenuItemNameDirective, ThyDropdownMenuItemIconDirective, ThyDropdownMenuItemMetaDirective, ThyDropdownMenuItemDescDirective, ThyDropdownMenuItemExtendIconDirective, ThyDropdownMenuItemActiveDirective],
      exports: [ThyDropdownDirective, ThyDropdownActiveDirective, ThyDropdownMenuComponent, ThyDropdownSubmenu, ThyDropdownMenuGroup, ThyDropdownMenuDivider, ThyDropdownMenuItemDirective, ThyDropdownMenuItemNameDirective, ThyDropdownMenuItemIconDirective, ThyDropdownMenuItemMetaDirective, ThyDropdownMenuItemDescDirective, ThyDropdownMenuItemExtendIconDirective, ThyDropdownMenuItemActiveDirective]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-nav.mjs
var _c07 = ["thyIconNavLink", ""];
var _c14 = ["*"];
function ThyIconNavLink_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("thyIconName", ctx_r0.thyIconNavLinkIcon());
  }
}
var _c23 = ["more"];
var _c32 = ["morePopover"];
var _c42 = ["extra"];
var _c5 = ["moreOperationContainer"];
var _c6 = (a0) => ({
  $implicit: a0
});
function ThyNav_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 5);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.moreOperation());
  }
}
function ThyNav_Conditional_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275element(1, "thy-icon", 10);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale().more, " ");
  }
}
function ThyNav_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 9, 3);
    \u0275\u0275listener("click", function ThyNav_Conditional_3_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      const navListPopover_r3 = \u0275\u0275reference(7);
      return \u0275\u0275resetView(ctx_r1.openMoreMenu($event, navListPopover_r3));
    });
    \u0275\u0275conditionalCreate(2, ThyNav_Conditional_3_Conditional_2_Template, 1, 1, "ng-container", 5)(3, ThyNav_Conditional_3_Conditional_3_Template, 2, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("d-none", !ctx_r1.showMore())("invisible", !ctx_r1.initialized);
    \u0275\u0275property("thyNavItemActive", ctx_r1.moreActive);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.moreOperation() ? 2 : 3);
  }
}
function ThyNav_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275elementContainer(1, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.thyExtra() || ctx_r1.extra());
  }
}
function ThyNav_ng_template_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 11);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.morePopover())("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c6, ctx_r1.hiddenItems));
  }
}
function ThyNav_ng_template_6_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275pipe(1, "bypassSecurityTrustHtml");
    \u0275\u0275listener("click", function ThyNav_ng_template_6_Conditional_1_For_2_Template_span_click_0_listener() {
      const item_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.navItemClick(item_r5));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    \u0275\u0275property("thyDropdownMenuItemActive", item_r5.isActive)("innerHTML", \u0275\u0275pipeBind1(1, 2, item_r5.elementRef.nativeElement.innerHTML), \u0275\u0275sanitizeHtml);
  }
}
function ThyNav_ng_template_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thy-dropdown-menu", 12);
    \u0275\u0275repeaterCreate(1, ThyNav_ng_template_6_Conditional_1_For_2_Template, 2, 4, "span", 13, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.hiddenItems);
  }
}
function ThyNav_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyNav_ng_template_6_Conditional_0_Template, 1, 4, "ng-container", 11)(1, ThyNav_ng_template_6_Conditional_1_Template, 3, 0, "thy-dropdown-menu", 12);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r1.morePopover() ? 0 : 1);
  }
}
function ThyNav_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
var ThyIconNavLink = class _ThyIconNavLink {
  constructor() {
    this.thyIconNavLinkIcon = input("", ...ngDevMode ? [{
      debugName: "thyIconNavLinkIcon"
    }] : []);
    this.thyIconNavLinkActive = input(false, ...ngDevMode ? [{
      debugName: "thyIconNavLinkActive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThyIconNavLink_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyIconNavLink)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyIconNavLink,
      selectors: [["", "thyIconNavLink", ""]],
      hostVars: 4,
      hostBindings: function ThyIconNavLink_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("active", ctx.thyIconNavLinkActive())("thy-icon-nav-link", true);
        }
      },
      inputs: {
        thyIconNavLinkIcon: [1, "thyIconNavLinkIcon"],
        thyIconNavLinkActive: [1, "thyIconNavLinkActive"]
      },
      attrs: _c07,
      ngContentSelectors: _c14,
      decls: 2,
      vars: 1,
      consts: [[3, "thyIconName"]],
      template: function ThyIconNavLink_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
          \u0275\u0275conditionalCreate(1, ThyIconNavLink_Conditional_1_Template, 1, 1, "thy-icon", 0);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyIconNavLinkIcon() ? 1 : -1);
        }
      },
      dependencies: [ThyIcon],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyIconNavLink, [{
    type: Component,
    args: [{
      // eslint-disable-next-line @angular-eslint/component-selector
      selector: "[thyIconNavLink]",
      template: '<ng-content></ng-content>@if (thyIconNavLinkIcon()) {<thy-icon [thyIconName]="thyIconNavLinkIcon()"></thy-icon>}',
      host: {
        "[class.active]": "thyIconNavLinkActive()",
        "[class.thy-icon-nav-link]": "true"
      },
      imports: [ThyIcon]
    }]
  }], null, {
    thyIconNavLinkIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconNavLinkIcon",
        required: false
      }]
    }],
    thyIconNavLinkActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconNavLinkActive",
        required: false
      }]
    }]
  });
})();
var ThyIconNav = class _ThyIconNav {
  updateClasses() {
    this.hostRenderer.updateClass(this.thyType() ? [`thy-icon-nav-${this.thyType()}`] : []);
  }
  constructor() {
    this.hostRenderer = useHostRenderer();
    this.isIconNav = true;
    this.thyType = input("", ...ngDevMode ? [{
      debugName: "thyType"
    }] : []);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      warnDeprecation("thy-icon-nav has been deprecated, please use thyAction and thy-space components instead of it");
    }
    effect(() => {
      this.updateClasses();
    });
  }
  static {
    this.\u0275fac = function ThyIconNav_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyIconNav)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyIconNav,
      selectors: [["thy-icon-nav"]],
      hostVars: 2,
      hostBindings: function ThyIconNav_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-icon-nav", ctx.isIconNav);
        }
      },
      inputs: {
        thyType: [1, "thyType"]
      },
      ngContentSelectors: _c14,
      decls: 1,
      vars: 0,
      template: function ThyIconNav_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyIconNav, [{
    type: Component,
    args: [{
      selector: "thy-icon-nav",
      changeDetection: ChangeDetectionStrategy.OnPush,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [], {
    isIconNav: [{
      type: HostBinding,
      args: [`class.thy-icon-nav`]
    }],
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }]
  });
})();
var ThyNavItemDirective = class _ThyNavItemDirective {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.routerLinkActive = inject(RouterLinkActive, {
      optional: true
    });
    this.ngZone = inject(NgZone);
    this.id = input(...ngDevMode ? [void 0, {
      debugName: "id"
    }] : []);
    this.thyNavItemActive = input(false, ...ngDevMode ? [{
      debugName: "thyNavItemActive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyNavLinkActive = input(false, ...ngDevMode ? [{
      debugName: "thyNavLinkActive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyNavItemDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyNavItemDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.links = contentChildren(forwardRef(() => _ThyNavItemDirective), ...ngDevMode ? [{
      debugName: "links",
      descendants: true
    }] : [{
      descendants: true
    }]);
    this.routers = contentChildren(RouterLinkActive, ...ngDevMode ? [{
      debugName: "routers",
      descendants: true
    }] : [{
      descendants: true
    }]);
    this.offset = {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    this.hostRenderer = useHostRenderer();
    this.destroyRef = inject(DestroyRef);
  }
  ngAfterViewInit() {
    this.setOffset();
    this.content = this.elementRef.nativeElement.outerHTML;
    this.ngZone.onStable.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
      this.isActive = this.linkIsActive();
    });
  }
  setOffset() {
    this.offset = {
      width: this.elementRef.nativeElement.offsetWidth || this.offset.width,
      height: this.elementRef.nativeElement.offsetHeight || this.offset.height,
      left: this.elementRef.nativeElement.offsetLeft || this.offset.left,
      top: this.elementRef.nativeElement.offsetTop || this.offset.top
    };
  }
  linkIsActive() {
    const links = this.links();
    return this.thyNavItemActive() || this.thyNavLinkActive() || this.routerLinkActive && this.routerLinkActive.isActive || this.routers().some((router) => router.isActive) || links.some((item) => item.thyNavItemActive()) || links.some((item) => item.thyNavLinkActive());
  }
  setNavLinkHidden(value) {
    if (value) {
      this.hostRenderer.addClass("thy-nav-item-hidden");
    } else {
      this.hostRenderer.removeClass("thy-nav-item-hidden");
    }
  }
  addClass(className) {
    this.hostRenderer.addClass(className);
  }
  removeClass(className) {
    this.hostRenderer.removeClass(className);
  }
  static {
    this.\u0275fac = function ThyNavItemDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNavItemDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyNavItemDirective,
      selectors: [["", "thyNavLink", ""], ["", "thyNavItem", ""]],
      contentQueries: function ThyNavItemDirective_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.links, _ThyNavItemDirective, 5)(dirIndex, ctx.routers, RouterLinkActive, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      hostAttrs: [1, "thy-nav-item"],
      hostVars: 4,
      hostBindings: function ThyNavItemDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("active", ctx.thyNavItemActive() || ctx.thyNavLinkActive())("disabled", ctx.thyNavItemDisabled());
        }
      },
      inputs: {
        id: [1, "id"],
        thyNavItemActive: [1, "thyNavItemActive"],
        thyNavLinkActive: [1, "thyNavLinkActive"],
        thyNavItemDisabled: [1, "thyNavItemDisabled"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNavItemDirective, [{
    type: Directive,
    args: [{
      selector: "[thyNavLink],[thyNavItem]",
      host: {
        class: "thy-nav-item",
        "[class.active]": "thyNavItemActive() || thyNavLinkActive()",
        "[class.disabled]": "thyNavItemDisabled()"
      }
    }]
  }], null, {
    id: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "id",
        required: false
      }]
    }],
    thyNavItemActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyNavItemActive",
        required: false
      }]
    }],
    thyNavLinkActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyNavLinkActive",
        required: false
      }]
    }],
    thyNavItemDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyNavItemDisabled",
        required: false
      }]
    }],
    links: [{
      type: ContentChildren,
      args: [forwardRef(() => ThyNavItemDirective), __spreadProps(__spreadValues({}, {
        descendants: true
      }), {
        isSignal: true
      })]
    }],
    routers: [{
      type: ContentChildren,
      args: [forwardRef(() => RouterLinkActive), __spreadProps(__spreadValues({}, {
        descendants: true
      }), {
        isSignal: true
      })]
    }]
  });
})();
var ThyNavInkBarDirective = class _ThyNavInkBarDirective {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ngZone = inject(NgZone);
    this.animationMode = inject(ANIMATION_MODULE_TYPE, {
      optional: true
    });
    this.isVertical = input(false, ...ngDevMode ? [{
      debugName: "isVertical",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showInkBar = input(false, ...ngDevMode ? [{
      debugName: "showInkBar",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.animated = computed(() => this.animationMode !== "NoopAnimations" && this.showInkBar(), ...ngDevMode ? [{
      debugName: "animated"
    }] : []);
  }
  alignToElement(element) {
    this.show();
    this.ngZone.run(() => {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.setStyles(element);
      });
    });
  }
  setStyles(element) {
    const inkBar = this.elementRef.nativeElement;
    if (!this.isVertical()) {
      inkBar.style.top = "";
      inkBar.style.bottom = "0px";
      inkBar.style.height = "2px";
      inkBar.style.left = this.getLeftPosition(element);
      inkBar.style.width = this.getElementWidth(element);
    } else {
      inkBar.style.left = "";
      inkBar.style.width = "2px";
      inkBar.style.top = this.getTopPosition(element);
      inkBar.style.height = this.getElementHeight(element);
    }
  }
  getLeftPosition(element) {
    return element ? `${element.offsetLeft || 0}px` : "0";
  }
  getElementWidth(element) {
    return element ? `${element.offsetWidth || 0}px` : "0";
  }
  getTopPosition(element) {
    return element ? `${element.offsetTop || 0}px` : "0";
  }
  getElementHeight(element) {
    return element ? `${element.offsetHeight || 0}px` : "0";
  }
  show() {
    this.elementRef.nativeElement.style.visibility = "visible";
  }
  hide() {
    this.elementRef.nativeElement.style.visibility = "hidden";
  }
  static {
    this.\u0275fac = function ThyNavInkBarDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNavInkBarDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyNavInkBarDirective,
      selectors: [["thy-nav-ink-bar"], ["", "thyNavInkBar", ""]],
      hostAttrs: [1, "thy-nav-ink-bar"],
      hostVars: 2,
      hostBindings: function ThyNavInkBarDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-nav-ink-bar-animated", ctx.animated());
        }
      },
      inputs: {
        isVertical: [1, "isVertical"],
        showInkBar: [1, "showInkBar"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNavInkBarDirective, [{
    type: Directive,
    args: [{
      selector: "thy-nav-ink-bar, [thyNavInkBar]",
      host: {
        class: "thy-nav-ink-bar",
        "[class.thy-nav-ink-bar-animated]": "animated()"
      }
    }]
  }], null, {
    isVertical: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "isVertical",
        required: false
      }]
    }],
    showInkBar: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showInkBar",
        required: false
      }]
    }]
  });
})();
var BypassSecurityTrustHtmlPipe = class _BypassSecurityTrustHtmlPipe {
  constructor() {
    this.sanitizer = inject(DomSanitizer);
  }
  transform(format4) {
    return this.sanitizer.bypassSecurityTrustHtml(format4);
  }
  static {
    this.\u0275fac = function BypassSecurityTrustHtmlPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _BypassSecurityTrustHtmlPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "bypassSecurityTrustHtml",
      type: _BypassSecurityTrustHtmlPipe,
      pure: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BypassSecurityTrustHtmlPipe, [{
    type: Pipe,
    args: [{
      name: "bypassSecurityTrustHtml"
    }]
  }], null, null);
})();
var navTypeClassesMap = {
  pulled: ["thy-nav-pulled"],
  tabs: ["thy-nav-tabs"],
  pills: ["thy-nav-pills"],
  lite: ["thy-nav-lite"],
  card: ["thy-nav-card"],
  //如下类型已经废弃
  primary: ["thy-nav-primary"],
  secondary: ["thy-nav-secondary"],
  thirdly: ["thy-nav-thirdly"],
  "secondary-divider": ["thy-nav-secondary-divider"]
};
var navSizeClassesMap = {
  lg: "thy-nav-lg",
  md: "thy-nav-md",
  sm: "thy-nav-sm"
};
var tabItemRight = 20;
var ThyNav = class _ThyNav {
  /**
   * @private
   */
  set links(value) {
    this.innerLinks = value;
    this.prevActiveIndex = NaN;
  }
  get links() {
    return this.innerLinks;
  }
  get showInkBar() {
    const showTypes = ["pulled", "tabs"];
    return showTypes.includes(this.type());
  }
  updateClasses() {
    let classNames = [];
    if (navTypeClassesMap[this.type()]) {
      classNames = [...navTypeClassesMap[this.type()]];
    }
    if (navSizeClassesMap[this.thySize()]) {
      classNames.push(navSizeClassesMap[this.thySize()]);
    }
    this.hostRenderer.updateClass(classNames);
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ngZone = inject(NgZone);
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this.popover = inject(ThyPopover);
    this.destroyRef = inject(DestroyRef);
    this.initialized = false;
    this.wrapperOffset = {
      height: 0,
      width: 0,
      left: 0,
      top: 0
    };
    this.hiddenItems = [];
    this.showMore = signal(false, ...ngDevMode ? [{
      debugName: "showMore"
    }] : []);
    this.moreBtnOffset = {
      height: 0,
      width: 0
    };
    this.hostRenderer = useHostRenderer();
    this.locale = injectLocale("nav");
    this.thyType = input(...ngDevMode ? [void 0, {
      debugName: "thyType"
    }] : []);
    this.thySize = input("md", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.thyHorizontal = input("", ...ngDevMode ? [{
      debugName: "thyHorizontal"
    }] : []);
    this.thyVertical = input(false, ...ngDevMode ? [{
      debugName: "thyVertical",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyFill = input(false, ...ngDevMode ? [{
      debugName: "thyFill",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyResponsive = input(void 0, ...ngDevMode ? [{
      debugName: "thyResponsive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPauseReCalculate = input(false, ...ngDevMode ? [{
      debugName: "thyPauseReCalculate"
    }] : []);
    this.thyInsideClosable = input(true, ...ngDevMode ? [{
      debugName: "thyInsideClosable",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPopoverOptions = input(null, ...ngDevMode ? [{
      debugName: "thyPopoverOptions"
    }] : []);
    this.thyExtra = input(...ngDevMode ? [void 0, {
      debugName: "thyExtra"
    }] : []);
    this.routers = contentChildren(RouterLinkActive, ...ngDevMode ? [{
      debugName: "routers",
      descendants: true
    }] : [{
      descendants: true
    }]);
    this.moreOperation = contentChild("more", ...ngDevMode ? [{
      debugName: "moreOperation"
    }] : []);
    this.morePopover = contentChild("morePopover", ...ngDevMode ? [{
      debugName: "morePopover"
    }] : []);
    this.extra = contentChild("extra", ...ngDevMode ? [{
      debugName: "extra"
    }] : []);
    this.defaultMoreOperation = viewChild("moreOperationContainer", ...ngDevMode ? [{
      debugName: "defaultMoreOperation"
    }] : []);
    this.inkBar = viewChild.required(ThyNavInkBarDirective);
    this.horizontal = computed(() => {
      const horizontalValue = this.thyHorizontal();
      return horizontalValue === "right" ? "end" : horizontalValue;
    }, ...ngDevMode ? [{
      debugName: "horizontal"
    }] : []);
    this.prevActiveIndex = NaN;
    this.navSubscription = null;
    this.type = computed(() => this.thyType() || "pulled", ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    effect(() => {
      this.updateClasses();
    });
  }
  ngOnInit() {
    if (!this.thyResponsive()) {
      this.initialized = true;
    }
  }
  ngAfterViewInit() {
    if (this.thyResponsive()) {
      this.setMoreBtnOffset();
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.setMoreBtnOffset();
        this.links.toArray().forEach((link) => link.setOffset());
        this.setHiddenItems();
      });
    }
    this.ngZone.runOutsideAngular(() => {
      this.links.changes.pipe(startWith(this.links), takeUntilDestroyed(this.destroyRef)).subscribe(() => {
        if (this.navSubscription) {
          this.navSubscription.unsubscribe();
        }
        this.navSubscription = merge(this.createResizeObserver(this.elementRef.nativeElement), ...this.links.map((item) => this.createResizeObserver(item.elementRef.nativeElement).pipe(tap(() => item.setOffset()))), ...(this.routers() || []).map((router) => router?.isActiveChange)).pipe(takeUntilDestroyed(this.destroyRef), tap(() => {
          if (this.thyPauseReCalculate()) {
            return;
          }
          if (this.thyResponsive()) {
            this.setMoreBtnOffset();
            this.resetSizes();
            this.setHiddenItems();
            this.calculateMoreIsActive();
          }
          if (this.type() === "card") {
            this.setNavItemDivider();
          }
        })).subscribe(() => {
          this.alignInkBarToSelectedTab();
        });
      });
    });
  }
  ngAfterContentInit() {
    if (this.thyResponsive()) {
      this.ngZone.onStable.pipe(take(1)).subscribe(() => {
        this.resetSizes();
      });
    }
  }
  ngAfterContentChecked() {
    this.calculateMoreIsActive();
    this.curActiveIndex = this.links && this.links.length ? this.links.toArray().findIndex((item) => item.linkIsActive()) : -1;
    if (this.curActiveIndex < 0) {
      this.inkBar().hide();
    } else if (this.curActiveIndex !== this.prevActiveIndex) {
      this.alignInkBarToSelectedTab();
    }
  }
  setMoreBtnOffset() {
    const defaultMoreOperation = this.defaultMoreOperation();
    const computedStyle = window.getComputedStyle(defaultMoreOperation.nativeElement);
    this.moreBtnOffset = {
      height: defaultMoreOperation.nativeElement.offsetHeight + parseFloat(computedStyle?.marginBottom) || 0,
      width: defaultMoreOperation.nativeElement.offsetWidth + parseFloat(computedStyle?.marginRight) || 0
    };
  }
  setNavItemDivider() {
    const tabs = this.links.toArray();
    const activeIndex = tabs.findIndex((item) => item.linkIsActive());
    for (let i = 0; i < tabs.length; i++) {
      if (i !== activeIndex && i !== activeIndex - 1 && i !== tabs.length - 1 || i === activeIndex - 1 && this.moreActive) {
        tabs[i].addClass("has-right-divider");
      } else {
        tabs[i].removeClass("has-right-divider");
      }
    }
  }
  createResizeObserver(element) {
    return typeof ResizeObserver === "undefined" ? of(null) : new Observable((observer) => {
      const resize = new ResizeObserver((entries) => {
        observer.next(entries);
      });
      resize.observe(element);
      return () => {
        resize.disconnect();
      };
    });
  }
  calculateMoreIsActive() {
    this.moreActive = this.hiddenItems.some((item) => {
      return item.linkIsActive();
    });
    this.changeDetectorRef.detectChanges();
  }
  setHiddenItems() {
    this.moreActive = false;
    const tabs = this.links.toArray();
    if (!tabs.length) {
      this.hiddenItems = [];
      this.showMore.set(false);
      return;
    }
    const endIndex = this.thyVertical() ? this.getShowItemsEndIndexWhenVertical(tabs) : this.getShowItemsEndIndexWhenHorizontal(tabs);
    const showItems = tabs.slice(0, endIndex + 1);
    (showItems || []).forEach((item) => {
      item.setNavLinkHidden(false);
    });
    this.hiddenItems = endIndex === tabs.length - 1 ? [] : tabs.slice(endIndex + 1);
    (this.hiddenItems || []).forEach((item) => {
      item.setNavLinkHidden(true);
    });
    this.showMore.set(this.hiddenItems.length > 0);
    this.initialized = true;
  }
  getShowItemsEndIndexWhenHorizontal(tabs) {
    const tabsLength = tabs.length;
    let endIndex = tabsLength;
    let totalWidth = 0;
    for (let i = 0; i < tabsLength; i += 1) {
      const _totalWidth = i === tabsLength - 1 ? totalWidth + tabs[i].offset.width : totalWidth + tabs[i].offset.width + tabItemRight;
      if (_totalWidth > this.wrapperOffset.width) {
        const moreOperationWidth = this.moreBtnOffset.width;
        if (totalWidth + moreOperationWidth <= this.wrapperOffset.width) {
          endIndex = i - 1;
        } else {
          endIndex = i - 2;
        }
        break;
      } else {
        totalWidth = _totalWidth;
        endIndex = i;
      }
    }
    return endIndex;
  }
  getShowItemsEndIndexWhenVertical(tabs) {
    const tabsLength = tabs.length;
    let endIndex = tabsLength;
    let totalHeight = 0;
    for (let i = 0; i < tabsLength; i += 1) {
      const _totalHeight = totalHeight + tabs[i].offset.height;
      if (_totalHeight > this.wrapperOffset.height) {
        const moreOperationHeight = this.moreBtnOffset.height;
        if (totalHeight + moreOperationHeight <= this.wrapperOffset.height) {
          endIndex = i - 1;
        } else {
          endIndex = i - 2;
        }
        break;
      } else {
        totalHeight = _totalHeight;
        endIndex = i;
      }
    }
    return endIndex;
  }
  resetSizes() {
    this.wrapperOffset = {
      height: this.elementRef.nativeElement.offsetHeight || 0,
      width: this.elementRef.nativeElement.offsetWidth || 0,
      left: this.elementRef.nativeElement.offsetLeft || 0,
      top: this.elementRef.nativeElement.offsetTop || 0
    };
  }
  openMoreMenu(event, template) {
    this.popover.open(template, Object.assign({
      origin: event.currentTarget,
      hasBackdrop: true,
      backdropClosable: true,
      insideClosable: true,
      placement: "bottom",
      panelClass: "thy-nav-list-popover",
      originActiveClass: "thy-nav-origin-active"
    }, this.thyPopoverOptions() ? this.thyPopoverOptions() : {}));
  }
  navItemClick(item) {
    item.elementRef.nativeElement.click();
  }
  alignInkBarToSelectedTab() {
    if (!this.showInkBar) {
      this.inkBar().hide();
      return;
    }
    const tabs = this.links?.toArray() ?? [];
    const selectedItem = tabs.find((item) => item.linkIsActive());
    let selectedItemElement = selectedItem && selectedItem.elementRef.nativeElement;
    if (selectedItem && this.moreActive) {
      selectedItemElement = this.defaultMoreOperation().nativeElement;
    }
    if (selectedItemElement) {
      this.prevActiveIndex = this.curActiveIndex;
      this.inkBar().alignToElement(selectedItemElement);
    }
  }
  ngOnChanges(changes) {
    const {
      thyVertical,
      thyType
    } = changes;
    if (thyType?.currentValue !== thyType?.previousValue || thyVertical?.currentValue !== thyVertical?.previousValue) {
      this.alignInkBarToSelectedTab();
    }
  }
  ngOnDestroy() {
    if (this.navSubscription) {
      this.navSubscription.unsubscribe();
    }
  }
  static {
    this.\u0275fac = function ThyNav_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNav)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyNav,
      selectors: [["thy-nav"]],
      contentQueries: function ThyNav_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.routers, RouterLinkActive, 5)(dirIndex, ctx.moreOperation, _c23, 5)(dirIndex, ctx.morePopover, _c32, 5)(dirIndex, ctx.extra, _c42, 5);
          \u0275\u0275contentQuery(dirIndex, ThyNavItemDirective, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(4);
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.links = _t);
        }
      },
      viewQuery: function ThyNav_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.defaultMoreOperation, _c5, 5)(ctx.inkBar, ThyNavInkBarDirective, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      hostVars: 6,
      hostBindings: function ThyNav_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-nav", true)("thy-nav--vertical", ctx.thyVertical())("thy-nav--fill", ctx.thyFill());
        }
      },
      inputs: {
        thyType: [1, "thyType"],
        thySize: [1, "thySize"],
        thyHorizontal: [1, "thyHorizontal"],
        thyVertical: [1, "thyVertical"],
        thyFill: [1, "thyFill"],
        thyResponsive: [1, "thyResponsive"],
        thyPauseReCalculate: [1, "thyPauseReCalculate"],
        thyInsideClosable: [1, "thyInsideClosable"],
        thyPopoverOptions: [1, "thyPopoverOptions"],
        thyExtra: [1, "thyExtra"]
      },
      features: [\u0275\u0275NgOnChangesFeature],
      ngContentSelectors: _c14,
      decls: 10,
      vars: 6,
      consts: [["navList", ""], ["navListPopover", ""], ["content", ""], ["moreOperationContainer", ""], [1, "thy-nav-list", 3, "ngClass"], [3, "ngTemplateOutlet"], ["href", "javascript:;", "thyNavLink", "", 1, "thy-nav-more-container", 3, "d-none", "invisible", "thyNavItemActive"], [1, "thy-nav-extra"], [3, "showInkBar", "isVertical"], ["href", "javascript:;", "thyNavLink", "", 1, "thy-nav-more-container", 3, "click", "thyNavItemActive"], ["thyIconName", "angle-down", 1, "thy-nav-more-icon"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], ["thyImmediateRender", ""], ["thyDropdownMenuItem", "", 1, "thy-nav-item-more", 3, "thyDropdownMenuItemActive", "innerHTML"], ["thyDropdownMenuItem", "", 1, "thy-nav-item-more", 3, "click", "thyDropdownMenuItemActive", "innerHTML"]],
      template: function ThyNav_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275elementStart(0, "div", 4, 0);
          \u0275\u0275elementContainer(2, 5);
          \u0275\u0275conditionalCreate(3, ThyNav_Conditional_3_Template, 4, 6, "a", 6);
          \u0275\u0275conditionalCreate(4, ThyNav_Conditional_4_Template, 2, 1, "div", 7);
          \u0275\u0275element(5, "thy-nav-ink-bar", 8);
          \u0275\u0275elementEnd();
          \u0275\u0275template(6, ThyNav_ng_template_6_Template, 2, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(8, ThyNav_ng_template_8_Template, 1, 0, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          const content_r6 = \u0275\u0275reference(9);
          \u0275\u0275property("ngClass", ctx.horizontal() ? "justify-content-" + ctx.horizontal() : "");
          \u0275\u0275advance(2);
          \u0275\u0275property("ngTemplateOutlet", content_r6);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyResponsive() ? 3 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyExtra() || ctx.extra() ? 4 : -1);
          \u0275\u0275advance();
          \u0275\u0275property("showInkBar", ctx.showInkBar)("isVertical", ctx.thyVertical());
        }
      },
      dependencies: [NgClass, NgTemplateOutlet, ThyNavItemDirective, ThyIcon, ThyNavInkBarDirective, ThyDropdownMenuComponent, ThyDropdownMenuItemDirective, ThyDropdownMenuItemActiveDirective, BypassSecurityTrustHtmlPipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNav, [{
    type: Component,
    args: [{
      selector: "thy-nav",
      host: {
        "[class.thy-nav]": "true",
        "[class.thy-nav--vertical]": "thyVertical()",
        "[class.thy-nav--fill]": "thyFill()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [NgClass, NgTemplateOutlet, ThyNavItemDirective, ThyIcon, ThyNavInkBarDirective, ThyDropdownMenuComponent, ThyDropdownMenuItemDirective, ThyDropdownMenuItemActiveDirective, BypassSecurityTrustHtmlPipe],
      template: `<div class="thy-nav-list" [ngClass]="horizontal() ? 'justify-content-' + horizontal() : ''" #navList>
  <ng-container [ngTemplateOutlet]="content"></ng-container>
  @if (thyResponsive()) {
    <a
      href="javascript:;"
      class="thy-nav-more-container"
      [class.d-none]="!showMore()"
      [class.invisible]="!initialized"
      #moreOperationContainer
      thyNavLink
      [thyNavItemActive]="moreActive"
      (click)="openMoreMenu($event, navListPopover)">
      @if (moreOperation()) {
        <ng-container [ngTemplateOutlet]="moreOperation()"></ng-container>
      } @else {
        {{ locale().more }}
        <thy-icon thyIconName="angle-down" class="thy-nav-more-icon"></thy-icon>
      }
    </a>
  }
  @if (thyExtra() || extra()) {
    <div class="thy-nav-extra">
      <ng-container [ngTemplateOutlet]="thyExtra() || extra()"></ng-container>
    </div>
  }
  <thy-nav-ink-bar [showInkBar]="showInkBar" [isVertical]="thyVertical()"></thy-nav-ink-bar>
</div>

<ng-template #navListPopover>
  @if (morePopover()) {
    <ng-container [ngTemplateOutlet]="morePopover()" [ngTemplateOutletContext]="{ $implicit: hiddenItems }"></ng-container>
  } @else {
    <thy-dropdown-menu thyImmediateRender>
      @for (item of hiddenItems; track $index) {
        <span
          class="thy-nav-item-more"
          thyDropdownMenuItem
          [thyDropdownMenuItemActive]="item.isActive"
          (click)="navItemClick(item)"
          [innerHTML]="item.elementRef.nativeElement.innerHTML | bypassSecurityTrustHtml"></span>
      }
    </thy-dropdown-menu>
  }
</ng-template>

<ng-template #content>
  <ng-content></ng-content>
</ng-template>
`
    }]
  }], () => [], {
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyHorizontal: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHorizontal",
        required: false
      }]
    }],
    thyVertical: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyVertical",
        required: false
      }]
    }],
    thyFill: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFill",
        required: false
      }]
    }],
    thyResponsive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyResponsive",
        required: false
      }]
    }],
    thyPauseReCalculate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPauseReCalculate",
        required: false
      }]
    }],
    thyInsideClosable: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyInsideClosable",
        required: false
      }]
    }],
    thyPopoverOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPopoverOptions",
        required: false
      }]
    }],
    thyExtra: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyExtra",
        required: false
      }]
    }],
    links: [{
      type: ContentChildren,
      args: [ThyNavItemDirective, {
        descendants: true
      }]
    }],
    routers: [{
      type: ContentChildren,
      args: [forwardRef(() => RouterLinkActive), __spreadProps(__spreadValues({}, {
        descendants: true
      }), {
        isSignal: true
      })]
    }],
    moreOperation: [{
      type: ContentChild,
      args: ["more", {
        isSignal: true
      }]
    }],
    morePopover: [{
      type: ContentChild,
      args: ["morePopover", {
        isSignal: true
      }]
    }],
    extra: [{
      type: ContentChild,
      args: ["extra", {
        isSignal: true
      }]
    }],
    defaultMoreOperation: [{
      type: ViewChild,
      args: ["moreOperationContainer", {
        isSignal: true
      }]
    }],
    inkBar: [{
      type: ViewChild,
      args: [forwardRef(() => ThyNavInkBarDirective), {
        isSignal: true
      }]
    }]
  });
})();
var ThyNavModule = class _ThyNavModule {
  static {
    this.\u0275fac = function ThyNavModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNavModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyNavModule,
      imports: [CommonModule, ThyIconModule, ThyPopoverModule, ThyDropdownModule, RouterModule, ThyNav, ThyNavItemDirective, ThyIconNav, ThyIconNavLink, BypassSecurityTrustHtmlPipe, ThyNavInkBarDirective],
      exports: [ThyNav, ThyNavItemDirective, ThyIconNav, ThyIconNavLink, BypassSecurityTrustHtmlPipe]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyIconModule, ThyPopoverModule, ThyDropdownModule, RouterModule, ThyNav, ThyIconNavLink]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNavModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyIconModule, ThyPopoverModule, ThyDropdownModule, RouterModule, ThyNav, ThyNavItemDirective, ThyIconNav, ThyIconNavLink, BypassSecurityTrustHtmlPipe, ThyNavInkBarDirective],
      exports: [ThyNav, ThyNavItemDirective, ThyIconNav, ThyIconNavLink, BypassSecurityTrustHtmlPipe]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-button.mjs
var _c08 = ["*"];
function ThyButtonIcon_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("color", ctx_r0.thyColor())("border-color", ctx_r0.thyColor());
    \u0275\u0275property("thyIconName", ctx_r0.svgIconName());
  }
}
function ThyButtonIcon_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 3);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("color", ctx_r0.thyColor())("border-color", ctx_r0.thyColor());
    \u0275\u0275property("ngClass", ctx_r0.iconClasses());
  }
}
function ThyButtonIcon_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyButtonIcon_Conditional_1_Conditional_0_Template, 1, 5, "i", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r0.iconClasses() ? 0 : -1);
  }
}
function ThyButton_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("thyIconName", ctx_r0.svgIconName());
  }
}
function ThyButton_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "i", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", ctx_r0.iconClass());
  }
}
function ThyButton_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyButton_Conditional_1_Conditional_0_Template, 1, 1, "i", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r0.iconClass() ? 0 : -1);
  }
}
var buttonGroupSizeMap = {
  sm: ["btn-group-sm"],
  md: ["btn-group-md"],
  lg: ["btn-group-lg"],
  xs: ["btn-group-xs"]
};
var ThyButtonGroup = class _ThyButtonGroup {
  constructor() {
    this.hostRenderer = useHostRenderer();
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.thyType = input(...ngDevMode ? [void 0, {
      debugName: "thyType"
    }] : []);
    this.thyClearMinWidth = input(false, ...ngDevMode ? [{
      debugName: "thyClearMinWidth",
      transform: coerceBooleanProperty
    }] : [{
      transform: coerceBooleanProperty
    }]);
    effect(() => {
      this.setClasses();
    });
  }
  setClasses() {
    const type = this.thyType();
    const size = this.thySize();
    let classNames = [];
    if (type) {
      classNames.push(`btn-group-${type}`);
    }
    if (size && buttonGroupSizeMap[size]) {
      classNames = classNames.concat(...buttonGroupSizeMap[size]);
    }
    this.hostRenderer.updateClass(classNames);
  }
  static {
    this.\u0275fac = function ThyButtonGroup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyButtonGroup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyButtonGroup,
      selectors: [["thy-button-group"]],
      hostAttrs: [1, "btn-group"],
      hostVars: 2,
      hostBindings: function ThyButtonGroup_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("btn-group-clear-min-width", ctx.thyClearMinWidth());
        }
      },
      inputs: {
        thySize: [1, "thySize"],
        thyType: [1, "thyType"],
        thyClearMinWidth: [1, "thyClearMinWidth"]
      },
      ngContentSelectors: _c08,
      decls: 1,
      vars: 0,
      template: function ThyButtonGroup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyButtonGroup, [{
    type: Component,
    args: [{
      selector: "thy-button-group",
      template: "<ng-content></ng-content>",
      host: {
        class: "btn-group",
        "[class.btn-group-clear-min-width]": "thyClearMinWidth()"
      },
      encapsulation: ViewEncapsulation.None
    }]
  }], () => [], {
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    thyClearMinWidth: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyClearMinWidth",
        required: false
      }]
    }]
  });
})();
var sizeClassesMap = {
  lg: ["btn-icon-lg"],
  md: ["btn-icon-md"],
  sm: ["btn-icon-sm"],
  xs: ["btn-icon-xs"]
};
var shapeClassesMap = {
  "circle-dashed": ["btn-icon-circle", "circle-dashed"],
  "circle-solid": ["btn-icon-circle", "circle-solid"],
  "circle-thick-dashed": ["btn-icon-circle", "circle-dashed", "border-thick"],
  "circle-thick-solid": ["btn-icon-circle", "circle-solid", "border-thick"],
  "self-icon": ["btn-icon-self-circle"]
};
var themeClassesMap = {
  "danger-weak": ["btn-icon-danger-weak"]
};
var ThyButtonIcon = class _ThyButtonIcon {
  constructor() {
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.thyIcon = input(...ngDevMode ? [void 0, {
      debugName: "thyIcon"
    }] : []);
    this.thyButtonIcon = input(...ngDevMode ? [void 0, {
      debugName: "thyButtonIcon"
    }] : []);
    this.thyShape = input(...ngDevMode ? [void 0, {
      debugName: "thyShape"
    }] : []);
    this.thyLight = input(false, ...ngDevMode ? [{
      debugName: "thyLight",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyActive = input(false, ...ngDevMode ? [{
      debugName: "thyActive",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyTheme = input(...ngDevMode ? [void 0, {
      debugName: "thyTheme"
    }] : []);
    this.thyColor = input(...ngDevMode ? [void 0, {
      debugName: "thyColor"
    }] : []);
    this.hostRenderer = useHostRenderer();
    this.icon = computed(() => {
      return this.thyButtonIcon() || this.thyIcon();
    }, ...ngDevMode ? [{
      debugName: "icon"
    }] : []);
    this.isWtfIcon = computed(() => {
      const icon = this.icon();
      return icon && icon.includes("wtf");
    }, ...ngDevMode ? [{
      debugName: "isWtfIcon"
    }] : []);
    this.svgIconName = computed(() => {
      if (!this.isWtfIcon()) {
        return this.icon();
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "svgIconName"
    }] : []);
    this.iconClasses = computed(() => {
      const icon = this.icon();
      if (this.isWtfIcon()) {
        const classes = icon.split(" ");
        if (classes.length === 1) {
          classes.unshift("wtf");
        }
        return classes;
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "iconClasses"
    }] : []);
    effect(() => {
      this.setClasses();
    });
  }
  setClasses() {
    const size = this.thySize();
    const shape = this.thyShape();
    const theme = this.thyTheme();
    const classes = size && sizeClassesMap[size] ? [...sizeClassesMap[size]] : [];
    if (shape && shapeClassesMap[shape]) {
      shapeClassesMap[shape].forEach((className) => {
        classes.push(className);
      });
    }
    if (theme && themeClassesMap[theme]) {
      themeClassesMap[theme].forEach((className) => {
        classes.push(className);
      });
    }
    this.hostRenderer.updateClass(classes);
  }
  static {
    this.\u0275fac = function ThyButtonIcon_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyButtonIcon)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyButtonIcon,
      selectors: [["thy-button-icon"], ["", "thy-button-icon", ""], ["", "thyButtonIcon", ""]],
      hostAttrs: [1, "btn", "btn-icon"],
      hostVars: 4,
      hostBindings: function ThyButtonIcon_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("btn-icon-light", ctx.thyLight())("btn-icon-active", ctx.thyActive());
        }
      },
      inputs: {
        thySize: [1, "thySize"],
        thyIcon: [1, "thyIcon"],
        thyButtonIcon: [1, "thyButtonIcon"],
        thyShape: [1, "thyShape"],
        thyLight: [1, "thyLight"],
        thyActive: [1, "thyActive"],
        thyTheme: [1, "thyTheme"],
        thyColor: [1, "thyColor"]
      },
      ngContentSelectors: _c08,
      decls: 3,
      vars: 1,
      consts: [[3, "thyIconName", "color", "borderColor"], [3, "thyIconName"], [3, "ngClass", "color", "borderColor"], [3, "ngClass"]],
      template: function ThyButtonIcon_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275conditionalCreate(0, ThyButtonIcon_Conditional_0_Template, 1, 5, "thy-icon", 0)(1, ThyButtonIcon_Conditional_1_Template, 1, 1);
          \u0275\u0275projection(2);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.svgIconName() ? 0 : 1);
        }
      },
      dependencies: [ThyIcon, NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyButtonIcon, [{
    type: Component,
    args: [{
      selector: "thy-button-icon,[thy-button-icon],[thyButtonIcon]",
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "btn btn-icon",
        "[class.btn-icon-light]": "thyLight()",
        "[class.btn-icon-active]": "thyActive()"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [ThyIcon, NgClass],
      template: '@if (svgIconName()) {\n  <thy-icon [thyIconName]="svgIconName()" [style.color]="thyColor()" [style.borderColor]="thyColor()"></thy-icon>\n} @else {\n  @if (iconClasses()) {\n    <i [ngClass]="iconClasses()" [style.color]="thyColor()" [style.borderColor]="thyColor()"></i>\n  }\n}\n<ng-content></ng-content>\n'
    }]
  }], () => [], {
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIcon",
        required: false
      }]
    }],
    thyButtonIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyButtonIcon",
        required: false
      }]
    }],
    thyShape: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShape",
        required: false
      }]
    }],
    thyLight: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLight",
        required: false
      }]
    }],
    thyActive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyActive",
        required: false
      }]
    }],
    thyTheme: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTheme",
        required: false
      }]
    }],
    thyColor: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyColor",
        required: false
      }]
    }]
  });
})();
var btnTypeClassesMap = {
  primary: ["btn-primary"],
  secondary: ["btn-primary", "btn-md"],
  info: ["btn-info"],
  warning: ["btn-warning"],
  danger: ["btn-danger"],
  "outline-primary": ["btn-outline-primary"],
  "outline-default": ["btn-outline-default"],
  link: ["btn-link"],
  // 链接按钮
  "link-info": ["btn-link", "btn-link-info"],
  // 幽灵链接按钮
  "link-secondary": ["btn-link", "btn-link-primary-weak"],
  // 幽灵链接按钮
  "link-danger-weak": ["btn-link", "btn-link-danger-weak"],
  // 幽灵危险按钮
  "link-danger": ["btn-link", "btn-link-danger"],
  // 危险按钮
  "link-success": ["btn-link", "btn-link-success"]
  // 成功按钮
};
var iconOnlyClass = "thy-btn-icon-only";
var ThyButton = class _ThyButton {
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  setButtonText() {
    const text = this.thyLoading() ? this.thyLoadingText() : this._originalText;
    const spanElement = this.nativeElement.querySelector("span");
    if (spanElement && text) {
      this.renderer.setProperty(spanElement, "innerText", text);
    }
  }
  updateClasses() {
    const type = this.type();
    if (!type) {
      return;
    }
    let classNames = [];
    if (btnTypeClassesMap[type]) {
      classNames = [...btnTypeClassesMap[type]];
    } else {
      if (type) {
        classNames.push(`btn-${type}`);
      }
    }
    const size = this.thySize();
    if (size) {
      classNames.push(`btn-${size}`);
    }
    if (this.isRadiusSquare()) {
      classNames.push("btn-square");
    }
    const loading = this.thyLoading();
    if (loading) {
      classNames.push("loading");
    }
    this.hostRenderer.updateClass(classNames);
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.hostRenderer = useHostRenderer();
    this.thyButton = input(...ngDevMode ? [void 0, {
      debugName: "thyButton"
    }] : []);
    this.thyType = input(...ngDevMode ? [void 0, {
      debugName: "thyType"
    }] : []);
    this.thyLoading = input(false, ...ngDevMode ? [{
      debugName: "thyLoading",
      transform: (value) => {
        if (!this.thyLoading() && value) {
          const textElement = this.nativeElement?.querySelector("span");
          this._originalText = textElement ? textElement.innerText : "";
        }
        return coerceBooleanProperty2(value);
      }
    }] : [{
      transform: (value) => {
        if (!this.thyLoading() && value) {
          const textElement = this.nativeElement?.querySelector("span");
          this._originalText = textElement ? textElement.innerText : "";
        }
        return coerceBooleanProperty2(value);
      }
    }]);
    this.thyLoadingText = input(...ngDevMode ? [void 0, {
      debugName: "thyLoadingText"
    }] : []);
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.thyIcon = input(...ngDevMode ? [void 0, {
      debugName: "thyIcon"
    }] : []);
    this.thyBlock = input(false, ...ngDevMode ? [{
      debugName: "thyBlock",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.isWtfIcon = computed(() => {
      const icon = this.thyIcon();
      return icon && icon.includes("wtf");
    }, ...ngDevMode ? [{
      debugName: "isWtfIcon"
    }] : []);
    this.svgIconName = computed(() => {
      if (!this.isWtfIcon()) {
        return this.thyIcon();
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "svgIconName"
    }] : []);
    this.iconClass = computed(() => {
      const icon = this.thyIcon();
      if (this.isWtfIcon()) {
        const classes = icon.split(" ");
        if (classes.length === 1) {
          classes.unshift("wtf");
        }
        return classes;
      }
      return null;
    }, ...ngDevMode ? [{
      debugName: "iconClass"
    }] : []);
    this.buttonType = computed(() => {
      return this.thyButton() || this.thyType();
    }, ...ngDevMode ? [{
      debugName: "buttonType"
    }] : []);
    this.isRadiusSquare = computed(() => {
      const type = this.buttonType();
      return !!type?.includes("-square");
    }, ...ngDevMode ? [{
      debugName: "isRadiusSquare"
    }] : []);
    this.type = computed(() => {
      const type = this.buttonType();
      if (this.isRadiusSquare()) {
        return type?.replace("-square", "");
      } else {
        return type;
      }
    }, ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    effect(() => {
      this.updateClasses();
    });
    effect(() => {
      this.setButtonText();
    });
    afterNextRender(() => {
      if (assertIconOnly(this.nativeElement)) {
        this.hostRenderer.addClass(iconOnlyClass);
      } else {
        this.hostRenderer.removeClass(iconOnlyClass);
      }
      this.wrapSpanForText(this.nativeElement.childNodes);
    });
  }
  wrapSpanForText(nodes) {
    nodes.forEach((node) => {
      if (node.nodeName === "#text") {
        const span = this.renderer.createElement("span");
        const parent = this.renderer.parentNode(node);
        this.renderer.addClass(span, "thy-btn-wrap-span");
        this.renderer.insertBefore(parent, span, node);
        this.renderer.appendChild(span, node);
      }
    });
  }
  static {
    this.\u0275fac = function ThyButton_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyButton)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyButton,
      selectors: [["thy-button"], ["", "thy-button", ""], ["", "thyButton", ""]],
      hostAttrs: [1, "thy-btn", "btn"],
      hostVars: 2,
      hostBindings: function ThyButton_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("btn-block", ctx.thyBlock());
        }
      },
      inputs: {
        thyButton: [1, "thyButton"],
        thyType: [1, "thyType"],
        thyLoading: [1, "thyLoading"],
        thyLoadingText: [1, "thyLoadingText"],
        thySize: [1, "thySize"],
        thyIcon: [1, "thyIcon"],
        thyBlock: [1, "thyBlock"]
      },
      ngContentSelectors: _c08,
      decls: 3,
      vars: 1,
      consts: [[3, "thyIconName"], [3, "ngClass"]],
      template: function ThyButton_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275conditionalCreate(0, ThyButton_Conditional_0_Template, 1, 1, "thy-icon", 0)(1, ThyButton_Conditional_1_Template, 1, 1);
          \u0275\u0275projection(2);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.svgIconName() ? 0 : 1);
        }
      },
      dependencies: [ThyIcon, NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyButton, [{
    type: Component,
    args: [{
      selector: "thy-button,[thy-button],[thyButton]",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-btn btn",
        "[class.btn-block]": "thyBlock()"
      },
      imports: [ThyIcon, NgClass],
      template: '@if (svgIconName()) {\n  <thy-icon [thyIconName]="svgIconName()"></thy-icon>\n} @else {\n  @if (iconClass()) {\n    <i [ngClass]="iconClass()"></i>\n  }\n}\n<ng-content></ng-content>\n'
    }]
  }], () => [], {
    thyButton: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyButton",
        required: false
      }]
    }],
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    thyLoading: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLoading",
        required: false
      }]
    }],
    thyLoadingText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLoadingText",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIcon",
        required: false
      }]
    }],
    thyBlock: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyBlock",
        required: false
      }]
    }]
  });
})();
var ThyButtonModule = class _ThyButtonModule {
  static {
    this.\u0275fac = function ThyButtonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyButtonModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyButtonModule,
      imports: [CommonModule, ThyIconModule, ThyButton, ThyButtonIcon, ThyButtonGroup],
      exports: [ThyButton, ThyButtonIcon, ThyButtonGroup]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyIconModule, ThyButton, ThyButtonIcon]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyButtonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyIconModule, ThyButton, ThyButtonIcon, ThyButtonGroup],
      exports: [ThyButton, ThyButtonIcon, ThyButtonGroup]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-tag.mjs
var _c09 = ["*"];
var ThyTag = class _ThyTag {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.hostRenderer = useHostRenderer();
    this.thyTag = input("", ...ngDevMode ? [{
      debugName: "thyTag"
    }] : []);
    this.thyShape = input("rectangle", ...ngDevMode ? [{
      debugName: "thyShape"
    }] : []);
    this.thyColor = input("", ...ngDevMode ? [{
      debugName: "thyColor"
    }] : []);
    this.thyTheme = input("fill", ...ngDevMode ? [{
      debugName: "thyTheme"
    }] : []);
    this.thySize = input("md", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.thyHoverable = input(false, ...ngDevMode ? [{
      debugName: "thyHoverable",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.color = computed(() => this.thyColor() || this.thyTag() || "default", ...ngDevMode ? [{
      debugName: "color"
    }] : []);
    effect(() => {
      this.setColor();
    });
  }
  setColor() {
    this.elementRef.nativeElement.style.removeProperty("background-color");
    this.elementRef.nativeElement.style.removeProperty("border-color");
    this.elementRef.nativeElement.style.removeProperty("color");
    this.hostRenderer.updateClass([]);
    if (isThemeColor(this.color())) {
      this.hostRenderer.updateClass([`thy-tag-${this.thyTheme() === "fill" ? "" : `${this.thyTheme()}-`}${this.color()}`]);
    } else {
      if (this.thyTheme() === "fill") {
        this.elementRef.nativeElement.style.backgroundColor = this.color();
      } else if (this.thyTheme() === "outline") {
        this.elementRef.nativeElement.style.color = this.color();
        this.elementRef.nativeElement.style["border-color"] = this.color();
      } else {
        this.elementRef.nativeElement.style.backgroundColor = hexToRgb(this.color(), 0.1);
        this.elementRef.nativeElement.style.color = this.color();
      }
    }
  }
  static {
    this.\u0275fac = function ThyTag_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTag)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyTag,
      selectors: [["thy-tag"], ["", "thyTag", ""]],
      hostAttrs: [1, "thy-tag"],
      hostVars: 14,
      hostBindings: function ThyTag_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-tag-pill", ctx.thyShape() === "pill")("thy-tag-outline", ctx.thyTheme() === "outline")("thy-tag-hover", ctx.thyHoverable())("thy-tag-md", ctx.thySize() === "md")("thy-tag-sm", ctx.thySize() === "sm")("thy-tag-xs", ctx.thySize() === "xs")("thy-tag-lg", ctx.thySize() === "lg");
        }
      },
      inputs: {
        thyTag: [1, "thyTag"],
        thyShape: [1, "thyShape"],
        thyColor: [1, "thyColor"],
        thyTheme: [1, "thyTheme"],
        thySize: [1, "thySize"],
        thyHoverable: [1, "thyHoverable"]
      },
      ngContentSelectors: _c09,
      decls: 1,
      vars: 0,
      template: function ThyTag_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTag, [{
    type: Component,
    args: [{
      selector: "thy-tag,[thyTag]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-tag",
        "[class.thy-tag-pill]": 'thyShape() === "pill"',
        "[class.thy-tag-outline]": 'thyTheme() === "outline"',
        "[class.thy-tag-hover]": "thyHoverable()",
        "[class.thy-tag-md]": 'thySize() === "md"',
        "[class.thy-tag-sm]": 'thySize() === "sm"',
        "[class.thy-tag-xs]": 'thySize() === "xs"',
        "[class.thy-tag-lg]": 'thySize() === "lg"'
      },
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [], {
    thyTag: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTag",
        required: false
      }]
    }],
    thyShape: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShape",
        required: false
      }]
    }],
    thyColor: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyColor",
        required: false
      }]
    }],
    thyTheme: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTheme",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyHoverable: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHoverable",
        required: false
      }]
    }]
  });
})();
var ThyTags = class _ThyTags {
  constructor() {
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function ThyTags_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTags)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyTags,
      selectors: [["thy-tags"]],
      hostAttrs: [1, "thy-tags"],
      ngContentSelectors: _c09,
      decls: 1,
      vars: 0,
      template: function ThyTags_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTags, [{
    type: Component,
    args: [{
      selector: "thy-tags",
      template: "<ng-content></ng-content>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-tags"
      }
    }]
  }], () => [], null);
})();
var ThyTagModule = class _ThyTagModule {
  static {
    this.\u0275fac = function ThyTagModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTagModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyTagModule,
      imports: [CommonModule, ThyIconModule, ThyTag, ThyTags],
      exports: [ThyTag, ThyTags]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTagModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyIconModule, ThyTag, ThyTags],
      exports: [ThyTag, ThyTags]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-flexible-text.mjs
var _c010 = ["*"];
var ThyFlexibleText = class _ThyFlexibleText {
  static createResizeObserver(element) {
    return new Observable((observer) => {
      const resize = new ResizeObserver((entries) => {
        observer.next(entries);
      });
      resize.observe(element);
      return () => {
        resize.disconnect();
      };
    });
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.contentObserver = inject(ContentObserver);
    this.ngZone = inject(NgZone);
    this.tooltipDirective = inject(ThyTooltipDirective);
    this.isOverflow = false;
    this.subscription = null;
    this.trigger = input(void 0, ...ngDevMode ? [{
      debugName: "trigger",
      alias: "thyTooltipTrigger"
    }] : [{
      alias: "thyTooltipTrigger"
    }]);
    this.thyContainerClass = input(...ngDevMode ? [void 0, {
      debugName: "thyContainerClass"
    }] : []);
    this.thyTooltipContent = input(...ngDevMode ? [void 0, {
      debugName: "thyTooltipContent"
    }] : []);
    this.thyTooltipPlacement = input(...ngDevMode ? [void 0, {
      debugName: "thyTooltipPlacement"
    }] : []);
    this.thyTooltipOffset = input(void 0, ...ngDevMode ? [{
      debugName: "thyTooltipOffset",
      transform: numberAttribute
    }] : [{
      transform: numberAttribute
    }]);
    this.destroy$ = new Subject();
    this.hostRenderer = useHostRenderer();
    effect(() => {
      this.updateContainerClass();
    });
    effect(() => {
      const content = this.thyTooltipContent();
      if (this.tooltipDirective && content) {
        this.tooltipDirective.setContent(content);
      }
    });
    effect(() => {
      const placement = this.thyTooltipPlacement();
      if (this.tooltipDirective && placement) {
        this.tooltipDirective.setPlacement(placement);
      }
    });
    effect(() => {
      const offset = this.thyTooltipOffset();
      if (this.tooltipDirective && !isUndefinedOrNull(offset)) {
        this.tooltipDirective.setOffset(offset);
      }
    });
    effect(() => {
      const trigger2 = this.trigger();
      if (this.tooltipDirective && trigger2) {
        this.tooltipDirective.trigger = trigger2;
      }
    });
  }
  ngAfterContentInit() {
    const onStable$ = this.ngZone.isStable ? from(Promise.resolve()) : this.ngZone.onStable.pipe(take(1));
    this.ngZone.runOutsideAngular(() => {
      onStable$.pipe(takeUntil(this.destroy$)).subscribe(() => {
        this.contentObserver.observe(this.elementRef).pipe(debounceTime(100), takeUntil(this.destroy$)).subscribe(() => {
          this.applyOverflow();
        });
        _ThyFlexibleText.createResizeObserver(this.elementRef.nativeElement).pipe(debounceTime(100), takeUntil(this.destroy$)).subscribe(() => {
          this.applyOverflow();
        });
      });
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.tooltipDirective.hide();
  }
  applyOverflow() {
    const nativeElement = this.elementRef.nativeElement;
    if (nativeElement.clientWidth < nativeElement.scrollWidth || nativeElement.clientHeight < nativeElement.scrollHeight) {
      this.isOverflow = true;
    } else {
      this.isOverflow = false;
    }
    this.tooltipDirective.setDisabled(!this.isOverflow);
  }
  updateContainerClass() {
    const containerClass = isUndefinedOrNull(this.thyContainerClass()) ? "flexible-text-container" : this.thyContainerClass();
    const flexibleTextClass = {
      "text-truncate": true,
      [containerClass]: containerClass !== ""
    };
    this.hostRenderer.updateClassByMap(flexibleTextClass);
  }
  static {
    this.\u0275fac = function ThyFlexibleText_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlexibleText)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyFlexibleText,
      selectors: [["thy-flexible-text"], ["", "thyFlexibleText", ""]],
      inputs: {
        trigger: [1, "thyTooltipTrigger", "trigger"],
        thyContainerClass: [1, "thyContainerClass"],
        thyTooltipContent: [1, "thyTooltipContent"],
        thyTooltipPlacement: [1, "thyTooltipPlacement"],
        thyTooltipOffset: [1, "thyTooltipOffset"]
      },
      exportAs: ["thyFlexibleText"],
      features: [\u0275\u0275HostDirectivesFeature([ThyTooltipDirective])],
      ngContentSelectors: _c010,
      decls: 1,
      vars: 0,
      template: function ThyFlexibleText_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlexibleText, [{
    type: Component,
    args: [{
      selector: "thy-flexible-text,[thyFlexibleText]",
      exportAs: "thyFlexibleText",
      hostDirectives: [ThyTooltipDirective],
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [], {
    trigger: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipTrigger",
        required: false
      }]
    }],
    thyContainerClass: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyContainerClass",
        required: false
      }]
    }],
    thyTooltipContent: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipContent",
        required: false
      }]
    }],
    thyTooltipPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipPlacement",
        required: false
      }]
    }],
    thyTooltipOffset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTooltipOffset",
        required: false
      }]
    }]
  });
})();
var ThyFlexibleTextModule = class _ThyFlexibleTextModule {
  static {
    this.\u0275fac = function ThyFlexibleTextModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlexibleTextModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyFlexibleTextModule,
      imports: [CommonModule, ThyTooltipModule, ObserversModule, ThyFlexibleText],
      exports: [ThyFlexibleText]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyTooltipModule, ObserversModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlexibleTextModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyTooltipModule, ObserversModule, ThyFlexibleText],
      exports: [ThyFlexibleText]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-grid.mjs
var _c011 = ["*"];
var ThyRowDirective = class _ThyRowDirective {
  constructor() {
    this.thyGutter = input(...ngDevMode ? [void 0, {
      debugName: "thyGutter"
    }] : []);
    this.actualGutter$ = new ReplaySubject(1);
    this.hostRenderer = useHostRenderer();
    effect(() => {
      this.setGutterStyle();
    });
  }
  setGutterStyle() {
    const [horizontalGutter, verticalGutter] = this.getGutter();
    this.actualGutter$.next([horizontalGutter, verticalGutter]);
    const renderGutter = (name, gutter) => {
      this.hostRenderer.setStyle(name, `-${gutter / 2}px`);
    };
    if (horizontalGutter > 0) {
      renderGutter("margin-left", horizontalGutter);
      renderGutter("margin-right", horizontalGutter);
    }
    if (verticalGutter > 0) {
      renderGutter("margin-top", verticalGutter);
      renderGutter("margin-bottom", verticalGutter);
    }
  }
  getGutter() {
    const thyGutter = this.thyGutter();
    if (isString(thyGutter)) {
      throw Error(`thyGutter value can not be string type`);
    }
    return [thyGutter, 0];
  }
  static {
    this.\u0275fac = function ThyRowDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyRowDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyRowDirective,
      selectors: [["", "thyRow", ""]],
      hostAttrs: [1, "thy-row"],
      inputs: {
        thyGutter: [1, "thyGutter"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyRowDirective, [{
    type: Directive,
    args: [{
      selector: "[thyRow]",
      host: {
        class: "thy-row"
      }
    }]
  }], () => [], {
    thyGutter: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGutter",
        required: false
      }]
    }]
  });
})();
var ThyColDirective = class _ThyColDirective {
  constructor() {
    this.thyRowDirective = inject(ThyRowDirective, {
      optional: true,
      host: true
    });
    this.thyCol = input(...ngDevMode ? [void 0, {
      debugName: "thyCol"
    }] : []);
    this.thySpan = input(...ngDevMode ? [void 0, {
      debugName: "thySpan"
    }] : []);
    this.span = computed(() => {
      const span = this.thySpan() ?? this.thyCol();
      return span || 24;
    }, ...ngDevMode ? [{
      debugName: "span"
    }] : []);
    this.hostRenderer = useHostRenderer();
    this.takeUntilDestroyed = takeUntilDestroyed();
    effect(() => {
      this.updateHostClass();
    });
    afterNextRender(() => {
      if (this.thyRowDirective) {
        this.thyRowDirective.actualGutter$.pipe(this.takeUntilDestroyed).subscribe((data) => {
          const [horizontalGutter, verticalGutter] = data;
          const renderGutter = (name, gutter) => {
            this.hostRenderer.setStyle(name, `${gutter / 2}px`);
          };
          if (horizontalGutter > 0) {
            renderGutter("padding-left", horizontalGutter);
            renderGutter("padding-right", horizontalGutter);
          }
          if (verticalGutter > 0) {
            renderGutter("padding-top", verticalGutter);
            renderGutter("padding-bottom", verticalGutter);
          }
        });
      }
    });
  }
  updateHostClass() {
    const span = this.span();
    this.hostRenderer.updateClassByMap({
      [`thy-col-${span}`]: true
    });
  }
  static {
    this.\u0275fac = function ThyColDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyColDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyColDirective,
      selectors: [["", "thyCol", ""]],
      hostAttrs: [1, "thy-col"],
      inputs: {
        thyCol: [1, "thyCol"],
        thySpan: [1, "thySpan"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyColDirective, [{
    type: Directive,
    args: [{
      selector: "[thyCol]",
      host: {
        class: "thy-col"
      }
    }]
  }], () => [], {
    thyCol: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyCol",
        required: false
      }]
    }],
    thySpan: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySpan",
        required: false
      }]
    }]
  });
})();
var THY_GRID_COMPONENT = new InjectionToken("THY_GRID_COMPONENT");
var THY_GRID_DEFAULT_COLUMNS = 24;
var THY_GRID_ITEM_DEFAULT_SPAN = 1;
var screenBreakpointsMap = {
  xs: 0,
  sm: 576,
  md: 768,
  lg: 992,
  xl: 1200
};
var ThyGridItem = class _ThyGridItem {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.grid = inject(THY_GRID_COMPONENT, {
      optional: true
    });
    this.thySpan = input(THY_GRID_ITEM_DEFAULT_SPAN, ...ngDevMode ? [{
      debugName: "thySpan"
    }] : []);
    this.thyOffset = input(0, ...ngDevMode ? [{
      debugName: "thyOffset"
    }] : []);
    this.destroyRef = inject(DestroyRef);
    this.hostRenderer = useHostRenderer();
    this.span = THY_GRID_ITEM_DEFAULT_SPAN;
    this.offset = 0;
  }
  ngOnInit() {
    this.grid.gridItemPropValueChange$.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => {
      this.setGridItemStyle();
    });
  }
  setGridItemStyle() {
    const xGap = this.grid?.xGap || 0;
    this.hostRenderer.setStyle("display", this.span === 0 ? "none" : "");
    this.hostRenderer.setStyle("grid-column", `span ${this.span}`);
    this.hostRenderer.setStyle("margin-left", this.offset ? `calc(((100% - ${(this.span - 1) * xGap}px) / ${this.span} + ${xGap}px) * ${this.offset})` : "");
  }
  static {
    this.\u0275fac = function ThyGridItem_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyGridItem)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyGridItem,
      selectors: [["thy-grid-item"], ["", "thyGridItem", ""]],
      hostAttrs: [1, "thy-grid-item"],
      inputs: {
        thySpan: [1, "thySpan"],
        thyOffset: [1, "thyOffset"]
      },
      ngContentSelectors: _c011,
      decls: 1,
      vars: 0,
      template: function ThyGridItem_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyGridItem, [{
    type: Component,
    args: [{
      selector: "thy-grid-item,[thyGridItem]",
      template: "<ng-content></ng-content>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-grid-item"
      }
    }]
  }], null, {
    thySpan: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySpan",
        required: false
      }]
    }],
    thyOffset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyOffset",
        required: false
      }]
    }]
  });
})();
var ThyGrid = class _ThyGrid {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.viewportRuler = inject(ViewportRuler);
    this.ngZone = inject(NgZone);
    this.gridItems = contentChildren(ThyGridItem, ...ngDevMode ? [{
      debugName: "gridItems"
    }] : []);
    this.thyCols = input(THY_GRID_DEFAULT_COLUMNS, ...ngDevMode ? [{
      debugName: "thyCols"
    }] : []);
    this.thyXGap = input(0, ...ngDevMode ? [{
      debugName: "thyXGap"
    }] : []);
    this.thyYGap = input(0, ...ngDevMode ? [{
      debugName: "thyYGap"
    }] : []);
    this.thyGap = input(0, ...ngDevMode ? [{
      debugName: "thyGap"
    }] : []);
    this.thyResponsive = input("none", ...ngDevMode ? [{
      debugName: "thyResponsive"
    }] : []);
    this.hostRenderer = useHostRenderer();
    this.numRegex = /^\d+$/;
    this.gridItemPropValueChange$ = new Subject();
    this.takeUntilDestroyed = takeUntilDestroyed();
    effect(() => {
      this.handleGridItems();
    });
  }
  ngOnInit() {
    this.setGridStyle();
    if (this.thyResponsive() !== "none") {
      this.listenResizeEvent();
    }
  }
  setGridStyle() {
    this.cols = this.calculateActualValue(this.thyCols() || THY_GRID_DEFAULT_COLUMNS, THY_GRID_DEFAULT_COLUMNS);
    const xGap = this.thyXGap();
    const yGap = this.thyYGap();
    const gap = this.thyGap();
    if (!xGap && !yGap) {
      this.xGap = this.calculateActualValue(gap || 0);
      this.yGap = this.xGap;
    } else {
      this.xGap = this.calculateActualValue(xGap || gap);
      this.yGap = this.calculateActualValue(yGap || gap);
    }
    this.hostRenderer.setStyle("display", "grid");
    this.hostRenderer.setStyle("grid-template-columns", `repeat(${this.cols}, minmax(0, 1fr))`);
    this.hostRenderer.setStyle("gap", `${this.yGap}px ${this.xGap}px`);
  }
  listenResizeEvent() {
    if (this.thyResponsive() === "screen") {
      this.viewportRuler.change(100).pipe(this.takeUntilDestroyed).subscribe(() => {
        this.responsiveContainerWidth = this.viewportRuler.getViewportSize().width;
        this.setGridStyle();
        this.handleGridItems();
      });
    } else {
      this.ngZone.runOutsideAngular(() => {
        this.gridResizeObserver(this.elementRef.nativeElement).pipe(throttleTime(100), this.takeUntilDestroyed).subscribe((data) => {
          this.responsiveContainerWidth = data[0]?.contentRect?.width;
          this.setGridStyle();
          this.handleGridItems();
        });
      });
    }
  }
  handleGridItems() {
    this.gridItems().forEach((gridItem) => {
      const rawSpan = getRawSpan(gridItem.thySpan());
      const span = this.calculateActualValue(rawSpan, THY_GRID_ITEM_DEFAULT_SPAN);
      const offset = this.calculateActualValue(gridItem.thyOffset() || 0);
      gridItem.span = Math.min(span + offset, this.cols);
      gridItem.offset = offset;
    });
    this.gridItemPropValueChange$.next();
  }
  calculateActualValue(rawValue, defaultValue) {
    if (this.numRegex.test(rawValue.toString().trim())) {
      return Number(rawValue);
    } else {
      const responsiveValueMap = this.getResponsiveValueMap(rawValue);
      const breakpointKeys = Object.keys(responsiveValueMap);
      const breakpoint = this.calculateBreakPoint(breakpointKeys);
      if (this.thyResponsive() !== "none" && breakpoint) {
        return responsiveValueMap[breakpoint];
      } else if (breakpointKeys.includes("0")) {
        return responsiveValueMap["0"];
      } else {
        return defaultValue || 0;
      }
    }
  }
  getResponsiveValueMap(responsiveValue) {
    return responsiveValue.split(" ").reduce((map2, item) => {
      if (this.numRegex.test(item.toString())) {
        item = `0:${item}`;
      }
      const [key, value] = item.split(":");
      map2[key] = Number(value);
      return map2;
    }, {});
  }
  calculateBreakPoint(breakpointKeys) {
    if (this.thyResponsive() === "screen") {
      const width = this.responsiveContainerWidth || this.viewportRuler.getViewportSize().width;
      return breakpointKeys.find((key, index2) => {
        return index2 < breakpointKeys.length - 1 ? width >= screenBreakpointsMap[key] && width < screenBreakpointsMap[breakpointKeys[index2 + 1]] : width >= screenBreakpointsMap[key];
      });
    } else {
      const width = this.responsiveContainerWidth || this.elementRef.nativeElement.getBoundingClientRect().width;
      return breakpointKeys.find((key, index2) => {
        return index2 < breakpointKeys.length - 1 ? width >= Number(key) && width < Number(breakpointKeys[index2 + 1]) : width >= Number(key);
      });
    }
  }
  gridResizeObserver(element) {
    return new Observable((observer) => {
      const resize = new ResizeObserver((entries) => {
        observer.next(entries);
      });
      resize.observe(element);
      return () => {
        resize.disconnect();
      };
    });
  }
  static {
    this.\u0275fac = function ThyGrid_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyGrid)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyGrid,
      selectors: [["", "thyGrid", ""]],
      contentQueries: function ThyGrid_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.gridItems, ThyGridItem, 4);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: [1, "thy-grid"],
      inputs: {
        thyCols: [1, "thyCols"],
        thyXGap: [1, "thyXGap"],
        thyYGap: [1, "thyYGap"],
        thyGap: [1, "thyGap"],
        thyResponsive: [1, "thyResponsive"]
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: THY_GRID_COMPONENT,
        useExisting: _ThyGrid
      }])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyGrid, [{
    type: Directive,
    args: [{
      selector: "[thyGrid]",
      providers: [{
        provide: THY_GRID_COMPONENT,
        useExisting: ThyGrid
      }],
      host: {
        class: "thy-grid"
      }
    }]
  }], () => [], {
    gridItems: [{
      type: ContentChildren,
      args: [forwardRef(() => ThyGridItem), {
        isSignal: true
      }]
    }],
    thyCols: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyCols",
        required: false
      }]
    }],
    thyXGap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyXGap",
        required: false
      }]
    }],
    thyYGap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyYGap",
        required: false
      }]
    }],
    thyGap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGap",
        required: false
      }]
    }],
    thyResponsive: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyResponsive",
        required: false
      }]
    }]
  });
})();
var ThyGridComponent = class _ThyGridComponent {
  constructor() {
    this.grid = inject(ThyGrid);
  }
  static {
    this.\u0275fac = function ThyGridComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyGridComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyGridComponent,
      selectors: [["thy-grid"]],
      features: [\u0275\u0275ProvidersFeature([{
        provide: THY_GRID_COMPONENT,
        useExisting: ThyGrid
      }]), \u0275\u0275HostDirectivesFeature([{
        directive: ThyGrid,
        inputs: ["thyCols", "thyCols", "thyXGap", "thyXGap", "thyYGap", "thyYGap", "thyGap", "thyGap", "thyResponsive", "thyResponsive"]
      }])],
      ngContentSelectors: _c011,
      decls: 1,
      vars: 0,
      template: function ThyGridComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyGridComponent, [{
    type: Component,
    args: [{
      selector: "thy-grid",
      template: "<ng-content></ng-content>",
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [],
      providers: [{
        provide: THY_GRID_COMPONENT,
        useExisting: ThyGrid
      }],
      hostDirectives: [{
        directive: ThyGrid,
        inputs: ["thyCols", "thyXGap", "thyYGap", "thyGap", "thyResponsive"]
      }]
    }]
  }], null, null);
})();
function getRawSpan(span) {
  return span === void 0 || span === null ? THY_GRID_ITEM_DEFAULT_SPAN : span;
}
var ThyFlex = class _ThyFlex {
  constructor() {
    this.hostRenderer = useHostRenderer();
    this.thyDirection = input("row", ...ngDevMode ? [{
      debugName: "thyDirection",
      transform: (value) => value || "row"
    }] : [{
      transform: (value) => value || "row"
    }]);
    this.thyWrap = input(...ngDevMode ? [void 0, {
      debugName: "thyWrap"
    }] : []);
    this.thyJustifyContent = input(...ngDevMode ? [void 0, {
      debugName: "thyJustifyContent"
    }] : []);
    this.thyAlignItems = input(...ngDevMode ? [void 0, {
      debugName: "thyAlignItems"
    }] : []);
    this.thyGap = input(...ngDevMode ? [void 0, {
      debugName: "thyGap"
    }] : []);
    effect(() => {
      this.updateClasses();
    });
  }
  updateClasses() {
    const classes = [];
    const justifyContent = this.thyJustifyContent();
    if (!isUndefinedOrNull2(justifyContent)) {
      classes.push(`justify-content-${normalizeStartEnd(justifyContent)}`);
    }
    const alignItems = this.thyAlignItems();
    if (!isUndefinedOrNull2(alignItems)) {
      classes.push(`align-items-${normalizeStartEnd(alignItems)}`);
    }
    const wrap = this.thyWrap();
    if (!isUndefinedOrNull2(wrap)) {
      classes.push(`flex-${wrap}`);
    }
    const direction = this.thyDirection();
    if (!isUndefinedOrNull2(direction)) {
      classes.push(`flex-${direction}`);
    }
    this.hostRenderer.updateClass(classes);
    this.hostRenderer.setStyle("gap", `${this.thyGap() ?? "0"}px`);
  }
  static {
    this.\u0275fac = function ThyFlex_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlex)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyFlex,
      selectors: [["", "thyFlex", ""]],
      hostAttrs: [1, "thy-flex", "d-flex"],
      inputs: {
        thyDirection: [1, "thyDirection"],
        thyWrap: [1, "thyWrap"],
        thyJustifyContent: [1, "thyJustifyContent"],
        thyAlignItems: [1, "thyAlignItems"],
        thyGap: [1, "thyGap"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlex, [{
    type: Directive,
    args: [{
      selector: "[thyFlex]",
      host: {
        class: "thy-flex d-flex"
      }
    }]
  }], () => [], {
    thyDirection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDirection",
        required: false
      }]
    }],
    thyWrap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyWrap",
        required: false
      }]
    }],
    thyJustifyContent: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyJustifyContent",
        required: false
      }]
    }],
    thyAlignItems: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAlignItems",
        required: false
      }]
    }],
    thyGap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGap",
        required: false
      }]
    }]
  });
})();
var ThyFlexComponent = class _ThyFlexComponent {
  static {
    this.\u0275fac = function ThyFlexComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlexComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyFlexComponent,
      selectors: [["thy-flex"]],
      features: [\u0275\u0275HostDirectivesFeature([{
        directive: ThyFlex,
        inputs: ["thyDirection", "thyDirection", "thyWrap", "thyWrap", "thyJustifyContent", "thyJustifyContent", "thyAlignItems", "thyAlignItems", "thyGap", "thyGap"]
      }])],
      ngContentSelectors: _c011,
      decls: 1,
      vars: 0,
      template: function ThyFlexComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlexComponent, [{
    type: Component,
    args: [{
      selector: "thy-flex",
      template: `<ng-content></ng-content>`,
      changeDetection: ChangeDetectionStrategy.OnPush,
      hostDirectives: [{
        directive: ThyFlex,
        inputs: ["thyDirection", "thyWrap", "thyJustifyContent", "thyAlignItems", "thyGap"]
      }],
      imports: []
    }]
  }], null, null);
})();
var ThyFlexItem = class _ThyFlexItem {
  constructor() {
    this.hostRenderer = useHostRenderer();
    this.thyFlexItem = input(...ngDevMode ? [void 0, {
      debugName: "thyFlexItem"
    }] : []);
    this.thyGrow = input(...ngDevMode ? [void 0, {
      debugName: "thyGrow"
    }] : []);
    this.thyShrink = input(...ngDevMode ? [void 0, {
      debugName: "thyShrink"
    }] : []);
    this.thyBasis = input(...ngDevMode ? [void 0, {
      debugName: "thyBasis"
    }] : []);
    effect(() => {
      this.updateClasses();
    });
  }
  updateClasses() {
    const flexItem = this.thyFlexItem();
    const classes = [];
    this.hostRenderer.setStyle("flex", "");
    this.hostRenderer.setStyle("basis", "");
    if (flexItem) {
      if (flexItem === "fill") {
        classes.push(`flex-${flexItem}`);
      } else {
        this.hostRenderer.setStyle("flex", flexItem);
      }
    }
    const grow = this.thyGrow();
    if (!isUndefinedOrNull2(grow)) {
      classes.push(`flex-grow-${grow}`);
    }
    const shrink = this.thyShrink();
    if (!isUndefinedOrNull2(shrink)) {
      classes.push(`flex-shrink-${shrink}`);
    }
    const basis = this.thyBasis();
    if (!isUndefinedOrNull2(basis)) {
      this.hostRenderer.setStyle("flex-basis", basis);
    }
    this.hostRenderer.updateClass(classes);
  }
  static {
    this.\u0275fac = function ThyFlexItem_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlexItem)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyFlexItem,
      selectors: [["", "thyFlexItem", ""]],
      hostAttrs: [1, "thy-flex-item"],
      inputs: {
        thyFlexItem: [1, "thyFlexItem"],
        thyGrow: [1, "thyGrow"],
        thyShrink: [1, "thyShrink"],
        thyBasis: [1, "thyBasis"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlexItem, [{
    type: Directive,
    args: [{
      selector: "[thyFlexItem]",
      host: {
        class: "thy-flex-item"
      }
    }]
  }], () => [], {
    thyFlexItem: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFlexItem",
        required: false
      }]
    }],
    thyGrow: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGrow",
        required: false
      }]
    }],
    thyShrink: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShrink",
        required: false
      }]
    }],
    thyBasis: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyBasis",
        required: false
      }]
    }]
  });
})();
var ThyFlexItemComponent = class _ThyFlexItemComponent {
  static {
    this.\u0275fac = function ThyFlexItemComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFlexItemComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyFlexItemComponent,
      selectors: [["thy-flex-item"]],
      features: [\u0275\u0275HostDirectivesFeature([{
        directive: ThyFlexItem,
        inputs: ["thyFlexItem", "thyFlexItem", "thyGrow", "thyGrow", "thyShrink", "thyShrink", "thyBasis", "thyBasis"]
      }])],
      ngContentSelectors: _c011,
      decls: 1,
      vars: 0,
      template: function ThyFlexItemComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFlexItemComponent, [{
    type: Component,
    args: [{
      selector: "thy-flex-item",
      template: `<ng-content></ng-content>`,
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [],
      hostDirectives: [{
        directive: ThyFlexItem,
        inputs: ["thyFlexItem", "thyGrow", "thyShrink", "thyBasis"]
      }]
    }]
  }], null, null);
})();
function normalizeStartEnd(value) {
  return value === "flex-start" ? "start" : value === "flex-end" ? "end" : value;
}
var ThyGridModule = class _ThyGridModule {
  static {
    this.\u0275fac = function ThyGridModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyGridModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyGridModule,
      imports: [ThyGrid, ThyGridComponent, ThyGridItem, ThyRowDirective, ThyColDirective, ThyFlex, ThyFlexItem, ThyFlexComponent, ThyFlexItemComponent],
      exports: [ThyGrid, ThyGridComponent, ThyGridItem, ThyRowDirective, ThyColDirective, ThyFlex, ThyFlexItem, ThyFlexComponent, ThyFlexItemComponent]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyGridModule, [{
    type: NgModule,
    args: [{
      exports: [ThyGrid, ThyGridComponent, ThyGridItem, ThyRowDirective, ThyColDirective, ThyFlex, ThyFlexItem, ThyFlexComponent, ThyFlexItemComponent],
      imports: [ThyGrid, ThyGridComponent, ThyGridItem, ThyRowDirective, ThyColDirective, ThyFlex, ThyFlexItem, ThyFlexComponent, ThyFlexItemComponent]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-shared.mjs
var _c012 = ["inputElement"];
var _c15 = ["tagsContainer"];
var _c24 = (a0) => ({
  hidden: a0
});
var _c33 = (a0) => ({
  $implicit: a0
});
var _c43 = (a0, a1) => ({
  disabled: a0,
  hidden: a1
});
var _c52 = (a0) => ({
  disabled: a0
});
function ThySelectControl_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "input", 10, 2);
    \u0275\u0275listener("compositionstart", function ThySelectControl_ng_template_0_Template_input_compositionstart_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.compositionChange(true));
    })("compositionend", function ThySelectControl_ng_template_0_Template_input_compositionend_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.compositionChange(false));
    })("input", function ThySelectControl_ng_template_0_Template_input_input_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateWidth());
    })("ngModelChange", function ThySelectControl_ng_template_0_Template_input_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.setInputValue($event));
    })("keydown.backspace", function ThySelectControl_ng_template_0_Template_input_keydown_backspace_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.handleBackspace($event));
    })("blur", function ThySelectControl_ng_template_0_Template_input_blur_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.onBlur($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("tabindex", -1)("ngClass", ctx_r1.searchInputControlClass)("ngModel", ctx_r1.inputValue())("disabled", ctx_r1.thyDisabled());
  }
}
function ThySelectControl_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngStyle", ctx_r1.placeholderStyle());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.thyPlaceholder(), " ");
  }
}
function ThySelectControl_Conditional_4_Conditional_2_For_1_ng_template_1_Template(rf, ctx) {
}
function ThySelectControl_Conditional_4_Conditional_2_For_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275listener("click", function ThySelectControl_Conditional_4_Conditional_2_For_1_Conditional_2_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const item_r4 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.removeHandle(item_r4, $event));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275element(2, "thy-icon", 18);
    \u0275\u0275elementEnd()();
  }
}
function ThySelectControl_Conditional_4_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275template(1, ThySelectControl_Conditional_4_Conditional_2_For_1_ng_template_1_Template, 0, 0, "ng-template", 15);
    \u0275\u0275conditionalCreate(2, ThySelectControl_Conditional_4_Conditional_2_For_1_Conditional_2_Template, 3, 0, "div", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const $index_r5 = ctx.$index;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(4, _c24, $index_r5 > ctx_r1.visibleTagCount() - 1));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.customDisplayTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(6, _c33, item_r4.thyRawValue || item_r4.thyValue || item_r4));
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.thyDisabled() ? 2 : -1);
  }
}
function ThySelectControl_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, ThySelectControl_Conditional_4_Conditional_2_For_1_Template, 3, 8, "div", 14, \u0275\u0275componentInstance().trackValue, true);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r1.selectedTags());
  }
}
function ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "thy-flexible-text", 21);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("thyTooltipContent", item_r6 == null ? null : item_r6.thyLabelText);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r6 == null ? null : item_r6.thyLabelText, " ");
  }
}
function ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    const item_r6 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.customDisplayTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c33, item_r6.thyRawValue || item_r6.thyValue || item_r6));
  }
}
function ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275listener("click", function ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_4_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r7);
      const item_r6 = \u0275\u0275nextContext().$implicit;
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.removeHandle(item_r6, $event));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275element(2, "thy-icon", 18);
    \u0275\u0275elementEnd()();
  }
}
function ThySelectControl_Conditional_4_Conditional_3_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19)(1, "div", 20);
    \u0275\u0275conditionalCreate(2, ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_2_Template, 2, 2, "thy-flexible-text", 21)(3, ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_3_Template, 1, 4, null, 15);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(4, ThySelectControl_Conditional_4_Conditional_3_For_1_Conditional_4_Template, 3, 0, "div", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const $index_r8 = ctx.$index;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(4, _c43, ctx_r1.thyDisabled() === true, $index_r8 > ctx_r1.visibleTagCount() - 1))("thySize", ctx_r1.tagSize());
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!ctx_r1.customDisplayTemplate() ? 2 : 3);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!ctx_r1.thyDisabled() ? 4 : -1);
  }
}
function ThySelectControl_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, ThySelectControl_Conditional_4_Conditional_3_For_1_Template, 5, 7, "div", 19, \u0275\u0275componentInstance().trackValue, true);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275repeater(ctx_r1.selectedTags());
  }
}
function ThySelectControl_Conditional_4_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11)(1, "div", 22);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_8_0;
    const ctx_r1 = \u0275\u0275nextContext(2);
    const maxTagTooltip_r9 = \u0275\u0275reference(10);
    \u0275\u0275property("thySize", ctx_r1.tagSize())("ngClass", \u0275\u0275pureFunction1(4, _c52, ctx_r1.thyDisabled() === true))("thyTooltip", maxTagTooltip_r9);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("+", (tmp_8_0 = ctx_r1.collapsedSelectedTags()) == null ? null : tmp_8_0.length);
  }
}
function ThySelectControl_Conditional_4_ng_template_6_Template(rf, ctx) {
}
function ThySelectControl_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6, 3);
    \u0275\u0275conditionalCreate(2, ThySelectControl_Conditional_4_Conditional_2_Template, 2, 0)(3, ThySelectControl_Conditional_4_Conditional_3_Template, 2, 0);
    \u0275\u0275conditionalCreate(4, ThySelectControl_Conditional_4_Conditional_4_Template, 3, 6, "div", 11);
    \u0275\u0275elementStart(5, "div", 12);
    \u0275\u0275template(6, ThySelectControl_Conditional_4_ng_template_6_Template, 0, 0, "ng-template", 13);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r1 = \u0275\u0275nextContext();
    const inputTemplate_r10 = \u0275\u0275reference(1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.thyPreset() === "tag" ? 2 : 3);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(((tmp_5_0 = ctx_r1.collapsedSelectedTags()) == null ? null : tmp_5_0.length) > 0 ? 4 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", inputTemplate_r10);
  }
}
function ThySelectControl_Conditional_5_Conditional_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 22);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_5_0;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate((tmp_5_0 = ctx_r1.thySelectedOptions()) == null ? null : tmp_5_0.thyLabelText);
  }
}
function ThySelectControl_Conditional_5_Conditional_0_Conditional_2_ng_template_0_Template(rf, ctx) {
}
function ThySelectControl_Conditional_5_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThySelectControl_Conditional_5_Conditional_0_Conditional_2_ng_template_0_Template, 0, 0, "ng-template", 15);
  }
  if (rf & 2) {
    let tmp_6_0;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.customDisplayTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c33, ((tmp_6_0 = ctx_r1.thySelectedOptions()) == null ? null : tmp_6_0.thyRawValue) || ((tmp_6_0 = ctx_r1.thySelectedOptions()) == null ? null : tmp_6_0.thyValue) || ctx_r1.thySelectedOptions()));
  }
}
function ThySelectControl_Conditional_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 23);
    \u0275\u0275conditionalCreate(1, ThySelectControl_Conditional_5_Conditional_0_Conditional_1_Template, 2, 1, "span", 22)(2, ThySelectControl_Conditional_5_Conditional_0_Conditional_2_Template, 1, 4, null, 15);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngStyle", ctx_r1.selectedValueStyle());
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.customDisplayTemplate() ? 1 : 2);
  }
}
function ThySelectControl_Conditional_5_ng_template_2_Template(rf, ctx) {
}
function ThySelectControl_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThySelectControl_Conditional_5_Conditional_0_Template, 3, 2, "div", 23);
    \u0275\u0275elementStart(1, "div", 24);
    \u0275\u0275template(2, ThySelectControl_Conditional_5_ng_template_2_Template, 0, 0, "ng-template", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const inputTemplate_r10 = \u0275\u0275reference(1);
    \u0275\u0275conditional(ctx_r1.isSelectedValue() ? 0 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", inputTemplate_r10);
  }
}
function ThySelectControl_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r11 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 25);
    \u0275\u0275listener("click", function ThySelectControl_Conditional_8_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r11);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.clearHandle($event));
    });
    \u0275\u0275element(1, "thy-icon", 26);
    \u0275\u0275elementEnd();
  }
}
function ThySelectControl_ng_template_9_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275textInterpolate1(" ", ctx_r1.locale().comma, " ");
  }
}
function ThySelectControl_ng_template_9_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275conditionalCreate(1, ThySelectControl_ng_template_9_For_2_Conditional_1_Template, 1, 1);
  }
  if (rf & 2) {
    const item_r12 = ctx.$implicit;
    const $index_r13 = ctx.$index;
    \u0275\u0275nextContext();
    const lastIndex_r14 = \u0275\u0275readContextLet(0);
    \u0275\u0275textInterpolate1(" ", item_r12.thyLabelText, " ");
    \u0275\u0275advance();
    \u0275\u0275conditional($index_r13 !== lastIndex_r14 ? 1 : -1);
  }
}
function ThySelectControl_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275declareLet(0);
    \u0275\u0275repeaterCreate(1, ThySelectControl_ng_template_9_For_2_Template, 2, 2, null, null, \u0275\u0275componentInstance().trackValue, true);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275storeLet(ctx_r1.collapsedSelectedTags().length - 1);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.collapsedSelectedTags());
  }
}
var _c62 = ["*"];
function ThyListOption_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275element(1, "thy-icon", 1);
    \u0275\u0275elementEnd();
  }
}
function ThyListOption_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275element(1, "thy-icon", 2);
    \u0275\u0275elementEnd();
  }
}
var _c7 = ["suffixTemplate"];
function ThyOption_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275projection(0);
  }
}
function ThyOptionRender_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyOptionRender_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyOptionRender_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.thyTemplate())("ngTemplateOutletContext", ctx_r0.thyTemplateContext());
  }
}
function ThyOptionRender_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 0);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.thyLabelText());
  }
}
function ThyOptionRender_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 1);
  }
}
var ThyTranscludeDirective = class _ThyTranscludeDirective {
  constructor() {
    this.thyTransclude = input(...ngDevMode ? [void 0, {
      debugName: "thyTransclude"
    }] : []);
    const viewRef = inject(ViewContainerRef);
    this.viewRef = viewRef;
    effect(() => {
      const transclude = this.thyTransclude();
      if (transclude) {
        this.viewRef.createEmbeddedView(transclude);
      }
    });
  }
  static {
    this.\u0275fac = function ThyTranscludeDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTranscludeDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyTranscludeDirective,
      selectors: [["", "thyTransclude", ""]],
      inputs: {
        thyTransclude: [1, "thyTransclude"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTranscludeDirective, [{
    type: Directive,
    args: [{
      selector: "[thyTransclude]"
    }]
  }], () => [], {
    thyTransclude: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTransclude",
        required: false
      }]
    }]
  });
})();
var ThyAutofocusDirective = class _ThyAutofocusDirective {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ngZone = inject(NgZone);
    this._autoSelect = false;
    this.thyAutofocus = input(false, ...ngDevMode ? [{
      debugName: "thyAutofocus",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyAutoSelect = input(false, ...ngDevMode ? [{
      debugName: "thyAutoSelect",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    effect(() => {
      if (this.thyAutofocus()) {
        this.ngZone.runOutsideAngular(() => (
          // Note: `element.focus()` causes re-layout and this may lead to frame drop on slower devices.
          // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#setting-focus
          // `setTimeout` is a macrotask and macrotasks are executed within the current rendering frame.
          // Animation tasks are executed within the next rendering frame.
          reqAnimFrame(() => {
            this.elementRef.nativeElement.focus();
            if (this.thyAutoSelect() && this.elementRef.nativeElement.select) {
              this.elementRef.nativeElement.select();
            }
          })
        ));
      }
    });
  }
  static {
    this.\u0275fac = function ThyAutofocusDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyAutofocusDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyAutofocusDirective,
      selectors: [["input", "thyAutofocus", ""], ["textarea", "thyAutofocus", ""]],
      inputs: {
        thyAutofocus: [1, "thyAutofocus"],
        thyAutoSelect: [1, "thyAutoSelect"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyAutofocusDirective, [{
    type: Directive,
    args: [{
      selector: "input[thyAutofocus],textarea[thyAutofocus]"
    }]
  }], () => [], {
    thyAutofocus: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutofocus",
        required: false
      }]
    }],
    thyAutoSelect: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutoSelect",
        required: false
      }]
    }]
  });
})();
var ThyEnterDirective = class _ThyEnterDirective {
  constructor() {
    this.ngZone = inject(NgZone);
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.thyEnter = output();
    this.onKeydown = (event) => {
      const keyCode = event.which || event.keyCode;
      if (keyCode === keycodes_exports.ENTER) {
        this.ngZone.run(() => {
          this.thyEnter.emit(event);
        });
      }
    };
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      this.removeKeydownListenerFn = this.renderer.listen(this.elementRef.nativeElement, "keydown", this.onKeydown);
    });
  }
  ngOnDestroy() {
    this.removeKeydownListenerFn();
  }
  static {
    this.\u0275fac = function ThyEnterDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyEnterDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyEnterDirective,
      selectors: [["", "thyEnter", ""]],
      outputs: {
        thyEnter: "thyEnter"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyEnterDirective, [{
    type: Directive,
    args: [{
      selector: "[thyEnter]"
    }]
  }], null, {
    thyEnter: [{
      type: Output,
      args: ["thyEnter"]
    }]
  });
})();
var ThyCtrlEnterDirective = class _ThyCtrlEnterDirective {
  constructor() {
    this.ngZone = inject(NgZone);
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.thyCtrlEnter = output();
    this.onKeydown = (event) => {
      const keyCode = event.which || event.keyCode;
      if ((event.ctrlKey || event.metaKey) && keyCode === keycodes_exports.ENTER) {
        event.preventDefault();
        this.ngZone.run(() => {
          this.thyCtrlEnter.emit(event);
        });
      }
    };
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      this.removeKeydownListenerFn = this.renderer.listen(this.elementRef.nativeElement, "keydown", this.onKeydown);
    });
  }
  ngOnDestroy() {
    this.removeKeydownListenerFn();
  }
  static {
    this.\u0275fac = function ThyCtrlEnterDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyCtrlEnterDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyCtrlEnterDirective,
      selectors: [["", "thyCtrlEnter", ""]],
      outputs: {
        thyCtrlEnter: "thyCtrlEnter"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyCtrlEnterDirective, [{
    type: Directive,
    args: [{
      selector: "[thyCtrlEnter]"
    }]
  }], null, {
    thyCtrlEnter: [{
      type: Output,
      args: ["thyCtrlEnter"]
    }]
  });
})();
var ThyShowDirective = class _ThyShowDirective {
  unListenDocument() {
    if (this.unListenEvent) {
      this.unListenEvent();
      this.unListenEvent = null;
    }
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.ngZone = inject(NgZone);
    this.thyShowChange = output();
    this.hostRenderer = useHostRenderer();
    this.unListenEvent = null;
    this.thyShow = input(false, ...ngDevMode ? [{
      debugName: "thyShow",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    effect(() => {
      if (this.thyShow()) {
        this.hostRenderer.setStyle("display", "block");
        this.ngZone.runOutsideAngular(() => setTimeout(() => {
          this.unListenEvent = this.renderer.listen("document", "click", (event) => {
            if (!this.elementRef.nativeElement.contains(event.target)) {
              this.ngZone.run(() => this.thyShowChange.emit(false));
              this.unListenDocument();
            }
          });
        }));
      } else {
        this.hostRenderer.setStyle("display", "none");
        this.unListenDocument();
      }
    });
  }
  ngOnDestroy() {
    this.unListenDocument();
  }
  static {
    this.\u0275fac = function ThyShowDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyShowDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyShowDirective,
      selectors: [["", "thyShow", ""]],
      inputs: {
        thyShow: [1, "thyShow"]
      },
      outputs: {
        thyShowChange: "thyShowChange"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyShowDirective, [{
    type: Directive,
    args: [{
      selector: "[thyShow]"
    }]
  }], () => [], {
    thyShowChange: [{
      type: Output,
      args: ["thyShowChange"]
    }],
    thyShow: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShow",
        required: false
      }]
    }]
  });
})();
var ThyStopPropagationDirective = class _ThyStopPropagationDirective {
  constructor() {
    this.thyStopPropagation = input(true, ...ngDevMode ? [{
      debugName: "thyStopPropagation"
    }] : []);
    this._eventName = computed(() => {
      const stopPropagation = this.thyStopPropagation();
      if (stopPropagation !== false) {
        if (!stopPropagation || stopPropagation === true || stopPropagation === "true") {
          return "click";
        } else {
          return stopPropagation;
        }
      }
    }, ...ngDevMode ? [{
      debugName: "_eventName"
    }] : []);
    this._shouldStopPropagation = computed(() => {
      const stopPropagation = this.thyStopPropagation();
      return stopPropagation === false || stopPropagation === "false" ? false : true;
    }, ...ngDevMode ? [{
      debugName: "_shouldStopPropagation"
    }] : []);
    this._changes$ = new Subject();
    this._destroy$ = new Subject();
    const _host = inject(ElementRef);
    const _ngZone = inject(NgZone);
    effect(() => {
      this._changes$.next(this.thyStopPropagation());
    });
    this._changes$.pipe(
      // Note: we start the stream immediately since the `thyStopPropagation` setter may never be reached.
      startWith(null),
      switchMap(() => new Observable((subscriber) => _ngZone.runOutsideAngular(() => fromEvent(_host.nativeElement, this._eventName()).subscribe(subscriber)))),
      takeUntil(this._destroy$)
    ).subscribe((event) => {
      if (this._shouldStopPropagation()) {
        event.stopPropagation();
      }
    });
  }
  ngOnDestroy() {
    this._destroy$.next();
  }
  static {
    this.\u0275fac = function ThyStopPropagationDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyStopPropagationDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyStopPropagationDirective,
      selectors: [["", "thyStopPropagation", ""]],
      inputs: {
        thyStopPropagation: [1, "thyStopPropagation"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyStopPropagationDirective, [{
    type: Directive,
    args: [{
      selector: "[thyStopPropagation]"
    }]
  }], () => [], {
    thyStopPropagation: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyStopPropagation",
        required: false
      }]
    }]
  });
})();
var ThyContextMenuDirective = class _ThyContextMenuDirective {
  constructor() {
    this.ngZone = inject(NgZone);
    this.elementRef = inject(ElementRef);
    this.renderer = inject(Renderer2);
    this.thyContextMenu = output();
    this.rightClick = (event) => {
      event.preventDefault();
      this.ngZone.run(() => {
        this.thyContextMenu.emit(event);
      });
    };
  }
  ngOnInit() {
    this.ngZone.runOutsideAngular(() => {
      this.removeContextListenerFn = this.renderer.listen(this.elementRef.nativeElement, "contextmenu", this.rightClick);
    });
  }
  ngOnDestroy() {
    this.removeContextListenerFn();
  }
  static {
    this.\u0275fac = function ThyContextMenuDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyContextMenuDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyContextMenuDirective,
      selectors: [["", "thyContextMenu", ""]],
      outputs: {
        thyContextMenu: "thyContextMenu"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyContextMenuDirective, [{
    type: Directive,
    args: [{
      selector: "[thyContextMenu]"
    }]
  }], null, {
    thyContextMenu: [{
      type: Output,
      args: ["thyContextMenu"]
    }]
  });
})();
var passiveEventListenerOptions3 = normalizePassiveListenerOptions({
  passive: true
});
var ThyScrollDirective = class _ThyScrollDirective {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ngZone = inject(NgZone);
    this._destroyed = new Subject();
    this._subscription = null;
    this._elementScrolled = new Observable((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, "scroll", passiveEventListenerOptions3).pipe(takeUntil(this._destroyed)).subscribe(observer)));
    this.thyEnable = input(true, ...ngDevMode ? [{
      debugName: "thyEnable",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyOnScrolled = output();
    effect(() => {
      const thyEnable = this.thyEnable();
      if (thyEnable && !this._subscription) {
        this._subscription = this._elementScrolled.subscribe(() => this.thyOnScrolled.emit(this.elementRef));
      } else {
        if (this._subscription) {
          this._subscription.unsubscribe();
          this._subscription = null;
        }
      }
    });
  }
  ngOnInit() {
  }
  ngOnDestroy() {
    this._destroyed.next();
    this._destroyed.complete();
  }
  getElementRef() {
    return this.elementRef;
  }
  static {
    this.\u0275fac = function ThyScrollDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyScrollDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyScrollDirective,
      selectors: [["", "thyScroll", ""]],
      inputs: {
        thyEnable: [1, "thyEnable"]
      },
      outputs: {
        thyOnScrolled: "thyOnScrolled"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyScrollDirective, [{
    type: Directive,
    args: [{
      selector: "[thyScroll]"
    }]
  }], () => [], {
    thyEnable: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyEnable",
        required: false
      }]
    }],
    thyOnScrolled: [{
      type: Output,
      args: ["thyOnScrolled"]
    }]
  });
})();
var ThyDragDropDirective = class _ThyDragDropDirective {
  constructor() {
    this.ngUnsubscribe$ = new Subject();
  }
  ngAfterContentInit() {
    if (this.draggables) {
      this.draggables.changes.pipe(startWith(this.draggables)).subscribe(() => {
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
        this.ngUnsubscribe$ = new Subject();
        merge(...this.draggables.toArray().map((dragRef) => {
          return dragRef.started;
        })).pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => {
          document.body.classList.add("thy-dragging-body");
        });
        merge(...this.draggables.toArray().map((dragRef) => dragRef.released)).pipe(takeUntil(this.ngUnsubscribe$)).subscribe(() => {
          document.body.classList.remove("thy-dragging-body");
        });
      });
    }
  }
  ngOnDestroy() {
    this.ngUnsubscribe$.next();
    this.ngUnsubscribe$.complete();
  }
  static {
    this.\u0275fac = function ThyDragDropDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDragDropDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDragDropDirective,
      selectors: [["", "thyDragDrop", ""]],
      contentQueries: function ThyDragDropDirective_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuery(dirIndex, CdkDrag, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.draggables = _t);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDragDropDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDragDrop]"
    }]
  }], () => [], {
    draggables: [{
      type: ContentChildren,
      args: [CdkDrag, {
        descendants: true
      }]
    }]
  });
})();
var ThyStringOrTemplateOutletDirective = class _ThyStringOrTemplateOutletDirective {
  constructor() {
    this.viewContainerRef = inject(ViewContainerRef);
    this.renderer = inject(Renderer2);
    this.viewRef = null;
    this.thyStringOrTemplateOutletContext = input(...ngDevMode ? [void 0, {
      debugName: "thyStringOrTemplateOutletContext"
    }] : []);
    this.thyStringOrTemplateOutlet = input(...ngDevMode ? [void 0, {
      debugName: "thyStringOrTemplateOutlet"
    }] : []);
    effect(() => {
      this.updateView();
    });
    effect(() => {
      if (this.viewRef && this.thyStringOrTemplateOutletContext()) {
        this.viewRef.context = this.thyStringOrTemplateOutletContext();
      }
    });
  }
  updateView() {
    const thyStringOrTemplateOutlet = this.thyStringOrTemplateOutlet();
    this.clear();
    if (thyStringOrTemplateOutlet) {
      if (isTemplateRef(thyStringOrTemplateOutlet)) {
        this.viewRef = this.viewContainerRef.createEmbeddedView(thyStringOrTemplateOutlet, this.thyStringOrTemplateOutletContext());
      } else {
        this.textNode = this.renderer.createText(`${thyStringOrTemplateOutlet}`);
        const element = this.viewContainerRef.element.nativeElement;
        this.renderer.insertBefore(element.parentNode, this.textNode, element);
      }
    } else {
      this.viewRef = null;
    }
  }
  clear() {
    this.viewContainerRef.clear();
    if (this.textNode) {
      this.renderer.removeChild(this.textNode.parentNode, this.textNode);
    }
  }
  static {
    this.\u0275fac = function ThyStringOrTemplateOutletDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyStringOrTemplateOutletDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyStringOrTemplateOutletDirective,
      selectors: [["", "thyStringOrTemplateOutlet", ""]],
      inputs: {
        thyStringOrTemplateOutletContext: [1, "thyStringOrTemplateOutletContext"],
        thyStringOrTemplateOutlet: [1, "thyStringOrTemplateOutlet"]
      },
      exportAs: ["thyStringOrTemplateOutlet"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyStringOrTemplateOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[thyStringOrTemplateOutlet]",
      exportAs: "thyStringOrTemplateOutlet"
    }]
  }], () => [], {
    thyStringOrTemplateOutletContext: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyStringOrTemplateOutletContext",
        required: false
      }]
    }],
    thyStringOrTemplateOutlet: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyStringOrTemplateOutlet",
        required: false
      }]
    }]
  });
})();
function hasInput(componentRef, inputKey) {
  return componentRef["_tNode"].inputs?.[inputKey];
}
var ThyViewOutletDirective = class _ThyViewOutletDirective {
  constructor() {
    this.viewContainerRef = inject(ViewContainerRef);
    this.keyValueDiffers = inject(KeyValueDiffers);
    this.thyViewOutlet = input(null, ...ngDevMode ? [{
      debugName: "thyViewOutlet"
    }] : []);
    this.thyViewOutletContext = input(...ngDevMode ? [void 0, {
      debugName: "thyViewOutletContext"
    }] : []);
    this.isViewOutletChanged = linkedSignal(...ngDevMode ? [{
      debugName: "isViewOutletChanged",
      source: () => this.thyViewOutlet(),
      computation: (source, previous) => {
        return !!(source && previous?.source && source !== previous?.source);
      }
    }] : [{
      source: () => this.thyViewOutlet(),
      computation: (source, previous) => {
        return !!(source && previous?.source && source !== previous?.source);
      }
    }]);
    effect(() => {
      const thyViewOutlet = this.thyViewOutlet();
      const {
        viewContainerRef
      } = this;
      viewContainerRef.clear();
      this.componentRef = void 0;
      this.embeddedViewRef = void 0;
      if (thyViewOutlet) {
        if (thyViewOutlet instanceof TemplateRef) {
          this.embeddedViewRef = viewContainerRef.createEmbeddedView(thyViewOutlet, this.thyViewOutletContext());
        } else {
          this.componentRef = viewContainerRef.createComponent(thyViewOutlet, {
            index: viewContainerRef.length
          });
        }
      }
    });
    effect(() => {
      const thyViewOutletContext = this.thyViewOutletContext();
      let updatedKeys = [];
      const isViewOutletChanged = untracked(this.isViewOutletChanged);
      if (thyViewOutletContext) {
        if (!this.keyValueDiffer || isViewOutletChanged) {
          if (!this.keyValueDiffer) {
            this.keyValueDiffer = this.keyValueDiffers.find(thyViewOutletContext).create();
          }
          this.keyValueDiffer.diff(thyViewOutletContext);
          updatedKeys = Object.keys(thyViewOutletContext);
          this.isViewOutletChanged.set(false);
        } else {
          const diffChanges = this.keyValueDiffer.diff(thyViewOutletContext);
          diffChanges?.forEachChangedItem((item) => {
            updatedKeys.push(item.key);
          });
        }
      }
      if (this.componentRef) {
        this.updateContext(this.componentRef.instance, updatedKeys);
        this.componentRef.injector.get(ChangeDetectorRef).markForCheck();
      } else if (this.embeddedViewRef) {
        this.updateContext(this.embeddedViewRef.context, updatedKeys);
        this.embeddedViewRef.markForCheck();
      }
    });
  }
  updateContext(context, updatedKeys) {
    updatedKeys.forEach((key) => {
      if (this.componentRef && hasInput(this.componentRef, key)) {
        this.componentRef.setInput(key, this.thyViewOutletContext()[key]);
      } else {
        context[key] = this.thyViewOutletContext()[key];
      }
    });
  }
  static {
    this.\u0275fac = function ThyViewOutletDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyViewOutletDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyViewOutletDirective,
      selectors: [["", "thyViewOutlet", ""]],
      inputs: {
        thyViewOutlet: [1, "thyViewOutlet"],
        thyViewOutletContext: [1, "thyViewOutletContext"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyViewOutletDirective, [{
    type: Directive,
    args: [{
      selector: "[thyViewOutlet]"
    }]
  }], () => [], {
    thyViewOutlet: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyViewOutlet",
        required: false
      }]
    }],
    thyViewOutletContext: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyViewOutletContext",
        required: false
      }]
    }]
  });
})();
var ThySharedModule = class _ThySharedModule {
  static {
    this.\u0275fac = function ThySharedModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySharedModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThySharedModule,
      imports: [ThyViewOutletDirective, ThyTranscludeDirective, ThyAutofocusDirective, ThyEnterDirective, ThyCtrlEnterDirective, ThyShowDirective, ThyStopPropagationDirective, ThyContextMenuDirective, ThyScrollDirective, ThyDragDropDirective, ThyStringOrTemplateOutletDirective],
      exports: [ThyTranscludeDirective, ThyAutofocusDirective, ThyEnterDirective, ThyCtrlEnterDirective, ThyShowDirective, ThyStopPropagationDirective, ThyContextMenuDirective, ThyScrollDirective, ThyDragDropDirective, ThyStringOrTemplateOutletDirective, ThyViewOutletDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({});
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySharedModule, [{
    type: NgModule,
    args: [{
      imports: [ThyViewOutletDirective, ThyTranscludeDirective, ThyAutofocusDirective, ThyEnterDirective, ThyCtrlEnterDirective, ThyShowDirective, ThyStopPropagationDirective, ThyContextMenuDirective, ThyScrollDirective, ThyDragDropDirective, ThyStringOrTemplateOutletDirective],
      exports: [ThyTranscludeDirective, ThyAutofocusDirective, ThyEnterDirective, ThyCtrlEnterDirective, ThyShowDirective, ThyStopPropagationDirective, ThyContextMenuDirective, ThyScrollDirective, ThyDragDropDirective, ThyStringOrTemplateOutletDirective, ThyViewOutletDirective],
      providers: []
    }]
  }], null, null);
})();
var noop3 = () => {
};
var ThyFormCheckBaseComponent = class _ThyFormCheckBaseComponent extends TabIndexDisabledControlValueAccessorMixin {
  /**
   * 是否禁用
   * @default false
   */
  set thyDisabled(value) {
    this.disabled = value;
    this.setDisabledState(this.disabled);
  }
  get thyDisabled() {
    return this.disabled;
  }
  writeValue(obj) {
    if (obj !== this._innerValue) {
      this._innerValue = obj;
      this._isChecked = !!this._innerValue;
    }
  }
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  setDisabledState(isDisabled) {
    this._disabled = isDisabled;
    this.markForCheck();
  }
  updateValue(value) {
    this._innerValue = value;
    this._isChecked = !!this._innerValue;
    this.onChangeCallback(value);
    this.markForCheck();
  }
  constructor() {
    super();
    this.thyTranslate = inject(ThyTranslate);
    this.changeDetectorRef = inject(ChangeDetectorRef);
    this._innerValue = null;
    this._disabled = false;
    this.onTouchedCallback = noop3;
    this.onChangeCallback = noop3;
    this._isFormCheck = true;
    this._isChecked = false;
    this.thyInline = input(false, ...ngDevMode ? [{
      debugName: "thyInline",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyLabelText = input(...ngDevMode ? [void 0, {
      debugName: "thyLabelText"
    }] : []);
    this.thyLabelTextTranslateKey = input(...ngDevMode ? [void 0, {
      debugName: "thyLabelTextTranslateKey"
    }] : []);
    this._labelText = computed(() => {
      const labelTextTranslateKey = this.thyLabelTextTranslateKey();
      const labelText = this.thyLabelText();
      return labelTextTranslateKey ? this.thyTranslate.instant(labelTextTranslateKey) : labelText || "";
    }, ...ngDevMode ? [{
      debugName: "_labelText"
    }] : []);
    this._isNoText = computed(() => {
      return this.thyInline() && !this._labelText();
    }, ...ngDevMode ? [{
      debugName: "_isNoText"
    }] : []);
    this.disabled = false;
  }
  change() {
    this.updateValue(!this._innerValue);
  }
  markForCheck() {
    if (this.changeDetectorRef) {
      this.changeDetectorRef.markForCheck();
    }
  }
  static {
    this.\u0275fac = function ThyFormCheckBaseComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyFormCheckBaseComponent)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyFormCheckBaseComponent,
      hostVars: 8,
      hostBindings: function ThyFormCheckBaseComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("form-check", ctx._isFormCheck)("form-check-inline", ctx.thyInline())("form-check-checked", ctx._isChecked)("form-check-inline-no-label-text", ctx._isNoText());
        }
      },
      inputs: {
        thyInline: [1, "thyInline"],
        thyLabelText: [1, "thyLabelText"],
        thyLabelTextTranslateKey: [1, "thyLabelTextTranslateKey"],
        thyDisabled: [2, "thyDisabled", "thyDisabled", coerceBooleanProperty2]
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyFormCheckBaseComponent, [{
    type: Directive,
    args: [{
      host: {
        "[class.form-check]": "_isFormCheck",
        "[class.form-check-inline]": "thyInline()",
        "[class.form-check-checked]": "_isChecked",
        "[class.form-check-inline-no-label-text]": "_isNoText()"
      }
    }]
  }], () => [], {
    thyInline: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyInline",
        required: false
      }]
    }],
    thyLabelText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLabelText",
        required: false
      }]
    }],
    thyLabelTextTranslateKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLabelTextTranslateKey",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        transform: coerceBooleanProperty2
      }]
    }]
  });
})();
var ThySelectControl = class _ThySelectControl {
  constructor() {
    this.renderer = inject(Renderer2);
    this.cdr = inject(ChangeDetectorRef);
    this.ngZone = inject(NgZone);
    this.destroyRef = inject(DestroyRef);
    this.inputValue = model("", ...ngDevMode ? [{
      debugName: "inputValue"
    }] : []);
    this.isComposing = signal(false, ...ngDevMode ? [{
      debugName: "isComposing"
    }] : []);
    this.isFirstPanelOpenedChange = true;
    this.hostRenderer = useHostRenderer();
    this.thyPanelOpened = input(false, ...ngDevMode ? [{
      debugName: "thyPanelOpened",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyIsMultiple = input(false, ...ngDevMode ? [{
      debugName: "thyIsMultiple",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyShowSearch = input(false, ...ngDevMode ? [{
      debugName: "thyShowSearch",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thySelectedOptions = input(...ngDevMode ? [void 0, {
      debugName: "thySelectedOptions"
    }] : []);
    this.previousSelectedOptions = linkedSignal(...ngDevMode ? [{
      debugName: "previousSelectedOptions",
      source: () => this.thySelectedOptions(),
      computation: (source, previous) => previous?.source
    }] : [{
      source: () => this.thySelectedOptions(),
      computation: (source, previous) => previous?.source
    }]);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.customDisplayTemplate = input(...ngDevMode ? [void 0, {
      debugName: "customDisplayTemplate"
    }] : []);
    this.thyAllowClear = input(false, ...ngDevMode ? [{
      debugName: "thyAllowClear",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPlaceholder = input("", ...ngDevMode ? [{
      debugName: "thyPlaceholder"
    }] : []);
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.tagSize = computed(() => {
      const value = this.thySize();
      if (value === "xs" || value === "sm") {
        return "sm";
      } else if (value === "lg") {
        return "lg";
      } else {
        return "md";
      }
    }, ...ngDevMode ? [{
      debugName: "tagSize"
    }] : []);
    this.thyMaxTagCount = input(0, ...ngDevMode ? [{
      debugName: "thyMaxTagCount",
      transform: (value) => {
        if (value === "auto") return "auto";
        return numberAttribute(value, 0);
      }
    }] : [{
      transform: (value) => {
        if (value === "auto") return "auto";
        return numberAttribute(value, 0);
      }
    }]);
    this.thyBorderless = input(false, ...ngDevMode ? [{
      debugName: "thyBorderless",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPreset = input("", ...ngDevMode ? [{
      debugName: "thyPreset"
    }] : []);
    this.thyOnSearch = output();
    this.thyOnRemove = output();
    this.thyOnClear = output();
    this.thyOnBlur = output();
    this.inputElement = viewChild("inputElement", ...ngDevMode ? [{
      debugName: "inputElement"
    }] : []);
    this.locale = injectLocale("shared");
    this.isSelectedValue = computed(() => {
      return !this.thyIsMultiple() && !isUndefinedOrNull(this.thySelectedOptions()) || this.thyIsMultiple() && this.thySelectedOptions().length > 0;
    }, ...ngDevMode ? [{
      debugName: "isSelectedValue"
    }] : []);
    this.tagsContainer = viewChild("tagsContainer", ...ngDevMode ? [{
      debugName: "tagsContainer"
    }] : []);
    this.visibleTagCount = signal(0, ...ngDevMode ? [{
      debugName: "visibleTagCount"
    }] : []);
    this.showClearIcon = computed(() => {
      return this.thyAllowClear() && this.isSelectedValue();
    }, ...ngDevMode ? [{
      debugName: "showClearIcon"
    }] : []);
    this.selectedTags = computed(() => {
      if (!this.thyIsMultiple() || !this.thySelectedOptions()) return [];
      const selectedOptions = coerceArray2(this.thySelectedOptions());
      return selectedOptions;
    }, ...ngDevMode ? [{
      debugName: "selectedTags"
    }] : []);
    this.collapsedSelectedTags = computed(() => {
      if (!this.thyIsMultiple() || !this.thySelectedOptions()) return [];
      const selectedOptions = coerceArray2(this.thySelectedOptions());
      const shouldShowMoreTags = this.thyMaxTagCount() === "auto" || this.thyMaxTagCount() > 0;
      if (!shouldShowMoreTags) {
        return [];
      }
      if (this.visibleTagCount() <= 0) {
        return selectedOptions;
      }
      return selectedOptions.slice(this.visibleTagCount());
    }, ...ngDevMode ? [{
      debugName: "collapsedSelectedTags"
    }] : []);
    this.selectedValueStyle = computed(() => {
      let showSelectedValue = false;
      if (this.thyShowSearch()) {
        if (this.thyPanelOpened()) {
          showSelectedValue = !(this.isComposing() || this.inputValue());
        } else {
          showSelectedValue = true;
        }
      } else {
        showSelectedValue = true;
      }
      return {
        display: showSelectedValue ? "flex" : "none"
      };
    }, ...ngDevMode ? [{
      debugName: "selectedValueStyle"
    }] : []);
    this.placeholderStyle = computed(() => {
      let placeholder = true;
      if (this.isSelectedValue()) {
        placeholder = false;
      }
      if (!this.thyPlaceholder()) {
        placeholder = false;
      }
      if (this.isComposing() || this.inputValue()) {
        placeholder = false;
      }
      return {
        display: placeholder ? "block" : "none"
      };
    }, ...ngDevMode ? [{
      debugName: "placeholderStyle"
    }] : []);
    effect(() => {
      const panelOpened = this.thyPanelOpened();
      if (this.isFirstPanelOpenedChange) {
        this.isFirstPanelOpenedChange = false;
        return;
      }
      if (panelOpened) {
        untracked(() => {
          if (this.thyShowSearch()) {
            Promise.resolve(null).then(() => {
              this.inputElement()?.nativeElement.focus();
            });
          }
        });
      } else {
        untracked(() => {
          if (this.thyShowSearch()) {
            new Promise((resolve) => setTimeout(resolve, 100)).then(() => {
              this.inputValue.set("");
              this.updateWidth();
              this.thyOnSearch.emit(this.inputValue());
            });
          }
        });
      }
    });
    effect(() => {
      this.setSelectControlClass();
    });
    effect(() => {
      const oldValue = this.previousSelectedOptions();
      const value = this.thySelectedOptions();
      if (value) {
        let sameValue = false;
        untracked(() => {
          if (this.thyIsMultiple()) {
            if (oldValue instanceof Array && value instanceof Array && oldValue.length === value.length) {
              sameValue = value.every((option, index2) => option.thyValue === oldValue[index2].thyValue);
            }
          } else {
            if (oldValue && value) {
              sameValue = oldValue.thyValue === value.thyValue;
            }
          }
          if (this.thyPanelOpened() && this.thyShowSearch()) {
            if (!sameValue) {
              Promise.resolve(null).then(() => {
                this.inputValue.set("");
                this.updateWidth();
              });
            }
            setTimeout(() => {
              if (this.thyPanelOpened()) {
                this.inputElement()?.nativeElement.focus();
              }
            }, 200);
          }
          if (!sameValue && this.thyIsMultiple()) {
            this.calculateVisibleTags();
          }
        });
      }
    });
  }
  ngOnInit() {
  }
  ngAfterViewInit() {
    setTimeout(() => {
      this.calculateVisibleTags();
    }, 0);
    this.ngZone.runOutsideAngular(() => {
      this.resizeObserver(this.inputElement()?.nativeElement).pipe(throttleTime(100), takeUntilDestroyed(this.destroyRef)).subscribe(() => {
        this.calculateVisibleTags();
      });
    });
  }
  resizeObserver(element) {
    return typeof ResizeObserver === "undefined" || !ResizeObserver ? of(null) : new Observable((observer) => {
      const resize = new ResizeObserver((entries) => {
        observer.next(entries);
      });
      resize.observe(element);
      return () => {
        resize.disconnect();
      };
    });
  }
  calculateVisibleTags() {
    if (!this.tagsContainer()?.nativeElement) return;
    const containerWidth = this.tagsContainer()?.nativeElement.offsetWidth;
    if (containerWidth <= 0) return;
    const selectedOptions = coerceArray2(this.thySelectedOptions());
    if (!selectedOptions?.length) {
      this.visibleTagCount.set(0);
      return;
    }
    const shouldShowMoreTags = this.thyMaxTagCount() === "auto" || this.thyMaxTagCount() > 0;
    if (!shouldShowMoreTags) {
      this.visibleTagCount.set(selectedOptions.length);
      this.cdr.markForCheck();
      return;
    }
    if (this.thyMaxTagCount() > 0) {
      this.visibleTagCount.set(this.thyMaxTagCount() - 1);
      this.cdr.markForCheck();
      return;
    }
    const COLLAPSED_TAG_WIDTH = 46;
    const TAG_GAP = 4;
    const availableWidth = containerWidth - COLLAPSED_TAG_WIDTH - 3;
    let totalWidth = 0;
    let visibleCount = 0;
    Promise.resolve().then(() => {
      const tagElements = this.tagsContainer()?.nativeElement.querySelectorAll(".choice-item.selected,.custom-choice-item");
      for (let i = 0; i < selectedOptions.length; i++) {
        const tagWidth = (tagElements[i]?.offsetWidth || 80) + TAG_GAP;
        if (totalWidth + tagWidth > availableWidth) {
          break;
        }
        totalWidth += tagWidth;
        visibleCount++;
      }
      this.visibleTagCount.set(Math.max(1, visibleCount));
      this.cdr.markForCheck();
    });
  }
  setSelectControlClass() {
    const modeType = this.thyIsMultiple() ? "multiple" : "single";
    const selectControlClass = {
      [`form-control`]: true,
      [`form-control-${this.thySize()}`]: !!this.thySize(),
      [`form-control-custom`]: true,
      [`select-control`]: true,
      [`select-control-${modeType}`]: true,
      [`select-control-show-search`]: this.thyShowSearch(),
      [`panel-is-opened`]: this.thyPanelOpened(),
      [`disabled`]: this.thyDisabled()
    };
    this.hostRenderer.updateClassByMap(selectControlClass);
    this.searchInputControlClass = {
      [`form-control`]: true,
      [`form-control-${this.thySize()}`]: !!this.thySize(),
      [`search-input-field`]: true,
      [`hidden`]: !this.thyShowSearch(),
      [`disabled`]: this.thyDisabled()
    };
  }
  setInputValue(value) {
    if (value !== this.inputValue()) {
      this.inputValue.set(value);
      this.updateWidth();
      this.thyOnSearch.emit(this.inputValue());
    }
  }
  handleBackspace(event) {
    if (event.isComposing) {
      return;
    }
    const selectedOptions = this.thySelectedOptions();
    if (!this.inputValue()?.length && selectedOptions instanceof Array) {
      if (selectedOptions.length > 0) {
        this.removeHandle(selectedOptions[selectedOptions.length - 1], event);
      }
    }
  }
  updateWidth() {
    if (this.thyIsMultiple() && this.thyShowSearch()) {
      if (this.inputValue() || this.isComposing()) {
        this.renderer.setStyle(this.inputElement()?.nativeElement, "width", `${this.inputElement()?.nativeElement.scrollWidth}px`);
      } else {
        this.renderer.removeStyle(this.inputElement()?.nativeElement, "width");
      }
    }
  }
  removeHandle(item, $event) {
    this.thyOnRemove.emit({
      item,
      $eventOrigin: $event
    });
  }
  clearHandle($event) {
    this.thyOnClear.emit($event);
  }
  compositionChange(isComposing) {
    this.isComposing.set(isComposing);
  }
  trackValue(_index, option) {
    return option.thyValue;
  }
  onBlur(event) {
    this.thyOnBlur.emit(event);
  }
  static {
    this.\u0275fac = function ThySelectControl_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySelectControl)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySelectControl,
      selectors: [["thy-select-control"], ["", "thySelectControl", ""]],
      viewQuery: function ThySelectControl_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.inputElement, _c012, 5)(ctx.tagsContainer, _c15, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      hostVars: 2,
      hostBindings: function ThySelectControl_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("select-control-borderless", ctx.thyBorderless());
        }
      },
      inputs: {
        inputValue: [1, "inputValue"],
        thyPanelOpened: [1, "thyPanelOpened"],
        thyIsMultiple: [1, "thyIsMultiple"],
        thyShowSearch: [1, "thyShowSearch"],
        thySelectedOptions: [1, "thySelectedOptions"],
        thyDisabled: [1, "thyDisabled"],
        customDisplayTemplate: [1, "customDisplayTemplate"],
        thyAllowClear: [1, "thyAllowClear"],
        thyPlaceholder: [1, "thyPlaceholder"],
        thySize: [1, "thySize"],
        thyMaxTagCount: [1, "thyMaxTagCount"],
        thyBorderless: [1, "thyBorderless"],
        thyPreset: [1, "thyPreset"]
      },
      outputs: {
        inputValue: "inputValueChange",
        thyOnSearch: "thyOnSearch",
        thyOnRemove: "thyOnRemove",
        thyOnClear: "thyOnClear",
        thyOnBlur: "thyOnBlur"
      },
      decls: 11,
      vars: 3,
      consts: [["inputTemplate", ""], ["maxTagTooltip", ""], ["inputElement", ""], ["tagsContainer", ""], [1, "select-control-rendered"], [1, "text-placeholder", "text-truncate", 3, "ngStyle"], ["thyFlex", "", "thyWrap", "wrap", "thyGap", "4", "thyAlignItems", "center", 1, "w-100"], [1, "select-control-arrow"], ["thyIconName", "angle-down", 1, "font-size-base"], [1, "select-control-clear", "remove-link"], ["autocomplete", "something-new", 3, "compositionstart", "compositionend", "input", "ngModelChange", "keydown.backspace", "blur", "tabindex", "ngClass", "ngModel", "disabled"], ["thyFlexItem", "", "thyTag", "", 1, "choice-item", "max-tag-count-choice", 3, "thySize", "ngClass", "thyTooltip"], ["thyFlexItem", "", 1, "select-control-search"], [3, "ngTemplateOutlet"], ["thyFlexItem", "", 1, "custom-choice-item", "text-truncate", 3, "ngClass"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "choice-remove-link", "ml-1"], [1, "choice-remove-link", "ml-1", 3, "click"], ["thyIconName", "close", 1, "font-size-sm"], ["thyFlexItem", "", "thyTag", "", 1, "choice-item", "selected", 3, "ngClass", "thySize"], [1, "text-truncate", "h-100", "d-flex", "align-items-center"], [1, "text-truncate", "h-100", 3, "thyTooltipContent"], [1, "text-truncate"], [1, "selected-value", "text-truncate", 3, "ngStyle"], [1, "select-control-search"], [1, "select-control-clear", "remove-link", 3, "click"], ["thyIconName", "close-circle-bold-fill", 1, "remove-link-icon", "font-size-base"]],
      template: function ThySelectControl_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, ThySelectControl_ng_template_0_Template, 2, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
          \u0275\u0275elementStart(2, "div", 4);
          \u0275\u0275conditionalCreate(3, ThySelectControl_Conditional_3_Template, 2, 2, "div", 5);
          \u0275\u0275conditionalCreate(4, ThySelectControl_Conditional_4_Template, 7, 3, "div", 6)(5, ThySelectControl_Conditional_5_Template, 3, 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "span", 7);
          \u0275\u0275element(7, "thy-icon", 8);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(8, ThySelectControl_Conditional_8_Template, 2, 0, "span", 9);
          \u0275\u0275template(9, ThySelectControl_ng_template_9_Template, 3, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          \u0275\u0275advance(3);
          \u0275\u0275conditional(!ctx.isSelectedValue() ? 3 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyIsMultiple() ? 4 : 5);
          \u0275\u0275advance(4);
          \u0275\u0275conditional(ctx.showClearIcon() ? 8 : -1);
        }
      },
      dependencies: [FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NgClass, NgStyle, ThyTag, NgTemplateOutlet, ThyIcon, ThyGridModule, ThyFlex, ThyFlexItem, ThyTooltipDirective, ThyFlexibleText],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySelectControl, [{
    type: Component,
    args: [{
      selector: "thy-select-control,[thySelectControl]",
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [FormsModule, NgClass, NgStyle, ThyTag, NgTemplateOutlet, ThyIcon, ThyGridModule, ThyTooltipDirective, ThyFlexibleText],
      host: {
        "[class.select-control-borderless]": "thyBorderless()"
      },
      template: `<ng-template #inputTemplate>
  <input
    #inputElement
    [tabindex]="-1"
    (compositionstart)="compositionChange(true)"
    (compositionend)="compositionChange(false)"
    autocomplete="something-new"
    [ngClass]="searchInputControlClass"
    (input)="updateWidth()"
    [ngModel]="inputValue()"
    (ngModelChange)="setInputValue($event)"
    (keydown.backspace)="handleBackspace($event)"
    [disabled]="thyDisabled()"
    (blur)="onBlur($event)" />
</ng-template>

<div class="select-control-rendered">
  @if (!isSelectedValue()) {
    <div class="text-placeholder text-truncate" [ngStyle]="placeholderStyle()">
      {{ thyPlaceholder() }}
    </div>
  }
  @if (thyIsMultiple()) {
    <div thyFlex thyWrap="wrap" thyGap="4" thyAlignItems="center" class="w-100" #tagsContainer>
      @if (thyPreset() === 'tag') {
        @for (item of selectedTags(); track trackValue($index, item)) {
          <div thyFlexItem class="custom-choice-item text-truncate" [ngClass]="{ hidden: $index > visibleTagCount() - 1 }">
            <ng-template
              [ngTemplateOutlet]="customDisplayTemplate()"
              [ngTemplateOutletContext]="{ $implicit: item.thyRawValue || item.thyValue || item }">
            </ng-template>
            @if (!thyDisabled()) {
              <div class="choice-remove-link ml-1" (click)="removeHandle(item, $event)">
                <span>
                  <thy-icon thyIconName="close" class="font-size-sm"></thy-icon>
                </span>
              </div>
            }
          </div>
        }
      } @else {
        @for (item of selectedTags(); track trackValue($index, item)) {
          <div
            thyFlexItem
            thyTag
            class="choice-item selected"
            [ngClass]="{ disabled: thyDisabled() === true, hidden: $index > visibleTagCount() - 1 }"
            [thySize]="tagSize()">
            <div class="text-truncate h-100 d-flex align-items-center">
              @if (!customDisplayTemplate()) {
                <thy-flexible-text [thyTooltipContent]="item?.thyLabelText" class="text-truncate h-100">
                  {{ item?.thyLabelText }}
                </thy-flexible-text>
              } @else {
                <ng-template
                  [ngTemplateOutlet]="customDisplayTemplate()"
                  [ngTemplateOutletContext]="{ $implicit: item.thyRawValue || item.thyValue || item }"></ng-template>
              }
            </div>
            @if (!thyDisabled()) {
              <div class="choice-remove-link ml-1" (click)="removeHandle(item, $event)">
                <span>
                  <thy-icon thyIconName="close" class="font-size-sm"></thy-icon>
                </span>
              </div>
            }
          </div>
        }
      }
      @if (collapsedSelectedTags()?.length > 0) {
        <div
          thyFlexItem
          class="choice-item max-tag-count-choice"
          thyTag
          [thySize]="tagSize()"
          [ngClass]="{ disabled: thyDisabled() === true }"
          [thyTooltip]="maxTagTooltip">
          <div class="text-truncate">+{{ collapsedSelectedTags()?.length }}</div>
        </div>
      }
      <div thyFlexItem class="select-control-search">
        <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template>
      </div>
    </div>
  } @else {
    @if (isSelectedValue()) {
      <div class="selected-value text-truncate" [ngStyle]="selectedValueStyle()">
        @if (!customDisplayTemplate()) {
          <span class="text-truncate">{{ thySelectedOptions()?.thyLabelText }}</span>
        } @else {
          <ng-template
            [ngTemplateOutlet]="customDisplayTemplate()"
            [ngTemplateOutletContext]="{
              $implicit: thySelectedOptions()?.thyRawValue || thySelectedOptions()?.thyValue || thySelectedOptions()
            }"></ng-template>
        }
      </div>
    }
    <div class="select-control-search">
      <ng-template [ngTemplateOutlet]="inputTemplate"></ng-template>
    </div>
  }
</div>
<span class="select-control-arrow">
  <thy-icon thyIconName="angle-down" class="font-size-base"></thy-icon>
</span>
@if (showClearIcon()) {
  <span class="select-control-clear remove-link" (click)="clearHandle($event)">
    <thy-icon class="remove-link-icon font-size-base" thyIconName="close-circle-bold-fill"></thy-icon>
  </span>
}

<ng-template #maxTagTooltip>
  @let lastIndex = collapsedSelectedTags().length - 1;
  @for (item of collapsedSelectedTags(); track trackValue($index, item)) {
    {{ item.thyLabelText }}
    @if ($index !== lastIndex) {
      {{ locale().comma }}
    }
  }
</ng-template>
`
    }]
  }], () => [], {
    inputValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "inputValue",
        required: false
      }]
    }, {
      type: Output,
      args: ["inputValueChange"]
    }],
    thyPanelOpened: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPanelOpened",
        required: false
      }]
    }],
    thyIsMultiple: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIsMultiple",
        required: false
      }]
    }],
    thyShowSearch: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowSearch",
        required: false
      }]
    }],
    thySelectedOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySelectedOptions",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    customDisplayTemplate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "customDisplayTemplate",
        required: false
      }]
    }],
    thyAllowClear: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAllowClear",
        required: false
      }]
    }],
    thyPlaceholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlaceholder",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyMaxTagCount: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMaxTagCount",
        required: false
      }]
    }],
    thyBorderless: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyBorderless",
        required: false
      }]
    }],
    thyPreset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPreset",
        required: false
      }]
    }],
    thyOnSearch: [{
      type: Output,
      args: ["thyOnSearch"]
    }],
    thyOnRemove: [{
      type: Output,
      args: ["thyOnRemove"]
    }],
    thyOnClear: [{
      type: Output,
      args: ["thyOnClear"]
    }],
    thyOnBlur: [{
      type: Output,
      args: ["thyOnBlur"]
    }],
    inputElement: [{
      type: ViewChild,
      args: ["inputElement", {
        isSignal: true
      }]
    }],
    tagsContainer: [{
      type: ViewChild,
      args: ["tagsContainer", {
        isSignal: true
      }]
    }]
  });
})();
var ThySelectCommonModule = class _ThySelectCommonModule {
  static {
    this.\u0275fac = function ThySelectCommonModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySelectCommonModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThySelectCommonModule,
      imports: [CommonModule, FormsModule, ThyIconModule, ThyTagModule, ThySelectControl],
      exports: [ThySelectControl]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, FormsModule, ThyIconModule, ThyTagModule, ThySelectControl]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySelectCommonModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ThyIconModule, ThyTagModule, ThySelectControl],
      exports: [ThySelectControl]
    }]
  }], null, null);
})();
var THY_LIST_OPTION_PARENT_COMPONENT = new InjectionToken("THY_LIST_OPTION_PARENT_COMPONENT");
var _uniqueIdCounter = 0;
var ThyListOption = class _ThyListOption {
  constructor() {
    this.element = inject(ElementRef);
    this.parentSelectionList = inject(THY_LIST_OPTION_PARENT_COMPONENT, {
      optional: true
    });
    this.role = "option";
    this.tabIndex = -1;
    this.isMultiple = computed(() => (this.parentSelectionList?.multiple && this.parentSelectionList.multiple()) ?? false, ...ngDevMode ? [{
      debugName: "isMultiple"
    }] : []);
    this.isListOption = computed(() => this.parentSelectionList?.layout && this.parentSelectionList?.layout() === "list", ...ngDevMode ? [{
      debugName: "isListOption"
    }] : []);
    this.isGridOption = computed(() => this.parentSelectionList?.layout && this.parentSelectionList?.layout() === "grid", ...ngDevMode ? [{
      debugName: "isGridOption"
    }] : []);
    this.id = input(`thy-list-option-${_uniqueIdCounter++}`, ...ngDevMode ? [{
      debugName: "id"
    }] : []);
    this.thyValue = input(void 0, ...ngDevMode ? [{
      debugName: "thyValue"
    }] : []);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  /** Whether the option is selected. */
  get selected() {
    return this.parentSelectionList.isSelected(this);
  }
  onClick(event) {
    if (this.parentSelectionList.multiple && this.parentSelectionList.multiple() || !this.parentSelectionList.isSelected(this)) {
      this.parentSelectionList.toggleOption(this, event);
      this.parentSelectionList.setActiveOption(this);
    }
  }
  setActiveStyles() {
    this.element.nativeElement.classList.add("hover");
    this.parentSelectionList.scrollIntoView(this);
  }
  setInactiveStyles() {
    this.element.nativeElement.classList.remove("hover");
  }
  /**
   * Returns the list item's text label. Implemented as a part of the FocusKeyManager.
   * @docs-private
   */
  getLabel() {
    return "";
  }
  static {
    this.\u0275fac = function ThyListOption_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyListOption)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyListOption,
      selectors: [["thy-list-option"], ["", "thy-list-option", ""]],
      hostVars: 10,
      hostBindings: function ThyListOption_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("click", function ThyListOption_click_HostBindingHandler($event) {
            return ctx.onClick($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275attribute("role", ctx.role)("tabindex", ctx.tabIndex);
          \u0275\u0275classProp("disabled", ctx.thyDisabled())("thy-list-option", ctx.isListOption())("thy-grid-option", ctx.isGridOption())("active", ctx.selected);
        }
      },
      inputs: {
        id: [1, "id"],
        thyValue: [1, "thyValue"],
        thyDisabled: [1, "thyDisabled"]
      },
      ngContentSelectors: _c62,
      decls: 3,
      vars: 2,
      consts: [[1, "checked-icon"], ["thyIconName", "check"], ["thyIconName", "check-circle-fill"]],
      template: function ThyListOption_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
          \u0275\u0275conditionalCreate(1, ThyListOption_Conditional_1_Template, 2, 0, "span", 0);
          \u0275\u0275conditionalCreate(2, ThyListOption_Conditional_2_Template, 2, 0, "span", 0);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.isMultiple() && ctx.isListOption() ? 1 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.isGridOption() ? 2 : -1);
        }
      },
      dependencies: [ThyIcon],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyListOption, [{
    type: Component,
    args: [{
      selector: "thy-list-option,[thy-list-option]",
      imports: [ThyIcon],
      host: {
        "[class.disabled]": "thyDisabled()",
        "[class.thy-list-option]": "isListOption()",
        "[class.thy-grid-option]": "isGridOption()",
        "[class.active]": "selected",
        "[attr.role]": "role",
        "[attr.tabindex]": "tabIndex"
      },
      template: '<ng-content></ng-content>\n@if (isMultiple() && isListOption()) {\n  <span class="checked-icon">\n    <thy-icon thyIconName="check"></thy-icon>\n  </span>\n}\n@if (isGridOption()) {\n  <span class="checked-icon">\n    <thy-icon thyIconName="check-circle-fill"></thy-icon>\n  </span>\n}\n'
    }]
  }], null, {
    id: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "id",
        required: false
      }]
    }],
    thyValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyValue",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    onClick: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var _MixinBase = mixinDisabled(MixinBase);
var ThyOptionGroup = class _ThyOptionGroup extends _MixinBase {
  set thyDisabled(value) {
    this.thyDisabled = value;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyOptionGroup_BaseFactory;
      return function ThyOptionGroup_Factory(__ngFactoryType__) {
        return (\u0275ThyOptionGroup_BaseFactory || (\u0275ThyOptionGroup_BaseFactory = \u0275\u0275getInheritedFactory(_ThyOptionGroup)))(__ngFactoryType__ || _ThyOptionGroup);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyOptionGroup,
      selectors: [["thy-list-option-group"], ["", "thy-list-option-group", ""]],
      features: [\u0275\u0275InheritDefinitionFeature],
      ngContentSelectors: _c62,
      decls: 1,
      vars: 0,
      template: function ThyOptionGroup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyOptionGroup, [{
    type: Component,
    args: [{
      selector: "thy-list-option-group,[thy-list-option-group]",
      template: "<ng-content></ng-content>",
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, null);
})();
var ThySelectOptionGroup = class _ThySelectOptionGroup {
  constructor() {
    this.thyGroupLabel = input(...ngDevMode ? [void 0, {
      debugName: "thyGroupLabel"
    }] : []);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThySelectOptionGroup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySelectOptionGroup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySelectOptionGroup,
      selectors: [["thy-option-group"]],
      inputs: {
        thyGroupLabel: [1, "thyGroupLabel"],
        thyDisabled: [1, "thyDisabled"]
      },
      ngContentSelectors: _c62,
      decls: 1,
      vars: 0,
      template: function ThySelectOptionGroup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySelectOptionGroup, [{
    type: Component,
    args: [{
      selector: "thy-option-group",
      template: `<ng-content></ng-content>`
    }]
  }], null, {
    thyGroupLabel: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGroupLabel",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }]
  });
})();
var ThyOption = class _ThyOption {
  constructor() {
    this.thyValue = input(...ngDevMode ? [void 0, {
      debugName: "thyValue"
    }] : []);
    this.thyRawValue = input(...ngDevMode ? [void 0, {
      debugName: "thyRawValue"
    }] : []);
    this.thyLabelText = input(...ngDevMode ? [void 0, {
      debugName: "thyLabelText"
    }] : []);
    this.thyShowOptionCustom = input(...ngDevMode ? [void 0, {
      debugName: "thyShowOptionCustom"
    }] : []);
    this.thySearchKey = input(...ngDevMode ? [void 0, {
      debugName: "thySearchKey"
    }] : []);
    this.thyDisabled = input(...ngDevMode ? [void 0, {
      debugName: "thyDisabled"
    }] : []);
    this.selected = signal(false, ...ngDevMode ? [{
      debugName: "selected"
    }] : []);
    this.selectionChange = output();
    this.template = viewChild(TemplateRef, ...ngDevMode ? [{
      debugName: "template"
    }] : []);
    this.suffixTemplate = contentChild("suffixTemplate", ...ngDevMode ? [{
      debugName: "suffixTemplate"
    }] : []);
    this.optionGroupComponent = inject(ThySelectOptionGroup, {
      optional: true
    });
  }
  get groupLabel() {
    return this.optionGroupComponent?.thyGroupLabel() || "";
  }
  static {
    this.\u0275fac = function ThyOption_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyOption)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyOption,
      selectors: [["thy-option"]],
      contentQueries: function ThyOption_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.suffixTemplate, _c7, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      viewQuery: function ThyOption_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.template, TemplateRef, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      inputs: {
        thyValue: [1, "thyValue"],
        thyRawValue: [1, "thyRawValue"],
        thyLabelText: [1, "thyLabelText"],
        thyShowOptionCustom: [1, "thyShowOptionCustom"],
        thySearchKey: [1, "thySearchKey"],
        thyDisabled: [1, "thyDisabled"]
      },
      outputs: {
        selectionChange: "selectionChange"
      },
      ngContentSelectors: _c62,
      decls: 1,
      vars: 0,
      template: function ThyOption_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275domTemplate(0, ThyOption_ng_template_0_Template, 1, 0, "ng-template");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyOption, [{
    type: Component,
    args: [{
      selector: "thy-option",
      template: `
        <ng-template>
            <ng-content></ng-content>
        </ng-template>
    `,
      changeDetection: ChangeDetectionStrategy.OnPush
    }]
  }], null, {
    thyValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyValue",
        required: false
      }]
    }],
    thyRawValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyRawValue",
        required: false
      }]
    }],
    thyLabelText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLabelText",
        required: false
      }]
    }],
    thyShowOptionCustom: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowOptionCustom",
        required: false
      }]
    }],
    thySearchKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySearchKey",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    selectionChange: [{
      type: Output,
      args: ["selectionChange"]
    }],
    template: [{
      type: ViewChild,
      args: [forwardRef(() => TemplateRef), {
        isSignal: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: ["suffixTemplate", {
        isSignal: true
      }]
    }]
  });
})();
var ThyOptionRender = class _ThyOptionRender {
  constructor() {
    this.element = inject(ElementRef);
    this.hostRenderer = useHostRenderer();
    this.thyValue = input(...ngDevMode ? [void 0, {
      debugName: "thyValue"
    }] : []);
    this.thyRawValue = input(...ngDevMode ? [void 0, {
      debugName: "thyRawValue"
    }] : []);
    this.thyLabelText = input(...ngDevMode ? [void 0, {
      debugName: "thyLabelText"
    }] : []);
    this.thySearchKey = input(...ngDevMode ? [void 0, {
      debugName: "thySearchKey"
    }] : []);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyShowOptionCustom = input(false, ...ngDevMode ? [{
      debugName: "thyShowOptionCustom",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyTemplate = input(...ngDevMode ? [void 0, {
      debugName: "thyTemplate"
    }] : []);
    this.thyTemplateContext = input(...ngDevMode ? [void 0, {
      debugName: "thyTemplateContext"
    }] : []);
    this.thyShowCheckedIcon = input(false, ...ngDevMode ? [{
      debugName: "thyShowCheckedIcon",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thySelectedValuesMap = input(/* @__PURE__ */ new Map(), ...ngDevMode ? [{
      debugName: "thySelectedValuesMap"
    }] : []);
    this.thyActivatedValue = input(...ngDevMode ? [void 0, {
      debugName: "thyActivatedValue"
    }] : []);
    this.optionClick = output();
    this.optionHover = output();
    this.selected = computed(() => {
      return this.thySelectedValuesMap().has(this.thyValue());
    }, ...ngDevMode ? [{
      debugName: "selected"
    }] : []);
    this.activated = computed(() => {
      return this.thyActivatedValue() === this.thyValue();
    }, ...ngDevMode ? [{
      debugName: "activated"
    }] : []);
    this.tabIndex = computed(() => {
      return this.thyDisabled() ? "-1" : "0";
    }, ...ngDevMode ? [{
      debugName: "tabIndex"
    }] : []);
    effect(() => {
      this.activated() ? this.setActiveStyles() : this.setInactiveStyles();
    });
  }
  mouseEnter() {
    this.optionHover.emit(this.thyValue());
  }
  handleKeydown(event) {
    if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {
      this.selectViaInteraction();
      event.preventDefault();
    }
  }
  selectViaInteraction() {
    if (!this.thyDisabled()) {
      this.optionClick.emit({
        value: this.thyValue(),
        isUserInput: true
      });
    }
  }
  select() {
    if (!this.thyDisabled()) {
      if (!this.selected()) {
        this.optionClick.emit({
          value: this.thyValue()
        });
      }
    }
  }
  deselect() {
    if (this.selected() || this.thyDisabled()) {
      this.optionClick.emit({
        value: this.thyValue()
      });
    }
  }
  setActiveStyles() {
    this.hostRenderer.addClass("hover");
  }
  setInactiveStyles() {
    this.hostRenderer.removeClass("hover");
  }
  static {
    this.\u0275fac = function ThyOptionRender_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyOptionRender)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyOptionRender,
      selectors: [["thy-option-render"]],
      hostAttrs: [1, "thy-option-item"],
      hostVars: 5,
      hostBindings: function ThyOptionRender_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("click", function ThyOptionRender_click_HostBindingHandler() {
            return ctx.selectViaInteraction();
          })("mouseenter", function ThyOptionRender_mouseenter_HostBindingHandler() {
            return ctx.mouseEnter();
          })("keydown", function ThyOptionRender_keydown_HostBindingHandler($event) {
            return ctx.handleKeydown($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275attribute("tabindex", ctx.tabIndex());
          \u0275\u0275classProp("disabled", ctx.thyDisabled())("active", ctx.selected());
        }
      },
      inputs: {
        thyValue: [1, "thyValue"],
        thyRawValue: [1, "thyRawValue"],
        thyLabelText: [1, "thyLabelText"],
        thySearchKey: [1, "thySearchKey"],
        thyDisabled: [1, "thyDisabled"],
        thyShowOptionCustom: [1, "thyShowOptionCustom"],
        thyTemplate: [1, "thyTemplate"],
        thyTemplateContext: [1, "thyTemplateContext"],
        thyShowCheckedIcon: [1, "thyShowCheckedIcon"],
        thySelectedValuesMap: [1, "thySelectedValuesMap"],
        thyActivatedValue: [1, "thyActivatedValue"]
      },
      outputs: {
        optionClick: "optionClick",
        optionHover: "optionHover"
      },
      decls: 3,
      vars: 2,
      consts: [[1, "text-truncate"], ["thyIconName", "check", 1, "checked-icon"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"]],
      template: function ThyOptionRender_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ThyOptionRender_Conditional_0_Template, 1, 2, "ng-container")(1, ThyOptionRender_Conditional_1_Template, 2, 1, "span", 0);
          \u0275\u0275conditionalCreate(2, ThyOptionRender_Conditional_2_Template, 1, 0, "thy-icon", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.thyShowOptionCustom() ? 0 : 1);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.thyShowCheckedIcon() && ctx.selected() ? 2 : -1);
        }
      },
      dependencies: [ThyIcon, NgTemplateOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyOptionRender, [{
    type: Component,
    args: [{
      selector: "thy-option-render",
      imports: [ThyIcon, NgTemplateOutlet],
      host: {
        class: "thy-option-item",
        "[class.disabled]": "thyDisabled()",
        "[attr.tabindex]": `tabIndex()`,
        "[class.active]": "selected()",
        "(click)": "selectViaInteraction()",
        "(mouseenter)": "mouseEnter()",
        "(keydown)": "handleKeydown($event)"
      },
      template: '@if (thyShowOptionCustom()) {\n  <ng-container *ngTemplateOutlet="thyTemplate(); context: thyTemplateContext()"></ng-container>\n} @else {\n  <span class="text-truncate">{{ thyLabelText() }}</span>\n}\n@if (thyShowCheckedIcon() && selected()) {\n  <thy-icon class="checked-icon" thyIconName="check"></thy-icon>\n}\n'
    }]
  }], () => [], {
    thyValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyValue",
        required: false
      }]
    }],
    thyRawValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyRawValue",
        required: false
      }]
    }],
    thyLabelText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLabelText",
        required: false
      }]
    }],
    thySearchKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySearchKey",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    thyShowOptionCustom: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowOptionCustom",
        required: false
      }]
    }],
    thyTemplate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTemplate",
        required: false
      }]
    }],
    thyTemplateContext: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTemplateContext",
        required: false
      }]
    }],
    thyShowCheckedIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowCheckedIcon",
        required: false
      }]
    }],
    thySelectedValuesMap: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySelectedValuesMap",
        required: false
      }]
    }],
    thyActivatedValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyActivatedValue",
        required: false
      }]
    }],
    optionClick: [{
      type: Output,
      args: ["optionClick"]
    }],
    optionHover: [{
      type: Output,
      args: ["optionHover"]
    }]
  });
})();
var ThyOptionGroupRender = class _ThyOptionGroupRender {
  constructor() {
    this.thyGroupLabel = input(void 0, ...ngDevMode ? [{
      debugName: "thyGroupLabel"
    }] : []);
    this.thyDisabled = input(false, ...ngDevMode ? [{
      debugName: "thyDisabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = function ThyOptionGroupRender_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyOptionGroupRender)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyOptionGroupRender,
      selectors: [["thy-option-group-render"]],
      hostAttrs: [1, "thy-option-group-render"],
      hostVars: 2,
      hostBindings: function ThyOptionGroupRender_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("disabled", ctx.thyDisabled());
        }
      },
      inputs: {
        thyGroupLabel: [1, "thyGroupLabel"],
        thyDisabled: [1, "thyDisabled"]
      },
      decls: 2,
      vars: 1,
      consts: [[1, "group-name", "text-truncate"]],
      template: function ThyOptionGroupRender_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275domElementStart(0, "span", 0);
          \u0275\u0275text(1);
          \u0275\u0275domElementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275textInterpolate(ctx.thyGroupLabel());
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyOptionGroupRender, [{
    type: Component,
    args: [{
      selector: "thy-option-group-render",
      template: `<span class="group-name text-truncate">{{ thyGroupLabel() }}</span>`,
      host: {
        class: "thy-option-group-render",
        "[class.disabled]": "thyDisabled()"
      }
    }]
  }], null, {
    thyGroupLabel: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyGroupLabel",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }]
  });
})();
var ThyOptionModule = class _ThyOptionModule {
  static {
    this.\u0275fac = function ThyOptionModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyOptionModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyOptionModule,
      imports: [CommonModule, ThyIconModule, ThyListOption, ThyOptionGroup, ThyOption, ThyOptionRender, ThySelectOptionGroup, ThyOptionGroupRender],
      exports: [ThyListOption, ThyOptionGroup, ThyOption, ThyOptionRender, ThySelectOptionGroup, ThyOptionGroupRender]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThyIconModule, ThyListOption, ThyOptionRender]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyOptionModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThyIconModule, ThyListOption, ThyOptionGroup, ThyOption, ThyOptionRender, ThySelectOptionGroup, ThyOptionGroupRender],
      exports: [ThyListOption, ThyOptionGroup, ThyOption, ThyOptionRender, ThySelectOptionGroup, ThyOptionGroupRender]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-checkbox.mjs
var _c013 = ["*"];
var _c16 = (a0, a1) => ({
  "form-check-indeterminate": a0,
  "form-check-no-label-text": a1
});
function ThyCheckbox_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 1);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0._labelText());
  }
}
var ThyCheckbox = class _ThyCheckbox extends ThyFormCheckBaseComponent {
  constructor() {
    super(...arguments);
    this.thyIndeterminate = input(false, ...ngDevMode ? [{
      debugName: "thyIndeterminate",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyCheckbox_BaseFactory;
      return function ThyCheckbox_Factory(__ngFactoryType__) {
        return (\u0275ThyCheckbox_BaseFactory || (\u0275ThyCheckbox_BaseFactory = \u0275\u0275getInheritedFactory(_ThyCheckbox)))(__ngFactoryType__ || _ThyCheckbox);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyCheckbox,
      selectors: [["thy-checkbox"], ["", "thy-checkbox", ""], ["", "thyCheckbox", ""]],
      hostAttrs: [1, "thy-checkbox"],
      hostVars: 3,
      hostBindings: function ThyCheckbox_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("tabindex", -1);
          \u0275\u0275classProp("disabled", ctx._disabled);
        }
      },
      inputs: {
        thyIndeterminate: [1, "thyIndeterminate"]
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _ThyCheckbox),
        multi: true
      }]), \u0275\u0275InheritDefinitionFeature],
      ngContentSelectors: _c013,
      decls: 3,
      vars: 8,
      consts: [["type", "checkbox", 1, "form-check-input", 3, "change", "ngClass", "checked", "disabled"], [1, "form-check-label"]],
      template: function ThyCheckbox_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275elementStart(0, "input", 0);
          \u0275\u0275listener("change", function ThyCheckbox_Template_input_change_0_listener() {
            return ctx.change();
          });
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(1, ThyCheckbox_Conditional_1_Template, 2, 1, "span", 1);
          \u0275\u0275projection(2);
        }
        if (rf & 2) {
          \u0275\u0275property("ngClass", \u0275\u0275pureFunction2(5, _c16, ctx.thyIndeterminate(), !ctx._labelText()))("checked", ctx._innerValue)("disabled", ctx._disabled);
          \u0275\u0275attribute("tabindex", ctx.tabIndex);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx._labelText() ? 1 : -1);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyCheckbox, [{
    type: Component,
    args: [{
      selector: "thy-checkbox,[thy-checkbox],[thyCheckbox]",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ThyCheckbox),
        multi: true
      }],
      host: {
        "[attr.tabindex]": "-1",
        class: "thy-checkbox",
        "[class.disabled]": "_disabled"
      },
      imports: [NgClass],
      template: `<input
  class="form-check-input"
  [ngClass]="{ 'form-check-indeterminate': thyIndeterminate(), 'form-check-no-label-text': !_labelText() }"
  [checked]="_innerValue"
  (change)="change()"
  type="checkbox"
  [attr.tabindex]="tabIndex"
  [disabled]="_disabled" />
@if (_labelText()) {
  <span class="form-check-label">{{ _labelText() }}</span>
}
<ng-content></ng-content>
`
    }]
  }], null, {
    thyIndeterminate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIndeterminate",
        required: false
      }]
    }]
  });
})();
var ThyCheckboxModule = class _ThyCheckboxModule {
  static {
    this.\u0275fac = function ThyCheckboxModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyCheckboxModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyCheckboxModule,
      imports: [CommonModule, FormsModule, ThyCheckbox],
      exports: [ThyCheckbox]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, FormsModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyCheckboxModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ThyCheckbox],
      exports: [ThyCheckbox]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-switch.mjs
var _c014 = ["switch"];
function ThySwitch_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg");
    \u0275\u0275element(1, "circle", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const circleConfig_r3 = ctx_r1.loadingCircle();
    \u0275\u0275classProp("mb-1", ctx_r1.size() === "xs");
    \u0275\u0275attribute("viewBox", circleConfig_r3 == null ? null : circleConfig_r3.viewBox);
    \u0275\u0275advance();
    \u0275\u0275styleProp("transform-origin", (circleConfig_r3 == null ? null : circleConfig_r3.cx) + "px " + (circleConfig_r3 == null ? null : circleConfig_r3.cy) + "px");
    \u0275\u0275attribute("cx", circleConfig_r3 == null ? null : circleConfig_r3.cx)("cy", circleConfig_r3 == null ? null : circleConfig_r3.cy)("r", circleConfig_r3 == null ? null : circleConfig_r3.r)("stroke", ctx_r1.model() ? "rgba(102,152,255,1)" : "rgba(202,202,202,1)")("stroke-dasharray", circleConfig_r3 == null ? null : circleConfig_r3.dasharray);
  }
}
var supportedTypes = ["primary", "info", "warning", "danger"];
var supportedSizes = ["", "sm", "xs"];
var ThySwitch = class _ThySwitch extends TabIndexDisabledControlValueAccessorMixin {
  get thyDisabled() {
    return this.disabled();
  }
  constructor() {
    super();
    this.thyType = input("primary", ...ngDevMode ? [{
      debugName: "thyType"
    }] : []);
    this.thySize = input("", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.inputDisabled = input(false, ...ngDevMode ? [{
      debugName: "inputDisabled",
      transform: coerceBooleanProperty2,
      alias: `thyDisabled`
    }] : [{
      transform: coerceBooleanProperty2,
      alias: `thyDisabled`
    }]);
    this.thyLoading = input(false, ...ngDevMode ? [{
      debugName: "thyLoading",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyChange = output();
    this.model = signal(false, ...ngDevMode ? [{
      debugName: "model"
    }] : []);
    this.disabled = signal(false, ...ngDevMode ? [{
      debugName: "disabled"
    }] : []);
    this.type = computed(() => {
      if (!supportedTypes.includes(this.thyType())) {
        return "primary";
      } else {
        return this.thyType();
      }
    }, ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    this.size = computed(() => {
      if (!supportedSizes.includes(this.thySize())) {
        return "";
      } else {
        return this.thySize();
      }
    }, ...ngDevMode ? [{
      debugName: "size"
    }] : []);
    this.classNames = computed(() => {
      const classList = [`thy-switch-${this.type()}`];
      if (this.size()) {
        classList.push(`thy-switch-${this.size()}`);
      }
      if (this.disabled() || this.thyLoading()) {
        classList.push(`thy-switch-disabled`);
        if (this.model()) {
          classList.push(`thy-switch-disabled-true`);
        }
      }
      return classList;
    }, ...ngDevMode ? [{
      debugName: "classNames"
    }] : []);
    this.loadingCircle = computed(() => {
      const svgSize = {
        xs: 12,
        sm: 16
      };
      const circleSize = svgSize[this.size()] ?? 20;
      const centerPoint = circleSize / 2;
      const r = circleSize / 4;
      return {
        viewBox: `0 0 ${circleSize} ${circleSize}`,
        cx: centerPoint,
        cy: centerPoint,
        r,
        dasharray: `${2 * Math.PI * r * 0.75} ${2 * Math.PI * r * 0.25}`
      };
    }, ...ngDevMode ? [{
      debugName: "loadingCircle"
    }] : []);
    this.onModelChange = () => {
    };
    this.onModelTouched = () => {
    };
    this.switchElementRef = viewChild("switch", ...ngDevMode ? [{
      debugName: "switchElementRef",
      read: ElementRef
    }] : [{
      read: ElementRef
    }]);
    this.cdr = inject(ChangeDetectorRef);
    effect(() => {
      this.disabled.set(this.inputDisabled());
    });
  }
  writeValue(value) {
    this.model.set(value);
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onModelChange = fn;
  }
  registerOnTouched(fn) {
    this.onModelTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled.set(isDisabled);
  }
  toggle(event) {
    this.model.set(!this.model());
    this.onModelChange(this.model());
    this.onModelTouched();
    this.thyChange?.emit(event);
  }
  static {
    this.\u0275fac = function ThySwitch_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySwitch)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThySwitch,
      selectors: [["thy-switch"]],
      viewQuery: function ThySwitch_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.switchElementRef, _c014, 5, ElementRef);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: [1, "thy-switch"],
      hostVars: 4,
      hostBindings: function ThySwitch_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-switch-xs", ctx.size() === "xs")("thy-switch-sm", ctx.size() === "sm");
        }
      },
      inputs: {
        thyType: [1, "thyType"],
        thySize: [1, "thySize"],
        inputDisabled: [1, "thyDisabled", "inputDisabled"],
        thyLoading: [1, "thyLoading"]
      },
      outputs: {
        thyChange: "thyChange"
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => _ThySwitch),
        multi: true
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 6,
      vars: 6,
      consts: [["switch", ""], [1, "thy-switch", 3, "ngClass"], ["type", "checkbox", 1, "thy-switch-input", 3, "change", "disabled", "checked"], [1, "thy-switch-label"], [1, "thy-switch-handle"], [3, "mb-1"], ["stroke-width", "1", "fill", "white", 1, "thy-switch-loading"]],
      template: function ThySwitch_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "label", 1, 0)(2, "input", 2);
          \u0275\u0275listener("change", function ThySwitch_Template_input_change_2_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.toggle($event));
          });
          \u0275\u0275elementEnd();
          \u0275\u0275element(3, "span", 3);
          \u0275\u0275elementStart(4, "span", 4);
          \u0275\u0275conditionalCreate(5, ThySwitch_Conditional_5_Template, 2, 10, ":svg:svg", 5);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275property("ngClass", ctx.classNames());
          \u0275\u0275advance(2);
          \u0275\u0275property("disabled", ctx.disabled() || ctx.thyLoading())("checked", ctx.model());
          \u0275\u0275attribute("tabindex", -1);
          \u0275\u0275advance();
          \u0275\u0275attribute("tabindex", ctx.tabIndex);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.thyLoading() ? 5 : -1);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySwitch, [{
    type: Component,
    args: [{
      selector: "thy-switch",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => ThySwitch),
        multi: true
      }],
      imports: [NgClass],
      host: {
        class: "thy-switch",
        "[class.thy-switch-xs]": 'size() === "xs"',
        "[class.thy-switch-sm]": 'size() === "sm"'
      },
      template: `<label #switch class="thy-switch" [ngClass]="classNames()">
  <input
    type="checkbox"
    [attr.tabindex]="-1"
    [disabled]="disabled() || thyLoading()"
    class="thy-switch-input"
    [checked]="model()"
    (change)="toggle($event)" />
  <span class="thy-switch-label" [attr.tabindex]="tabIndex"></span>
  <span class="thy-switch-handle">
    @if (thyLoading()) {
      @let circleConfig = loadingCircle();
      <svg [attr.viewBox]="circleConfig?.viewBox" [class.mb-1]="size() === 'xs'">
        <circle
          class="thy-switch-loading"
          [style.transform-origin]="circleConfig?.cx + 'px ' + circleConfig?.cy + 'px'"
          [attr.cx]="circleConfig?.cx"
          [attr.cy]="circleConfig?.cy"
          [attr.r]="circleConfig?.r"
          [attr.stroke]="model() ? 'rgba(102,152,255,1)' : 'rgba(202,202,202,1)'"
          stroke-width="1"
          [attr.stroke-dasharray]="circleConfig?.dasharray"
          fill="white" />
      </svg>
    }
  </span>
</label>
`
    }]
  }], () => [], {
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    inputDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }],
    thyLoading: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLoading",
        required: false
      }]
    }],
    thyChange: [{
      type: Output,
      args: ["thyChange"]
    }],
    switchElementRef: [{
      type: ViewChild,
      args: ["switch", __spreadProps(__spreadValues({}, {
        read: ElementRef
      }), {
        isSignal: true
      })]
    }]
  });
})();
var ThySwitchModule = class _ThySwitchModule {
  static {
    this.\u0275fac = function ThySwitchModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThySwitchModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThySwitchModule,
      imports: [CommonModule, ThySwitch],
      exports: [ThySwitch]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThySwitchModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThySwitch],
      exports: [ThySwitch]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-message.mjs
function ThyMessage_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("thyIconName", ctx_r0.iconName);
  }
}
function ThyMessage_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "span", 1);
  }
}
function ThyMessage_ng_container_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyMessage_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-icon", 5);
    \u0275\u0275listener("click", function ThyMessage_Conditional_4_Template_thy_icon_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.close());
    });
    \u0275\u0275elementEnd();
  }
}
var _forTrack0 = ($index, $item) => $item.id;
function ThyMessageContainer_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-message", 0);
  }
  if (rf & 2) {
    const message_r1 = ctx.$implicit;
    \u0275\u0275property("thyConfig", message_r1.config);
  }
}
var ThyAbstractMessageContainerComponent = class _ThyAbstractMessageContainerComponent {
  constructor() {
    this.elementRef = inject(ElementRef);
  }
  get offset() {
    return coerceCssPixelValue2(this.defaultConfig.offset);
  }
  toOverlayTop() {
    const globalOverlayWrapper = this.elementRef.nativeElement.closest(".cdk-global-overlay-wrapper");
    const overlayContainer = globalOverlayWrapper.parentElement;
    overlayContainer.appendChild(globalOverlayWrapper);
  }
  static {
    this.\u0275fac = function ThyAbstractMessageContainerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyAbstractMessageContainerComponent)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyAbstractMessageContainerComponent,
      hostVars: 2,
      hostBindings: function ThyAbstractMessageContainerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275styleProp("top", ctx.offset);
        }
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyAbstractMessageContainerComponent, [{
    type: Directive
  }], null, {
    offset: [{
      type: HostBinding,
      args: ["style.top"]
    }]
  });
})();
var ThyAbstractMessageQueue = class {
  setQueues(newValue) {
    this.queues.set(newValue);
  }
  constructor(defaultConfig2) {
    this.queues = signal([], ...ngDevMode ? [{
      debugName: "queues"
    }] : []);
    this.defaultConfig = defaultConfig2;
  }
  add(messageRef) {
    const queues = this.queues();
    if (queues.length >= this.defaultConfig.maxStack) {
      const closedRef = queues.shift();
      closedRef?.close();
    }
    this.queues.set([...queues, messageRef]);
  }
  remove(id) {
    if (!id) {
      this.queues().forEach((item) => item.close());
      this.queues.set([]);
    } else {
      const removeItem = this.queues().find((item) => item.id === id);
      removeItem?.close();
      const afterRemovedQueues = this.queues().filter((item) => item.id !== id);
      this.queues.set(afterRemovedQueues);
    }
  }
};
var ANIMATION_IN_DURATION = 100;
var ANIMATION_OUT_DURATION = 150;
var HIDE_STYLE = {
  transform: "translateX(0)",
  opacity: 0,
  height: 0,
  paddingTop: 0,
  paddingBottom: 0,
  margin: 0
};
var ThyAbstractMessageComponent = class _ThyAbstractMessageComponent {
  constructor() {
    this._ngZone = inject(NgZone);
    this.iconName = "";
    this.config = input(null, ...ngDevMode ? [{
      debugName: "config",
      alias: "thyConfig"
    }] : [{
      alias: "thyConfig"
    }]);
  }
  ngOnInit() {
    const iconName = {
      success: "check-circle-fill",
      info: "info-circle-fill",
      warning: "waring-fill",
      error: "close-circle-fill"
    };
    this.iconName = this.config()?.type ? iconName[this.config().type] : "";
    this.createCloseTimer();
  }
  mouseenter() {
    if (this.config()?.pauseOnHover) {
      this.clearCloseTimer();
    }
  }
  mouseleave() {
    if (this.config()?.pauseOnHover) {
      this.createCloseTimer();
    }
  }
  close() {
    this._ngZone.runOutsideAngular(() => {
      this.animationState = "componentHide";
      setTimeout(() => {
        this.queue.remove(this.config()?.id);
      }, ANIMATION_OUT_DURATION);
    });
  }
  createCloseTimer() {
    const config2 = this.config();
    if (config2?.duration) {
      this.closeTimer = setInterval(() => {
        this.clearCloseTimer();
        this.close();
      }, config2.duration);
    }
  }
  clearCloseTimer() {
    clearInterval(this.closeTimer);
  }
  ngOnDestroy() {
    this.clearCloseTimer();
  }
  static {
    this.\u0275fac = function ThyAbstractMessageComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyAbstractMessageComponent)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyAbstractMessageComponent,
      hostBindings: function ThyAbstractMessageComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function ThyAbstractMessageComponent_mouseenter_HostBindingHandler() {
            return ctx.mouseenter();
          })("mouseleave", function ThyAbstractMessageComponent_mouseleave_HostBindingHandler() {
            return ctx.mouseleave();
          });
        }
      },
      inputs: {
        config: [1, "thyConfig", "config"]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyAbstractMessageComponent, [{
    type: Directive
  }], null, {
    config: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyConfig",
        required: false
      }]
    }],
    mouseenter: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    mouseleave: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var ThyAbstractMessageService = class {
  constructor(overlay, injector, queue) {
    this.overlay = overlay;
    this.injector = injector;
    this.queue = queue;
  }
  createContainer(container) {
    if (this.container) {
      this.container.toOverlayTop();
      return this.container;
    }
    this.overlayRef = this.overlay.create({
      hasBackdrop: false,
      scrollStrategy: this.overlay.scrollStrategies.noop(),
      positionStrategy: this.overlay.position().global()
    });
    const componentPortal = new ComponentPortal(container, null, this.injector);
    const componentRef = this.overlayRef.attach(componentPortal);
    return componentRef.instance;
  }
  remove(id) {
    this.queue.remove(id);
  }
};
var ThyAbstractMessageRef = class {
  constructor(config2, overlayRef, queueService) {
    this._afterClosed = new Subject();
    this.id = config2.id;
    this.config = config2;
    this.overlayRef = overlayRef;
    this.queueService = queueService;
  }
  close() {
    this.queueService.setQueues(this.queueService.queues().filter((item) => item.id !== this.id));
    this._afterClosed.next();
    this._afterClosed.complete();
  }
  afterClosed() {
    return this._afterClosed.asObservable();
  }
  getOverlayRef() {
    return this.overlayRef;
  }
};
var THY_MESSAGE_DEFAULT_CONFIG = new InjectionToken("thy-message-default-config");
var THY_MESSAGE_DEFAULT_CONFIG_VALUE = {
  offset: "20",
  duration: 4500,
  pauseOnHover: true,
  maxStack: 8,
  showClose: true
};
var THY_MESSAGE_DEFAULT_CONFIG_PROVIDER = {
  provide: THY_MESSAGE_DEFAULT_CONFIG,
  useValue: THY_MESSAGE_DEFAULT_CONFIG_VALUE
};
var ThyMessageQueue = class _ThyMessageQueue extends ThyAbstractMessageQueue {
  constructor() {
    const defaultConfig2 = inject(THY_MESSAGE_DEFAULT_CONFIG);
    super(__spreadValues(__spreadValues({}, THY_MESSAGE_DEFAULT_CONFIG_VALUE), defaultConfig2));
  }
  static {
    this.\u0275fac = function ThyMessageQueue_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyMessageQueue)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyMessageQueue,
      factory: _ThyMessageQueue.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMessageQueue, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var ThyMessage = class _ThyMessage extends ThyAbstractMessageComponent {
  constructor() {
    super();
    this.animationState = "flyIn";
    this.hostRenderer = useHostRenderer();
    this.queue = inject(ThyMessageQueue);
    effect(() => {
      const config2 = this.config();
      if (config2?.hostClass) {
        const hostClass = coerceArray2(config2.hostClass);
        this.hostRenderer.updateClass(hostClass);
      }
    });
  }
  static {
    this.\u0275fac = function ThyMessage_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyMessage)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyMessage,
      selectors: [["thy-message"]],
      hostVars: 3,
      hostBindings: function ThyMessage_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275syntheticHostProperty("@flyInOut", ctx.animationState);
          \u0275\u0275classMap("thy-message thy-message-" + ctx.config().type);
        }
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 3,
      consts: [[1, "thy-message-icon", 3, "thyIconName"], [1, "thy-message-icon", "loading-icon"], [1, "thy-message-main"], [4, "thyStringOrTemplateOutlet"], ["thyIconName", "close", 1, "thy-message-close"], ["thyIconName", "close", 1, "thy-message-close", 3, "click"]],
      template: function ThyMessage_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ThyMessage_Conditional_0_Template, 1, 1, "thy-icon", 0)(1, ThyMessage_Conditional_1_Template, 1, 0, "span", 1);
          \u0275\u0275elementStart(2, "div", 2);
          \u0275\u0275template(3, ThyMessage_ng_container_3_Template, 1, 0, "ng-container", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(4, ThyMessage_Conditional_4_Template, 1, 0, "thy-icon", 4);
        }
        if (rf & 2) {
          const messageConfig_r3 = ctx.config();
          \u0275\u0275conditional(ctx.iconName ? 0 : 1);
          \u0275\u0275advance(3);
          \u0275\u0275property("thyStringOrTemplateOutlet", messageConfig_r3 == null ? null : messageConfig_r3.content);
          \u0275\u0275advance();
          \u0275\u0275conditional((messageConfig_r3 == null ? null : messageConfig_r3.showClose) ? 4 : -1);
        }
      },
      dependencies: [ThyIcon, ThyStringOrTemplateOutletDirective],
      encapsulation: 2,
      data: {
        animation: [trigger("flyInOut", [state("flyIn", style({
          transform: "translateY(0)",
          opacity: 1,
          height: "*"
        })), transition("void => flyIn", [style({
          transform: "translateY(-100%)",
          opacity: 0,
          height: "*"
        }), animate(ANIMATION_IN_DURATION)]), transition("flyIn => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("componentHide", style(HIDE_STYLE))])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMessage, [{
    type: Component,
    args: [{
      selector: "thy-message",
      host: {
        "[class]": "'thy-message thy-message-' + config().type"
      },
      animations: [trigger("flyInOut", [state("flyIn", style({
        transform: "translateY(0)",
        opacity: 1,
        height: "*"
      })), transition("void => flyIn", [style({
        transform: "translateY(-100%)",
        opacity: 0,
        height: "*"
      }), animate(ANIMATION_IN_DURATION)]), transition("flyIn => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("componentHide", style(HIDE_STYLE))])],
      imports: [ThyIcon, ThyStringOrTemplateOutletDirective],
      template: '@let messageConfig = config();\n\n@if (iconName) {\n  <thy-icon class="thy-message-icon" [thyIconName]="iconName"></thy-icon>\n} @else {\n  <span class="thy-message-icon loading-icon"></span>\n}\n<div class="thy-message-main">\n  <ng-container *thyStringOrTemplateOutlet="messageConfig?.content"></ng-container>\n</div>\n@if (messageConfig?.showClose) {\n  <thy-icon class="thy-message-close" thyIconName="close" (click)="close()"></thy-icon>\n}\n'
    }]
  }], () => [], {
    animationState: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }]
  });
})();
var ThyMessageContainer = class _ThyMessageContainer extends ThyAbstractMessageContainerComponent {
  constructor() {
    super(...arguments);
    this.messageQueue = inject(ThyMessageQueue);
    this.defaultConfig = (() => {
      const defaultConfig2 = inject(THY_MESSAGE_DEFAULT_CONFIG);
      return __spreadValues(__spreadValues({}, THY_MESSAGE_DEFAULT_CONFIG_VALUE), defaultConfig2);
    })();
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyMessageContainer_BaseFactory;
      return function ThyMessageContainer_Factory(__ngFactoryType__) {
        return (\u0275ThyMessageContainer_BaseFactory || (\u0275ThyMessageContainer_BaseFactory = \u0275\u0275getInheritedFactory(_ThyMessageContainer)))(__ngFactoryType__ || _ThyMessageContainer);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyMessageContainer,
      selectors: [["thy-message-container"]],
      hostAttrs: [1, "thy-message-container"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 2,
      vars: 0,
      consts: [[3, "thyConfig"]],
      template: function ThyMessageContainer_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275repeaterCreate(0, ThyMessageContainer_For_1_Template, 1, 1, "thy-message", 0, _forTrack0);
        }
        if (rf & 2) {
          \u0275\u0275repeater(ctx.messageQueue.queues());
        }
      },
      dependencies: [ThyMessage],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMessageContainer, [{
    type: Component,
    args: [{
      selector: "thy-message-container",
      template: `
        @for (message of messageQueue.queues(); track message.id) {
            <thy-message [thyConfig]="message.config"></thy-message>
        }
    `,
      imports: [ThyMessage],
      host: {
        class: "thy-message-container"
      }
    }]
  }], null, null);
})();
var ThyMessageModule = class _ThyMessageModule {
  static {
    this.\u0275fac = function ThyMessageModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyMessageModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyMessageModule,
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyMessageContainer, ThyMessage],
      exports: [ThyMessageContainer, ThyMessage]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [THY_MESSAGE_DEFAULT_CONFIG_PROVIDER],
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyMessageContainer, ThyMessage]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMessageModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyMessageContainer, ThyMessage],
      exports: [ThyMessageContainer, ThyMessage],
      providers: [THY_MESSAGE_DEFAULT_CONFIG_PROVIDER]
    }]
  }], null, null);
})();
var ThyMessageRef = class extends ThyAbstractMessageRef {
};
var ThyMessageService = class _ThyMessageService extends ThyAbstractMessageService {
  constructor() {
    const overlay = inject(Overlay);
    const injector = inject(Injector);
    const messageQueue = inject(ThyMessageQueue);
    const config2 = inject(THY_MESSAGE_DEFAULT_CONFIG);
    super(overlay, injector, messageQueue);
    this._lastMessageId = 0;
    this.messageQueue = messageQueue;
    this.defaultConfig = __spreadValues(__spreadValues({}, THY_MESSAGE_DEFAULT_CONFIG_VALUE), config2);
  }
  /**
   * 打开 success 类型的 Message
   */
  success(content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "success",
      content
    }));
  }
  /**
   * 打开 error 类型的 Message
   */
  error(content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "error",
      content
    }));
  }
  /**
   * 打开 info 类型的 Message
   */
  info(content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "info",
      content
    }));
  }
  /**
   * 打开 warning 类型的 Message
   */
  warning(content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "warning",
      content
    }));
  }
  /**
   * 打开 loading 类型的 Message
   */
  loading(content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "loading",
      content
    }));
  }
  show(config2) {
    this.container = this.createContainer(ThyMessageContainer);
    const messageConfig = this.formatOptions(config2);
    const messageRef = new ThyMessageRef(messageConfig, this.overlayRef, this.messageQueue);
    this.messageQueue.add(messageRef);
    return messageRef;
  }
  formatOptions(config2) {
    return Object.assign({
      id: String(this._lastMessageId++)
    }, this.defaultConfig, config2);
  }
  static {
    this.\u0275fac = function ThyMessageService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyMessageService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyMessageService,
      factory: _ThyMessageService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMessageService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-notify.mjs
var _c015 = (a0) => ({
  "thy-notify-content--extend": a0
});
var _c17 = () => ({});
function ThyNotify_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 0);
    \u0275\u0275listener("click", function ThyNotify_Conditional_1_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close());
    });
    \u0275\u0275element(1, "thy-icon", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div", 2);
    \u0275\u0275element(3, "template", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", notifyConfig_r3 == null ? null : notifyConfig_r3.html);
  }
}
function ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(4);
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275textInterpolate1(" ", notifyConfig_r3 == null ? null : notifyConfig_r3.content, " ");
  }
}
function ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(4);
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("thyViewOutlet", notifyConfig_r3 == null ? null : notifyConfig_r3.content)("thyViewOutletContext", (notifyConfig_r3 == null ? null : notifyConfig_r3.contentInitialState) || \u0275\u0275pureFunction0(2, _c17));
  }
}
function ThyNotify_Conditional_2_Conditional_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_0_Template, 1, 1)(1, ThyNotify_Conditional_2_Conditional_7_Conditional_1_Conditional_1_Template, 1, 3, "ng-container");
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275conditional(ctx_r1.contentIsString() ? 0 : 1);
  }
}
function ThyNotify_Conditional_2_Conditional_7_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 12);
    \u0275\u0275listener("click", function ThyNotify_Conditional_2_Conditional_7_Conditional_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r1.triggerDetail());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(3);
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate((notifyConfig_r3 == null ? null : notifyConfig_r3.detail)["link"]);
  }
}
function ThyNotify_Conditional_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("click", function ThyNotify_Conditional_2_Conditional_7_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.extendContent());
    });
    \u0275\u0275conditionalCreate(1, ThyNotify_Conditional_2_Conditional_7_Conditional_1_Template, 2, 1);
    \u0275\u0275conditionalCreate(2, ThyNotify_Conditional_2_Conditional_7_Conditional_2_Template, 2, 1, "a", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(3, _c015, ctx_r1.extendContentClass()));
    \u0275\u0275advance();
    \u0275\u0275conditional((notifyConfig_r3 == null ? null : notifyConfig_r3.content) ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional((notifyConfig_r3 == null ? null : notifyConfig_r3.detail) ? 2 : -1);
  }
}
function ThyNotify_Conditional_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate((notifyConfig_r3 == null ? null : notifyConfig_r3.detail)["content"]);
  }
}
function ThyNotify_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 0);
    \u0275\u0275listener("click", function ThyNotify_Conditional_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.close());
    });
    \u0275\u0275element(1, "thy-icon", 1);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div", 4);
    \u0275\u0275element(3, "thy-icon", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 2)(5, "div", 6);
    \u0275\u0275text(6);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(7, ThyNotify_Conditional_2_Conditional_7_Template, 3, 5, "div", 7);
    \u0275\u0275conditionalCreate(8, ThyNotify_Conditional_2_Conditional_8_Template, 2, 1, "div", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    const notifyConfig_r3 = \u0275\u0275readContextLet(0);
    \u0275\u0275advance(3);
    \u0275\u0275property("thyIconName", ctx_r1.iconName);
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(notifyConfig_r3 == null ? null : notifyConfig_r3.title);
    \u0275\u0275advance();
    \u0275\u0275conditional((notifyConfig_r3 == null ? null : notifyConfig_r3.detail) || (notifyConfig_r3 == null ? null : notifyConfig_r3.content) ? 7 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.isShowDetail() ? 8 : -1);
  }
}
var _forTrack02 = ($index, $item) => $item.id;
function ThyNotifyContainer_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-notify", 1);
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275property("thyConfig", item_r1.config);
  }
}
function ThyNotifyContainer_For_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-notify", 1);
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    \u0275\u0275property("thyConfig", item_r2.config);
  }
}
function ThyNotifyContainer_For_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-notify", 1);
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275property("thyConfig", item_r3.config);
  }
}
function ThyNotifyContainer_For_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-notify", 1);
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    \u0275\u0275property("thyConfig", item_r4.config);
  }
}
var THY_NOTIFY_DEFAULT_CONFIG = new InjectionToken("thy-notify-default-config");
var THY_NOTIFY_DEFAULT_CONFIG_VALUE = {
  placement: "topRight",
  offset: "20",
  duration: 4500,
  pauseOnHover: true,
  maxStack: 8
};
var THY_NOTIFY_DEFAULT_CONFIG_PROVIDER = {
  provide: THY_NOTIFY_DEFAULT_CONFIG,
  useValue: THY_NOTIFY_DEFAULT_CONFIG_VALUE
};
var ThyNotifyQueue = class _ThyNotifyQueue extends ThyAbstractMessageQueue {
  constructor() {
    const defaultConfig2 = inject(THY_NOTIFY_DEFAULT_CONFIG);
    super(__spreadValues(__spreadValues({}, THY_NOTIFY_DEFAULT_CONFIG_VALUE), defaultConfig2));
    this.topLeftQueues = computed(() => {
      return this.queues().filter((item) => item.config.placement === "topLeft");
    }, ...ngDevMode ? [{
      debugName: "topLeftQueues"
    }] : []);
    this.topRightQueues = computed(() => {
      return this.queues().filter((item) => item.config.placement === "topRight");
    }, ...ngDevMode ? [{
      debugName: "topRightQueues"
    }] : []);
    this.bottomLeftQueues = computed(() => {
      return this.queues().filter((item) => item.config.placement === "bottomLeft");
    }, ...ngDevMode ? [{
      debugName: "bottomLeftQueues"
    }] : []);
    this.bottomRightQueues = computed(() => {
      return this.queues().filter((item) => item.config.placement === "bottomRight");
    }, ...ngDevMode ? [{
      debugName: "bottomRightQueues"
    }] : []);
  }
  static {
    this.\u0275fac = function ThyNotifyQueue_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNotifyQueue)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyNotifyQueue,
      factory: _ThyNotifyQueue.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNotifyQueue, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
var ThyNotify = class _ThyNotify extends ThyAbstractMessageComponent {
  constructor() {
    super();
    this.extendContentClass = signal(false, ...ngDevMode ? [{
      debugName: "extendContentClass"
    }] : []);
    this.isShowDetail = signal(false, ...ngDevMode ? [{
      debugName: "isShowDetail"
    }] : []);
    this.contentIsString = computed(() => isString(this.config()?.content), ...ngDevMode ? [{
      debugName: "contentIsString"
    }] : []);
    this.queue = inject(ThyNotifyQueue);
    this.placement = computed(() => {
      const config2 = this.config();
      return config2?.placement || "topRight";
    }, ...ngDevMode ? [{
      debugName: "placement"
    }] : []);
    effect(() => {
      const placement = this.placement();
      if (placement === "topLeft" || placement === "bottomLeft") {
        this.animationState = "flyInOutLeft";
      } else {
        this.animationState = "flyInOutRight";
      }
    });
  }
  extendContent() {
    this.extendContentClass.set(true);
  }
  showDetailToggle() {
    this.isShowDetail.set(!this.isShowDetail());
  }
  triggerDetail() {
    const config2 = this.config();
    if (index.isFunction((config2?.detail).action)) {
      config2.detail.action();
    }
    if ((config2?.detail).content) {
      this.showDetailToggle();
    }
  }
  static {
    this.\u0275fac = function ThyNotify_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNotify)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyNotify,
      selectors: [["thy-notify"]],
      hostVars: 3,
      hostBindings: function ThyNotify_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275syntheticHostProperty("@flyInOut", ctx.animationState);
          \u0275\u0275classMap("thy-notify thy-notify-" + ctx.config().type);
        }
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 2,
      consts: [["href", "javascript:;", 1, "thy-notify-close", 3, "click"], ["thyIconName", "close"], [1, "thy-notify-main"], [3, "ngTemplateOutlet"], [1, "thy-notify-icon-container"], [3, "thyIconName"], [1, "thy-notify-title"], [1, "thy-notify-content", 3, "ngClass"], [1, "thy-notify-detail"], [1, "thy-notify-content", 3, "click", "ngClass"], ["href", "javascript:;", 1, "link-secondary"], [4, "thyViewOutlet", "thyViewOutletContext"], ["href", "javascript:;", 1, "link-secondary", 3, "click"]],
      template: function ThyNotify_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275conditionalCreate(1, ThyNotify_Conditional_1_Template, 4, 1)(2, ThyNotify_Conditional_2_Template, 9, 4);
        }
        if (rf & 2) {
          const notifyConfig_r7 = \u0275\u0275storeLet(ctx.config());
          \u0275\u0275advance();
          \u0275\u0275conditional((notifyConfig_r7 == null ? null : notifyConfig_r7.html) ? 1 : 2);
        }
      },
      dependencies: [ThyIcon, NgClass, ThyViewOutletDirective, NgTemplateOutlet],
      encapsulation: 2,
      data: {
        animation: [trigger("flyInOut", [state("flyInOutRight", style({
          transform: "translateX(0)",
          opacity: 1,
          height: "*"
        })), transition("void => flyInOutRight", [style({
          transform: "translateX(100%)",
          opacity: 0,
          height: "*"
        }), animate(ANIMATION_IN_DURATION)]), transition("flyInOutRight => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("flyInOutLeft", style({
          transform: "translateX(0)",
          opacity: 1,
          height: "*"
        })), transition("void => flyInOutLeft", [style({
          transform: "translateX(-100%)",
          opacity: 0,
          height: "*"
        }), animate(ANIMATION_IN_DURATION)]), transition("flyInOutLeft => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("componentHide", style(HIDE_STYLE))])]
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNotify, [{
    type: Component,
    args: [{
      selector: "thy-notify",
      host: {
        "[class]": "'thy-notify thy-notify-' + config().type"
      },
      animations: [trigger("flyInOut", [state("flyInOutRight", style({
        transform: "translateX(0)",
        opacity: 1,
        height: "*"
      })), transition("void => flyInOutRight", [style({
        transform: "translateX(100%)",
        opacity: 0,
        height: "*"
      }), animate(ANIMATION_IN_DURATION)]), transition("flyInOutRight => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("flyInOutLeft", style({
        transform: "translateX(0)",
        opacity: 1,
        height: "*"
      })), transition("void => flyInOutLeft", [style({
        transform: "translateX(-100%)",
        opacity: 0,
        height: "*"
      }), animate(ANIMATION_IN_DURATION)]), transition("flyInOutLeft => componentHide", [animate(ANIMATION_OUT_DURATION, style(HIDE_STYLE))]), state("componentHide", style(HIDE_STYLE))])],
      imports: [ThyIcon, NgClass, ThyViewOutletDirective, NgTemplateOutlet],
      template: `@let notifyConfig = config();

@if (notifyConfig?.html) {
  <a href="javascript:;" class="thy-notify-close" (click)="close()">
    <thy-icon thyIconName="close"></thy-icon>
  </a>
  <div class="thy-notify-main">
    <template [ngTemplateOutlet]="notifyConfig?.html"></template>
  </div>
} @else {
  <a href="javascript:;" class="thy-notify-close" (click)="close()">
    <thy-icon thyIconName="close"></thy-icon>
  </a>
  <div class="thy-notify-icon-container">
    <thy-icon [thyIconName]="iconName"></thy-icon>
  </div>
  <div class="thy-notify-main">
    <div class="thy-notify-title">{{ notifyConfig?.title }}</div>
    @if (notifyConfig?.detail || notifyConfig?.content) {
      <div class="thy-notify-content" [ngClass]="{ 'thy-notify-content--extend': extendContentClass() }" (click)="extendContent()">
        @if (notifyConfig?.content) {
          @if (contentIsString()) {
            {{ notifyConfig?.content }}
          } @else {
            <ng-container *thyViewOutlet="notifyConfig?.content; context: notifyConfig?.contentInitialState || {}"></ng-container>
          }
        }
        @if (notifyConfig?.detail) {
          <a href="javascript:;" class="link-secondary" (click)="triggerDetail()">{{ (notifyConfig?.detail)['link'] }}</a>
        }
      </div>
    }
    @if (isShowDetail()) {
      <div class="thy-notify-detail">{{ (notifyConfig?.detail)['content'] }}</div>
    }
  </div>
}
`
    }]
  }], () => [], {
    animationState: [{
      type: HostBinding,
      args: ["@flyInOut"]
    }]
  });
})();
var ThyNotifyContainer = class _ThyNotifyContainer extends ThyAbstractMessageContainerComponent {
  constructor() {
    super(...arguments);
    this.notifyQueue = inject(ThyNotifyQueue);
    this.defaultConfig = (() => {
      const defaultConfig2 = inject(THY_NOTIFY_DEFAULT_CONFIG);
      return __spreadValues(__spreadValues({}, THY_NOTIFY_DEFAULT_CONFIG_VALUE), defaultConfig2);
    })();
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyNotifyContainer_BaseFactory;
      return function ThyNotifyContainer_Factory(__ngFactoryType__) {
        return (\u0275ThyNotifyContainer_BaseFactory || (\u0275ThyNotifyContainer_BaseFactory = \u0275\u0275getInheritedFactory(_ThyNotifyContainer)))(__ngFactoryType__ || _ThyNotifyContainer);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyNotifyContainer,
      selectors: [["thy-notify-container"]],
      hostAttrs: [1, "thy-notify-container"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 12,
      vars: 16,
      consts: [[1, "thy-notify-bottomRight"], [3, "thyConfig"], [1, "thy-notify-bottomLeft"], [1, "thy-notify-topLeft"], [1, "thy-notify-topRight"]],
      template: function ThyNotifyContainer_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275repeaterCreate(1, ThyNotifyContainer_For_2_Template, 1, 1, "thy-notify", 1, _forTrack02);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(3, "div", 2);
          \u0275\u0275repeaterCreate(4, ThyNotifyContainer_For_5_Template, 1, 1, "thy-notify", 1, _forTrack02);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "div", 3);
          \u0275\u0275repeaterCreate(7, ThyNotifyContainer_For_8_Template, 1, 1, "thy-notify", 1, _forTrack02);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "div", 4);
          \u0275\u0275repeaterCreate(10, ThyNotifyContainer_For_11_Template, 1, 1, "thy-notify", 1, _forTrack02);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275styleProp("bottom", ctx.offset, "px")("right", ctx.offset, "px");
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.notifyQueue.bottomRightQueues());
          \u0275\u0275advance(2);
          \u0275\u0275styleProp("bottom", ctx.offset, "px")("left", ctx.offset, "px");
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.notifyQueue.bottomLeftQueues());
          \u0275\u0275advance(2);
          \u0275\u0275styleProp("top", ctx.offset, "px")("left", ctx.offset, "px");
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.notifyQueue.topLeftQueues());
          \u0275\u0275advance(2);
          \u0275\u0275styleProp("top", ctx.offset, "px")("right", ctx.offset, "px");
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.notifyQueue.topRightQueues());
        }
      },
      dependencies: [ThyNotify],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNotifyContainer, [{
    type: Component,
    args: [{
      selector: "thy-notify-container",
      imports: [ThyNotify],
      host: {
        class: "thy-notify-container"
      },
      template: '<div class="thy-notify-bottomRight" [style.bottom.px]="offset" [style.right.px]="offset">\n  @for (item of notifyQueue.bottomRightQueues(); track item.id) {\n    <thy-notify [thyConfig]="item.config"></thy-notify>\n  }\n</div>\n<div class="thy-notify-bottomLeft" [style.bottom.px]="offset" [style.left.px]="offset">\n  @for (item of notifyQueue.bottomLeftQueues(); track item.id) {\n    <thy-notify [thyConfig]="item.config"></thy-notify>\n  }\n</div>\n<div class="thy-notify-topLeft" [style.top.px]="offset" [style.left.px]="offset">\n  @for (item of notifyQueue.topLeftQueues(); track item.id) {\n    <thy-notify [thyConfig]="item.config"></thy-notify>\n  }\n</div>\n<div class="thy-notify-topRight" [style.top.px]="offset" [style.right.px]="offset">\n  @for (item of notifyQueue.topRightQueues(); track item.id) {\n    <thy-notify [thyConfig]="item.config"></thy-notify>\n  }\n</div>\n'
    }]
  }], null, null);
})();
var ThyNotifyModule = class _ThyNotifyModule {
  static {
    this.\u0275fac = function ThyNotifyModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNotifyModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyNotifyModule,
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyNotifyContainer, ThyNotify],
      exports: [ThyNotifyContainer, ThyNotify]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [THY_NOTIFY_DEFAULT_CONFIG_PROVIDER],
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyNotifyContainer, ThyNotify]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNotifyModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThySharedModule, OverlayModule, PortalModule, ThyIconModule, ThyNotifyContainer, ThyNotify],
      exports: [ThyNotifyContainer, ThyNotify],
      providers: [THY_NOTIFY_DEFAULT_CONFIG_PROVIDER]
    }]
  }], null, null);
})();
var ThyNotifyRef = class extends ThyAbstractMessageRef {
};
var ThyNotifyService = class _ThyNotifyService extends ThyAbstractMessageService {
  constructor() {
    const overlay = inject(Overlay);
    const injector = inject(Injector);
    const notifyQueue = inject(ThyNotifyQueue);
    super(overlay, injector, notifyQueue);
    this.config = inject(THY_NOTIFY_DEFAULT_CONFIG);
    this.locale = injectLocale("notify");
    this._lastNotifyId = 0;
    this.notifyQueue = notifyQueue;
    const config2 = this.config;
    this.defaultConfig = __spreadValues(__spreadValues({}, THY_NOTIFY_DEFAULT_CONFIG_VALUE), config2);
  }
  /**
   * 打开自定义配置的 Notify
   */
  show(config2) {
    this.container = this.createContainer(ThyNotifyContainer);
    const notifyConfig = this.formatOptions(config2);
    const notifyRef = new ThyNotifyRef(notifyConfig, this.overlayRef, this.notifyQueue);
    this.notifyQueue.add(notifyRef);
    return notifyRef;
  }
  /**
   * 打开类型为"success"的 Notify
   */
  success(title, content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "success",
      title: title || config2?.title || this.locale().success,
      content: content || config2?.content
    }));
  }
  /**
   * 打开类型为"info"的 Notify
   */
  info(title, content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "info",
      title: title || config2?.title || this.locale().info,
      content: content || config2?.content
    }));
  }
  /**
   * 打开类型为"warning"的 Notify
   */
  warning(title, content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "warning",
      title: title || config2?.title || this.locale().warning,
      content: content || config2?.content
    }));
  }
  /**
   * 打开类型为"error"的 Notify
   */
  error(title, content, config2) {
    return this.show(__spreadProps(__spreadValues({}, config2 || {}), {
      type: "error",
      title: title || config2?.title || this.locale().error,
      content: content || config2?.content
    }));
  }
  formatOptions(config2) {
    if (isString(config2.detail)) {
      config2 = __spreadProps(__spreadValues({}, config2), {
        detail: {
          link: `[${this.locale().detail}]`,
          content: config2.detail
        }
      });
    }
    return Object.assign({
      type: "blank"
    }, {
      id: String(this._lastNotifyId++)
    }, this.defaultConfig, config2);
  }
  static {
    this.\u0275fac = function ThyNotifyService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyNotifyService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyNotifyService,
      factory: _ThyNotifyService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyNotifyService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();

// node_modules/@angular/common/locales/zh-Hans.js
var u = void 0;
function plural(val) {
  const n = val;
  return 5;
}
var zh_Hans_default = ["zh-Hans", [["\u4E0A\u5348", "\u4E0B\u5348"]], u, [["\u65E5", "\u4E00", "\u4E8C", "\u4E09", "\u56DB", "\u4E94", "\u516D"], ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"], ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"]], u, [["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"]], u, [["\u516C\u5143\u524D", "\u516C\u5143"]], 1, [6, 0], ["y/M/d", "y\u5E74M\u6708d\u65E5", u, "y\u5E74M\u6708d\u65E5EEEE"], ["HH:mm", "HH:mm:ss", "z HH:mm:ss", "zzzz HH:mm:ss"], ["{1} {0}", u, u, u], [".", ",", ";", "%", "+", "-", "E", "\xD7", "\u2030", "\u221E", "NaN", ":"], ["#,##0.###", "#,##0%", "\xA4#,##0.00", "#E0"], "CNY", "\xA5", "\u4EBA\u6C11\u5E01", { "AUD": ["AU$", "$"], "BYN": [u, "\u0440."], "CNY": ["\xA5"], "ILR": ["ILS"], "JPY": ["JP\xA5", "\xA5"], "PHP": [u, "\u20B1"], "RUR": [u, "\u0440."], "TWD": ["NT$"], "USD": ["US$", "$"], "XXX": [] }, "ltr", plural];

// node_modules/ngx-tethys/fesm2022/ngx-tethys-divider.mjs
function ThyDivider_Conditional_0_1_ng_template_0_Template(rf, ctx) {
}
function ThyDivider_Conditional_0_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyDivider_Conditional_0_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyDivider_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275template(1, ThyDivider_Conditional_0_1_Template, 1, 0, null, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.templateContent());
  }
}
function ThyDivider_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 1);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.textContent());
  }
}
var ThyDivider = class _ThyDivider {
  constructor() {
    this.hostRenderer = useHostRenderer();
    this.thyVertical = input(false, ...ngDevMode ? [{
      debugName: "thyVertical",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyStyle = input("solid", ...ngDevMode ? [{
      debugName: "thyStyle"
    }] : []);
    this.thyColor = input("default", ...ngDevMode ? [{
      debugName: "thyColor"
    }] : []);
    this.thyText = input(...ngDevMode ? [void 0, {
      debugName: "thyText"
    }] : []);
    this.templateContent = computed(() => {
      const text = this.thyText();
      if (text instanceof TemplateRef) {
        return text;
      }
    }, ...ngDevMode ? [{
      debugName: "templateContent"
    }] : []);
    this.textContent = computed(() => {
      const text = this.thyText();
      if (typeof text === "string") {
        return text;
      }
    }, ...ngDevMode ? [{
      debugName: "textContent"
    }] : []);
    this.thyTextDirection = input("center", ...ngDevMode ? [{
      debugName: "thyTextDirection"
    }] : []);
    this.thyDeeper = input(false, ...ngDevMode ? [{
      debugName: "thyDeeper",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    effect(() => {
      this.setColor();
    });
  }
  ngOnInit() {
  }
  setColor() {
    this.hostRenderer.updateClass([`thy-divider-${this.thyColor()}`]);
  }
  static {
    this.\u0275fac = function ThyDivider_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDivider)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDivider,
      selectors: [["thy-divider"]],
      hostVars: 20,
      hostBindings: function ThyDivider_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-divider", true)("thy-divider-horizontal", !ctx.thyVertical())("thy-divider-vertical", ctx.thyVertical())("thy-divider-with-content", ctx.textContent() || ctx.templateContent())("thy-divider-with-content-left", (ctx.textContent() || ctx.templateContent()) && ctx.thyTextDirection() === "left")("thy-divider-with-content-right", (ctx.textContent() || ctx.templateContent()) && ctx.thyTextDirection() === "right")("thy-divider-with-content-center", (ctx.textContent() || ctx.templateContent()) && ctx.thyTextDirection() === "center")("thy-divider-solid", ctx.thyStyle() === "solid")("thy-divider-dashed", ctx.thyStyle() === "dashed")("thy-divider-deeper", !!ctx.thyDeeper());
        }
      },
      inputs: {
        thyVertical: [1, "thyVertical"],
        thyStyle: [1, "thyStyle"],
        thyColor: [1, "thyColor"],
        thyText: [1, "thyText"],
        thyTextDirection: [1, "thyTextDirection"],
        thyDeeper: [1, "thyDeeper"]
      },
      decls: 2,
      vars: 2,
      consts: [[1, "thy-divider-inner-template"], [1, "thy-divider-inner-text"], [4, "ngTemplateOutlet"]],
      template: function ThyDivider_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ThyDivider_Conditional_0_Template, 2, 1, "div", 0);
          \u0275\u0275conditionalCreate(1, ThyDivider_Conditional_1_Template, 2, 1, "span", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.templateContent() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.textContent() ? 1 : -1);
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDivider, [{
    type: Component,
    args: [{
      preserveWhitespaces: false,
      encapsulation: ViewEncapsulation.None,
      selector: "thy-divider",
      template: `
        @if (templateContent()) {
            <div class="thy-divider-inner-template">
                <ng-template *ngTemplateOutlet="templateContent()"></ng-template>
            </div>
        }

        @if (textContent()) {
            <span class="thy-divider-inner-text">{{ textContent() }}</span>
        }
    `,
      host: {
        "[class.thy-divider]": `true`,
        "[class.thy-divider-horizontal]": `!thyVertical()`,
        "[class.thy-divider-vertical]": `thyVertical()`,
        "[class.thy-divider-with-content]": `textContent() || templateContent()`,
        "[class.thy-divider-with-content-left]": `(textContent() || templateContent()) && thyTextDirection() === 'left'`,
        "[class.thy-divider-with-content-right]": `(textContent() || templateContent()) && thyTextDirection() === 'right'`,
        "[class.thy-divider-with-content-center]": `(textContent() || templateContent()) && thyTextDirection() === 'center'`,
        "[class.thy-divider-solid]": `thyStyle() === 'solid'`,
        "[class.thy-divider-dashed]": `thyStyle() === 'dashed'`,
        "[class.thy-divider-deeper]": `!!thyDeeper()`
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [NgTemplateOutlet]
    }]
  }], () => [], {
    thyVertical: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyVertical",
        required: false
      }]
    }],
    thyStyle: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyStyle",
        required: false
      }]
    }],
    thyColor: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyColor",
        required: false
      }]
    }],
    thyText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyText",
        required: false
      }]
    }],
    thyTextDirection: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTextDirection",
        required: false
      }]
    }],
    thyDeeper: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDeeper",
        required: false
      }]
    }]
  });
})();
var ThyDividerModule = class _ThyDividerModule {
  static {
    this.\u0275fac = function ThyDividerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDividerModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyDividerModule,
      imports: [CommonModule, ThySharedModule, ThyIconModule, ThyDivider],
      exports: [ThyDivider]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, ThySharedModule, ThyIconModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDividerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, ThySharedModule, ThyIconModule, ThyDivider],
      exports: [ThyDivider],
      providers: []
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-input.mjs
var _c016 = ["append"];
var _c18 = ["prepend"];
function ThyInput_Conditional_0_2_ng_template_0_Template(rf, ctx) {
}
function ThyInput_Conditional_0_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInput_Conditional_0_2_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInput_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3, 1);
    \u0275\u0275template(2, ThyInput_Conditional_0_2_Template, 1, 0, null, 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.prependTemplate());
  }
}
function ThyInput_Conditional_5_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 9);
  }
}
function ThyInput_Conditional_5_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 10);
  }
}
function ThyInput_Conditional_5_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275listener("click", function ThyInput_Conditional_5_Conditional_2_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.togglePasswordType());
    });
    \u0275\u0275conditionalCreate(1, ThyInput_Conditional_5_Conditional_2_Conditional_1_Template, 1, 0, "thy-icon", 9);
    \u0275\u0275conditionalCreate(2, ThyInput_Conditional_5_Conditional_2_Conditional_2_Template, 1, 0, "thy-icon", 10);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.isPassword(ctx_r1.type()) ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r1.isPassword(ctx_r1.type()) ? 2 : -1);
  }
}
function ThyInput_Conditional_5_Conditional_3_0_ng_template_0_Template(rf, ctx) {
}
function ThyInput_Conditional_5_Conditional_3_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInput_Conditional_5_Conditional_3_0_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInput_Conditional_5_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInput_Conditional_5_Conditional_3_0_Template, 1, 0, null, 6);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.appendTemplate());
  }
}
function ThyInput_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5, 2);
    \u0275\u0275conditionalCreate(2, ThyInput_Conditional_5_Conditional_2_Template, 3, 2, "a", 7)(3, ThyInput_Conditional_5_Conditional_3_Template, 1, 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.isPasswordType() ? 2 : 3);
  }
}
var _c25 = ["prefix"];
var _c34 = ["suffix"];
var _c44 = ["*"];
function ThyInputGroup_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "span", 4);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.prependText());
  }
}
function ThyInputGroup_Conditional_1_1_ng_template_0_Template(rf, ctx) {
}
function ThyInputGroup_Conditional_1_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInputGroup_Conditional_1_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInputGroup_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275template(1, ThyInputGroup_Conditional_1_1_Template, 1, 0, null, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.prependTemplate());
  }
}
function ThyInputGroup_Conditional_2_1_ng_template_0_Template(rf, ctx) {
}
function ThyInputGroup_Conditional_2_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInputGroup_Conditional_2_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInputGroup_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275template(1, ThyInputGroup_Conditional_2_1_Template, 1, 0, null, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.prefixTemplate());
  }
}
function ThyInputGroup_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "span", 4);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r0.appendText());
  }
}
function ThyInputGroup_Conditional_5_1_ng_template_0_Template(rf, ctx) {
}
function ThyInputGroup_Conditional_5_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInputGroup_Conditional_5_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInputGroup_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275template(1, ThyInputGroup_Conditional_5_1_Template, 1, 0, null, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.appendTemplate());
  }
}
function ThyInputGroup_Conditional_6_1_ng_template_0_Template(rf, ctx) {
}
function ThyInputGroup_Conditional_6_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ThyInputGroup_Conditional_6_1_ng_template_0_Template, 0, 0, "ng-template");
  }
}
function ThyInputGroup_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275template(1, ThyInputGroup_Conditional_6_1_Template, 1, 0, null, 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.suffixTemplate());
  }
}
var _c53 = ["input"];
function ThyInputSearch_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 1);
  }
}
function ThyInputSearch_Conditional_3_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function ThyInputSearch_Conditional_3_Conditional_1_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.clearSearchText($event));
    });
    \u0275\u0275element(1, "thy-icon", 8);
    \u0275\u0275elementEnd();
  }
}
function ThyInputSearch_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 6);
  }
}
function ThyInputSearch_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275conditionalCreate(1, ThyInputSearch_Conditional_3_Conditional_1_Template, 2, 0, "a", 5)(2, ThyInputSearch_Conditional_3_Conditional_2_Template, 1, 0, "thy-icon", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.searchText() ? 1 : 2);
  }
}
function ThyInputSearch_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 9);
    \u0275\u0275listener("click", function ThyInputSearch_Conditional_4_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.clearSearchText($event));
    });
    \u0275\u0275element(1, "thy-icon", 8);
    \u0275\u0275elementEnd();
  }
}
var inputGroupSizeMap$1 = {
  xs: ["form-control-xs"],
  sm: ["form-control-sm"],
  md: ["form-control-md"],
  lg: ["form-control-lg"]
};
var ThyInputDirective = class _ThyInputDirective {
  get ngControl() {
    return this.control;
  }
  get nativeElement() {
    return this.elementRef.nativeElement;
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.render = inject(Renderer2);
    this.control = inject(NgControl, {
      optional: true,
      self: true
    });
    this.isFormControl = true;
    this.hostRenderer = useHostRenderer();
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    effect(() => {
      const size = this.thySize();
      if (size && inputGroupSizeMap$1[size]) {
        this.hostRenderer.updateClass(inputGroupSizeMap$1[size]);
      } else {
        this.hostRenderer.updateClass([]);
      }
    });
  }
  static {
    this.\u0275fac = function ThyInputDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInputDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyInputDirective,
      selectors: [["input", "thyInput", ""], ["select", "thyInput", ""], ["textarea", "thyInput", ""]],
      hostVars: 2,
      hostBindings: function ThyInputDirective_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("form-control", ctx.isFormControl);
        }
      },
      inputs: {
        thySize: [1, "thySize"]
      },
      exportAs: ["thyInput"]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInputDirective, [{
    type: Directive,
    args: [{
      selector: "input[thyInput], select[thyInput], textarea[thyInput]",
      exportAs: "thyInput"
    }]
  }], () => [], {
    isFormControl: [{
      type: HostBinding,
      args: ["class.form-control"]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }]
  });
})();
var CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ThyInput),
  multi: true
};
var noop$1 = () => {
};
var password = "password";
var ThyInput = class _ThyInput {
  constructor() {
    this.ngZone = inject(NgZone);
    this.elementRef = inject(ElementRef);
    this.placeholder = input("", ...ngDevMode ? [{
      debugName: "placeholder"
    }] : []);
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.thyAutofocus = input(false, ...ngDevMode ? [{
      debugName: "thyAutofocus",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyType = input(...ngDevMode ? [void 0, {
      debugName: "thyType"
    }] : []);
    this._type = input(void 0, ...ngDevMode ? [{
      debugName: "_type",
      alias: "type"
    }] : [{
      alias: "type"
    }]);
    this.thyLabelText = input(...ngDevMode ? [void 0, {
      debugName: "thyLabelText"
    }] : []);
    this.readonly = input(false, ...ngDevMode ? [{
      debugName: "readonly",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.focus = output();
    this.blur = output();
    this.appendTemplate = contentChild("append", ...ngDevMode ? [{
      debugName: "appendTemplate"
    }] : []);
    this.prependTemplate = contentChild("prepend", ...ngDevMode ? [{
      debugName: "prependTemplate"
    }] : []);
    this.type = signal(void 0, ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    this.value = signal("", ...ngDevMode ? [{
      debugName: "value"
    }] : []);
    this.showLabel = signal(false, ...ngDevMode ? [{
      debugName: "showLabel"
    }] : []);
    this.focused = signal(false, ...ngDevMode ? [{
      debugName: "focused"
    }] : []);
    this.disabled = signal(false, ...ngDevMode ? [{
      debugName: "disabled"
    }] : []);
    this.onTouchedCallback = noop$1;
    this.onChangeCallback = noop$1;
    this.isPasswordType = signal(false, ...ngDevMode ? [{
      debugName: "isPasswordType"
    }] : []);
    effect(() => {
      this.type.set(this.thyType() || this._type());
    });
  }
  ngOnInit() {
    this.ngZone.onStable.pipe(take(1)).subscribe(() => {
      this.isPasswordType.set(this.isPassword(this.type()));
    });
  }
  writeValue(value) {
    this.value.set(value);
  }
  registerOnChange(fn) {
    this.onChangeCallback = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedCallback = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled.set(isDisabled);
  }
  onModelChange() {
    this.onChangeCallback(this.value());
  }
  onInputFocus(event) {
    this.focused.set(true);
    this.showLabel.set(true);
    this.focus.emit(event);
  }
  onInputBlur(event) {
    this.onTouchedCallback();
    if (this.elementRef.nativeElement.onblur) {
      this.elementRef.nativeElement.onblur(event);
    }
    this.focused.set(false);
    this.showLabel.set(false);
    this.blur.emit(event);
  }
  isPassword(value) {
    return value === password;
  }
  togglePasswordType() {
    this.type.set(this.isPassword(this.type()) ? "text" : "password");
  }
  static {
    this.\u0275fac = function ThyInput_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInput)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyInput,
      selectors: [["thy-input"]],
      contentQueries: function ThyInput_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.appendTemplate, _c016, 5)(dirIndex, ctx.prependTemplate, _c18, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(2);
        }
      },
      hostAttrs: [1, "thy-input", "form-control"],
      hostVars: 4,
      hostBindings: function ThyInput_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("form-control-active", ctx.focused())("disabled", ctx.disabled());
        }
      },
      inputs: {
        placeholder: [1, "placeholder"],
        thySize: [1, "thySize"],
        thyAutofocus: [1, "thyAutofocus"],
        thyType: [1, "thyType"],
        _type: [1, "type", "_type"],
        thyLabelText: [1, "thyLabelText"],
        readonly: [1, "readonly"]
      },
      outputs: {
        focus: "focus",
        blur: "blur"
      },
      features: [\u0275\u0275ProvidersFeature([CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR])],
      decls: 6,
      vars: 15,
      consts: [["input", ""], ["prepend", ""], ["append", ""], [1, "input-prepend"], ["thyInput", "", 3, "ngModelChange", "focus", "blur", "thySize", "thyAutofocus", "type", "placeholder", "disabled", "ngModel", "readonly"], [1, "input-append"], [4, "ngTemplateOutlet"], ["href", "javascript:;", 1, "link-secondary", "input-password-icon"], ["href", "javascript:;", 1, "link-secondary", "input-password-icon", 3, "click"], ["thyIconName", "eye"], ["thyIconName", "eye-invisible"]],
      template: function ThyInput_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275conditionalCreate(0, ThyInput_Conditional_0_Template, 3, 1, "div", 3);
          \u0275\u0275elementStart(1, "input", 4, 0);
          \u0275\u0275twoWayListener("ngModelChange", function ThyInput_Template_input_ngModelChange_1_listener($event) {
            \u0275\u0275restoreView(_r1);
            \u0275\u0275twoWayBindingSet(ctx.value, $event) || (ctx.value = $event);
            return \u0275\u0275resetView($event);
          });
          \u0275\u0275listener("ngModelChange", function ThyInput_Template_input_ngModelChange_1_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onModelChange());
          })("focus", function ThyInput_Template_input_focus_1_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputFocus($event));
          })("blur", function ThyInput_Template_input_blur_1_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputBlur($event));
          });
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(3, "span");
          \u0275\u0275text(4);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(5, ThyInput_Conditional_5_Template, 4, 1, "div", 5);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.prependTemplate() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275property("thySize", ctx.thySize())("thyAutofocus", ctx.thyAutofocus())("type", ctx.type())("placeholder", ctx.placeholder())("disabled", ctx.disabled());
          \u0275\u0275twoWayProperty("ngModel", ctx.value);
          \u0275\u0275property("readonly", ctx.readonly());
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("input-label input-label-", ctx.thySize()));
          \u0275\u0275classProp("active", ctx.showLabel());
          \u0275\u0275advance();
          \u0275\u0275textInterpolate(ctx.thyLabelText());
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.isPasswordType() || ctx.appendTemplate() ? 5 : -1);
        }
      },
      dependencies: [NgTemplateOutlet, ThyInputDirective, ThyAutofocusDirective, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, ThyIcon],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInput, [{
    type: Component,
    args: [{
      selector: "thy-input",
      providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR],
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "thy-input form-control",
        "[class.form-control-active]": "focused()",
        "[class.disabled]": "disabled()"
      },
      imports: [NgTemplateOutlet, ThyInputDirective, ThyAutofocusDirective, FormsModule, ThyIcon],
      template: '@if (prependTemplate()) {\n  <div #prepend class="input-prepend">\n    <ng-template *ngTemplateOutlet="prependTemplate()"></ng-template>\n  </div>\n}\n<input\n  #input\n  thyInput\n  [thySize]="thySize()"\n  [thyAutofocus]="thyAutofocus()"\n  [type]="type()"\n  [placeholder]="placeholder()"\n  [disabled]="disabled()"\n  [(ngModel)]="value"\n  (ngModelChange)="onModelChange()"\n  (focus)="onInputFocus($event)"\n  (blur)="onInputBlur($event)"\n  [readonly]="readonly()" />\n<span class="input-label input-label-{{ thySize() }}" [class.active]="showLabel()">{{ thyLabelText() }}</span>\n\n@if (isPasswordType() || appendTemplate()) {\n  <div #append class="input-append">\n    @if (isPasswordType()) {\n      <a href="javascript:;" class="link-secondary input-password-icon" (click)="togglePasswordType()">\n        @if (isPassword(type())) {\n          <thy-icon thyIconName="eye"></thy-icon>\n        }\n        @if (!isPassword(type())) {\n          <thy-icon thyIconName="eye-invisible"></thy-icon>\n        }\n      </a>\n    } @else {\n      <ng-template *ngTemplateOutlet="appendTemplate()"></ng-template>\n    }\n  </div>\n}\n'
    }]
  }], () => [], {
    placeholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "placeholder",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyAutofocus: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutofocus",
        required: false
      }]
    }],
    thyType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyType",
        required: false
      }]
    }],
    _type: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "type",
        required: false
      }]
    }],
    thyLabelText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyLabelText",
        required: false
      }]
    }],
    readonly: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "readonly",
        required: false
      }]
    }],
    focus: [{
      type: Output,
      args: ["focus"]
    }],
    blur: [{
      type: Output,
      args: ["blur"]
    }],
    appendTemplate: [{
      type: ContentChild,
      args: ["append", {
        isSignal: true
      }]
    }],
    prependTemplate: [{
      type: ContentChild,
      args: ["prepend", {
        isSignal: true
      }]
    }]
  });
})();
var inputGroupSizeMap = {
  sm: ["input-group-sm"],
  lg: ["input-group-lg"],
  md: ["input-group-md"]
};
var ThyInputGroup = class _ThyInputGroup {
  constructor() {
    this.thyTranslate = inject(ThyTranslate);
    this.ngZone = inject(NgZone);
    this.hostRenderer = useHostRenderer();
    this.hostFocusControl = useHostFocusControl();
    this.destroyRef = inject(DestroyRef);
    this.isTextareaSuffix = signal(false, ...ngDevMode ? [{
      debugName: "isTextareaSuffix"
    }] : []);
    this.hasScrollbar = signal(false, ...ngDevMode ? [{
      debugName: "hasScrollbar"
    }] : []);
    this.disabled = signal(false, ...ngDevMode ? [{
      debugName: "disabled"
    }] : []);
    this.thyAppendText = input(...ngDevMode ? [void 0, {
      debugName: "thyAppendText"
    }] : []);
    this.thyAppendTextTranslateKey = input(...ngDevMode ? [void 0, {
      debugName: "thyAppendTextTranslateKey"
    }] : []);
    this.thyPrependText = input(...ngDevMode ? [void 0, {
      debugName: "thyPrependText"
    }] : []);
    this.thyPrependTextTranslateKey = input(...ngDevMode ? [void 0, {
      debugName: "thyPrependTextTranslateKey"
    }] : []);
    this.prependText = computed(() => {
      const prependTextTranslateKey = this.thyPrependTextTranslateKey();
      if (prependTextTranslateKey) {
        return this.thyTranslate.instant(prependTextTranslateKey);
      }
      return this.thyPrependText();
    }, ...ngDevMode ? [{
      debugName: "prependText"
    }] : []);
    this.appendText = computed(() => {
      const appendTextTranslateKey = this.thyAppendTextTranslateKey();
      if (appendTextTranslateKey) {
        return this.thyTranslate.instant(appendTextTranslateKey);
      }
      return this.thyAppendText();
    }, ...ngDevMode ? [{
      debugName: "appendText"
    }] : []);
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.appendTemplate = contentChild("append", ...ngDevMode ? [{
      debugName: "appendTemplate"
    }] : []);
    this.prependTemplate = contentChild("prepend", ...ngDevMode ? [{
      debugName: "prependTemplate"
    }] : []);
    this.prefixTemplate = contentChild("prefix", ...ngDevMode ? [{
      debugName: "prefixTemplate"
    }] : []);
    this.suffixTemplate = contentChild("suffix", ...ngDevMode ? [{
      debugName: "suffixTemplate"
    }] : []);
    this.inputDirective = contentChild(ThyInputDirective, ...ngDevMode ? [{
      debugName: "inputDirective"
    }] : []);
    this.disabledObservable = null;
    effect(() => {
      const size = this.thySize();
      if (size && inputGroupSizeMap[size]) {
        this.hostRenderer.updateClass(inputGroupSizeMap[size]);
      } else {
        this.hostRenderer.updateClass([]);
      }
    });
    effect(() => {
      const inputDirective = this.inputDirective();
      if (inputDirective?.nativeElement) {
        this.isTextareaSuffix.set(inputDirective?.nativeElement?.tagName === "TEXTAREA");
        if (this.isTextareaSuffix()) {
          this.determineHasScrollbar();
        }
      }
    });
    effect(() => {
      const inputDirective = this.inputDirective();
      this.disabledObservable?.disconnect();
      if (inputDirective?.nativeElement) {
        this.disabledObservable = new MutationObserverFactory().create((mutations) => {
          for (const mutation of mutations) {
            if (mutation.type === "attributes" && mutation.attributeName === "disabled") {
              this.disabled.set(!!inputDirective.nativeElement.hasAttribute("disabled"));
            }
          }
        });
        if (this.disabledObservable) {
          this.disabledObservable.observe(inputDirective.nativeElement, {
            attributes: true,
            attributeFilter: ["disabled"]
          });
        }
      }
    });
  }
  ngOnInit() {
    this.hostFocusControl.focusChanged = (origin) => {
      if (origin) {
        this.hostRenderer.addClass("form-control-active");
      } else {
        this.hostRenderer.removeClass("form-control-active");
      }
    };
  }
  determineHasScrollbar() {
    this.ngZone.runOutsideAngular(() => {
      this.resizeObserver(this.inputDirective().nativeElement).pipe(throttleTime(100), takeUntilDestroyed(this.destroyRef)).subscribe(() => {
        const hasScrollbar = this.inputDirective().nativeElement.scrollHeight > this.inputDirective().nativeElement.clientHeight;
        if (this.hasScrollbar() !== hasScrollbar) {
          this.ngZone.run(() => {
            this.hasScrollbar.set(hasScrollbar);
          });
        }
      });
    });
  }
  resizeObserver(element) {
    return typeof ResizeObserver === "undefined" || !ResizeObserver ? of(null) : new Observable((observer) => {
      const resize = new ResizeObserver((entries) => {
        observer.next(entries);
      });
      resize.observe(element);
      return () => {
        resize.disconnect();
      };
    });
  }
  ngOnDestroy() {
    this.hostFocusControl.destroy();
  }
  static {
    this.\u0275fac = function ThyInputGroup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInputGroup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyInputGroup,
      selectors: [["thy-input-group"]],
      contentQueries: function ThyInputGroup_ContentQueries(rf, ctx, dirIndex) {
        if (rf & 1) {
          \u0275\u0275contentQuerySignal(dirIndex, ctx.appendTemplate, _c016, 5)(dirIndex, ctx.prependTemplate, _c18, 5)(dirIndex, ctx.prefixTemplate, _c25, 5)(dirIndex, ctx.suffixTemplate, _c34, 5)(dirIndex, ctx.inputDirective, ThyInputDirective, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(5);
        }
      },
      hostAttrs: [1, "thy-input-group"],
      hostVars: 12,
      hostBindings: function ThyInputGroup_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("form-control", ctx.prefixTemplate() || ctx.suffixTemplate())("thy-input-group-with-prefix", ctx.prefixTemplate())("thy-input-group-with-suffix", ctx.suffixTemplate())("thy-input-group-with-textarea-suffix", ctx.isTextareaSuffix())("thy-input-group-with-scroll-bar", ctx.isTextareaSuffix() && ctx.hasScrollbar())("disabled", ctx.disabled());
        }
      },
      inputs: {
        thyAppendText: [1, "thyAppendText"],
        thyAppendTextTranslateKey: [1, "thyAppendTextTranslateKey"],
        thyPrependText: [1, "thyPrependText"],
        thyPrependTextTranslateKey: [1, "thyPrependTextTranslateKey"],
        thySize: [1, "thySize"]
      },
      ngContentSelectors: _c44,
      decls: 7,
      vars: 6,
      consts: [[1, "input-group-prepend"], [1, "input-group-prefix"], [1, "input-group-append"], [1, "input-group-suffix"], [1, "input-group-text"], [4, "ngTemplateOutlet"]],
      template: function ThyInputGroup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275conditionalCreate(0, ThyInputGroup_Conditional_0_Template, 3, 1, "div", 0);
          \u0275\u0275conditionalCreate(1, ThyInputGroup_Conditional_1_Template, 2, 1, "div", 0);
          \u0275\u0275conditionalCreate(2, ThyInputGroup_Conditional_2_Template, 2, 1, "div", 1);
          \u0275\u0275projection(3);
          \u0275\u0275conditionalCreate(4, ThyInputGroup_Conditional_4_Template, 3, 1, "div", 2);
          \u0275\u0275conditionalCreate(5, ThyInputGroup_Conditional_5_Template, 2, 1, "div", 2);
          \u0275\u0275conditionalCreate(6, ThyInputGroup_Conditional_6_Template, 2, 1, "div", 3);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.prependText() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.prependTemplate() ? 1 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.prefixTemplate() ? 2 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.appendText() ? 4 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.appendTemplate() ? 5 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.suffixTemplate() ? 6 : -1);
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInputGroup, [{
    type: Component,
    args: [{
      selector: "thy-input-group",
      changeDetection: ChangeDetectionStrategy.OnPush,
      encapsulation: ViewEncapsulation.None,
      host: {
        class: "thy-input-group",
        "[class.form-control]": "prefixTemplate() || suffixTemplate()",
        "[class.thy-input-group-with-prefix]": "prefixTemplate()",
        "[class.thy-input-group-with-suffix]": "suffixTemplate()",
        "[class.thy-input-group-with-textarea-suffix]": "isTextareaSuffix()",
        "[class.thy-input-group-with-scroll-bar]": "isTextareaSuffix() && hasScrollbar()",
        "[class.disabled]": "disabled()"
      },
      imports: [NgTemplateOutlet],
      template: '@if (prependText()) {\n  <div class="input-group-prepend">\n    <span class="input-group-text">{{ prependText() }}</span>\n  </div>\n}\n@if (prependTemplate()) {\n  <div class="input-group-prepend">\n    <ng-template *ngTemplateOutlet="prependTemplate()"></ng-template>\n  </div>\n}\n\n@if (prefixTemplate()) {\n  <div class="input-group-prefix">\n    <ng-template *ngTemplateOutlet="prefixTemplate()"></ng-template>\n  </div>\n}\n\n<ng-content></ng-content>\n\n@if (appendText()) {\n  <div class="input-group-append">\n    <span class="input-group-text">{{ appendText() }}</span>\n  </div>\n}\n@if (appendTemplate()) {\n  <div class="input-group-append">\n    <ng-template *ngTemplateOutlet="appendTemplate()"></ng-template>\n  </div>\n}\n\n@if (suffixTemplate()) {\n  <div class="input-group-suffix">\n    <ng-template *ngTemplateOutlet="suffixTemplate()"></ng-template>\n  </div>\n}\n'
    }]
  }], () => [], {
    thyAppendText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAppendText",
        required: false
      }]
    }],
    thyAppendTextTranslateKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAppendTextTranslateKey",
        required: false
      }]
    }],
    thyPrependText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPrependText",
        required: false
      }]
    }],
    thyPrependTextTranslateKey: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPrependTextTranslateKey",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    appendTemplate: [{
      type: ContentChild,
      args: ["append", {
        isSignal: true
      }]
    }],
    prependTemplate: [{
      type: ContentChild,
      args: ["prepend", {
        isSignal: true
      }]
    }],
    prefixTemplate: [{
      type: ContentChild,
      args: ["prefix", {
        isSignal: true
      }]
    }],
    suffixTemplate: [{
      type: ContentChild,
      args: ["suffix", {
        isSignal: true
      }]
    }],
    inputDirective: [{
      type: ContentChild,
      args: [forwardRef(() => ThyInputDirective), {
        isSignal: true
      }]
    }]
  });
})();
var CUSTOM_INPUT_SEARCH_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ThyInputSearch),
  multi: true
};
var _MixinBase2 = mixinInitialized(mixinTabIndex(mixinDisabled(AbstractControlValueAccessor)));
var ThyInputSearch = class _ThyInputSearch extends _MixinBase2 {
  constructor() {
    super();
    this.elementRef = inject(ElementRef);
    this.inputElement = viewChild.required("input");
    this.hostRenderer = useHostRenderer();
    this.hostFocusControl = useHostFocusControl();
    this.disabled = signal(false, ...ngDevMode ? [{
      debugName: "disabled"
    }] : []);
    this.searchText = signal("", ...ngDevMode ? [{
      debugName: "searchText"
    }] : []);
    this.focused = signal(false, ...ngDevMode ? [{
      debugName: "focused"
    }] : []);
    this.name = input("", ...ngDevMode ? [{
      debugName: "name"
    }] : []);
    this.placeholder = input("", ...ngDevMode ? [{
      debugName: "placeholder"
    }] : []);
    this.thyTheme = input(...ngDevMode ? [void 0, {
      debugName: "thyTheme"
    }] : []);
    this.autoFocus = input(false, ...ngDevMode ? [{
      debugName: "autoFocus",
      alias: "thySearchFocus",
      transform: coerceBooleanProperty2
    }] : [{
      alias: "thySearchFocus",
      transform: coerceBooleanProperty2
    }]);
    this.iconPosition = input("before", ...ngDevMode ? [{
      debugName: "iconPosition",
      alias: "thyIconPosition",
      transform: (value) => value || "before"
    }] : [{
      alias: "thyIconPosition",
      transform: (value) => value || "before"
    }]);
    this.thySize = input(...ngDevMode ? [void 0, {
      debugName: "thySize"
    }] : []);
    this.clear = output();
    this.thyClear = output();
    effect(() => {
      this.focused.set(this.autoFocus());
    });
    effect(() => {
      const iconPosition = this.iconPosition();
      this.hostRenderer.updateClass([`thy-input-search-${iconPosition}`]);
    });
  }
  ngOnInit() {
    super.ngOnInit();
    this.hostFocusControl.focusChanged = (origin) => {
      if (this.disabled()) {
        return;
      }
      if (origin) {
        if (!this.focused()) {
          this.inputElement().nativeElement.focus();
        }
      } else {
        if (this.focused()) {
          this.focused.set(false);
          this.onTouchedFn();
        }
      }
    };
  }
  writeValue(value) {
    this.searchText.set(value);
  }
  setDisabledState(isDisabled) {
    this.disabled.set(isDisabled);
  }
  searchModelChange() {
    this.onChangeFn(this.searchText());
  }
  clearSearchText(event) {
    const element = this.elementRef.nativeElement.querySelector(".input-search-control");
    element.focus();
    event.stopPropagation();
    if (this.disabled()) {
      return;
    }
    this.searchText.set("");
    this.onChangeFn(this.searchText());
    this.clear.emit(event);
    this.thyClear.emit(event);
  }
  ngOnDestroy() {
    this.hostFocusControl.destroy();
  }
  static {
    this.\u0275fac = function ThyInputSearch_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInputSearch)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyInputSearch,
      selectors: [["thy-input-search"]],
      viewQuery: function ThyInputSearch_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.inputElement, _c53, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: [1, "thy-input", "form-control", "thy-input-search"],
      hostVars: 9,
      hostBindings: function ThyInputSearch_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("tabindex", ctx.tabIndex);
          \u0275\u0275classProp("thy-input-search-ellipse", ctx.thyTheme() === "ellipse")("thy-input-search-transparent", ctx.thyTheme() === "transparent")("thy-input-search-before-with-clear", ctx.searchText() && ctx.iconPosition() === "before")("form-control-active", ctx.focused());
        }
      },
      inputs: {
        name: [1, "name"],
        placeholder: [1, "placeholder"],
        thyTheme: [1, "thyTheme"],
        autoFocus: [1, "thySearchFocus", "autoFocus"],
        iconPosition: [1, "thyIconPosition", "iconPosition"],
        thySize: [1, "thySize"]
      },
      outputs: {
        clear: "clear",
        thyClear: "thyClear"
      },
      features: [\u0275\u0275ProvidersFeature([CUSTOM_INPUT_SEARCH_CONTROL_VALUE_ACCESSOR]), \u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 9,
      consts: [["input", ""], ["thyIconName", "search", 1, "input-prepend"], ["thyInput", "", "tabindex", "-1", 1, "input-search-control", 3, "ngModelChange", "focus", "name", "placeholder", "disabled", "thyAutofocus", "ngModel", "thySize"], [1, "input-append", "input-append-divider"], ["href", "javascript:;", 1, "close", "input-append"], ["href", "javascript:;", 1, "close"], ["thyIconName", "search", 1, "text-placeholder"], ["href", "javascript:;", 1, "close", 3, "click"], ["thyIconName", "close"], ["href", "javascript:;", 1, "close", "input-append", 3, "click"]],
      template: function ThyInputSearch_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275conditionalCreate(0, ThyInputSearch_Conditional_0_Template, 1, 0, "thy-icon", 1);
          \u0275\u0275elementStart(1, "input", 2, 0);
          \u0275\u0275twoWayListener("ngModelChange", function ThyInputSearch_Template_input_ngModelChange_1_listener($event) {
            \u0275\u0275restoreView(_r1);
            \u0275\u0275twoWayBindingSet(ctx.searchText, $event) || (ctx.searchText = $event);
            return \u0275\u0275resetView($event);
          });
          \u0275\u0275listener("ngModelChange", function ThyInputSearch_Template_input_ngModelChange_1_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.searchModelChange());
          })("focus", function ThyInputSearch_Template_input_focus_1_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(!ctx.focused() ? ctx.focused.set(true) : null);
          });
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(3, ThyInputSearch_Conditional_3_Template, 3, 1, "div", 3);
          \u0275\u0275conditionalCreate(4, ThyInputSearch_Conditional_4_Template, 2, 0, "a", 4);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.iconPosition() === "before" ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275property("name", ctx.name())("placeholder", ctx.placeholder())("disabled", ctx.disabled())("thyAutofocus", ctx.autoFocus());
          \u0275\u0275twoWayProperty("ngModel", ctx.searchText);
          \u0275\u0275property("thySize", ctx.thySize());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.iconPosition() === "after" ? 3 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.searchText() && ctx.iconPosition() === "before" ? 4 : -1);
        }
      },
      dependencies: [ThyIcon, ThyInputDirective, ThyAutofocusDirective, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInputSearch, [{
    type: Component,
    args: [{
      selector: "thy-input-search",
      providers: [CUSTOM_INPUT_SEARCH_CONTROL_VALUE_ACCESSOR],
      encapsulation: ViewEncapsulation.None,
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-input form-control thy-input-search",
        "[class.thy-input-search-ellipse]": 'thyTheme() === "ellipse"',
        "[class.thy-input-search-transparent]": 'thyTheme() === "transparent"',
        "[class.thy-input-search-before-with-clear]": 'searchText() && iconPosition() === "before"',
        "[class.form-control-active]": "focused()",
        "[attr.tabindex]": "tabIndex"
      },
      imports: [ThyIcon, ThyInputDirective, ThyAutofocusDirective, FormsModule],
      template: `@if (iconPosition() === 'before') {
  <thy-icon class="input-prepend" thyIconName="search"></thy-icon>
}
<input
  class="input-search-control"
  #input
  thyInput
  [name]="name()"
  [placeholder]="placeholder()"
  [disabled]="disabled()"
  [thyAutofocus]="autoFocus()"
  [(ngModel)]="searchText"
  (ngModelChange)="searchModelChange()"
  (focus)="!focused() ? focused.set(true) : null"
  [thySize]="thySize()"
  tabindex="-1" />
@if (iconPosition() === 'after') {
  <div class="input-append input-append-divider">
    @if (searchText()) {
      <a class="close" href="javascript:;" (click)="clearSearchText($event)">
        <thy-icon thyIconName="close"></thy-icon>
      </a>
    } @else {
      <thy-icon class="text-placeholder" thyIconName="search"></thy-icon>
    }
  </div>
}

@if (searchText() && iconPosition() === 'before') {
  <a class="close input-append" href="javascript:;" (click)="clearSearchText($event)">
    <thy-icon thyIconName="close"></thy-icon>
  </a>
}
`
    }]
  }], () => [], {
    inputElement: [{
      type: ViewChild,
      args: ["input", {
        isSignal: true
      }]
    }],
    name: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "name",
        required: false
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "placeholder",
        required: false
      }]
    }],
    thyTheme: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTheme",
        required: false
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySearchFocus",
        required: false
      }]
    }],
    iconPosition: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyIconPosition",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    clear: [{
      type: Output,
      args: ["clear"]
    }],
    thyClear: [{
      type: Output,
      args: ["thyClear"]
    }]
  });
})();
var ThyInputCount = class _ThyInputCount {
  constructor() {
    this.inputGroup = inject(ThyInputGroup, {
      optional: true
    });
    this.destroyRef = inject(DestroyRef);
    this.hasInput = false;
    this.thyInput = input(...ngDevMode ? [void 0, {
      debugName: "thyInput"
    }] : []);
    this.maxLength = signal(null, ...ngDevMode ? [{
      debugName: "maxLength"
    }] : []);
    this.inputLength = signal(0, ...ngDevMode ? [{
      debugName: "inputLength"
    }] : []);
    this.thyInput$ = new Subject();
    this.setup();
    effect(() => {
      const input2 = this.thyInput();
      if (input2) {
        this.hasInput = true;
        this.thyInput$.next(input2);
      }
    });
  }
  setup() {
    this.thyInput$.pipe(filter((input2) => {
      return !!input2;
    }), tap((input2) => {
      this.maxLength.set(input2?.nativeElement?.getAttribute("maxlength"));
    }), takeUntilDestroyed(this.destroyRef), switchMap((input2) => {
      return input2.ngControl.valueChanges;
    }), tap((value) => {
      this.inputLength.set(value?.length || 0);
    }), takeUntilDestroyed(this.destroyRef)).subscribe();
  }
  ngOnInit() {
    const inputDirective = this.inputGroup.inputDirective();
    if (!this.hasInput && this.inputGroup && inputDirective) {
      this.thyInput$.next(inputDirective);
    }
  }
  static {
    this.\u0275fac = function ThyInputCount_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInputCount)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyInputCount,
      selectors: [["thy-input-count"]],
      hostAttrs: [1, "thy-input-count", "text-muted"],
      inputs: {
        thyInput: [1, "thyInput"]
      },
      decls: 1,
      vars: 2,
      template: function ThyInputCount_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275text(0);
        }
        if (rf & 2) {
          \u0275\u0275textInterpolate2("", ctx.inputLength(), " / ", ctx.maxLength());
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInputCount, [{
    type: Component,
    args: [{
      selector: "thy-input-count",
      template: "{{inputLength()}} / {{maxLength()}}",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "thy-input-count text-muted"
      }
    }]
  }], () => [], {
    thyInput: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyInput",
        required: false
      }]
    }]
  });
})();
var ThyInputModule = class _ThyInputModule {
  static {
    this.\u0275fac = function ThyInputModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInputModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyInputModule,
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyDividerModule, ThyInputDirective, ThyInput, ThyInputGroup, ThyInputSearch, ThyInputCount],
      exports: [ThyInputDirective, ThyInput, ThyInputGroup, ThyInputSearch, ThyInputCount]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyDividerModule, ThyInput, ThyInputSearch]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInputModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyDividerModule, ThyInputDirective, ThyInput, ThyInputGroup, ThyInputSearch, ThyInputCount],
      exports: [ThyInputDirective, ThyInput, ThyInputGroup, ThyInputSearch, ThyInputCount]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-time-picker.mjs
function ThyInnerTimePicker_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0\xA0\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td")(1, "a", 1);
    \u0275\u0275domListener("click", function ThyInnerTimePicker_Conditional_7_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeMinutes(ctx_r1.minuteStep()));
    });
    \u0275\u0275domElement(2, "span", 2);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("disabled", !ctx_r1.canIncrementMinutes || !ctx_r1.isEditable());
  }
}
function ThyInnerTimePicker_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td")(1, "a", 1);
    \u0275\u0275domListener("click", function ThyInnerTimePicker_Conditional_9_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeSeconds(ctx_r1.secondsStep()));
    });
    \u0275\u0275domElement(2, "span", 2);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("disabled", !ctx_r1.canIncrementSeconds || !ctx_r1.isEditable());
  }
}
function ThyInnerTimePicker_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0\xA0\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElement(0, "td");
  }
}
function ThyInnerTimePicker_Conditional_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0:\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td", 3)(1, "input", 4);
    \u0275\u0275domListener("wheel", function ThyInnerTimePicker_Conditional_16_Template_input_wheel_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.prevDef($event);
      return \u0275\u0275resetView(ctx_r1.changeMinutes(ctx_r1.minuteStep() * ctx_r1.wheelSign($event), "wheel"));
    })("keydown.ArrowUp", function ThyInnerTimePicker_Conditional_16_Template_input_keydown_ArrowUp_1_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeMinutes(ctx_r1.minuteStep(), "key"));
    })("keydown.ArrowDown", function ThyInnerTimePicker_Conditional_16_Template_input_keydown_ArrowDown_1_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeMinutes(-ctx_r1.minuteStep(), "key"));
    })("change", function ThyInnerTimePicker_Conditional_16_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateMinutes($event.target.value));
    });
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("has-error", ctx_r1.invalidMinutes);
    \u0275\u0275advance();
    \u0275\u0275classProp("is-invalid", ctx_r1.invalidMinutes);
    \u0275\u0275domProperty("placeholder", ctx_r1.minutesPlaceholder())("readOnly", ctx_r1.readonlyInput())("disabled", ctx_r1.disabled())("value", ctx_r1.minutes);
  }
}
function ThyInnerTimePicker_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0:\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td", 3)(1, "input", 4);
    \u0275\u0275domListener("wheel", function ThyInnerTimePicker_Conditional_18_Template_input_wheel_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      ctx_r1.prevDef($event);
      return \u0275\u0275resetView(ctx_r1.changeSeconds(ctx_r1.secondsStep() * ctx_r1.wheelSign($event), "wheel"));
    })("keydown.ArrowUp", function ThyInnerTimePicker_Conditional_18_Template_input_keydown_ArrowUp_1_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeSeconds(ctx_r1.secondsStep(), "key"));
    })("keydown.ArrowDown", function ThyInnerTimePicker_Conditional_18_Template_input_keydown_ArrowDown_1_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeSeconds(-ctx_r1.secondsStep(), "key"));
    })("change", function ThyInnerTimePicker_Conditional_18_Template_input_change_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.updateSeconds($event.target.value));
    });
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275classProp("has-error", ctx_r1.invalidSeconds);
    \u0275\u0275advance();
    \u0275\u0275classProp("is-invalid", ctx_r1.invalidSeconds);
    \u0275\u0275domProperty("placeholder", ctx_r1.secondsPlaceholder())("readOnly", ctx_r1.readonlyInput())("disabled", ctx_r1.disabled())("value", ctx_r1.seconds);
  }
}
function ThyInnerTimePicker_Conditional_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0\xA0\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_20_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td")(1, "button", 7);
    \u0275\u0275domListener("click", function ThyInnerTimePicker_Conditional_20_Template_button_click_1_listener() {
      \u0275\u0275restoreView(_r6);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleMeridian());
    });
    \u0275\u0275text(2);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("disabled", !ctx_r1.isEditable() || !ctx_r1.canToggleMeridian);
    \u0275\u0275domProperty("disabled", !ctx_r1.isEditable() || !ctx_r1.canToggleMeridian);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r1.meridian, " ");
  }
}
function ThyInnerTimePicker_Conditional_25_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0\xA0\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_26_Template(rf, ctx) {
  if (rf & 1) {
    const _r7 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td")(1, "a", 1);
    \u0275\u0275domListener("click", function ThyInnerTimePicker_Conditional_26_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r7);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeMinutes(-ctx_r1.minuteStep()));
    });
    \u0275\u0275domElement(2, "span", 6);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("disabled", !ctx_r1.canDecrementMinutes || !ctx_r1.isEditable());
  }
}
function ThyInnerTimePicker_Conditional_27_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_28_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "td")(1, "a", 1);
    \u0275\u0275domListener("click", function ThyInnerTimePicker_Conditional_28_Template_a_click_1_listener() {
      \u0275\u0275restoreView(_r8);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.changeSeconds(-ctx_r1.secondsStep()));
    });
    \u0275\u0275domElement(2, "span", 6);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275classProp("disabled", !ctx_r1.canDecrementSeconds || !ctx_r1.isEditable());
  }
}
function ThyInnerTimePicker_Conditional_29_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElementStart(0, "td");
    \u0275\u0275text(1, "\xA0\xA0\xA0");
    \u0275\u0275domElementEnd();
  }
}
function ThyInnerTimePicker_Conditional_30_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElement(0, "td");
  }
}
var _c017 = ["hourListElement"];
var _c19 = ["minuteListElement"];
var _c26 = ["secondListElement"];
function ThyTimePanel_Conditional_1_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 5);
    \u0275\u0275listener("click", function ThyTimePanel_Conditional_1_For_3_Template_li_click_0_listener() {
      const ctx_r1 = \u0275\u0275restoreView(_r1);
      const time_r3 = ctx_r1.$implicit;
      const \u0275$index_6_r4 = ctx_r1.$index;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.pickHours(time_r3, \u0275$index_6_r4));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const time_r3 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell"));
    \u0275\u0275classProp("thy-time-picker-panel-time-column-cell-selected", ctx_r4.hour === time_r3.value);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 9, time_r3.value, "2.0-0"));
  }
}
function ThyTimePanel_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", null, 0);
    \u0275\u0275repeaterCreate(2, ThyTimePanel_Conditional_1_For_3_Template, 4, 12, "li", 4, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate2("", ctx_r4.prefixCls, "-time-column ", ctx_r4.prefixCls, "-hour-column"));
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r4.hourRange);
  }
}
function ThyTimePanel_Conditional_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 5);
    \u0275\u0275listener("click", function ThyTimePanel_Conditional_2_For_3_Template_li_click_0_listener() {
      const ctx_r6 = \u0275\u0275restoreView(_r6);
      const time_r8 = ctx_r6.$implicit;
      const \u0275$index_16_r9 = ctx_r6.$index;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.pickMinutes(time_r8, \u0275$index_16_r9));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const time_r8 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell"));
    \u0275\u0275classProp("thy-time-picker-panel-time-column-cell-selected", ctx_r4.minute === time_r8.value);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 9, time_r8.value, "2.0-0"));
  }
}
function ThyTimePanel_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", null, 1);
    \u0275\u0275repeaterCreate(2, ThyTimePanel_Conditional_2_For_3_Template, 4, 12, "li", 4, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate2("", ctx_r4.prefixCls, "-time-column ", ctx_r4.prefixCls, "-minute-column"));
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r4.minuteRange);
  }
}
function ThyTimePanel_Conditional_3_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "li", 5);
    \u0275\u0275listener("click", function ThyTimePanel_Conditional_3_For_3_Template_li_click_0_listener() {
      const ctx_r10 = \u0275\u0275restoreView(_r10);
      const time_r12 = ctx_r10.$implicit;
      const \u0275$index_26_r13 = ctx_r10.$index;
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.pickSeconds(time_r12, \u0275$index_26_r13));
    });
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275pipe(3, "number");
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const time_r12 = ctx.$implicit;
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell"));
    \u0275\u0275classProp("thy-time-picker-panel-time-column-cell-selected", ctx_r4.second === time_r12.value);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-column-cell-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind2(3, 9, time_r12.value, "2.0-0"));
  }
}
function ThyTimePanel_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "ul", null, 2);
    \u0275\u0275repeaterCreate(2, ThyTimePanel_Conditional_3_For_3_Template, 4, 12, "li", 4, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate2("", ctx_r4.prefixCls, "-time-column ", ctx_r4.prefixCls, "-second-column"));
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r4.secondRange);
  }
}
function ThyTimePanel_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r15 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275listener("click", function ThyTimePanel_Conditional_4_Conditional_1_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r15);
      const ctx_r4 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r4.selectNow());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-now"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r4.locale().now);
  }
}
function ThyTimePanel_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r14 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275conditionalCreate(1, ThyTimePanel_Conditional_4_Conditional_1_Template, 2, 4, "a", 6);
    \u0275\u0275elementStart(2, "button", 7);
    \u0275\u0275listener("click", function ThyTimePanel_Conditional_4_Template_button_click_2_listener() {
      \u0275\u0275restoreView(_r14);
      const ctx_r4 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r4.confirmPickTime());
    });
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-bottom-operation"));
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r4.thyShowSelectNow() ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r4.prefixCls, "-time-confirm"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r4.locale().ok, " ");
  }
}
var _c35 = ["origin"];
var _c45 = ["pickerInput"];
var _c54 = ["overlayContainer"];
function ThyTimePicker_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyTimePicker_ng_template_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span")(1, "thy-icon", 10);
    \u0275\u0275listener("click", function ThyTimePicker_ng_template_6_Conditional_0_Template_thy_icon_click_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onClearTime($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-clear"));
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275interpolate1("remove-link remove-link-", ctx_r2.thySize()));
  }
}
function ThyTimePicker_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, ThyTimePicker_ng_template_6_Conditional_0_Template, 2, 5, "span", 8);
    \u0275\u0275elementStart(1, "span");
    \u0275\u0275element(2, "thy-icon", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(!ctx_r2.thyDisabled() && ctx_r2.thyAllowClear() && !ctx_r2.thyReadonly() && ctx_r2.showText() ? 0 : -1);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-icon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275interpolate1("remove-link-", ctx_r2.thySize()))("thyIconName", "clock-circle-moment");
  }
}
function ThyTimePicker_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 11, 3)(2, "thy-time-picker-panel", 12);
    \u0275\u0275twoWayListener("ngModelChange", function ThyTimePicker_ng_template_8_Template_thy_time_picker_panel_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.value, $event) || (ctx_r2.value = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function ThyTimePicker_ng_template_8_Template_thy_time_picker_panel_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onPickTimeConfirm($event));
    })("thyPickChange", function ThyTimePicker_ng_template_8_Template_thy_time_picker_panel_thyPickChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onPickTime($event));
    })("thyClosePanel", function ThyTimePicker_ng_template_8_Template_thy_time_picker_panel_thyClosePanel_2_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.closeOverlay());
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("@scaleXMotion", ctx_r2.thyPlacement() === "left" || ctx_r2.thyPlacement() === "right" ? "enter" : "void")("@scaleYMotion", ctx_r2.thyPlacement() === "top" || ctx_r2.thyPlacement() === "bottom" ? "enter" : "void")("@scaleMotion", ctx_r2.thyPlacement() !== "left" && ctx_r2.thyPlacement() !== "right" && ctx_r2.thyPlacement() !== "top" && ctx_r2.thyPlacement() !== "bottom" ? "enter" : "void");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngClass", ctx_r2.thyPopupClass());
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.value);
    \u0275\u0275property("thyFormat", ctx_r2.thyFormat())("thyHourStep", ctx_r2.thyHourStep())("thyMinuteStep", ctx_r2.thyMinuteStep())("thySecondStep", ctx_r2.thySecondStep())("thyShowSelectNow", ctx_r2.thyShowSelectNow());
  }
}
var hoursPerDay = 24;
var hoursPerDayHalf = 12;
var minutesPerHour = 60;
var secondsPerMinute = 60;
function isValidDate(value) {
  if (!value) {
    return false;
  }
  if (value instanceof Date && isNaN(value.getHours())) {
    return false;
  }
  if (typeof value === "string") {
    return isValidDate(new TinyDate(value)?.nativeDate);
  }
  return true;
}
function isValidLimit(controls, newDate) {
  const min = isFunction(controls.min) ? controls.min() : controls.min;
  const max = isFunction(controls.max) ? controls.max() : controls.max;
  if (min && newDate < min) {
    return false;
  }
  if (max && newDate > max) {
    return false;
  }
  return true;
}
function parseHours(value, isPM = false) {
  const hour = coerceNumberProperty(value);
  if (isNaN(hour) || hour < 0 || hour > (isPM ? hoursPerDayHalf : hoursPerDay)) {
    return NaN;
  }
  return hour;
}
function parseMinutes(value) {
  const minute = coerceNumberProperty(value);
  if (isNaN(minute) || minute < 0 || minute > minutesPerHour) {
    return NaN;
  }
  return minute;
}
function parseSeconds(value) {
  const seconds = coerceNumberProperty(value);
  if (isNaN(seconds) || seconds < 0 || seconds > secondsPerMinute) {
    return NaN;
  }
  return seconds;
}
function parseTime2(value, timeZone) {
  if (typeof value === "string") {
    return new TinyDate(value, timeZone)?.nativeDate;
  } else if (value instanceof TinyDate) {
    return value?.nativeDate;
  } else {
    return new TinyDate(value, timeZone)?.nativeDate;
  }
}
function changeTime(value, diff, timeZone) {
  if (!value) {
    return changeTime(createDate(new TinyDate(void 0, timeZone)?.nativeDate, 0, 0, 0), diff, timeZone);
  }
  let hour = value.getHours();
  let minutes = value.getMinutes();
  let seconds = value.getSeconds();
  if (diff.hour) {
    hour = (hour + coerceNumberProperty(diff.hour)) % hoursPerDay;
    if (hour < 0) {
      hour += hoursPerDay;
    }
  }
  if (diff.minute) {
    minutes = minutes + coerceNumberProperty(diff.minute);
  }
  if (diff.seconds) {
    seconds = seconds + coerceNumberProperty(diff.seconds);
  }
  return createDate(value, hour, minutes, seconds, timeZone);
}
function setTime(value, opts, timeZone) {
  let hour = parseHours(opts.hour);
  const minute = parseMinutes(opts.minute);
  const seconds = parseSeconds(opts.seconds) || 0;
  if (opts.isPM && hour !== 12) {
    hour += hoursPerDayHalf;
  }
  if (!value) {
    if (!isNaN(hour) && !isNaN(minute)) {
      return createDate(new TinyDate(void 0, timeZone)?.nativeDate, hour, minute, seconds, timeZone);
    }
    return value;
  }
  if (isNaN(hour) || isNaN(minute)) {
    return value;
  }
  return createDate(value, hour, minute, seconds, timeZone);
}
function createDate(value, hours, minutes, seconds, timeZone) {
  return new TinyDate(value, timeZone).setHours(hours).setMinutes(minutes).setSeconds(seconds).nativeDate;
}
function padNumber(value) {
  const _value = value.toString();
  if (_value.length > 1) {
    return _value;
  }
  return `0${_value}`;
}
function isHourInputValid(hours, isPM) {
  return !isNaN(parseHours(hours, isPM));
}
function isMinuteInputValid(minutes) {
  return !isNaN(parseMinutes(minutes));
}
function isSecondInputValid(seconds) {
  return !isNaN(parseSeconds(seconds));
}
function isInputLimitValid(diff, max, min, timeZone) {
  const newDate = setTime(new TinyDate(void 0, timeZone)?.nativeDate, diff, timeZone);
  if (max && newDate > max) {
    return false;
  }
  if (min && newDate < min) {
    return false;
  }
  return true;
}
function isInputValid(hours, minutes = "0", seconds = "0", isPM) {
  return isHourInputValid(hours, isPM) && isMinuteInputValid(minutes) && isSecondInputValid(seconds);
}
function canChangeValue(state2, event) {
  const mousewheel = state2.mousewheel();
  const arrowKeys = state2.arrowKeys();
  const readonlyInput = state2.readonlyInput();
  const disabled = state2.disabled();
  if (readonlyInput || disabled) {
    return false;
  }
  if (event) {
    if (event.source === "wheel" && !mousewheel) {
      return false;
    }
    if (event.source === "key" && !arrowKeys) {
      return false;
    }
  }
  return true;
}
function canChangeHours(event, controls) {
  if (!event.step) {
    return false;
  }
  if (event.step > 0 && !controls.canIncrementHours) {
    return false;
  }
  if (event.step < 0 && !controls.canDecrementHours) {
    return false;
  }
  return true;
}
function canChangeMinutes(event, controls) {
  if (!event.step) {
    return false;
  }
  if (event.step > 0 && !controls.canIncrementMinutes) {
    return false;
  }
  if (event.step < 0 && !controls.canDecrementMinutes) {
    return false;
  }
  return true;
}
function canChangeSeconds(event, controls) {
  if (!event.step) {
    return false;
  }
  if (event.step > 0 && !controls.canIncrementSeconds) {
    return false;
  }
  if (event.step < 0 && !controls.canDecrementSeconds) {
    return false;
  }
  return true;
}
function getControlsValue(state2) {
  const {
    hourStep,
    minuteStep,
    secondsStep,
    readonlyInput,
    disabled,
    mousewheel,
    arrowKeys,
    showSpinners,
    showMeridian,
    showSeconds,
    meridians,
    min,
    max
  } = state2;
  return {
    hourStep,
    minuteStep,
    secondsStep,
    readonlyInput,
    disabled,
    mousewheel,
    arrowKeys,
    showSpinners,
    showMeridian,
    showSeconds,
    meridians,
    min,
    max
  };
}
function timePickerControls(value, state2) {
  const hoursPerDayHalf2 = 12;
  const min = state2.min();
  const max = state2.max();
  const hourStep = state2.hourStep();
  const minuteStep = state2.minuteStep();
  const secondsStep = state2.secondsStep();
  const showSeconds = state2.showSeconds();
  const res = {
    canIncrementHours: true,
    canIncrementMinutes: true,
    canIncrementSeconds: true,
    canDecrementHours: true,
    canDecrementMinutes: true,
    canDecrementSeconds: true,
    canToggleMeridian: true
  };
  if (!value) {
    return res;
  }
  if (max) {
    const _newHour = changeTime(value, {
      hour: hourStep
    });
    res.canIncrementHours = max > _newHour;
    if (!res.canIncrementHours) {
      const _newMinutes = changeTime(value, {
        minute: minuteStep
      });
      res.canIncrementMinutes = showSeconds ? max > _newMinutes : max >= _newMinutes;
    }
    if (!res.canIncrementMinutes) {
      const _newSeconds = changeTime(value, {
        seconds: secondsStep
      });
      res.canIncrementSeconds = max >= _newSeconds;
    }
    if (value.getHours() < hoursPerDayHalf2) {
      res.canToggleMeridian = changeTime(value, {
        hour: hoursPerDayHalf2
      }) < max;
    }
  }
  if (min) {
    const _newHour = changeTime(value, {
      hour: -hourStep
    });
    res.canDecrementHours = min < _newHour;
    if (!res.canDecrementHours) {
      const _newMinutes = changeTime(value, {
        minute: -minuteStep
      });
      res.canDecrementMinutes = showSeconds ? min < _newMinutes : min <= _newMinutes;
    }
    if (!res.canDecrementMinutes) {
      const _newSeconds = changeTime(value, {
        seconds: -secondsStep
      });
      res.canDecrementSeconds = min <= _newSeconds;
    }
    if (value.getHours() >= hoursPerDayHalf2) {
      res.canToggleMeridian = changeTime(value, {
        hour: -hoursPerDayHalf2
      }) > min;
    }
  }
  return res;
}
var TimePickerConfig = class _TimePickerConfig {
  constructor() {
    this.hourStep = 1;
    this.minuteStep = 5;
    this.secondsStep = 10;
    this.showMeridian = true;
    this.meridians = ["AM", "PM"];
    this.readonlyInput = false;
    this.disabled = false;
    this.mousewheel = true;
    this.arrowKeys = true;
    this.showSpinners = true;
    this.showSeconds = false;
    this.showMinutes = true;
    this.hoursPlaceholder = "HH";
    this.minutesPlaceholder = "MM";
    this.secondsPlaceholder = "SS";
  }
  static {
    this.\u0275fac = function TimePickerConfig_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TimePickerConfig)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _TimePickerConfig,
      factory: _TimePickerConfig.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TimePickerConfig, [{
    type: Injectable
  }], null, null);
})();
var initialState = {
  value: null,
  config: new TimePickerConfig(),
  controls: {
    canIncrementHours: true,
    canIncrementMinutes: true,
    canIncrementSeconds: true,
    canDecrementHours: true,
    canDecrementMinutes: true,
    canDecrementSeconds: true,
    canToggleMeridian: true
  }
};
var ThyTimePickerStore = class _ThyTimePickerStore extends MiniStore {
  constructor() {
    super();
    this.initialize(initialState);
  }
  writeValue(value) {
    if (value?.getTime() !== this.snapshot.value?.getTime()) {
      this.setState({
        value
      });
    }
  }
  changeHours(event, timeZone) {
    const state2 = this.snapshot;
    if (!canChangeValue(state2.config, event) || !canChangeHours(event, state2.controls)) {
      return state2;
    }
    const _newTime = changeTime(state2.value, {
      hour: event.step
    }, timeZone);
    const max = state2.config.max();
    const min = state2.config.min();
    if ((max || min) && !isValidLimit(state2.config, _newTime)) {
      return state2;
    }
    this.setState({
      value: _newTime
    });
  }
  changeMinutes(event, timeZone) {
    const state2 = this.snapshot;
    if (!canChangeValue(state2.config, event) || !canChangeMinutes(event, state2.controls)) {
      return state2;
    }
    const _newTime = changeTime(state2.value, {
      minute: event.step
    }, timeZone);
    const max = state2.config.max();
    const min = state2.config.min();
    if ((max || min) && !isValidLimit(state2.config, _newTime)) {
      return state2;
    }
    this.setState({
      value: _newTime
    });
  }
  changeSeconds(event, timeZone) {
    const state2 = this.snapshot;
    if (!canChangeValue(state2.config, event) || !canChangeSeconds(event, state2.controls)) {
      return state2;
    }
    const _newTime = changeTime(state2.value, {
      seconds: event.step
    }, timeZone);
    const max = state2.config.max();
    const min = state2.config.min();
    if ((max || min) && !isValidLimit(state2.config, _newTime)) {
      return state2;
    }
    this.setState({
      value: _newTime
    });
  }
  setTime(value, timeZone) {
    const state2 = this.snapshot;
    if (!canChangeValue(state2.config)) {
      return state2;
    }
    const _newTime = setTime(state2.value, value, timeZone);
    this.setState({
      value: _newTime
    });
  }
  updateControls(value, timeZone) {
    const state2 = this.snapshot;
    const _newControlsState = timePickerControls(state2.value, value);
    const _newState = {
      value: state2.value,
      config: value,
      controls: _newControlsState
    };
    const showMeridian = isFunction(state2.config.showMeridian) ? state2.config.showMeridian() : state2.config.showMeridian;
    const newShowMeridian = isFunction(_newState.config.showMeridian) ? _newState.config.showMeridian() : _newState.config.showMeridian;
    if (showMeridian !== newShowMeridian) {
      if (state2.value) {
        _newState.value = new TinyDate(state2.value, timeZone)?.nativeDate;
      }
    }
    this.setState(_newState);
  }
  static {
    this.\u0275fac = function ThyTimePickerStore_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTimePickerStore)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyTimePickerStore,
      factory: _ThyTimePickerStore.\u0275fac
    });
  }
};
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "writeValue", null);
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, String]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "changeHours", null);
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, String]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "changeMinutes", null);
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, String]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "changeSeconds", null);
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, String]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "setTime", null);
__decorate([MiniAction(), __metadata("design:type", Function), __metadata("design:paramtypes", [Object, String]), __metadata("design:returntype", void 0)], ThyTimePickerStore.prototype, "updateControls", null);
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTimePickerStore, [{
    type: Injectable
  }], () => [], {
    writeValue: [],
    changeHours: [],
    changeMinutes: [],
    changeSeconds: [],
    setTime: [],
    updateControls: []
  });
})();
var TIMEPICKER_CONTROL_VALUE_ACCESSOR = {
  provide: NG_VALUE_ACCESSOR,
  useExisting: forwardRef(() => ThyInnerTimePicker),
  multi: true
};
var ThyInnerTimePicker = class _ThyInnerTimePicker {
  constructor() {
    this._cd = inject(ChangeDetectorRef);
    this._store = inject(ThyTimePickerStore);
    this._config = inject(TimePickerConfig);
    this.hourStep = input(this._config.hourStep, ...ngDevMode ? [{
      debugName: "hourStep"
    }] : []);
    this.minuteStep = input(this._config.minuteStep, ...ngDevMode ? [{
      debugName: "minuteStep"
    }] : []);
    this.secondsStep = input(this._config.secondsStep, ...ngDevMode ? [{
      debugName: "secondsStep"
    }] : []);
    this.readonlyInput = input(this._config.readonlyInput, ...ngDevMode ? [{
      debugName: "readonlyInput"
    }] : []);
    this.disabled = model(this._config.disabled, ...ngDevMode ? [{
      debugName: "disabled"
    }] : []);
    this.mousewheel = input(this._config.mousewheel, ...ngDevMode ? [{
      debugName: "mousewheel"
    }] : []);
    this.arrowKeys = input(this._config.arrowKeys, ...ngDevMode ? [{
      debugName: "arrowKeys"
    }] : []);
    this.showSpinners = input(this._config.showSpinners, ...ngDevMode ? [{
      debugName: "showSpinners"
    }] : []);
    this.showMeridian = input(this._config.showMeridian, ...ngDevMode ? [{
      debugName: "showMeridian"
    }] : []);
    this.showMinutes = input(this._config.showMinutes, ...ngDevMode ? [{
      debugName: "showMinutes"
    }] : []);
    this.showSeconds = input(this._config.showSeconds, ...ngDevMode ? [{
      debugName: "showSeconds"
    }] : []);
    this.meridians = input(this._config.meridians, ...ngDevMode ? [{
      debugName: "meridians"
    }] : []);
    this.min = input(this._config.min, ...ngDevMode ? [{
      debugName: "min"
    }] : []);
    this.max = input(this._config.max, ...ngDevMode ? [{
      debugName: "max"
    }] : []);
    this.hoursPlaceholder = input(this._config.hoursPlaceholder, ...ngDevMode ? [{
      debugName: "hoursPlaceholder"
    }] : []);
    this.minutesPlaceholder = input(this._config.minutesPlaceholder, ...ngDevMode ? [{
      debugName: "minutesPlaceholder"
    }] : []);
    this.secondsPlaceholder = input(this._config.secondsPlaceholder, ...ngDevMode ? [{
      debugName: "secondsPlaceholder"
    }] : []);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.isValid = output();
    this.isEditable = computed(() => !(this.readonlyInput() || this.disabled()), ...ngDevMode ? [{
      debugName: "isEditable"
    }] : []);
    this.isPM = computed(() => this.showMeridian() && this.meridian === this.meridians()[1], ...ngDevMode ? [{
      debugName: "isPM"
    }] : []);
    this.invalidHours = false;
    this.invalidMinutes = false;
    this.invalidSeconds = false;
    this.onChange = Function.prototype;
    this.onTouched = Function.prototype;
    this.timerPickerSubscription = new Subscription();
    const _cd = this._cd;
    const _store = this._store;
    this.timerPickerSubscription.add(_store.select((state2) => state2.value).subscribe((value) => {
      this._renderTime(value);
      this.onChange(value);
      this._store.updateControls(getControlsValue(this), this.timeZone());
    }));
    this.timerPickerSubscription.add(_store.select((state2) => state2.controls).subscribe((controlsState) => {
      this.isValid.emit(isInputValid(this.hours, this.minutes, this.seconds, this.isPM()));
      Object.assign(this, controlsState);
      _cd.markForCheck();
    }));
  }
  resetValidation() {
    this.invalidHours = false;
    this.invalidMinutes = false;
    this.invalidSeconds = false;
  }
  prevDef($event) {
    $event.preventDefault();
  }
  wheelSign($event) {
    return Math.sign($event.deltaY) * -1;
  }
  changeHours(step, source = "") {
    this.resetValidation();
    this._store.changeHours({
      step,
      source
    }, this.timeZone());
  }
  changeMinutes(step, source = "") {
    this.resetValidation();
    this._store.changeMinutes({
      step,
      source
    }, this.timeZone());
  }
  changeSeconds(step, source = "") {
    this.resetValidation();
    this._store.changeSeconds({
      step,
      source
    }, this.timeZone());
  }
  updateHours(hours) {
    this.resetValidation();
    this.hours = hours;
    const isValid3 = isHourInputValid(this.hours, this.isPM()) && this.isValidLimit();
    if (!isValid3) {
      this.invalidHours = true;
      this.isValid.emit(false);
      this.onChange(null);
      return;
    }
    this._updateTime();
  }
  updateMinutes(minutes) {
    this.resetValidation();
    this.minutes = minutes;
    const isValid3 = isMinuteInputValid(this.minutes) && this.isValidLimit();
    if (!isValid3) {
      this.invalidMinutes = true;
      this.isValid.emit(false);
      this.onChange(null);
      return;
    }
    this._updateTime();
  }
  updateSeconds(seconds) {
    this.resetValidation();
    this.seconds = seconds;
    const isValid3 = isSecondInputValid(this.seconds) && this.isValidLimit();
    if (!isValid3) {
      this.invalidSeconds = true;
      this.isValid.emit(false);
      this.onChange(null);
      return;
    }
    this._updateTime();
  }
  isValidLimit() {
    return isInputLimitValid({
      hour: this.hours,
      minute: this.minutes,
      seconds: this.seconds,
      isPM: this.isPM()
    }, this.max(), this.min(), this.timeZone());
  }
  _updateTime() {
    const _seconds = this.showSeconds() ? this.seconds : void 0;
    const _minutes = this.showMinutes() ? this.minutes : void 0;
    if (!isInputValid(this.hours, _minutes, _seconds, this.isPM())) {
      this.isValid.emit(false);
      this.onChange(null);
      return;
    }
    this._store.setTime({
      hour: this.hours,
      minute: this.minutes,
      seconds: this.seconds,
      isPM: this.isPM()
    }, this.timeZone());
  }
  toggleMeridian() {
    if (!this.showMeridian() || !this.isEditable()) {
      return;
    }
    const _hoursPerDayHalf = 12;
    this._store.changeHours({
      step: _hoursPerDayHalf,
      source: ""
    });
  }
  writeValue(obj) {
    if (obj && isValidDate(obj)) {
      this._store.writeValue(parseTime2(obj, this.timeZone()));
    } else if (obj == null) {
      this._store.writeValue(null);
    }
  }
  registerOnChange(fn) {
    this.onChange = fn;
  }
  registerOnTouched(fn) {
    this.onTouched = fn;
  }
  setDisabledState(isDisabled) {
    this.disabled.set(isDisabled);
    this._cd.markForCheck();
  }
  ngOnDestroy() {
    this.timerPickerSubscription.unsubscribe();
  }
  _renderTime(value) {
    if (!isValidDate(value)) {
      this.hours = "";
      this.minutes = "";
      this.seconds = "";
      this.meridian = this.meridians()[0];
      return;
    }
    const _value = parseTime2(value, this.timeZone());
    const _hoursPerDayHalf = 12;
    let _hours = _value.getHours();
    if (this.showMeridian()) {
      this.meridian = this.meridians()[_hours >= _hoursPerDayHalf ? 1 : 0];
      _hours = _hours % _hoursPerDayHalf;
      if (_hours === 0) {
        _hours = _hoursPerDayHalf;
      }
    }
    this.hours = padNumber(_hours);
    this.minutes = padNumber(_value.getMinutes());
    this.seconds = padNumber(_value.getUTCSeconds());
  }
  static {
    this.\u0275fac = function ThyInnerTimePicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyInnerTimePicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyInnerTimePicker,
      selectors: [["thy-inner-time-picker"]],
      inputs: {
        hourStep: [1, "hourStep"],
        minuteStep: [1, "minuteStep"],
        secondsStep: [1, "secondsStep"],
        readonlyInput: [1, "readonlyInput"],
        disabled: [1, "disabled"],
        mousewheel: [1, "mousewheel"],
        arrowKeys: [1, "arrowKeys"],
        showSpinners: [1, "showSpinners"],
        showMeridian: [1, "showMeridian"],
        showMinutes: [1, "showMinutes"],
        showSeconds: [1, "showSeconds"],
        meridians: [1, "meridians"],
        min: [1, "min"],
        max: [1, "max"],
        hoursPlaceholder: [1, "hoursPlaceholder"],
        minutesPlaceholder: [1, "minutesPlaceholder"],
        secondsPlaceholder: [1, "secondsPlaceholder"],
        timeZone: [1, "timeZone"]
      },
      outputs: {
        disabled: "disabledChange",
        isValid: "isValid"
      },
      features: [\u0275\u0275ProvidersFeature([TIMEPICKER_CONTROL_VALUE_ACCESSOR, ThyTimePickerStore])],
      decls: 31,
      vars: 32,
      consts: [[1, "text-center", 3, "hidden"], [1, "btn", "btn-link", 3, "click"], [1, "thy-chevron", "thy-chevron-up"], [1, "form-group"], ["type", "text", "maxlength", "2", 1, "form-control", "text-center", "thy-time-picker-field", 3, "wheel", "keydown.ArrowUp", "keydown.ArrowDown", "change", "placeholder", "readonly", "disabled", "value"], [1, "form-group", 3, "has-error"], [1, "thy-chevron", "thy-chevron-down"], ["type", "button", 1, "btn", "btn-default", "text-center", 3, "click", "disabled"]],
      template: function ThyInnerTimePicker_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275domElementStart(0, "table")(1, "tbody")(2, "tr", 0)(3, "td")(4, "a", 1);
          \u0275\u0275domListener("click", function ThyInnerTimePicker_Template_a_click_4_listener() {
            return ctx.changeHours(ctx.hourStep());
          });
          \u0275\u0275domElement(5, "span", 2);
          \u0275\u0275domElementEnd()();
          \u0275\u0275conditionalCreate(6, ThyInnerTimePicker_Conditional_6_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(7, ThyInnerTimePicker_Conditional_7_Template, 3, 2, "td");
          \u0275\u0275conditionalCreate(8, ThyInnerTimePicker_Conditional_8_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(9, ThyInnerTimePicker_Conditional_9_Template, 3, 2, "td");
          \u0275\u0275conditionalCreate(10, ThyInnerTimePicker_Conditional_10_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(11, ThyInnerTimePicker_Conditional_11_Template, 1, 0, "td");
          \u0275\u0275domElementEnd();
          \u0275\u0275domElementStart(12, "tr")(13, "td", 3)(14, "input", 4);
          \u0275\u0275domListener("wheel", function ThyInnerTimePicker_Template_input_wheel_14_listener($event) {
            ctx.prevDef($event);
            return ctx.changeHours(ctx.hourStep() * ctx.wheelSign($event), "wheel");
          })("keydown.ArrowUp", function ThyInnerTimePicker_Template_input_keydown_ArrowUp_14_listener() {
            return ctx.changeHours(ctx.hourStep(), "key");
          })("keydown.ArrowDown", function ThyInnerTimePicker_Template_input_keydown_ArrowDown_14_listener() {
            return ctx.changeHours(-ctx.hourStep(), "key");
          })("change", function ThyInnerTimePicker_Template_input_change_14_listener($event) {
            return ctx.updateHours($event.target.value);
          });
          \u0275\u0275domElementEnd()();
          \u0275\u0275conditionalCreate(15, ThyInnerTimePicker_Conditional_15_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(16, ThyInnerTimePicker_Conditional_16_Template, 2, 8, "td", 5);
          \u0275\u0275conditionalCreate(17, ThyInnerTimePicker_Conditional_17_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(18, ThyInnerTimePicker_Conditional_18_Template, 2, 8, "td", 5);
          \u0275\u0275conditionalCreate(19, ThyInnerTimePicker_Conditional_19_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(20, ThyInnerTimePicker_Conditional_20_Template, 3, 4, "td");
          \u0275\u0275domElementEnd();
          \u0275\u0275domElementStart(21, "tr", 0)(22, "td")(23, "a", 1);
          \u0275\u0275domListener("click", function ThyInnerTimePicker_Template_a_click_23_listener() {
            return ctx.changeHours(-ctx.hourStep());
          });
          \u0275\u0275domElement(24, "span", 6);
          \u0275\u0275domElementEnd()();
          \u0275\u0275conditionalCreate(25, ThyInnerTimePicker_Conditional_25_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(26, ThyInnerTimePicker_Conditional_26_Template, 3, 2, "td");
          \u0275\u0275conditionalCreate(27, ThyInnerTimePicker_Conditional_27_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(28, ThyInnerTimePicker_Conditional_28_Template, 3, 2, "td");
          \u0275\u0275conditionalCreate(29, ThyInnerTimePicker_Conditional_29_Template, 2, 0, "td");
          \u0275\u0275conditionalCreate(30, ThyInnerTimePicker_Conditional_30_Template, 1, 0, "td");
          \u0275\u0275domElementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275domProperty("hidden", !ctx.showSpinners());
          \u0275\u0275advance(2);
          \u0275\u0275classProp("disabled", !ctx.canIncrementHours || !ctx.isEditable());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.showMinutes() ? 6 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMinutes() ? 7 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 8 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 9 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 10 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 11 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275classProp("has-error", ctx.invalidHours);
          \u0275\u0275advance();
          \u0275\u0275classProp("is-invalid", ctx.invalidHours);
          \u0275\u0275domProperty("placeholder", ctx.hoursPlaceholder())("readOnly", ctx.readonlyInput())("disabled", ctx.disabled())("value", ctx.hours);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMinutes() ? 15 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMinutes() ? 16 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 17 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 18 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 19 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 20 : -1);
          \u0275\u0275advance();
          \u0275\u0275domProperty("hidden", !ctx.showSpinners());
          \u0275\u0275advance(2);
          \u0275\u0275classProp("disabled", !ctx.canDecrementHours || !ctx.isEditable());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.showMinutes() ? 25 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMinutes() ? 26 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 27 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSeconds() ? 28 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 29 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMeridian() ? 30 : -1);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyInnerTimePicker, [{
    type: Component,
    args: [{
      selector: "thy-inner-time-picker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [TIMEPICKER_CONTROL_VALUE_ACCESSOR, ThyTimePickerStore],
      imports: [],
      template: `<table>
  <tbody>
    <tr class="text-center" [hidden]="!showSpinners()">
      <!-- increment hours button-->
      <td>
        <a class="btn btn-link" [class.disabled]="!canIncrementHours || !isEditable()" (click)="changeHours(hourStep())"
          ><span class="thy-chevron thy-chevron-up"></span
        ></a>
      </td>
      <!-- divider -->
      @if (showMinutes()) {
        <td>&nbsp;&nbsp;&nbsp;</td>
      }
      <!-- increment minutes button -->
      @if (showMinutes()) {
        <td>
          <a class="btn btn-link" [class.disabled]="!canIncrementMinutes || !isEditable()" (click)="changeMinutes(minuteStep())"
            ><span class="thy-chevron thy-chevron-up"></span
          ></a>
        </td>
      }
      <!-- divider -->
      @if (showSeconds()) {
        <td>&nbsp;</td>
      }
      <!-- increment seconds button -->
      @if (showSeconds()) {
        <td>
          <a class="btn btn-link" [class.disabled]="!canIncrementSeconds || !isEditable()" (click)="changeSeconds(secondsStep())">
            <span class="thy-chevron thy-chevron-up"></span>
          </a>
        </td>
      }
      <!-- space between -->
      @if (showMeridian()) {
        <td>&nbsp;&nbsp;&nbsp;</td>
      }
      <!-- meridian placeholder-->
      @if (showMeridian()) {
        <td></td>
      }
    </tr>
    <tr>
      <!-- hours -->
      <td class="form-group" [class.has-error]="invalidHours">
        <input
          type="text"
          [class.is-invalid]="invalidHours"
          class="form-control text-center thy-time-picker-field"
          [placeholder]="hoursPlaceholder()"
          maxlength="2"
          [readonly]="readonlyInput()"
          [disabled]="disabled()"
          [value]="hours"
          (wheel)="prevDef($event); changeHours(hourStep() * wheelSign($event), 'wheel')"
          (keydown.ArrowUp)="changeHours(hourStep(), 'key')"
          (keydown.ArrowDown)="changeHours(-hourStep(), 'key')"
          (change)="updateHours($event.target.value)" />
      </td>

      <!-- divider -->
      @if (showMinutes()) {
        <td>&nbsp;:&nbsp;</td>
      }
      <!-- minutes -->
      @if (showMinutes()) {
        <td class="form-group" [class.has-error]="invalidMinutes">
          <input
            type="text"
            [class.is-invalid]="invalidMinutes"
            class="form-control text-center thy-time-picker-field"
            [placeholder]="minutesPlaceholder()"
            maxlength="2"
            [readonly]="readonlyInput()"
            [disabled]="disabled()"
            [value]="minutes"
            (wheel)="prevDef($event); changeMinutes(minuteStep() * wheelSign($event), 'wheel')"
            (keydown.ArrowUp)="changeMinutes(minuteStep(), 'key')"
            (keydown.ArrowDown)="changeMinutes(-minuteStep(), 'key')"
            (change)="updateMinutes($event.target.value)" />
        </td>
      }
      <!-- divider -->
      @if (showSeconds()) {
        <td>&nbsp;:&nbsp;</td>
      }
      <!-- seconds -->
      @if (showSeconds()) {
        <td class="form-group" [class.has-error]="invalidSeconds">
          <input
            type="text"
            [class.is-invalid]="invalidSeconds"
            class="form-control text-center thy-time-picker-field"
            [placeholder]="secondsPlaceholder()"
            maxlength="2"
            [readonly]="readonlyInput()"
            [disabled]="disabled()"
            [value]="seconds"
            (wheel)="prevDef($event); changeSeconds(secondsStep() * wheelSign($event), 'wheel')"
            (keydown.ArrowUp)="changeSeconds(secondsStep(), 'key')"
            (keydown.ArrowDown)="changeSeconds(-secondsStep(), 'key')"
            (change)="updateSeconds($event.target.value)" />
        </td>
      }
      <!-- space between -->
      @if (showMeridian()) {
        <td>&nbsp;&nbsp;&nbsp;</td>
      }
      <!-- meridian -->
      @if (showMeridian()) {
        <td>
          <button
            type="button"
            class="btn btn-default text-center"
            [disabled]="!isEditable() || !canToggleMeridian"
            [class.disabled]="!isEditable() || !canToggleMeridian"
            (click)="toggleMeridian()">
            {{ meridian }}
          </button>
        </td>
      }
    </tr>
    <tr class="text-center" [hidden]="!showSpinners()">
      <!-- decrement hours button-->
      <td>
        <a class="btn btn-link" [class.disabled]="!canDecrementHours || !isEditable()" (click)="changeHours(-hourStep())">
          <span class="thy-chevron thy-chevron-down"></span>
        </a>
      </td>
      <!-- divider -->
      @if (showMinutes()) {
        <td>&nbsp;&nbsp;&nbsp;</td>
      }
      <!-- decrement minutes button-->
      @if (showMinutes()) {
        <td>
          <a class="btn btn-link" [class.disabled]="!canDecrementMinutes || !isEditable()" (click)="changeMinutes(-minuteStep())">
            <span class="thy-chevron thy-chevron-down"></span>
          </a>
        </td>
      }
      <!-- divider -->
      @if (showSeconds()) {
        <td>&nbsp;</td>
      }
      <!-- decrement seconds button-->
      @if (showSeconds()) {
        <td>
          <a class="btn btn-link" [class.disabled]="!canDecrementSeconds || !isEditable()" (click)="changeSeconds(-secondsStep())">
            <span class="thy-chevron thy-chevron-down"></span>
          </a>
        </td>
      }
      <!-- space between -->
      @if (showMeridian()) {
        <td>&nbsp;&nbsp;&nbsp;</td>
      }
      <!-- meridian placeholder-->
      @if (showMeridian()) {
        <td></td>
      }
    </tr>
  </tbody>
</table>
`
    }]
  }], () => [], {
    hourStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "hourStep",
        required: false
      }]
    }],
    minuteStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "minuteStep",
        required: false
      }]
    }],
    secondsStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "secondsStep",
        required: false
      }]
    }],
    readonlyInput: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "readonlyInput",
        required: false
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disabled",
        required: false
      }]
    }, {
      type: Output,
      args: ["disabledChange"]
    }],
    mousewheel: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "mousewheel",
        required: false
      }]
    }],
    arrowKeys: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "arrowKeys",
        required: false
      }]
    }],
    showSpinners: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showSpinners",
        required: false
      }]
    }],
    showMeridian: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showMeridian",
        required: false
      }]
    }],
    showMinutes: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showMinutes",
        required: false
      }]
    }],
    showSeconds: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showSeconds",
        required: false
      }]
    }],
    meridians: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "meridians",
        required: false
      }]
    }],
    min: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "min",
        required: false
      }]
    }],
    max: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "max",
        required: false
      }]
    }],
    hoursPlaceholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "hoursPlaceholder",
        required: false
      }]
    }],
    minutesPlaceholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "minutesPlaceholder",
        required: false
      }]
    }],
    secondsPlaceholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "secondsPlaceholder",
        required: false
      }]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    isValid: [{
      type: Output,
      args: ["isValid"]
    }]
  });
})();
var ThyTimePanel = class _ThyTimePanel {
  constructor() {
    this.cdr = inject(ChangeDetectorRef);
    this.ngZone = inject(NgZone);
    this.locale = injectLocale("timePicker");
    this.hourListRef = viewChild("hourListElement", ...ngDevMode ? [{
      debugName: "hourListRef"
    }] : []);
    this.minuteListRef = viewChild("minuteListElement", ...ngDevMode ? [{
      debugName: "minuteListRef"
    }] : []);
    this.secondListRef = viewChild("secondListElement", ...ngDevMode ? [{
      debugName: "secondListRef"
    }] : []);
    this.thyFormat = input("HH:mm:ss", ...ngDevMode ? [{
      debugName: "thyFormat"
    }] : []);
    this.thyHourStep = input(1, ...ngDevMode ? [{
      debugName: "thyHourStep"
    }] : []);
    this.thyMinuteStep = input(1, ...ngDevMode ? [{
      debugName: "thyMinuteStep"
    }] : []);
    this.thySecondStep = input(1, ...ngDevMode ? [{
      debugName: "thySecondStep"
    }] : []);
    this.thyShowSelectNow = input(true, ...ngDevMode ? [{
      debugName: "thyShowSelectNow",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyShowOperations = input(true, ...ngDevMode ? [{
      debugName: "thyShowOperations",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyPickChange = output();
    this.thyClosePanel = output();
    this.SCROLL_OFFSET_SPACING = 5;
    this.SCROLL_DEFAULT_DURATION = 120;
    this.prefixCls = "thy-time-picker-panel";
    this.hourRange = [];
    this.minuteRange = [];
    this.secondRange = [];
    this.showHourColumn = computed(() => {
      const format4 = this.thyFormat();
      if (format4) {
        return new Set(format4).has("H") || new Set(format4).has("h");
      }
      return true;
    }, ...ngDevMode ? [{
      debugName: "showHourColumn"
    }] : []);
    this.showMinuteColumn = computed(() => {
      const format4 = this.thyFormat();
      if (format4) {
        return new Set(format4).has("m");
      }
      return true;
    }, ...ngDevMode ? [{
      debugName: "showMinuteColumn"
    }] : []);
    this.showSecondColumn = computed(() => {
      const format4 = this.thyFormat();
      if (format4) {
        return new Set(format4).has("s");
      }
      return true;
    }, ...ngDevMode ? [{
      debugName: "showSecondColumn"
    }] : []);
    this.showColumnCount = computed(() => {
      const showHour = this.showHourColumn();
      const showMinute = this.showMinuteColumn();
      const showSecond = this.showSecondColumn();
      return [showHour, showMinute, showSecond].filter((m) => m).length || 3;
    }, ...ngDevMode ? [{
      debugName: "showColumnCount"
    }] : []);
    this.onValueChangeFn = () => void 0;
    this.onTouchedFn = () => void 0;
  }
  ngOnInit() {
    this.generateTimeRange();
    this.initialValue();
    setTimeout(() => {
      this.initialScrollPosition = true;
    });
  }
  generateTimeRange() {
    this.hourRange = this.buildTimeRange(24, this.thyHourStep());
    this.minuteRange = this.buildTimeRange(60, this.thyMinuteStep());
    this.secondRange = this.buildTimeRange(60, this.thySecondStep());
  }
  pickHours(hours, index2) {
    this.value.setHours(hours.value);
    this.hour = hours.value;
    this.thyPickChange.emit(this.value);
    this.scrollTo(this.hourListRef().nativeElement, index2);
  }
  pickMinutes(minutes, index2) {
    this.value.setMinutes(minutes.value);
    this.minute = minutes.value;
    this.thyPickChange.emit(this.value);
    this.scrollTo(this.minuteListRef().nativeElement, index2);
  }
  pickSeconds(seconds, index2) {
    this.value.setSeconds(seconds.value);
    this.second = seconds.value;
    this.thyPickChange.emit(this.value);
    this.scrollTo(this.secondListRef().nativeElement, index2);
  }
  selectNow() {
    this.value = new TinyDate()?.nativeDate;
    this.setHMSProperty();
    this.thyPickChange.emit(this.value);
    this.thyClosePanel.emit();
  }
  confirmPickTime() {
    this.onValueChangeFn(this.value || new TinyDate()?.nativeDate);
    this.thyClosePanel.emit();
  }
  scrollTo(container, index2 = 0, duration = this.SCROLL_DEFAULT_DURATION) {
    const offsetTop = container.children[index2].offsetTop - this.SCROLL_OFFSET_SPACING;
    this.runScrollAnimationFrame(container, offsetTop, duration);
  }
  writeValue(value) {
    if (value && isValid2(value)) {
      this.value = new TinyDate(value)?.nativeDate;
      this.setHMSProperty();
    } else {
      this.initialValue();
    }
    this.autoScroll(this.initialScrollPosition ? this.SCROLL_DEFAULT_DURATION : 0);
    this.cdr.markForCheck();
  }
  registerOnChange(fn) {
    this.onValueChangeFn = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedFn = fn;
  }
  initialValue() {
    this.hour = 0;
    this.minute = 0;
    this.second = 0;
    this.value = new TinyDate().setHms(0, 0, 0).nativeDate;
  }
  buildTimeRange(length, step = 1, start = 0, disables = []) {
    return new Array(Math.ceil(length / step)).fill(0).map((_, i) => {
      const value = (i + start) * step;
      return {
        value,
        disabled: disables.indexOf(value) > -1
      };
    });
  }
  setHMSProperty() {
    this.hour = this.value.getHours();
    this.minute = this.value.getMinutes();
    this.second = this.value.getSeconds();
  }
  resetScrollPosition() {
    const hourListRef = this.hourListRef();
    if (hourListRef) {
      hourListRef.nativeElement.scrollTop = 0;
    }
    const minuteListRef = this.minuteListRef();
    if (minuteListRef) {
      minuteListRef.nativeElement.scrollTop = 0;
    }
    const secondListRef = this.secondListRef();
    if (secondListRef) {
      secondListRef.nativeElement.scrollTop = 0;
    }
    this.initialScrollPosition = false;
  }
  runScrollAnimationFrame(container, to, duration = this.SCROLL_DEFAULT_DURATION) {
    if (duration <= 0) {
      container.scrollTop = to;
      return;
    }
    const offset = to - container.scrollTop;
    const frame = offset / duration * 10;
    this.ngZone.runOutsideAngular(() => {
      reqAnimFrame(() => {
        container.scrollTop += frame;
        if (container.scrollTop === to) {
          return;
        }
        this.runScrollAnimationFrame(container, to, duration - 10);
      });
    });
  }
  autoScroll(duration = this.SCROLL_DEFAULT_DURATION) {
    const hourListRef = this.hourListRef();
    if (hourListRef) {
      this.scrollTo(hourListRef.nativeElement, this.hourRange.findIndex((m) => m.value === this.hour), duration);
    }
    const minuteListRef = this.minuteListRef();
    if (minuteListRef) {
      this.scrollTo(minuteListRef.nativeElement, this.minuteRange.findIndex((m) => m.value === this.minute), duration);
    }
    const secondListRef = this.secondListRef();
    if (secondListRef) {
      this.scrollTo(secondListRef.nativeElement, this.secondRange.findIndex((m) => m.value === this.second), duration);
    }
  }
  ngOnDestroy() {
    setTimeout(() => {
      this.resetScrollPosition();
    }, 200);
  }
  static {
    this.\u0275fac = function ThyTimePanel_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTimePanel)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyTimePanel,
      selectors: [["thy-time-picker-panel"]],
      viewQuery: function ThyTimePanel_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.hourListRef, _c017, 5)(ctx.minuteListRef, _c19, 5)(ctx.secondListRef, _c26, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(3);
        }
      },
      hostAttrs: [1, "thy-time-picker-panel"],
      hostVars: 6,
      hostBindings: function ThyTimePanel_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-time-picker-panel-has-bottom-operation", ctx.thyShowOperations())("thy-time-picker-panel-columns-2", ctx.showColumnCount() === 2)("thy-time-picker-panel-columns-3", ctx.showColumnCount() === 3);
        }
      },
      inputs: {
        thyFormat: [1, "thyFormat"],
        thyHourStep: [1, "thyHourStep"],
        thyMinuteStep: [1, "thyMinuteStep"],
        thySecondStep: [1, "thySecondStep"],
        thyShowSelectNow: [1, "thyShowSelectNow"],
        thyShowOperations: [1, "thyShowOperations"]
      },
      outputs: {
        thyPickChange: "thyPickChange",
        thyClosePanel: "thyClosePanel"
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyTimePanel)
      }])],
      decls: 5,
      vars: 7,
      consts: [["hourListElement", ""], ["minuteListElement", ""], ["secondListElement", ""], [3, "class"], [3, "class", "thy-time-picker-panel-time-column-cell-selected"], [3, "click"], ["href", "javascript:;", 3, "class"], ["thyButton", "primary", "thySize", "xs", 1, "confirm", 3, "click"], ["href", "javascript:;", 3, "click"]],
      template: function ThyTimePanel_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div");
          \u0275\u0275conditionalCreate(1, ThyTimePanel_Conditional_1_Template, 4, 4, "ul", 3);
          \u0275\u0275conditionalCreate(2, ThyTimePanel_Conditional_2_Template, 4, 4, "ul", 3);
          \u0275\u0275conditionalCreate(3, ThyTimePanel_Conditional_3_Template, 4, 4, "ul", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(4, ThyTimePanel_Conditional_4_Template, 4, 8, "div", 3);
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-content"));
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showHourColumn() ? 1 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showMinuteColumn() ? 2 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showSecondColumn() ? 3 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.thyShowOperations() ? 4 : -1);
        }
      },
      dependencies: [ThyButton, DecimalPipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTimePanel, [{
    type: Component,
    args: [{
      selector: "thy-time-picker-panel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyTimePanel)
      }],
      host: {
        class: "thy-time-picker-panel",
        "[class.thy-time-picker-panel-has-bottom-operation]": `thyShowOperations()`,
        "[class.thy-time-picker-panel-columns-2]": `showColumnCount() === 2`,
        "[class.thy-time-picker-panel-columns-3]": `showColumnCount() === 3`
      },
      imports: [ThyButton, DecimalPipe],
      template: `<div class="{{ prefixCls }}-content">
  @if (showHourColumn()) {
    <ul #hourListElement class="{{ prefixCls }}-time-column {{ prefixCls }}-hour-column">
      @for (time of hourRange; track $index; let i = $index) {
        <li
          class="{{ prefixCls }}-time-column-cell"
          [class.thy-time-picker-panel-time-column-cell-selected]="hour === time.value"
          (click)="pickHours(time, i)">
          <span class="{{ prefixCls }}-time-column-cell-inner">{{ time.value | number: '2.0-0' }}</span>
        </li>
      }
    </ul>
  }
  @if (showMinuteColumn()) {
    <ul #minuteListElement class="{{ prefixCls }}-time-column {{ prefixCls }}-minute-column">
      @for (time of minuteRange; track $index; let i = $index) {
        <li
          class="{{ prefixCls }}-time-column-cell"
          [class.thy-time-picker-panel-time-column-cell-selected]="minute === time.value"
          (click)="pickMinutes(time, i)">
          <span class="{{ prefixCls }}-time-column-cell-inner">{{ time.value | number: '2.0-0' }}</span>
        </li>
      }
    </ul>
  }
  @if (showSecondColumn()) {
    <ul #secondListElement class="{{ prefixCls }}-time-column {{ prefixCls }}-second-column">
      @for (time of secondRange; track $index; let i = $index) {
        <li
          class="{{ prefixCls }}-time-column-cell"
          [class.thy-time-picker-panel-time-column-cell-selected]="second === time.value"
          (click)="pickSeconds(time, i)">
          <span class="{{ prefixCls }}-time-column-cell-inner">{{ time.value | number: '2.0-0' }}</span>
        </li>
      }
    </ul>
  }
</div>

@if (thyShowOperations()) {
  <div class="{{ prefixCls }}-bottom-operation">
    @if (thyShowSelectNow()) {
      <a href="javascript:;" class="{{ prefixCls }}-time-now" (click)="selectNow()">{{ locale().now }}</a>
    }
    <button class="{{ prefixCls }}-time-confirm" thyButton="primary" thySize="xs" class="confirm" (click)="confirmPickTime()">
      {{ locale().ok }}
    </button>
  </div>
}
`
    }]
  }], () => [], {
    hourListRef: [{
      type: ViewChild,
      args: ["hourListElement", {
        isSignal: true
      }]
    }],
    minuteListRef: [{
      type: ViewChild,
      args: ["minuteListElement", {
        isSignal: true
      }]
    }],
    secondListRef: [{
      type: ViewChild,
      args: ["secondListElement", {
        isSignal: true
      }]
    }],
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }],
    thyHourStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHourStep",
        required: false
      }]
    }],
    thyMinuteStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinuteStep",
        required: false
      }]
    }],
    thySecondStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySecondStep",
        required: false
      }]
    }],
    thyShowSelectNow: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowSelectNow",
        required: false
      }]
    }],
    thyShowOperations: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowOperations",
        required: false
      }]
    }],
    thyPickChange: [{
      type: Output,
      args: ["thyPickChange"]
    }],
    thyClosePanel: [{
      type: Output,
      args: ["thyClosePanel"]
    }]
  });
})();
var ThyTimePicker = class _ThyTimePicker {
  constructor() {
    this.cdr = inject(ChangeDetectorRef);
    this.elementRef = inject(ElementRef);
    this.locale = injectLocale("timePicker");
    this.cdkConnectedOverlay = viewChild(CdkConnectedOverlay, ...ngDevMode ? [{
      debugName: "cdkConnectedOverlay"
    }] : []);
    this.origin = viewChild("origin", ...ngDevMode ? [{
      debugName: "origin"
    }] : []);
    this.inputRef = viewChild("pickerInput", ...ngDevMode ? [{
      debugName: "inputRef"
    }] : []);
    this.overlayContainer = viewChild.required("overlayContainer");
    this.thySize = input("default", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.thyPlaceholder = input(this.locale().placeholder, ...ngDevMode ? [{
      debugName: "thyPlaceholder"
    }] : []);
    this.thyPlacement = input("bottomLeft", ...ngDevMode ? [{
      debugName: "thyPlacement"
    }] : []);
    this.thyFormat = input("HH:mm:ss", ...ngDevMode ? [{
      debugName: "thyFormat",
      transform: (value) => value || "HH:mm:ss"
    }] : [{
      transform: (value) => value || "HH:mm:ss"
    }]);
    this.thyHourStep = input(1, ...ngDevMode ? [{
      debugName: "thyHourStep"
    }] : []);
    this.thyMinuteStep = input(1, ...ngDevMode ? [{
      debugName: "thyMinuteStep"
    }] : []);
    this.thySecondStep = input(1, ...ngDevMode ? [{
      debugName: "thySecondStep"
    }] : []);
    this.thyPopupClass = input(...ngDevMode ? [void 0, {
      debugName: "thyPopupClass"
    }] : []);
    this.thyBackdrop = input(false, ...ngDevMode ? [{
      debugName: "thyBackdrop",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDisabled = model(false, ...ngDevMode ? [{
      debugName: "thyDisabled"
    }] : []);
    this.thyReadonly = input(false, ...ngDevMode ? [{
      debugName: "thyReadonly",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyShowSelectNow = input(true, ...ngDevMode ? [{
      debugName: "thyShowSelectNow",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyAllowClear = input(true, ...ngDevMode ? [{
      debugName: "thyAllowClear",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyOpenChange = output();
    this.prefixCls = "thy-time-picker";
    this.overlayPositions = getFlexiblePositions(this.thyPlacement(), 4);
    this.showText = model("", ...ngDevMode ? [{
      debugName: "showText"
    }] : []);
    this.value = new TinyDate().setHms(0, 0, 0).nativeDate;
    this.isDisabledFirstChange = true;
    this.onValueChangeFn = () => void 0;
    this.onTouchedFn = () => void 0;
    effect(() => {
      if (this.thyFormat() && this.value && isValid2(this.value)) {
        this.showText.set(new TinyDate(this.value).format(this.thyFormat()));
      }
    });
  }
  ngOnInit() {
  }
  ngAfterViewInit() {
    this.overlayPositions = getFlexiblePositions(this.thyPlacement(), 4);
  }
  onInputPickerClick() {
    if (this.disabledUserOperation()) {
      return;
    }
    this.openOverlay();
  }
  onInputPickerBlur() {
    if (this.keepFocus) {
      this.focus();
    } else {
      if (this.openState) {
        this.closeOverlay();
      }
    }
  }
  onPickTime(value) {
    this.originValue = new TinyDate(value)?.nativeDate;
    this.setValue(value);
    this.emitValue();
  }
  onPickTimeConfirm(value) {
    this.originValue = new TinyDate(value)?.nativeDate;
    this.confirmValue(value);
  }
  onClearTime(e) {
    e.stopPropagation();
    this.originValue = null;
    this.setValue(null);
    this.emitValue();
  }
  onCustomizeInput(value) {
    this.formatInputValue(value);
    this.cdr.detectChanges();
  }
  onKeyupEnter() {
    this.confirmValue(this.value);
    this.closeOverlay();
  }
  onKeyupEsc() {
    this.closeOverlay();
  }
  onPositionChange(e) {
    this.cdr.detectChanges();
  }
  onClickBackdrop() {
    this.closeOverlay();
  }
  onOverlayDetach() {
    this.closeOverlay();
  }
  onOutsideClick(event) {
    if (this.openState && !this.elementRef.nativeElement.contains(event.target) && !this.overlayContainer().nativeElement.contains(event.target)) {
      this.closeOverlay();
      this.cdr.detectChanges();
    }
  }
  onOverlayAttach() {
    const cdkConnectedOverlay = this.cdkConnectedOverlay();
    if (cdkConnectedOverlay && cdkConnectedOverlay.overlayRef) {
      cdkConnectedOverlay.overlayRef.updatePosition();
    }
  }
  openOverlay() {
    if (this.disabledUserOperation()) {
      return;
    }
    this.keepFocus = true;
    this.openState = true;
    this.thyOpenChange.emit(this.openState);
  }
  closeOverlay() {
    if (this.openState) {
      this.keepFocus = false;
      this.openState = false;
      this.blur();
      if (this.showText()?.length) {
        if (!this.validateCustomizeInput(this.showText())) {
          this.setValue(this.originValue);
        } else {
          this.showText.set(new TinyDate(this.value).format(this.thyFormat()));
        }
      } else {
        if (!this.thyAllowClear()) {
          this.setValue(this.originValue);
        }
      }
      this.thyOpenChange.emit(this.openState);
    }
  }
  focus() {
    const inputRef = this.inputRef();
    if (inputRef) {
      inputRef.nativeElement.focus();
    }
  }
  blur() {
    const inputRef = this.inputRef();
    if (inputRef) {
      inputRef.nativeElement.blur();
    }
  }
  writeValue(value) {
    if (value && isValid2(value)) {
      this.originValue = new TinyDate(value)?.nativeDate;
      this.setValue(new TinyDate(value).nativeDate);
    } else {
      this.value = new TinyDate().setHms(0, 0, 0).nativeDate;
    }
  }
  registerOnChange(fn) {
    this.onValueChangeFn = fn;
  }
  registerOnTouched(fn) {
    this.onTouchedFn = fn;
  }
  setDisabledState(isDisabled) {
    this.thyDisabled.set(this.isDisabledFirstChange && this.thyDisabled() || isDisabled);
    this.isDisabledFirstChange = false;
  }
  setValue(value, formatText = true) {
    if (value && isValid2(value)) {
      this.value = new TinyDate(value)?.nativeDate;
      if (formatText) {
        this.showText.set(new TinyDate(this.value).format(this.thyFormat()));
      }
    } else {
      this.value = null;
      this.showText.set("");
    }
    this.cdr.markForCheck();
  }
  confirmValue(value) {
    this.setValue(value);
    this.emitValue();
    this.cdr.markForCheck();
  }
  emitValue() {
    if (this.onValueChangeFn) {
      this.onValueChangeFn(this.value);
    }
    if (this.onTouchedFn) {
      this.onTouchedFn();
    }
  }
  formatInputValue(value) {
    if (!this.openState) {
      this.openOverlay();
    }
    if (value?.length) {
      if (this.validateCustomizeInput(value)) {
        const formatter = value.split(":");
        const hour = formatter[0] || 0;
        const minute = formatter[1] || 0;
        const second = formatter[2] || 0;
        this.setValue(new TinyDate().setHms(+hour, +minute, +second).nativeDate, false);
        this.originValue = new TinyDate(this.value)?.nativeDate;
        this.emitValue();
      }
    } else {
      if (this.thyAllowClear()) {
        this.originValue = null;
        this.setValue(null);
        this.emitValue();
      } else {
        this.value = new TinyDate(this.originValue)?.nativeDate;
        this.showText.set("");
        this.cdr.markForCheck();
      }
    }
  }
  validateCustomizeInput(value) {
    let valid = false;
    if (value.length > this.thyFormat().length) {
      return valid;
    }
    const formatRule = this.thyFormat().split(":");
    const formatter = value.split(":");
    valid = !formatRule.map((m, i) => {
      return !!formatter[i];
    }).includes(false);
    return valid;
  }
  disabledUserOperation() {
    return this.thyDisabled() || this.thyReadonly();
  }
  static {
    this.\u0275fac = function ThyTimePicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTimePicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyTimePicker,
      selectors: [["thy-time-picker"]],
      viewQuery: function ThyTimePicker_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.cdkConnectedOverlay, CdkConnectedOverlay, 5)(ctx.origin, _c35, 5)(ctx.inputRef, _c45, 5)(ctx.overlayContainer, _c54, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(4);
        }
      },
      hostAttrs: [1, "thy-time-picker"],
      hostVars: 4,
      hostBindings: function ThyTimePicker_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-time-picker-disabled", ctx.thyDisabled())("thy-time-picker-readonly", ctx.thyReadonly());
        }
      },
      inputs: {
        thySize: [1, "thySize"],
        thyPlaceholder: [1, "thyPlaceholder"],
        thyPlacement: [1, "thyPlacement"],
        thyFormat: [1, "thyFormat"],
        thyHourStep: [1, "thyHourStep"],
        thyMinuteStep: [1, "thyMinuteStep"],
        thySecondStep: [1, "thySecondStep"],
        thyPopupClass: [1, "thyPopupClass"],
        thyBackdrop: [1, "thyBackdrop"],
        thyDisabled: [1, "thyDisabled"],
        thyReadonly: [1, "thyReadonly"],
        thyShowSelectNow: [1, "thyShowSelectNow"],
        thyAllowClear: [1, "thyAllowClear"],
        showText: [1, "showText"]
      },
      outputs: {
        thyDisabled: "thyDisabledChange",
        thyOpenChange: "thyOpenChange",
        showText: "showTextChange"
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyTimePicker)
      }])],
      decls: 9,
      vars: 22,
      consts: [["origin", "cdkOverlayOrigin"], ["pickerInput", ""], ["rightIcon", ""], ["overlayContainer", ""], ["cdkOverlayOrigin", "", 3, "click"], ["thyInput", "", 3, "ngModelChange", "blur", "keyup.enter", "keyup.escape", "ngModel", "thySize", "disabled", "readonly", "placeholder"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", "cdkConnectedOverlayTransformOriginOn", ".thy-time-picker-container", 3, "positionChange", "backdropClick", "overlayOutsideClick", "detach", "attach", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayPositions"], [3, "class"], [3, "thyIconName", "ngClass"], ["thyIconName", "close-circle-bold-fill", 3, "click", "ngClass"], [1, "thy-time-picker-container", 2, "position", "relative"], [3, "ngModelChange", "thyPickChange", "thyClosePanel", "ngClass", "ngModel", "thyFormat", "thyHourStep", "thyMinuteStep", "thySecondStep", "thyShowSelectNow"]],
      template: function ThyTimePicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "span", 4, 0);
          \u0275\u0275listener("click", function ThyTimePicker_Template_span_click_0_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputPickerClick());
          });
          \u0275\u0275elementContainerStart(2);
          \u0275\u0275elementStart(3, "input", 5, 1);
          \u0275\u0275twoWayListener("ngModelChange", function ThyTimePicker_Template_input_ngModelChange_3_listener($event) {
            \u0275\u0275restoreView(_r1);
            \u0275\u0275twoWayBindingSet(ctx.showText, $event) || (ctx.showText = $event);
            return \u0275\u0275resetView($event);
          });
          \u0275\u0275listener("blur", function ThyTimePicker_Template_input_blur_3_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputPickerBlur());
          })("keyup.enter", function ThyTimePicker_Template_input_keyup_enter_3_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onKeyupEnter());
          })("keyup.escape", function ThyTimePicker_Template_input_keyup_escape_3_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onKeyupEsc());
          })("ngModelChange", function ThyTimePicker_Template_input_ngModelChange_3_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onCustomizeInput($event));
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(5, ThyTimePicker_ng_container_5_Template, 1, 0, "ng-container", 6);
          \u0275\u0275elementContainerEnd();
          \u0275\u0275elementEnd();
          \u0275\u0275template(6, ThyTimePicker_ng_template_6_Template, 3, 7, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(8, ThyTimePicker_ng_template_8_Template, 3, 10, "ng-template", 7);
          \u0275\u0275listener("positionChange", function ThyTimePicker_Template_ng_template_positionChange_8_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onPositionChange($event));
          })("backdropClick", function ThyTimePicker_Template_ng_template_backdropClick_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onClickBackdrop());
          })("overlayOutsideClick", function ThyTimePicker_Template_ng_template_overlayOutsideClick_8_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOutsideClick($event));
          })("detach", function ThyTimePicker_Template_ng_template_detach_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOverlayDetach());
          })("attach", function ThyTimePicker_Template_ng_template_attach_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOverlayAttach());
          });
        }
        if (rf & 2) {
          const origin_r5 = \u0275\u0275reference(1);
          const rightIcon_r6 = \u0275\u0275reference(7);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-wrapper"));
          \u0275\u0275advance(3);
          \u0275\u0275classMap(\u0275\u0275interpolate1("form-control ", ctx.prefixCls, "-input"));
          \u0275\u0275classProp("thy-input-disabled", ctx.thyDisabled())("thy-input-readonly", ctx.thyReadonly())("thy-time-picker-panel-opened", ctx.openState);
          \u0275\u0275twoWayProperty("ngModel", ctx.showText);
          \u0275\u0275property("thySize", ctx.thySize())("disabled", ctx.thyDisabled())("readonly", ctx.thyReadonly())("placeholder", ctx.thyPlaceholder());
          \u0275\u0275advance(2);
          \u0275\u0275property("ngTemplateOutlet", rightIcon_r6);
          \u0275\u0275advance(3);
          \u0275\u0275property("cdkConnectedOverlayOrigin", origin_r5)("cdkConnectedOverlayOpen", ctx.openState)("cdkConnectedOverlayHasBackdrop", ctx.thyBackdrop())("cdkConnectedOverlayPositions", ctx.overlayPositions);
        }
      },
      dependencies: [CdkOverlayOrigin, ThyInputDirective, FormsModule, DefaultValueAccessor, NgControlStatus, NgModel, NgTemplateOutlet, ThyIcon, NgClass, CdkConnectedOverlay, ThyTimePanel],
      encapsulation: 2,
      data: {
        animation: [scaleXMotion, scaleYMotion, scaleMotion]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTimePicker, [{
    type: Component,
    args: [{
      selector: "thy-time-picker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyTimePicker)
      }],
      host: {
        class: "thy-time-picker",
        "[class.thy-time-picker-disabled]": `thyDisabled()`,
        "[class.thy-time-picker-readonly]": `thyReadonly()`
      },
      imports: [CdkOverlayOrigin, ThyInputDirective, FormsModule, NgTemplateOutlet, ThyIcon, NgClass, CdkConnectedOverlay, ThyTimePanel],
      animations: [scaleXMotion, scaleYMotion, scaleMotion],
      template: `<span cdkOverlayOrigin #origin="cdkOverlayOrigin" (click)="onInputPickerClick()" class="{{ prefixCls }}-wrapper">
  <ng-container>
    <input
      #pickerInput
      thyInput
      class="form-control {{ prefixCls }}-input"
      [class.thy-input-disabled]="thyDisabled()"
      [class.thy-input-readonly]="thyReadonly()"
      [class.thy-time-picker-panel-opened]="openState"
      [(ngModel)]="showText"
      [thySize]="thySize()"
      [disabled]="thyDisabled()"
      [readonly]="thyReadonly()"
      [placeholder]="thyPlaceholder()"
      (blur)="onInputPickerBlur()"
      (keyup.enter)="onKeyupEnter()"
      (keyup.escape)="onKeyupEsc()"
      (ngModelChange)="onCustomizeInput($event)" />
    <ng-container *ngTemplateOutlet="rightIcon"></ng-container>
  </ng-container>
</span>

<ng-template #rightIcon>
  @if (!thyDisabled() && thyAllowClear() && !thyReadonly() && showText()) {
    <span class="{{ prefixCls }}-clear">
      <thy-icon
        thyIconName="close-circle-bold-fill"
        (click)="onClearTime($event)"
        ngClass="remove-link remove-link-{{ thySize() }}"></thy-icon>
    </span>
  }
  <span class="{{ prefixCls }}-icon">
    <thy-icon [thyIconName]="'clock-circle-moment'" ngClass="remove-link-{{ thySize() }}"></thy-icon>
  </span>
</ng-template>

<!-- Overlay -->
<ng-template
  cdkConnectedOverlay
  [cdkConnectedOverlayOrigin]="origin"
  [cdkConnectedOverlayOpen]="openState"
  [cdkConnectedOverlayHasBackdrop]="thyBackdrop()"
  [cdkConnectedOverlayPositions]="overlayPositions"
  cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
  cdkConnectedOverlayTransformOriginOn=".thy-time-picker-container"
  (positionChange)="onPositionChange($event)"
  (backdropClick)="onClickBackdrop()"
  (overlayOutsideClick)="onOutsideClick($event)"
  (detach)="onOverlayDetach()"
  (attach)="onOverlayAttach()">
  <div
    #overlayContainer
    style="position: relative"
    [@scaleXMotion]="thyPlacement() === 'left' || thyPlacement() === 'right' ? 'enter' : 'void'"
    [@scaleYMotion]="thyPlacement() === 'top' || thyPlacement() === 'bottom' ? 'enter' : 'void'"
    [@scaleMotion]="
      thyPlacement() !== 'left' && thyPlacement() !== 'right' && thyPlacement() !== 'top' && thyPlacement() !== 'bottom' ? 'enter' : 'void'
    "
    class="thy-time-picker-container">
    <!-- Compatible for overlay that not support offset dynamically and immediately -->
    <thy-time-picker-panel
      [ngClass]="thyPopupClass()"
      [(ngModel)]="value"
      [thyFormat]="thyFormat()"
      [thyHourStep]="thyHourStep()"
      [thyMinuteStep]="thyMinuteStep()"
      [thySecondStep]="thySecondStep()"
      [thyShowSelectNow]="thyShowSelectNow()"
      (ngModelChange)="onPickTimeConfirm($event)"
      (thyPickChange)="onPickTime($event)"
      (thyClosePanel)="closeOverlay()"></thy-time-picker-panel>
  </div>
</ng-template>
`
    }]
  }], () => [], {
    cdkConnectedOverlay: [{
      type: ViewChild,
      args: [forwardRef(() => CdkConnectedOverlay), {
        isSignal: true
      }]
    }],
    origin: [{
      type: ViewChild,
      args: ["origin", {
        isSignal: true
      }]
    }],
    inputRef: [{
      type: ViewChild,
      args: ["pickerInput", {
        isSignal: true
      }]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: ["overlayContainer", {
        isSignal: true
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyPlaceholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlaceholder",
        required: false
      }]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlacement",
        required: false
      }]
    }],
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }],
    thyHourStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHourStep",
        required: false
      }]
    }],
    thyMinuteStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinuteStep",
        required: false
      }]
    }],
    thySecondStep: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySecondStep",
        required: false
      }]
    }],
    thyPopupClass: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPopupClass",
        required: false
      }]
    }],
    thyBackdrop: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyBackdrop",
        required: false
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabled",
        required: false
      }]
    }, {
      type: Output,
      args: ["thyDisabledChange"]
    }],
    thyReadonly: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyReadonly",
        required: false
      }]
    }],
    thyShowSelectNow: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowSelectNow",
        required: false
      }]
    }],
    thyAllowClear: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAllowClear",
        required: false
      }]
    }],
    thyOpenChange: [{
      type: Output,
      args: ["thyOpenChange"]
    }],
    showText: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showText",
        required: false
      }]
    }, {
      type: Output,
      args: ["showTextChange"]
    }]
  });
})();
var COMPONENTS = [ThyInnerTimePicker, ThyTimePicker, ThyTimePanel];
var ThyTimePickerModule = class _ThyTimePickerModule {
  static {
    this.\u0275fac = function ThyTimePickerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyTimePickerModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyTimePickerModule,
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyInputModule, OverlayModule, ThyPopoverModule, ThyButtonModule, ThyInnerTimePicker, ThyTimePicker, ThyTimePanel],
      exports: [ThyInnerTimePicker, ThyTimePicker, ThyTimePanel]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [TimePickerConfig, ThyTimePickerStore],
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyInputModule, OverlayModule, ThyPopoverModule, ThyButtonModule, ThyTimePicker, ThyTimePanel]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyTimePickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ThySharedModule, ThyIconModule, ThyInputModule, OverlayModule, ThyPopoverModule, ThyButtonModule, ...COMPONENTS],
      exports: [...COMPONENTS],
      providers: [TimePickerConfig, ThyTimePickerStore]
    }]
  }], null, null);
})();

// node_modules/ngx-tethys/fesm2022/ngx-tethys-date-picker.mjs
function MonthHeader_For_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function MonthHeader_For_8_Template_a_click_0_listener($event) {
      const selector_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectorClick($event, selector_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const selector_r2 = ctx.$implicit;
    \u0275\u0275classMap(selector_r2.className);
    \u0275\u0275property("title", \u0275\u0275interpolate(selector_r2.title || null));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", selector_r2.label, " ");
  }
}
function CalendarFooter_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function CalendarFooter_Conditional_2_Conditional_1_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.changeTimeShowMode("show"));
    });
    \u0275\u0275element(1, "thy-icon", 8);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1("", ctx_r2.locale().setTime, " ");
  }
}
function CalendarFooter_Conditional_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-inner-time-picker", 9);
    \u0275\u0275listener("ngModelChange", function CalendarFooter_Conditional_2_Conditional_2_Template_thy_inner_time_picker_ngModelChange_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onSelectTime($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("showMeridian", false)("timeZone", ctx_r2.timeZone())("ngModel", ctx_r2.value());
  }
}
function CalendarFooter_Conditional_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 10);
    \u0275\u0275listener("click", function CalendarFooter_Conditional_2_Conditional_4_Template_button_click_0_listener() {
      \u0275\u0275restoreView(_r5);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onTimeOk());
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("disabled", ctx_r2.disableTimeConfirm());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r2.locale().ok, " ");
  }
}
function CalendarFooter_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275listener("click", function CalendarFooter_Conditional_2_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      return \u0275\u0275resetView($event.stopPropagation());
    });
    \u0275\u0275conditionalCreate(1, CalendarFooter_Conditional_2_Conditional_1_Template, 3, 1, "a", 2);
    \u0275\u0275conditionalCreate(2, CalendarFooter_Conditional_2_Conditional_2_Template, 1, 3, "thy-inner-time-picker", 3);
    \u0275\u0275elementStart(3, "div", 4);
    \u0275\u0275conditionalCreate(4, CalendarFooter_Conditional_2_Conditional_4_Template, 2, 2, "button", 5);
    \u0275\u0275elementStart(5, "button", 6);
    \u0275\u0275listener("click", function CalendarFooter_Conditional_2_Template_button_click_5_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClear());
    });
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const showTime_r6 = \u0275\u0275readContextLet(0);
    const canTime_r7 = \u0275\u0275readContextLet(1);
    \u0275\u0275advance();
    \u0275\u0275conditional(canTime_r7 ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(showTime_r6 ? 2 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!canTime_r7 ? 4 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r2.locale().clear);
  }
}
var _c018 = (a0, a1) => ({
  title: a0,
  type: "year",
  selectableData: a1
});
var _c110 = (a0, a1) => ({
  title: a0,
  type: "quarter",
  selectableData: a1
});
var _c27 = (a0, a1) => ({
  title: a0,
  type: "month",
  selectableData: a1
});
function DateCarousel_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateCarousel_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateCarousel_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateCarousel_ng_template_3_For_7_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 10);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r5 == null ? null : item_r5.startValue == null ? null : item_r5.startValue.getYear());
  }
}
function DateCarousel_ng_template_3_For_7_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 11);
  }
}
function DateCarousel_ng_template_3_For_7_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "thy-icon", 12);
  }
}
function DateCarousel_ng_template_3_For_7_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r5 == null ? null : item_r5.content);
  }
}
function DateCarousel_ng_template_3_For_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 9);
    \u0275\u0275listener("click", function DateCarousel_ng_template_3_For_7_Template_div_click_0_listener() {
      const item_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const type_r2 = \u0275\u0275nextContext().type;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectDate(type_r2, item_r5));
    })("mouseenter", function DateCarousel_ng_template_3_For_7_Template_div_mouseenter_0_listener($event) {
      const item_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const type_r2 = \u0275\u0275nextContext().type;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onMouseenter($event, type_r2, item_r5));
    })("mouseleave", function DateCarousel_ng_template_3_For_7_Template_div_mouseleave_0_listener($event) {
      const item_r5 = \u0275\u0275restoreView(_r4).$implicit;
      const type_r2 = \u0275\u0275nextContext().type;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onMouseleave($event, type_r2, item_r5));
    });
    \u0275\u0275conditionalCreate(1, DateCarousel_ng_template_3_For_7_Conditional_1_Template, 2, 1, "span", 10);
    \u0275\u0275pipe(2, "showYearTip");
    \u0275\u0275conditionalCreate(3, DateCarousel_ng_template_3_For_7_Conditional_3_Template, 1, 0, "thy-icon", 11);
    \u0275\u0275conditionalCreate(4, DateCarousel_ng_template_3_For_7_Conditional_4_Template, 1, 0, "thy-icon", 12);
    \u0275\u0275conditionalCreate(5, DateCarousel_ng_template_3_For_7_Conditional_5_Template, 2, 1, "span");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.$implicit;
    const type_r2 = \u0275\u0275nextContext().type;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", item_r5.classMap);
    \u0275\u0275advance();
    \u0275\u0275conditional(\u0275\u0275pipeBind2(2, 5, item_r5, type_r2) ? 1 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(item_r5.isInRange && ctx_r2.isSelected(item_r5) ? 3 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r5.isInRange && !ctx_r2.isSelected(item_r5) ? 4 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(!item_r5.isInRange ? 5 : -1);
  }
}
function DateCarousel_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "p", 2);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "div", 3)(4, "button", 4);
    \u0275\u0275listener("click", function DateCarousel_ng_template_3_Template_button_click_4_listener() {
      const type_r2 = \u0275\u0275restoreView(_r1).type;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.prevClick(type_r2));
    });
    \u0275\u0275element(5, "thy-icon", 5);
    \u0275\u0275elementEnd();
    \u0275\u0275repeaterCreate(6, DateCarousel_ng_template_3_For_7_Template, 6, 8, "div", 6, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementStart(8, "button", 7);
    \u0275\u0275listener("click", function DateCarousel_ng_template_3_Template_button_click_8_listener() {
      const type_r2 = \u0275\u0275restoreView(_r1).type;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.nextClick(type_r2));
    });
    \u0275\u0275element(9, "thy-icon", 8);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const title_r6 = ctx.title;
    const selectableData_r7 = ctx.selectableData;
    const type_r2 = ctx.type;
    \u0275\u0275classMap(\u0275\u0275interpolate1("carousel-item carousel-item-", type_r2));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(title_r6);
    \u0275\u0275advance(4);
    \u0275\u0275repeater(selectableData_r7);
  }
}
function DateHeader_For_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function DateHeader_For_8_Template_a_click_0_listener($event) {
      const selector_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectorClick($event, selector_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const selector_r2 = ctx.$implicit;
    \u0275\u0275classMap(selector_r2.className);
    \u0275\u0275property("title", \u0275\u0275interpolate(selector_r2.title || null));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", selector_r2.label, " ");
  }
}
var _c36 = ["date-table-cell", ""];
var _c46 = (a0) => ({
  $implicit: a0
});
function DateTableCell_Case_3_Case_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableCell_Case_3_Case_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateTableCell_Case_3_Case_0_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275property("ngTemplateOutlet", dateCellRender_r2)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c46, dateCell_r1.value));
  }
}
function DateTableCell_Case_3_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 4);
    \u0275\u0275listener("click", function DateTableCell_Case_3_Case_1_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.cellClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275property("innerHTML", dateCellRender_r2, \u0275\u0275sanitizeHtml);
  }
}
function DateTableCell_Case_3_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span", 4);
    \u0275\u0275listener("click", function DateTableCell_Case_3_Case_2_Template_span_click_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.cellClick($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275property("innerHTML", dateCellRender_r2(dateCell_r1.value), \u0275\u0275sanitizeHtml);
  }
}
function DateTableCell_Case_3_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const prefixClass_r6 = \u0275\u0275readContextLet(0);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date"));
    \u0275\u0275attribute("aria-selected", dateCell_r1.isSelected)("aria-disabled", dateCell_r1.isDisabled);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", dateCell_r1.content, " ");
  }
}
function DateTableCell_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DateTableCell_Case_3_Case_0_Template, 1, 4, "ng-container")(1, DateTableCell_Case_3_Case_1_Template, 1, 1, "span", 1)(2, DateTableCell_Case_3_Case_2_Template, 1, 1, "span", 1)(3, DateTableCell_Case_3_Case_3_Template, 2, 6, "div", 2);
  }
  if (rf & 2) {
    let tmp_4_0;
    const ctx_r3 = \u0275\u0275nextContext();
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275conditional((tmp_4_0 = true) === ctx_r3.isTemplateRef(dateCellRender_r2) ? 0 : tmp_4_0 === ctx_r3.isNonEmptyString(dateCellRender_r2) ? 1 : tmp_4_0 === ctx_r3.functionRenderResult() ? 2 : 3);
  }
}
function DateTableCell_Case_4_Conditional_1_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableCell_Case_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateTableCell_Case_4_Conditional_1_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    \u0275\u0275property("ngTemplateOutlet", dateCell_r1.fullCellRender)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c46, dateCell_r1.value));
  }
}
function DateTableCell_Case_4_Conditional_2_Conditional_5_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DateTableCell_Case_4_Conditional_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DateTableCell_Case_4_Conditional_2_Conditional_5_ng_container_0_Template, 1, 0, "ng-container", 3);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(3);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275property("ngTemplateOutlet", dateCellRender_r2)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c46, dateCell_r1.value));
  }
}
function DateTableCell_Case_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "span")(2, "span");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(4, "div");
    \u0275\u0275conditionalCreate(5, DateTableCell_Case_4_Conditional_2_Conditional_5_Template, 1, 4, "ng-container");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext(2);
    const prefixClass_r6 = \u0275\u0275readContextLet(0);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    const dateCellRender_r2 = \u0275\u0275readContextLet(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date-value"));
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date-value-today-text"));
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date-value-text"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(dateCell_r1.content);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date-content"));
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r3.isTemplateRef(dateCellRender_r2) ? 5 : -1);
  }
}
function DateTableCell_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275conditionalCreate(1, DateTableCell_Case_4_Conditional_1_Template, 1, 4, "ng-container")(2, DateTableCell_Case_4_Conditional_2_Template, 6, 14);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    const prefixClass_r6 = \u0275\u0275readContextLet(0);
    const dateCell_r1 = \u0275\u0275readContextLet(1);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-date thy-calendar-full-cell-inner"));
    \u0275\u0275classProp("thy-calendar-full-calendar-date-today", dateCell_r1.isToday);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r3.isTemplateRef(dateCell_r1.fullCellRender) ? 1 : 2);
  }
}
function DateTable_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 4)(1, "span");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate2("", prefixClass_r2, "-column-header ", prefixClass_r2, "-week-number-header"));
    \u0275\u0275property("title", ctx_r0.locale().week);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r2, "-column-header-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.locale().prefixWeek);
  }
}
function DateTable_For_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r2, "-column-header-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(cell_r3.content);
  }
}
function DateTable_For_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r2, "-column-header-inner"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(cell_r3.content);
  }
}
function DateTable_For_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "th", 4);
    \u0275\u0275conditionalCreate(1, DateTable_For_6_Conditional_1_Template, 2, 4, "span", 5);
    \u0275\u0275conditionalCreate(2, DateTable_For_6_Conditional_2_Template, 2, 4, "span", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r3 = ctx.$implicit;
    \u0275\u0275nextContext();
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r2, "-column-header"));
    \u0275\u0275property("title", \u0275\u0275interpolate(cell_r3.title));
    \u0275\u0275advance();
    \u0275\u0275conditional(prefixClass_r2 === "thy-calendar" ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(prefixClass_r2 === "thy-calendar-full" ? 2 : -1);
  }
}
function DateTable_For_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "td", 8);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext();
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r2, "-week-number-cell"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", row_r4.weekNum, " ");
  }
}
function DateTable_For_9_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 9);
    \u0275\u0275listener("click", function DateTable_For_9_For_3_Template_td_click_0_listener() {
      const cell_r6 = \u0275\u0275restoreView(_r5).$implicit;
      return \u0275\u0275resetView(cell_r6.isDisabled ? null : cell_r6.onClick());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const cell_r6 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r2 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("ngClass", cell_r6.classMap)("prefixCls", prefixClass_r2)("cell", cell_r6);
  }
}
function DateTable_For_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 3);
    \u0275\u0275conditionalCreate(1, DateTable_For_9_Conditional_1_Template, 2, 4, "td", 6);
    \u0275\u0275repeaterCreate(2, DateTable_For_9_For_3_Template, 1, 3, "td", 7, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r4 = ctx.$implicit;
    \u0275\u0275property("ngClass", row_r4.classMap);
    \u0275\u0275advance();
    \u0275\u0275conditional(row_r4.weekNum ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275repeater(row_r4.dateCells);
  }
}
function DecadeHeader_For_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function DecadeHeader_For_8_Template_a_click_0_listener($event) {
      const selector_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectorClick($event, selector_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const selector_r2 = ctx.$implicit;
    \u0275\u0275classMap(selector_r2.className);
    \u0275\u0275property("title", \u0275\u0275interpolate(selector_r2.title || null));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", selector_r2.label, " ");
  }
}
function DecadeTable_For_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 3);
    \u0275\u0275listener("click", function DecadeTable_For_4_For_2_Template_td_click_0_listener($event) {
      const cell_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.cellClick($event, cell_r2));
    });
    \u0275\u0275elementStart(1, "a");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const cell_r2 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r4 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("title", \u0275\u0275interpolate(cell_r2.title))("ngClass", cell_r2.classMap);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r4, "-decade-panel-decade"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(cell_r2.content);
  }
}
function DecadeTable_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 1);
    \u0275\u0275repeaterCreate(1, DecadeTable_For_4_For_2_Template, 3, 7, "td", 2, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275repeater(row_r5.dateCells);
  }
}
function MonthTable_For_4_For_2_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const monthCell_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r4 = \u0275\u0275readContextLet(0);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r4, "-month-panel-month"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(monthCell_r2.content);
  }
}
function MonthTable_For_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 3);
    \u0275\u0275listener("click", function MonthTable_For_4_For_2_Template_td_click_0_listener($event) {
      const monthCell_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.monthCellClick($event, monthCell_r2));
    });
    \u0275\u0275conditionalCreate(1, MonthTable_For_4_For_2_Case_1_Template, 2, 4, "div", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_23_0;
    const monthCell_r2 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r4 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("title", \u0275\u0275interpolate(monthCell_r2.title))("ngClass", monthCell_r2.classMap);
    \u0275\u0275advance();
    \u0275\u0275conditional((tmp_23_0 = prefixClass_r4) === "thy-calendar" ? 1 : -1);
  }
}
function MonthTable_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 1);
    \u0275\u0275repeaterCreate(1, MonthTable_For_4_For_2_Template, 2, 4, "td", 2, \u0275\u0275componentInstance().trackByBodyColumn, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275repeater(row_r5.dateCells);
  }
}
function QuarterTable_For_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 3);
    \u0275\u0275listener("click", function QuarterTable_For_4_For_2_Template_td_click_0_listener($event) {
      const quarterCell_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.quarterCellClick($event, quarterCell_r2));
    });
    \u0275\u0275elementStart(1, "a");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const quarterCell_r2 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r4 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("title", \u0275\u0275interpolate(quarterCell_r2.title))("ngClass", quarterCell_r2.classMap);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r4, "-quarter-panel-quarter"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(quarterCell_r2.content);
  }
}
function QuarterTable_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 1);
    \u0275\u0275repeaterCreate(1, QuarterTable_For_4_For_2_Template, 3, 7, "td", 2, \u0275\u0275componentInstance().trackByBodyColumn, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275repeater(row_r5.dateCells);
  }
}
function YearHeader_For_8_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function YearHeader_For_8_Template_a_click_0_listener($event) {
      const selector_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectorClick($event, selector_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const selector_r2 = ctx.$implicit;
    \u0275\u0275classMap(selector_r2.className);
    \u0275\u0275property("title", \u0275\u0275interpolate(selector_r2.title || null));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", selector_r2.label, " ");
  }
}
function YearTable_For_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "td", 3);
    \u0275\u0275listener("click", function YearTable_For_4_For_2_Template_td_click_0_listener($event) {
      const yearCell_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.yearCellClick($event, yearCell_r2));
    });
    \u0275\u0275elementStart(1, "a");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const yearCell_r2 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const prefixClass_r4 = \u0275\u0275readContextLet(0);
    \u0275\u0275property("title", \u0275\u0275interpolate(yearCell_r2.title))("ngClass", yearCell_r2.classMap);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r4, "-year-panel-year"));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(yearCell_r2.content);
  }
}
function YearTable_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 1);
    \u0275\u0275repeaterCreate(1, YearTable_For_4_For_2_Template, 3, 7, "td", 2, \u0275\u0275componentInstance().trackByBodyColumn, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const row_r5 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275repeater(row_r5.dateCells);
  }
}
function InnerPopup_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275element(1, "input", 1)(2, "span", 2)(3, "input", 1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-picker-inner-popup-range-input"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.getReadableValue(ctx_r0.selectedValue()[0]))("placeholder", ctx_r0.locale().startDate);
    \u0275\u0275advance(2);
    \u0275\u0275property("value", ctx_r0.getReadableValue(ctx_r0.selectedValue()[1]))("placeholder", ctx_r0.locale().endDate);
  }
}
function InnerPopup_Case_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "decade-header", 3);
    \u0275\u0275twoWayListener("valueChange", function InnerPopup_Case_1_Template_decade_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r0.activeDate, $event) || (ctx_r0.activeDate = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("panelModeChange", function InnerPopup_Case_1_Template_decade_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.panelModeChange.emit($event));
    })("valueChange", function InnerPopup_Case_1_Template_decade_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "decade-table", 4);
    \u0275\u0275listener("valueChange", function InnerPopup_Case_1_Template_decade_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onChooseDecade($event));
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-decade"));
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("value", ctx_r0.activeDate);
    \u0275\u0275property("showSuperPreBtn", ctx_r0.enableSuperPrevNext("prev", "decade"))("showSuperNextBtn", ctx_r0.enableSuperPrevNext("next", "decade"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-body"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.value())("activeDate", ctx_r0.activeDate());
  }
}
function InnerPopup_Case_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "year-header", 3);
    \u0275\u0275twoWayListener("valueChange", function InnerPopup_Case_2_Template_year_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r0.activeDate, $event) || (ctx_r0.activeDate = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("panelModeChange", function InnerPopup_Case_2_Template_year_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.panelModeChange.emit($event));
    })("valueChange", function InnerPopup_Case_2_Template_year_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "year-table", 5);
    \u0275\u0275listener("valueChange", function InnerPopup_Case_2_Template_year_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onChooseYear($event));
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-year"));
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("value", ctx_r0.activeDate);
    \u0275\u0275property("showSuperPreBtn", ctx_r0.enableSuperPrevNext("prev", "year"))("showSuperNextBtn", ctx_r0.enableSuperPrevNext("next", "year"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-body"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.value())("activeDate", ctx_r0.activeDate())("disabledDate", ctx_r0.disabledDate())("selectedValue", ctx_r0.selectedValue());
  }
}
function InnerPopup_Case_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "month-header", 3);
    \u0275\u0275twoWayListener("valueChange", function InnerPopup_Case_3_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r0.activeDate, $event) || (ctx_r0.activeDate = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("panelModeChange", function InnerPopup_Case_3_Template_month_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.panelModeChange.emit($event));
    })("valueChange", function InnerPopup_Case_3_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "month-table", 5);
    \u0275\u0275listener("valueChange", function InnerPopup_Case_3_Template_month_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onChooseMonth($event));
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-month"));
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("value", ctx_r0.activeDate);
    \u0275\u0275property("showSuperPreBtn", ctx_r0.enableSuperPrevNext("prev", "month"))("showSuperNextBtn", ctx_r0.enableSuperPrevNext("next", "month"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-body"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.value())("activeDate", ctx_r0.activeDate())("disabledDate", ctx_r0.disabledDate())("selectedValue", ctx_r0.selectedValue());
  }
}
function InnerPopup_Case_4_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "month-header", 3);
    \u0275\u0275twoWayListener("valueChange", function InnerPopup_Case_4_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r0.activeDate, $event) || (ctx_r0.activeDate = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("panelModeChange", function InnerPopup_Case_4_Template_month_header_panelModeChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.panelModeChange.emit($event));
    })("valueChange", function InnerPopup_Case_4_Template_month_header_valueChange_1_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div")(3, "quarter-table", 5);
    \u0275\u0275listener("valueChange", function InnerPopup_Case_4_Template_quarter_table_valueChange_3_listener($event) {
      \u0275\u0275restoreView(_r5);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onChooseQuarter($event));
    });
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-quarter"));
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("value", ctx_r0.activeDate);
    \u0275\u0275property("showSuperPreBtn", ctx_r0.enableSuperPrevNext("prev", "month"))("showSuperNextBtn", ctx_r0.enableSuperPrevNext("next", "month"))("showNextBtn", false)("showPreBtn", false);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-body"));
    \u0275\u0275advance();
    \u0275\u0275property("value", ctx_r0.value())("activeDate", ctx_r0.activeDate())("disabledDate", ctx_r0.disabledDate())("selectedValue", ctx_r0.selectedValue());
  }
}
function InnerPopup_Case_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-header", 6);
    \u0275\u0275twoWayListener("valueChange", function InnerPopup_Case_5_Template_date_header_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r0.activeDate, $event) || (ctx_r0.activeDate = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("panelModeChange", function InnerPopup_Case_5_Template_date_header_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.panelModeChange.emit($event));
    })("valueChange", function InnerPopup_Case_5_Template_date_header_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.headerChange.emit($event));
    });
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(1, "div")(2, "date-table", 7);
    \u0275\u0275listener("valueChange", function InnerPopup_Case_5_Template_date_table_valueChange_2_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.onSelectDate($event));
    })("dayHover", function InnerPopup_Case_5_Template_date_table_dayHover_2_listener($event) {
      \u0275\u0275restoreView(_r6);
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.dayHover.emit($event));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275twoWayProperty("value", ctx_r0.activeDate);
    \u0275\u0275property("showSuperPreBtn", ctx_r0.enableSuperPrevNext("prev", "date"))("showSuperNextBtn", ctx_r0.enableSuperPrevNext("next", "date"))("showPreBtn", ctx_r0.enablePrevNext("prev", "date"))("showNextBtn", ctx_r0.enablePrevNext("next", "date"));
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r0.prefixCls, "-body"));
    \u0275\u0275advance();
    \u0275\u0275property("showWeek", ctx_r0.showWeek())("value", ctx_r0.value())("activeDate", ctx_r0.activeDate())("disabledDate", ctx_r0.disabledDate())("cellRender", ctx_r0.dateRender())("selectedValue", ctx_r0.selectedValue())("hoverValue", ctx_r0.hoverValue())("timeZone", ctx_r0.timeZone());
  }
}
var _c55 = () => ({
  partType: "left"
});
var _c63 = () => ({
  partType: "right"
});
var _c72 = (a0) => ({
  partType: a0
});
function DatePopup_Conditional_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275listener("click", function DatePopup_Conditional_2_For_2_Template_div_click_0_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.shortcutSetValue(item_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-picker-shortcut-item"));
    \u0275\u0275classProp("disabled", item_r2.disabled);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r2.title, " ");
  }
}
function DatePopup_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275repeaterCreate(1, DatePopup_Conditional_2_For_2_Template, 2, 6, "div", 4, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-picker-shortcut"));
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r2.innerShortcutPresets);
  }
}
function DatePopup_Conditional_5_ng_container_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div")(1, "div")(2, "thy-nav", 6)(3, "a", 7);
    \u0275\u0275listener("click", function DatePopup_Conditional_5_Template_a_click_3_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab("advanced"));
    });
    \u0275\u0275text(4);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(5, "a", 7);
    \u0275\u0275listener("click", function DatePopup_Conditional_5_Template_a_click_5_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.selectTab("custom"));
    });
    \u0275\u0275text(6);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(7, "button", 8);
    \u0275\u0275listener("click", function DatePopup_Conditional_5_Template_button_click_7_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.clearFlexibleValue());
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerStart(8);
    \u0275\u0275elementStart(9, "div", 9)(10, "date-carousel", 10);
    \u0275\u0275listener("ngModelChange", function DatePopup_Conditional_5_Template_date_carousel_ngModelChange_10_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.changeValueFromAdvancedSelect($event));
    });
    \u0275\u0275twoWayListener("ngModelChange", function DatePopup_Conditional_5_Template_date_carousel_ngModelChange_10_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.advancedSelectedValue, $event) || (ctx_r2.advancedSelectedValue = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd()();
    \u0275\u0275elementContainerEnd();
    \u0275\u0275elementStart(11, "div", 9);
    \u0275\u0275template(12, DatePopup_Conditional_5_ng_container_12_Template, 1, 0, "ng-container", 11);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    const tplInnerPopup_r5 = \u0275\u0275reference(8);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-date-panel-flexible"));
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-date-panel-flexible-tab"));
    \u0275\u0275advance(2);
    \u0275\u0275property("thyNavLinkActive", ctx_r2.flexibleActiveTab === "advanced");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r2.locale().advance);
    \u0275\u0275advance();
    \u0275\u0275property("thyNavLinkActive", ctx_r2.flexibleActiveTab === "custom");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r2.locale().custom);
    \u0275\u0275advance(3);
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-date-panel-advanced"));
    \u0275\u0275property("hidden", ctx_r2.flexibleActiveTab !== "advanced");
    \u0275\u0275advance();
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.advancedSelectedValue);
    \u0275\u0275property("activeDate", ctx_r2.selectedValue[0]);
    \u0275\u0275advance();
    \u0275\u0275property("hidden", ctx_r2.flexibleActiveTab !== "custom");
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", tplInnerPopup_r5);
  }
}
function DatePopup_Conditional_6_Conditional_0_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_Conditional_6_Conditional_0_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_Conditional_6_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DatePopup_Conditional_6_Conditional_0_ng_container_0_Template, 1, 0, "ng-container", 12)(1, DatePopup_Conditional_6_Conditional_0_ng_container_1_Template, 1, 0, "ng-container", 12);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const tplRangePart_r6 = \u0275\u0275reference(12);
    \u0275\u0275property("ngTemplateOutlet", tplRangePart_r6)("ngTemplateOutletContext", \u0275\u0275pureFunction0(4, _c55));
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", tplRangePart_r6)("ngTemplateOutletContext", \u0275\u0275pureFunction0(5, _c63));
  }
}
function DatePopup_Conditional_6_Conditional_1_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_Conditional_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div");
    \u0275\u0275template(1, DatePopup_Conditional_6_Conditional_1_ng_container_1_Template, 1, 0, "ng-container", 11);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const tplInnerPopup_r5 = \u0275\u0275reference(8);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", tplInnerPopup_r5);
  }
}
function DatePopup_Conditional_6_Conditional_2_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_Conditional_6_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, DatePopup_Conditional_6_Conditional_2_ng_container_0_Template, 1, 0, "ng-container", 11);
  }
  if (rf & 2) {
    \u0275\u0275nextContext(2);
    const tplFooter_r7 = \u0275\u0275reference(10);
    \u0275\u0275property("ngTemplateOutlet", tplFooter_r7);
  }
}
function DatePopup_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DatePopup_Conditional_6_Conditional_0_Template, 2, 6)(1, DatePopup_Conditional_6_Conditional_1_Template, 2, 1, "div");
    \u0275\u0275conditionalCreate(2, DatePopup_Conditional_6_Conditional_2_Template, 1, 1, "ng-container");
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r2.isRange() ? 0 : 1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!ctx_r2.isRange() ? 2 : -1);
  }
}
function DatePopup_ng_template_7_Template(rf, ctx) {
  if (rf & 1) {
    const _r8 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "inner-popup", 13);
    \u0275\u0275listener("panelModeChange", function DatePopup_ng_template_7_Template_inner_popup_panelModeChange_0_listener($event) {
      const partType_r9 = \u0275\u0275restoreView(_r8).partType;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onPanelModeChange($event, partType_r9));
    })("dayHover", function DatePopup_ng_template_7_Template_inner_popup_dayHover_0_listener($event) {
      \u0275\u0275restoreView(_r8);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDayHover($event));
    })("selectDate", function DatePopup_ng_template_7_Template_inner_popup_selectDate_0_listener($event) {
      const partType_r9 = \u0275\u0275restoreView(_r8).partType;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.changeValueFromSelect($event, partType_r9));
    })("headerChange", function DatePopup_ng_template_7_Template_inner_popup_headerChange_0_listener($event) {
      const partType_r9 = \u0275\u0275restoreView(_r8).partType;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onHeaderChange($event, partType_r9));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const partType_r9 = ctx.partType;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("showWeek", ctx_r2.showWeek())("isRange", ctx_r2.isRange())("panelMode", ctx_r2.getPanelMode(ctx_r2.panelMode(), partType_r9))("endPanelMode", ctx_r2.getPanelMode(ctx_r2.endPanelMode(), partType_r9))("partType", partType_r9)("showDateRangeInput", ctx_r2.flexible() && ctx_r2.flexibleActiveTab === "custom")("value", ctx_r2.getValueBySelector(partType_r9))("selectedValue", ctx_r2.selectedValue)("activeDate", ctx_r2.getActiveDate(partType_r9))("rangeActiveDate", ctx_r2.activeDate)("disabledDate", ctx_r2.disabledDate())("dateRender", ctx_r2.dateRender())("hoverValue", ctx_r2.hoverValue)("timeZone", ctx_r2.timeZone());
  }
}
function DatePopup_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    const _r10 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "calendar-footer", 14);
    \u0275\u0275listener("showTimePickerChange", function DatePopup_ng_template_9_Template_calendar_footer_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("selectTime", function DatePopup_ng_template_9_Template_calendar_footer_selectTime_0_listener($event) {
      \u0275\u0275restoreView(_r10);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onSelectTime($event));
    })("clickOk", function DatePopup_ng_template_9_Template_calendar_footer_clickOk_0_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClickOk());
    })("clickRemove", function DatePopup_ng_template_9_Template_calendar_footer_clickRemove_0_listener() {
      \u0275\u0275restoreView(_r10);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onClickRemove());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("showTime", ctx_r2.showTime())("mustShowTime", ctx_r2.mustShowTime())("value", ctx_r2.value())("timeZone", ctx_r2.timeZone())("disableTimeConfirm", ctx_r2.disableTimeConfirm());
  }
}
function DatePopup_ng_template_11_ng_container_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function DatePopup_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div")(1, "div", 15);
    \u0275\u0275template(2, DatePopup_ng_template_11_ng_container_2_Template, 1, 0, "ng-container", 12);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const partType_r11 = ctx.partType;
    const ctx_r2 = \u0275\u0275nextContext();
    const tplInnerPopup_r5 = \u0275\u0275reference(8);
    \u0275\u0275classMap(\u0275\u0275interpolate3("", ctx_r2.prefixCls, "-range-part ", ctx_r2.prefixCls, "-range-", partType_r11));
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", tplInnerPopup_r5)("ngTemplateOutletContext", \u0275\u0275pureFunction1(7, _c72, partType_r11));
  }
}
var _c8 = ["origin"];
var _c9 = ["pickerInput"];
var _c10 = ["overlayContainer"];
var _c11 = ["*"];
var _c122 = (a0) => ({
  "panel-is-opened": a0
});
function ThyPicker_ng_container_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function ThyPicker_ng_template_6_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-icon", 10);
    \u0275\u0275listener("click", function ThyPicker_ng_template_6_Conditional_1_Template_thy_icon_click_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.onClickClear($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275interpolate1("remove-link remove-link-", ctx_r2.size()));
  }
}
function ThyPicker_ng_template_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275conditionalCreate(1, ThyPicker_ng_template_6_Conditional_1_Template, 1, 2, "thy-icon", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "span");
    \u0275\u0275element(3, "thy-icon", 9);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-picker-clear"));
    \u0275\u0275advance();
    \u0275\u0275conditional(!ctx_r2.disabled() && !ctx_r2.isEmptyValue(ctx_r2.value()) && ctx_r2.allowClear() && !ctx_r2.readonly() ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx_r2.prefixCls, "-picker-icon"));
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275interpolate1("remove-link-", ctx_r2.size() ? ctx_r2.size() : "default"))("thyIconName", ctx_r2.suffixIcon());
  }
}
function ThyPicker_ng_template_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 11, 3);
    \u0275\u0275projection(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("@scaleXMotion", ctx_r2.placement() === "left" || ctx_r2.placement() === "right" ? "enter" : "void")("@scaleYMotion", ctx_r2.placement() === "top" || ctx_r2.placement() === "bottom" ? "enter" : "void")("@scaleMotion", ctx_r2.placement() !== "left" && ctx_r2.placement() !== "right" && ctx_r2.placement() !== "top" && ctx_r2.placement() !== "bottom" ? "enter" : "void");
  }
}
var _c132 = ["thyPicker"];
function ThyDatePicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyDatePicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyDatePicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyDatePicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyDatePicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyDatePicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyDatePicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function ThyMonthPicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyMonthPicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyMonthPicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyMonthPicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyMonthPicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyMonthPicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyMonthPicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function ThyRangePicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyRangePicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyRangePicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyRangePicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyRangePicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyRangePicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyRangePicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function ThyWeekPicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyWeekPicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyWeekPicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyWeekPicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyWeekPicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyWeekPicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyWeekPicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function ThyYearPicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyYearPicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyYearPicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyYearPicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyYearPicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyYearPicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyYearPicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function ThyQuarterPicker_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "date-popup", 3);
    \u0275\u0275listener("panelModeChange", function ThyQuarterPicker_Conditional_2_Template_date_popup_panelModeChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.thyOnPanelChange.emit($event));
    })("showTimePickerChange", function ThyQuarterPicker_Conditional_2_Template_date_popup_showTimePickerChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onShowTimePickerChange($event));
    })("valueChange", function ThyQuarterPicker_Conditional_2_Template_date_popup_valueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onValueChange($event));
    })("calendarChange", function ThyQuarterPicker_Conditional_2_Template_date_popup_calendarChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onCalendarChange($event));
    })("dateValueChange", function ThyQuarterPicker_Conditional_2_Template_date_popup_dateValueChange_0_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onDateValueChange($event));
    })("resultOk", function ThyQuarterPicker_Conditional_2_Template_date_popup_resultOk_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onResultOk());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275property("isRange", ctx_r2.isRange)("showWeek", ctx_r2.showWeek())("panelMode", ctx_r2.panelMode)("flexible", ctx_r2.flexible())("flexibleDateGranularity", ctx_r2.flexibleDateGranularity)("defaultPickerValue", ctx_r2.thyDefaultPickerValue())("value", ctx_r2.thyValue)("showTime", ctx_r2.thyShowTime())("mustShowTime", ctx_r2.withTime)("format", ctx_r2.thyFormat())("dateRender", ctx_r2.thyDateRender())("disabledDate", ctx_r2.thyDisabledDate())("minDate", ctx_r2.thyMinDate())("maxDate", ctx_r2.thyMaxDate())("showShortcut", ctx_r2.thyShowShortcut())("shortcutPresets", ctx_r2.thyShortcutPresets())("shortcutPosition", ctx_r2.thyShortcutPosition())("timestampPrecision", ctx_r2.thyTimestampPrecision())("className", ctx_r2.thyPanelClassName())("timeZone", ctx_r2.thyTimeZone());
    \u0275\u0275attribute("tabindex", -1);
  }
}
function DATE_HELPER_SERVICE_FACTORY() {
  return new DateHelperByDatePipe();
}
var DateHelperService = class _DateHelperService {
  constructor() {
    this.locale = injectLocale();
    this.relyOnDatePipe = this instanceof DateHelperByDatePipe;
  }
  static {
    this.\u0275fac = function DateHelperService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DateHelperService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _DateHelperService,
      factory: () => DATE_HELPER_SERVICE_FACTORY(),
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateHelperService, [{
    type: Injectable,
    args: [{
      providedIn: "root",
      useFactory: DATE_HELPER_SERVICE_FACTORY
    }]
  }], null, null);
})();
var DateHelperByDatePipe = class extends DateHelperService {
  getISOWeek(date) {
    return +this.format(date, "w");
  }
  format(date, formatStr) {
    return date ? formatDate(date, formatStr, this.locale().id) : "";
  }
  transCompatFormat(format4) {
    return format4 && format4.replace(/Y/g, "y").replace(/D/g, "d");
  }
};
var CalendarHeader = class _CalendarHeader {
  constructor() {
    this.dateHelper = inject(DateHelperService);
    this.locale = injectLocale("datePicker");
    this.showSuperPreBtn = input(true, ...ngDevMode ? [{
      debugName: "showSuperPreBtn",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showSuperNextBtn = input(true, ...ngDevMode ? [{
      debugName: "showSuperNextBtn",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showPreBtn = input(true, ...ngDevMode ? [{
      debugName: "showPreBtn",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showNextBtn = input(true, ...ngDevMode ? [{
      debugName: "showNextBtn",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.value = model(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.valueChange = output();
    this.panelModeChange = output();
    this.prefixCls = "thy-calendar";
    this.selectors = null;
    effect(() => {
      this.render();
    });
  }
  ngOnInit() {
    if (!this.value()) {
      this.value.set(new TinyDate());
    }
  }
  superPrevious() {
    this.gotoYear(-1);
  }
  superNext() {
    this.gotoYear(1);
  }
  previous() {
    this.gotoMonth(-1);
  }
  next() {
    this.gotoMonth(1);
  }
  changePanel(mode, value) {
    this.panelModeChange.emit(mode);
  }
  selectorClick(event, selector) {
    event.stopPropagation();
    return selector ? selector.onClick() : null;
  }
  render() {
    if (this.value()) {
      this.selectors = this.getSelectors();
    }
  }
  gotoMonth(amount) {
    this.changeValue(this.value().addMonths(amount));
  }
  gotoYear(amount) {
    this.changeValue(this.value().addYears(amount));
  }
  changeValue(value) {
    if (this.value() !== value) {
      this.value.set(value);
      this.valueChange.emit(value);
    }
  }
  formatDateTime(format4) {
    const date = this.value().nativeDate;
    return this.dateHelper.format(date, format4);
  }
  static {
    this.\u0275fac = function CalendarHeader_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CalendarHeader)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _CalendarHeader,
      inputs: {
        showSuperPreBtn: [1, "showSuperPreBtn"],
        showSuperNextBtn: [1, "showSuperNextBtn"],
        showPreBtn: [1, "showPreBtn"],
        showNextBtn: [1, "showNextBtn"],
        value: [1, "value"]
      },
      outputs: {
        value: "valueChange",
        valueChange: "valueChange",
        panelModeChange: "panelModeChange"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarHeader, [{
    type: Directive
  }], () => [], {
    showSuperPreBtn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showSuperPreBtn",
        required: false
      }]
    }],
    showSuperNextBtn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showSuperNextBtn",
        required: false
      }]
    }],
    showPreBtn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showPreBtn",
        required: false
      }]
    }],
    showNextBtn: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showNextBtn",
        required: false
      }]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }, {
      type: Output,
      args: ["valueChange"]
    }],
    valueChange: [{
      type: Output,
      args: ["valueChange"]
    }],
    panelModeChange: [{
      type: Output,
      args: ["panelModeChange"]
    }]
  });
})();
var MonthHeader = class _MonthHeader extends CalendarHeader {
  getSelectors() {
    const yearFormat = this.locale().yearFormat;
    return [{
      className: `${this.prefixCls}-month-btn`,
      onClick: () => this.changePanel("year"),
      label: this.formatDateTime(yearFormat)
    }];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275MonthHeader_BaseFactory;
      return function MonthHeader_Factory(__ngFactoryType__) {
        return (\u0275MonthHeader_BaseFactory || (\u0275MonthHeader_BaseFactory = \u0275\u0275getInheritedFactory(_MonthHeader)))(__ngFactoryType__ || _MonthHeader);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _MonthHeader,
      selectors: [["month-header"]],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 13,
      vars: 26,
      consts: [[2, "position", "relative"], ["role", "button", 3, "click", "ngClass", "title"], ["thyIconName", "angle-double-left"], ["thyIconName", "angle-left"], ["role", "button", 3, "class", "title"], ["thyIconName", "angle-right"], ["thyIconName", "angle-double-right"], ["role", "button", 3, "click", "title"]],
      template: function MonthHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "a", 1);
          \u0275\u0275listener("click", function MonthHeader_Template_a_click_2_listener() {
            return ctx.superPrevious();
          });
          \u0275\u0275element(3, "thy-icon", 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(4, "a", 1);
          \u0275\u0275listener("click", function MonthHeader_Template_a_click_4_listener() {
            return ctx.previous();
          });
          \u0275\u0275element(5, "thy-icon", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "span");
          \u0275\u0275repeaterCreate(7, MonthHeader_For_8_Template, 2, 5, "a", 4, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "a", 1);
          \u0275\u0275listener("click", function MonthHeader_Template_a_click_9_listener() {
            return ctx.next();
          });
          \u0275\u0275element(10, "thy-icon", 5);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(11, "a", 1);
          \u0275\u0275listener("click", function MonthHeader_Template_a_click_11_listener() {
            return ctx.superNext();
          });
          \u0275\u0275element(12, "thy-icon", 6);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-header"));
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousYear);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-month-btn"));
          \u0275\u0275property("ngClass", ctx.showPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-my-select"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.selectors);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-month-btn"));
          \u0275\u0275property("ngClass", ctx.showNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextYear);
        }
      },
      dependencies: [NgClass, ThyIcon],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthHeader, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "month-header",
      imports: [NgClass, ThyIcon],
      template: `<div class="{{ prefixCls }}-header">
  <div style="position: relative">
    <a
      class="{{ prefixCls }}-prev-year-btn"
      [ngClass]="showSuperPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superPrevious()"
      [title]="locale().previousYear">
      <thy-icon thyIconName="angle-double-left"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-prev-month-btn"
      [ngClass]="showPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="previous()"
      [title]="locale().previousMonth">
      <thy-icon thyIconName="angle-left"></thy-icon>
    </a>

    <span class="{{ prefixCls }}-my-select">
      @for (selector of selectors; track $index) {
        <a class="{{ selector.className }}" role="button" (click)="selectorClick($event, selector)" title="{{ selector.title || null }}">
          {{ selector.label }}
        </a>
      }
    </span>

    <a
      class="{{ prefixCls }}-next-month-btn"
      [ngClass]="showNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="next()"
      [title]="locale().nextMonth">
      <thy-icon thyIconName="angle-right"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-next-year-btn"
      [ngClass]="showSuperNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superNext()"
      [title]="locale().nextYear">
      <thy-icon thyIconName="angle-double-right"></thy-icon>
    </a>
  </div>
</div>
`
    }]
  }], null, null);
})();
var CalendarFooter = class _CalendarFooter {
  constructor() {
    this.showTime = input(false, ...ngDevMode ? [{
      debugName: "showTime",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.mustShowTime = input(false, ...ngDevMode ? [{
      debugName: "mustShowTime",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.value = model(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.disableTimeConfirm = input(false, ...ngDevMode ? [{
      debugName: "disableTimeConfirm",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.selectTime = output();
    this.clickOk = output();
    this.clickRemove = output();
    this.showTimePickerChange = output();
    this.isShowTime = signal(false, ...ngDevMode ? [{
      debugName: "isShowTime"
    }] : []);
    this.isCanTime = signal(false, ...ngDevMode ? [{
      debugName: "isCanTime"
    }] : []);
    this.locale = injectLocale("datePicker");
    effect(() => {
      this.initTimeShowMode();
    });
  }
  ngOnInit() {
    this.initValue();
  }
  initValue() {
    if (!this.value()) {
      const defaultDate = new TinyDate(void 0, this.timeZone());
      this.value.set(defaultDate);
    }
  }
  onSelectTime(date) {
    this.selectTime.emit(new TinyDate(date, this.timeZone()));
  }
  onTimeOk() {
    if (this.disableTimeConfirm()) {
      return;
    }
    this.selectTime.emit(this.value());
    this.clickOk.emit();
  }
  onClear() {
    this.value.set(null);
    this.clickRemove.emit();
  }
  changeTimeShowMode(type) {
    this.isCanTime.set(type === "can");
    this.isShowTime.set(type === "show");
    this.showTimePickerChange.emit(this.isShowTime());
  }
  initTimeShowMode() {
    if (this.mustShowTime()) {
      this.changeTimeShowMode("show");
    } else {
      if (this.showTime()) {
        this.changeTimeShowMode("can");
      }
    }
  }
  static {
    this.\u0275fac = function CalendarFooter_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CalendarFooter)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CalendarFooter,
      selectors: [["calendar-footer"]],
      inputs: {
        showTime: [1, "showTime"],
        mustShowTime: [1, "mustShowTime"],
        value: [1, "value"],
        timeZone: [1, "timeZone"],
        disableTimeConfirm: [1, "disableTimeConfirm"]
      },
      outputs: {
        value: "valueChange",
        selectTime: "selectTime",
        clickOk: "clickOk",
        clickRemove: "clickRemove",
        showTimePickerChange: "showTimePickerChange"
      },
      exportAs: ["calendarFooter"],
      decls: 3,
      vars: 3,
      consts: [[1, "time-picker-section"], [1, "time-picker-section", 3, "click"], ["href", "javascript:;", 1, "link-has-icon", "time-picker-set-btn"], [1, "time-picker-wrap", 3, "showMeridian", "timeZone", "ngModel"], [1, "time-picker-btn-wrap"], ["thyButton", "primary", "thySize", "sm", 1, "time-picker-ok-btn", 3, "disabled"], ["thyButton", "link-secondary", "thySize", "sm", 1, "time-picker-clear-btn", 3, "click"], ["href", "javascript:;", 1, "link-has-icon", "time-picker-set-btn", 3, "click"], ["thyIconName", "clock-circle"], [1, "time-picker-wrap", 3, "ngModelChange", "showMeridian", "timeZone", "ngModel"], ["thyButton", "primary", "thySize", "sm", 1, "time-picker-ok-btn", 3, "click", "disabled"]],
      template: function CalendarFooter_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0)(1);
          \u0275\u0275conditionalCreate(2, CalendarFooter_Conditional_2_Template, 7, 4, "div", 0);
        }
        if (rf & 2) {
          const showTime_r8 = \u0275\u0275storeLet(ctx.isShowTime());
          \u0275\u0275advance();
          const canTime_r9 = \u0275\u0275storeLet(ctx.isCanTime());
          \u0275\u0275advance();
          \u0275\u0275conditional(showTime_r8 || canTime_r9 ? 2 : -1);
        }
      },
      dependencies: [ThyIcon, ThyInnerTimePicker, FormsModule, NgControlStatus, NgModel, ThyButton],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarFooter, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "calendar-footer",
      exportAs: "calendarFooter",
      imports: [ThyIcon, ThyInnerTimePicker, FormsModule, ThyButton],
      template: `@let showTime = isShowTime();
@let canTime = isCanTime();

@if (showTime || canTime) {
  <div class="time-picker-section" (click)="$event.stopPropagation()">
    @if (canTime) {
      <a href="javascript:;" class="link-has-icon time-picker-set-btn" (click)="changeTimeShowMode('show')">
        <thy-icon thyIconName="clock-circle"></thy-icon>{{ locale().setTime }}
      </a>
    }
    @if (showTime) {
      <thy-inner-time-picker
        class="time-picker-wrap"
        [showMeridian]="false"
        [timeZone]="timeZone()"
        [ngModel]="value()"
        (ngModelChange)="onSelectTime($event)"></thy-inner-time-picker>
    }
    <div class="time-picker-btn-wrap">
      @if (!canTime) {
        <button [disabled]="disableTimeConfirm()" class="time-picker-ok-btn" thyButton="primary" thySize="sm" (click)="onTimeOk()">
          {{ locale().ok }}
        </button>
      }
      <button class="time-picker-clear-btn" thyButton="link-secondary" thySize="sm" (click)="onClear()">{{ locale().clear }}</button>
    </div>
  </div>
}
`
    }]
  }], () => [], {
    showTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showTime",
        required: false
      }]
    }],
    mustShowTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "mustShowTime",
        required: false
      }]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }, {
      type: Output,
      args: ["valueChange"]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    disableTimeConfirm: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disableTimeConfirm",
        required: false
      }]
    }],
    selectTime: [{
      type: Output,
      args: ["selectTime"]
    }],
    clickOk: [{
      type: Output,
      args: ["clickOk"]
    }],
    clickRemove: [{
      type: Output,
      args: ["clickRemove"]
    }],
    showTimePickerChange: [{
      type: Output,
      args: ["showTimePickerChange"]
    }]
  });
})();
var QUARTER_FORMAT = "'Q'q";
var THY_DATE_PICKER_CONFIG = new InjectionToken("thy-date-picker-config");
function useDatePickerDefaultConfig() {
  const locale2 = injectLocale("datePicker");
  return {
    shortcutPosition: "left",
    showShortcut: false,
    weekStartsOn: 1,
    separator: "~",
    timestampPrecision: "seconds",
    shortcutDatePresets: () => {
      return [{
        title: locale2().today,
        value: startOfDay2(new TinyDate().nativeDate).getTime()
      }, {
        title: locale2().tomorrow,
        value: startOfDay2(addDays2(new TinyDate().nativeDate, 1)).getTime()
      }, {
        title: locale2().nextWeek,
        value: startOfWeek2(addWeeks2(new TinyDate().nativeDate, 1), {
          weekStartsOn: 1
        }).getTime()
      }];
    },
    shortcutRangesPresets: () => {
      return [{
        title: locale2().lastSevenDays,
        value: [new TinyDate().subDays(6).getTime(), new TinyDate().endOfDay().getTime()]
      }, {
        title: locale2().lastThirtyDays,
        value: [new TinyDate().subDays(29).getTime(), new TinyDate().endOfDay().getTime()]
      }, {
        title: locale2().currentWeek,
        value: [new TinyDate().startOfWeek({
          weekStartsOn: 1
        }).getTime(), new TinyDate().endOfWeek({
          weekStartsOn: 1
        }).getTime()]
      }, {
        title: locale2().currentMonth,
        value: [new TinyDate().startOfMonth().getTime(), new TinyDate().endOfMonth().getTime()]
      }];
    }
  };
}
var ThyDatePickerConfigService = class _ThyDatePickerConfigService {
  constructor() {
    const datePickerConfig = inject(THY_DATE_PICKER_CONFIG, {
      optional: true
    });
    this.config = __spreadValues(__spreadValues({}, useDatePickerDefaultConfig()), datePickerConfig);
  }
  get shortcutDatePresets() {
    return this.config.shortcutDatePresets;
  }
  get shortcutPosition() {
    return this.config.shortcutPosition;
  }
  get showShortcut() {
    return this.config.showShortcut;
  }
  get shortcutRangesPresets() {
    return this.config.shortcutRangesPresets;
  }
  get timestampPrecision() {
    return this.config.timestampPrecision;
  }
  get separator() {
    return this.config.separator.trim();
  }
  static {
    this.\u0275fac = function ThyDatePickerConfigService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDatePickerConfigService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ThyDatePickerConfigService,
      factory: _ThyDatePickerConfigService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePickerConfigService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [], null);
})();
function transformDateValue(value) {
  if (!value) {
    return {
      value: null
    };
  }
  let withTime;
  let flexibleDateGranularity = void 0;
  if (value && typeof value === "number") {
    value = convertDate(value);
  }
  if (value && instanceOfCompatibleValue(value)) {
    if (value instanceof TinyDate) {
      value = convertDate(value.nativeDate);
    } else {
      value[0] = convertDate(value[0].nativeDate);
      value[1] = convertDate(value[1].nativeDate);
    }
  }
  if (value && instanceOfDateEntry(value)) {
    const {
      date,
      with_time
    } = value;
    value = date ? convertDate(date) : null;
    withTime = !!with_time;
  }
  if (value && instanceOfRangeEntry(value)) {
    const rangeValue = value;
    value = [];
    if (rangeValue.begin && rangeValue.end) {
      value[0] = convertDate(rangeValue.begin);
      value[1] = convertDate(rangeValue.end);
    }
    if (rangeValue.granularity) {
      flexibleDateGranularity = rangeValue.granularity;
    }
  }
  if (value && instanceOfRangeAdvancedValue(value)) {
    const rangeValue = value;
    if (rangeValue.dateGranularity) {
      flexibleDateGranularity = rangeValue.dateGranularity;
    }
    value = [];
    if (rangeValue.begin && rangeValue.end) {
      value[0] = convertDate(rangeValue.begin.nativeDate);
      value[1] = convertDate(rangeValue.end.nativeDate);
    }
  }
  return {
    value,
    withTime,
    flexibleDateGranularity
  };
}
function getFlexibleAdvancedReadableValue(tinyDates, flexibleDateGranularity, separator, locale2) {
  let value = "";
  if (!tinyDates[0] || !tinyDates[1]) {
    return value;
  }
  switch (flexibleDateGranularity) {
    case "year": {
      const yearFormatStr = locale2().datePicker.yearFormat;
      if (tinyDates[0].isSameYear(tinyDates[1])) {
        value = `${tinyDates[0].format(yearFormatStr)}`;
      } else {
        value = `${tinyDates[0].format(yearFormatStr)}${separator}${tinyDates[1].format(yearFormatStr)}`;
      }
      break;
    }
    case "quarter": {
      const quarterFormatStr = locale2().datePicker.yearQuarterFormat;
      if (tinyDates[0].isSameQuarter(tinyDates[1])) {
        value = `${tinyDates[0].format(quarterFormatStr)}`;
      } else {
        value = `${tinyDates[0].format(quarterFormatStr)}${separator}${tinyDates[1].format(quarterFormatStr)}`;
      }
      break;
    }
    case "month": {
      const monthFormatStr = locale2().datePicker.yearMonthFormat;
      if (tinyDates[0].isSameMonth(tinyDates[1])) {
        value = `${tinyDates[0].format(monthFormatStr)}`;
      } else {
        value = `${tinyDates[0].format(monthFormatStr)}${separator}${tinyDates[1].format(monthFormatStr)}`;
      }
      break;
    }
  }
  return value;
}
function convertDate(date) {
  if (typeof date === "number") {
    if (date.toString().length < 13) {
      return TinyDate.fromUnixTime(date)?.nativeDate;
    } else {
      return new TinyDate(date)?.nativeDate;
    }
  } else if (date instanceof TinyDate) {
    return date?.nativeDate;
  } else {
    return new TinyDate(date)?.nativeDate;
  }
}
function hasValue(value) {
  if (Array.isArray(value)) {
    return !!value[0] && !!value[1];
  } else {
    return !!value;
  }
}
function makeValue(value, isRange = false, withTime, timeZone) {
  if (isRange) {
    return Array.isArray(value) ? value.map((val) => new TinyDate(val, timeZone)) : [];
  } else {
    if (!value) {
      return null;
    }
    const date = new TinyDate(value, timeZone);
    return withTime ? date.setSeconds(0) : date.startOfDay();
  }
}
function dateAddAmount(value, amount, mode) {
  let date;
  switch (mode) {
    case "decade":
      date = value.addYears(amount * 10);
      break;
    case "year":
      date = value.addYears(amount);
      break;
    case "month":
      date = value.addMonths(amount);
      break;
    default:
      date = value.addMonths(amount);
      break;
  }
  return date;
}
function isAfterMoreThanOneMonth(rightDate, leftDate) {
  rightDate = rightDate ? rightDate : leftDate ? leftDate : new TinyDate();
  leftDate = leftDate ? leftDate : rightDate;
  if (rightDate.getYear() < leftDate.getYear()) {
    return false;
  }
  if (rightDate.getYear() === leftDate.getYear() && leftDate.getMonth() + 1 >= rightDate.getMonth()) {
    return false;
  }
  return !(rightDate.getYear() - leftDate.getYear() === 1 && rightDate.getMonth() === 0 && leftDate.getMonth() === 11);
}
function isAfterMoreThanLessOneYear(rightDate, leftDate) {
  rightDate = rightDate ? rightDate : leftDate ? leftDate : new TinyDate();
  leftDate = leftDate ? leftDate : rightDate;
  if (rightDate.getYear() <= leftDate.getYear()) {
    return false;
  }
  return !(rightDate.getYear() - leftDate.getYear() === 1 && rightDate.getMonth() <= leftDate.getMonth());
}
function isAfterMoreThanOneYear(rightDate, leftDate) {
  rightDate = rightDate ? rightDate : leftDate ? leftDate : new TinyDate();
  leftDate = leftDate ? leftDate : rightDate;
  if (leftDate.getYear() + 1 >= rightDate.getYear()) {
    return false;
  } else {
    return true;
  }
}
function isAfterMoreThanOneDecade(rightDate, leftDate) {
  rightDate = rightDate ? rightDate : leftDate ? leftDate : new TinyDate();
  leftDate = leftDate ? leftDate : rightDate;
  return rightDate.getYear() - leftDate.getYear() >= 20;
}
function instanceOfDateEntry(object) {
  return isSupportDateType(object, "date") && typeof object.with_time === "number";
}
function instanceOfRangeEntry(object) {
  return isSupportDateType(object, "begin") && isSupportDateType(object, "end");
}
function instanceOfCompatibleValue(object) {
  return object instanceof TinyDate || object[0] instanceof TinyDate;
}
function instanceOfRangeAdvancedValue(object) {
  return object["begin"] instanceof TinyDate && object["end"] instanceof TinyDate;
}
function isSupportDateType(object, key) {
  return typeof object[key] === "number" || object[key] === null || object[key] instanceof Date;
}
function getShortcutValue(value) {
  return index.isFunction(value) ? value() : value;
}
function isValidStringDate(dateStr, timeZone) {
  const parseDate2 = parseStringDate(dateStr, timeZone).nativeDate.getTime();
  return !(parseDate2 < 0 || isNaN(parseDate2));
}
function parseStringDate(dateStr, timeZone) {
  return hasTimeInStringDate2(dateStr, timeZone) ? new TinyDate(fixStringDate(dateStr, timeZone), timeZone) : new TinyDate(fixStringDate(dateStr, timeZone), timeZone).startOfDay();
}
function hasTimeInStringDate2(dateStr, timeZone) {
  const formatDate2 = fixStringDate(dateStr, timeZone);
  const timeRegex = /(\d{1,2}:\d{1,2}(:\d{1,2})?)|(^\d{1,2}时\d{1,2}分(\d{1,2}秒)?)$/;
  return timeRegex.test(formatDate2);
}
function fixStringDate(dateStr, timeZone) {
  let replacedStr = dateStr.replace(/[^0-9\s.,:]/g, "-").replace("- ", " ");
  const hasYear = /\d{4}/.test(replacedStr);
  if (!hasYear || replacedStr.length < "yyyy.M.d".length) {
    replacedStr = `${new TinyDate(void 0, timeZone).getYear()}-${replacedStr}`;
  }
  return replacedStr;
}
function setValueByTimestampPrecision(date, isRange, timestampPrecision, timeZone) {
  const {
    value
  } = transformDateValue(date);
  if (!value || index.isArray(value) && !value?.length) {
    return index.isArray(value) ? [null, null] : null;
  }
  if (timestampPrecision === "milliseconds") {
    return isRange ? coerceArray2(value).map((val) => new TinyDate(val, timeZone).getTime()) : new TinyDate(value, timeZone).getTime();
  } else {
    return isRange ? coerceArray2(value).map((val) => new TinyDate(val, timeZone).getUnixTime()) : new TinyDate(value, timeZone)?.getUnixTime();
  }
}
var ThyDatePickerFormatPipe = class _ThyDatePickerFormatPipe {
  constructor() {
    this.dateHelper = inject(DateHelperService);
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
    this.i18n = inject(ThyI18nService);
  }
  transform(originalValue, formatStr, separator) {
    const {
      value,
      withTime,
      flexibleDateGranularity
    } = transformDateValue(originalValue);
    if (!formatStr) {
      formatStr = withTime ? "yyyy-MM-dd HH:mm" : "yyyy-MM-dd";
    }
    const currentSeparator = ` ${(separator ?? this.datePickerConfigService.separator)?.trim()} `;
    if (!Array.isArray(value)) {
      return this.dateHelper.format(value, formatStr);
    } else {
      if (flexibleDateGranularity && flexibleDateGranularity !== "day") {
        const tinyDates = [new TinyDate(value[0]), new TinyDate(value[1])];
        return getFlexibleAdvancedReadableValue(tinyDates, flexibleDateGranularity, currentSeparator, this.i18n.getLocale());
      } else {
        return value.map((date) => this.dateHelper.format(date, formatStr)).join(currentSeparator);
      }
    }
  }
  static {
    this.\u0275fac = function ThyDatePickerFormatPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDatePickerFormatPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "thyDatePickerFormat",
      type: _ThyDatePickerFormatPipe,
      pure: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePickerFormatPipe, [{
    type: Pipe,
    args: [{
      name: "thyDatePickerFormat"
    }]
  }], null, null);
})();
var ThyQuarterPickerFormatPipe = class _ThyQuarterPickerFormatPipe {
  constructor() {
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
  }
  transform(originalValue, formatStr, separator) {
    const {
      value
    } = transformDateValue(originalValue);
    if (!formatStr) {
      formatStr = `yyyy-${QUARTER_FORMAT}`;
    }
    if (!value) {
      return;
    }
    if (!Array.isArray(value)) {
      const _value = new TinyDate(value);
      return _value.format(formatStr);
    } else {
      return value.map((date) => {
        const _date = new TinyDate(date);
        return _date.format(formatStr);
      }).join(` ${(separator ?? this.datePickerConfigService.separator)?.trim()} `);
    }
  }
  static {
    this.\u0275fac = function ThyQuarterPickerFormatPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyQuarterPickerFormatPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "thyQuarterPickerFormat",
      type: _ThyQuarterPickerFormatPipe,
      pure: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyQuarterPickerFormatPipe, [{
    type: Pipe,
    args: [{
      name: "thyQuarterPickerFormat"
    }]
  }], null, null);
})();
var ThyDatePickerFormatStringPipe = class _ThyDatePickerFormatStringPipe {
  transform(originalValue) {
    const {
      withTime
    } = transformDateValue(originalValue);
    return withTime ? "yyyy-MM-dd HH:mm" : "yyyy-MM-dd";
  }
  static {
    this.\u0275fac = function ThyDatePickerFormatStringPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDatePickerFormatStringPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "thyDatePickerFormatString",
      type: _ThyDatePickerFormatStringPipe,
      pure: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePickerFormatStringPipe, [{
    type: Pipe,
    args: [{
      name: "thyDatePickerFormatString"
    }]
  }], null, null);
})();
var DatePickerAdvancedShowYearTipPipe = class _DatePickerAdvancedShowYearTipPipe {
  transform(value, type) {
    return type !== "year" && value.startValue.isSameDay(value.startValue.startOfYear());
  }
  static {
    this.\u0275fac = function DatePickerAdvancedShowYearTipPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DatePickerAdvancedShowYearTipPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "showYearTip",
      type: _DatePickerAdvancedShowYearTipPipe,
      pure: true
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerAdvancedShowYearTipPipe, [{
    type: Pipe,
    args: [{
      name: "showYearTip"
    }]
  }], null, null);
})();
var DateCarousel = class _DateCarousel {
  constructor() {
    this.cdr = inject(ChangeDetectorRef);
    this.dateHelper = inject(DateHelperService);
    this.locale = injectLocale("datePicker");
    this.activeDate = input(...ngDevMode ? [void 0, {
      debugName: "activeDate"
    }] : []);
    this.selectableData = {};
    this.selectedValue = [];
    this.initialized = false;
    this.selectedValueChange$ = new Subject();
  }
  set defaultValue(value) {
    this.dateGranularity = value.dateGranularity;
    this.buildSelectableData(value.begin);
    if (value.begin && value.end) {
      const shouldBeSelectValue = this.getShouldBeToggleValue(value.begin, value.end);
      this.select(...shouldBeSelectValue);
    } else {
      this.clearSelect(true);
    }
    this.initialized = true;
  }
  ngOnInit() {
    this.selectedValueChange$.subscribe(() => {
      if (this.selectedValue.length) {
        this.buildSelectableData(this.selectedValue[0].startValue, this.dateGranularity);
      }
      this.selectableData.year?.forEach((item) => item.classMap = this.getClassMap(item));
      this.selectableData.quarter?.forEach((item) => item.classMap = this.getClassMap(item));
      this.selectableData.month?.forEach((item) => item.classMap = this.getClassMap(item));
      if (this.initialized) {
        if (this.isSelectEmpty()) {
          this._onChange({
            dateGranularity: void 0,
            begin: void 0,
            end: void 0
          });
        } else {
          const selctedValue = this.selectedValue;
          this._onChange({
            dateGranularity: this.dateGranularity,
            begin: selctedValue[0]?.startValue,
            end: selctedValue[selctedValue.length - 1]?.endValue
          });
        }
      }
    });
  }
  writeValue(value) {
    if (value) {
      this.defaultValue = value;
    }
  }
  registerOnChange(fn) {
    this._onChange = fn;
  }
  registerOnTouched(fn) {
    this._onTouched = fn;
  }
  getClassMap(cell) {
    return {
      [`active`]: this.isSelected(cell),
      [`indeterminate`]: this.isCellIndeterminate(this.selectedValue, cell),
      [`type-active`]: this.isTypeActive(this.selectedValue, cell),
      ["in-hover-range"]: cell.isInRange,
      ["out-range"]: cell.isOutRange
    };
  }
  isTypeActive(originalValue, value) {
    return originalValue?.length && originalValue[0].type === value.type;
  }
  isCellIndeterminate(originalValue, value) {
    if (originalValue[0]?.type === value.type) {
      return false;
    } else {
      if (originalValue[0]?.type === "year") {
        return !!originalValue.find((item) => item.startValue.isSameYear(value.startValue));
      } else {
        return value.type === "year" ? !!originalValue.find((item) => item.startValue.isSameYear(value.startValue)) : !!originalValue.find((item) => item.startValue.isSameQuarter(value.startValue));
      }
    }
  }
  isSelected(value) {
    return this.selectedValue.find((item) => item.startValue.isSameDay(value.startValue)) && this.dateGranularity === value.type;
  }
  isSelectEmpty() {
    return this.selectedValue.length == 0;
  }
  selectSort() {
    this.selectedValue.sort((a, b) => a.startValue.getTime() - b.startValue.getTime());
  }
  select(...value) {
    value.forEach((item) => {
      if (!this.isSelected(item)) {
        this.selectedValue.push(...value);
      }
    });
    this.selectSort();
    this.selectedValueChange$.next(void 0);
  }
  deselect(...value) {
    value.forEach((item) => {
      this.selectedValue = this.selectedValue.filter((selected) => !selected.startValue?.isSameDay(item.startValue));
    });
    this.selectSort();
    this.selectedValueChange$.next(void 0);
  }
  clearSelect(hidden) {
    this.selectedValue = [];
    if (!hidden) {
      this.selectedValueChange$.next(void 0);
    }
  }
  getShouldBeToggleValue(begin, end) {
    const selectedValue = [];
    switch (this.dateGranularity) {
      case "year":
        this.dateGranularity = "year";
        if (begin.isSameYear(end)) {
          selectedValue.push(this.getSelectableYear(begin));
        } else {
          selectedValue.push(this.getSelectableYear(begin));
          while (!begin.isSameYear(end)) {
            begin = begin.addYears(1);
            selectedValue.push(this.getSelectableYear(begin));
          }
        }
        break;
      case "month":
        this.dateGranularity = "month";
        if (begin.isSameMonth(end)) {
          selectedValue.push(this.getSelectableMonth(begin));
        } else {
          selectedValue.push(this.getSelectableMonth(begin));
          while (!begin.isSameMonth(end)) {
            begin = begin.addMonths(1);
            selectedValue.push(this.getSelectableMonth(begin));
          }
        }
        break;
      case "quarter":
        this.dateGranularity = "quarter";
        if (begin.isSameQuarter(end)) {
          selectedValue.push(this.getSelectableQuarter(begin));
        } else {
          selectedValue.push(this.getSelectableQuarter(begin));
          while (!begin.isSameQuarter(end)) {
            begin = begin.addQuarters(1);
            selectedValue.push(this.getSelectableQuarter(begin));
          }
        }
    }
    return selectedValue;
  }
  buildSelectableData(startDate, excludeGranularity) {
    const buildGranularity = ["year", "month", "quarter"].filter((item) => item !== excludeGranularity);
    buildGranularity.forEach((granularity) => {
      switch (granularity) {
        case "year":
          this.selectableData.year = [...Array(3).keys()].map((item, index2) => {
            return this.getSelectableYear(startDate, index2);
          });
          break;
        case "quarter":
          this.selectableData.quarter = [...Array(4).keys()].map((item, index2) => {
            return this.getSelectableQuarter(startDate, index2);
          });
          break;
        case "month":
          this.selectableData.month = [...Array(4).keys()].map((item, index2) => {
            return this.getSelectableMonth(startDate, index2);
          });
          break;
      }
    });
    this.cdr.markForCheck();
  }
  getSelectableYear(currentDate, preOrNextcount = 0) {
    currentDate = currentDate || this.activeDate() || new TinyDate().startOfYear();
    return {
      type: "year",
      content: `${currentDate.addYears(preOrNextcount).getYear()}`,
      startValue: currentDate.addYears(preOrNextcount).startOfYear(),
      endValue: currentDate.addYears(preOrNextcount).endOfYear(),
      classMap: {}
    };
  }
  getSelectableQuarter(currentDate, preOrNextcount = 0) {
    currentDate = currentDate || this.activeDate() || new TinyDate().startOfQuarter();
    return {
      type: "quarter",
      content: `${currentDate.addQuarters(preOrNextcount).format(QUARTER_FORMAT)}`,
      startValue: currentDate.addQuarters(preOrNextcount).startOfQuarter(),
      endValue: currentDate.addQuarters(preOrNextcount).endOfQuarter(),
      classMap: {}
    };
  }
  getSelectableMonth(currentDate, preOrNextcount = 0) {
    currentDate = currentDate || this.activeDate() || new TinyDate().startOfMonth();
    const cell = {
      type: "month",
      content: this.dateHelper.format(currentDate.addMonths(preOrNextcount).nativeDate, this.locale().monthFormat),
      startValue: currentDate.addMonths(preOrNextcount).startOfMonth(),
      endValue: currentDate.addMonths(preOrNextcount).endOfMonth(),
      classMap: {}
    };
    return cell;
  }
  prevClick(type) {
    switch (type) {
      case "year":
        this.selectableData.year = this.selectableData.year?.map((item) => this.getSelectableYear(item.startValue, -1));
        break;
      case "quarter":
        this.selectableData.quarter = this.selectableData.quarter?.map((item) => this.getSelectableQuarter(item.startValue, -2));
        break;
      case "month":
        this.selectableData.month = this.selectableData.month?.map((item) => this.getSelectableMonth(item.startValue, -2));
    }
    this.selectableData[type].forEach((item) => item.classMap = this.getClassMap(item));
  }
  nextClick(type) {
    switch (type) {
      case "year":
        this.selectableData.year = this.selectableData.year.map((item) => this.getSelectableYear(item.startValue, 1));
        break;
      case "quarter":
        this.selectableData.quarter = this.selectableData.quarter.map((item) => this.getSelectableQuarter(item.startValue, 2));
        break;
      case "month":
        this.selectableData.month = this.selectableData.month.map((item) => this.getSelectableMonth(item.startValue, 2));
    }
    this.selectableData[type].forEach((item) => item.classMap = this.getClassMap(item));
  }
  selectDate(type, value) {
    this.selectableData[type].forEach((item) => {
      item.isInRange = false;
      item.isOutRange = false;
    });
    if (this.isSelectEmpty()) {
      this.dateGranularity = type;
      this.select(value);
      return;
    }
    if (this.isSelected(value)) {
      this.toggleSelect(value);
      if (this.isSelectEmpty()) {
        this.dateGranularity = void 0;
      }
      return;
    }
    if (this.dateGranularity === value.type) {
      const {
        rangeStart,
        rangeEnd
      } = this.getActualStartAndEnd(value);
      const shouldBeSelectValue = this.getShouldBeToggleValue(rangeStart, rangeEnd);
      this.select(...shouldBeSelectValue);
    } else {
      this.dateGranularity = type;
      this.clearSelect(true);
      this.select(value);
    }
  }
  toggleSelect(value) {
    if (value.startValue?.isSameDay(this.selectedValue[0].startValue)) {
      this.deselect(value);
    } else {
      const rangeStart = value.startValue;
      const rangeEnd = this.selectedValue[this.selectedValue.length - 1].endValue;
      const shouldBeDeselectValue = this.getShouldBeToggleValue(rangeStart, rangeEnd);
      this.deselect(...shouldBeDeselectValue);
    }
  }
  onMouseenter(event, type, value) {
    if (this.isSelectEmpty() || this.dateGranularity !== type) {
      return;
    }
    if (this.isSelected(value)) {
      value.isInRange = true;
      if (value.startValue?.isSameDay(this.selectedValue[0].startValue)) {
        value.isOutRange = true;
      } else {
        const rangeStart = value.startValue;
        const rangeEnd = this.selectedValue[this.selectedValue.length - 1].endValue;
        this.selectableData[type].forEach((item) => {
          if (item.startValue.getTime() >= rangeStart.getTime() && item.startValue.getTime() < rangeEnd.getTime()) {
            item.isOutRange = true;
          } else {
            item.isOutRange = false;
          }
        });
      }
    } else {
      const {
        rangeStart,
        rangeEnd
      } = this.getActualStartAndEnd(value);
      this.selectableData[type]?.forEach((item) => {
        if (item.startValue.getTime() >= rangeStart.getTime() && item.startValue.getTime() < rangeEnd.getTime()) {
          item.isInRange = true;
        } else {
          item.isInRange = false;
        }
      });
    }
    this.selectableData[type]?.forEach((item) => item.classMap = this.getClassMap(item));
  }
  onMouseleave(event, type, value) {
    if (value.isInRange) {
      this.selectableData[type]?.forEach((item) => item.isInRange = false);
    }
    if (value.isOutRange) {
      this.selectableData[type]?.forEach((item) => item.isOutRange = false);
    }
    this.selectableData[type]?.forEach((item) => item.classMap = this.getClassMap(item));
  }
  getActualStartAndEnd(value) {
    const selectedStart = this.selectedValue[0].startValue;
    const selectedEnd = this.selectedValue[this.selectedValue.length - 1].endValue;
    let rangeStart;
    let rangeEnd;
    if (value.startValue?.isBeforeDay(selectedStart)) {
      rangeStart = value.startValue;
      rangeEnd = selectedStart;
    }
    if (value.startValue?.isAfterDay(selectedEnd)) {
      rangeStart = selectedEnd;
      rangeEnd = value.endValue;
    }
    return {
      rangeStart,
      rangeEnd
    };
  }
  ngOnDestroy() {
    this.selectedValueChange$.complete();
  }
  static {
    this.\u0275fac = function DateCarousel_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DateCarousel)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DateCarousel,
      selectors: [["date-carousel"]],
      hostAttrs: [1, "thy-date-picker-advanced-carousel"],
      inputs: {
        activeDate: [1, "activeDate"]
      },
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _DateCarousel)
      }])],
      decls: 5,
      vars: 15,
      consts: [["carouselItem", ""], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "carousel-item-title"], [1, "carousel-item-content"], ["thyButton", "outline-default", "thySize", "sm", 1, "right-space", 3, "click"], ["thyIconName", "angle-left"], [1, "selectable-button", "right-space", 3, "ngClass"], ["thyButton", "outline-default", "thySize", "sm", 3, "click"], ["thyIconName", "angle-right"], [1, "selectable-button", "right-space", 3, "click", "mouseenter", "mouseleave", "ngClass"], [1, "year-tip"], ["thyIconName", "close"], ["thyIconName", "plus"]],
      template: function DateCarousel_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, DateCarousel_ng_container_0_Template, 1, 0, "ng-container", 1)(1, DateCarousel_ng_container_1_Template, 1, 0, "ng-container", 1)(2, DateCarousel_ng_container_2_Template, 1, 0, "ng-container", 1)(3, DateCarousel_ng_template_3_Template, 10, 4, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          const carouselItem_r8 = \u0275\u0275reference(4);
          \u0275\u0275property("ngTemplateOutlet", carouselItem_r8)("ngTemplateOutletContext", \u0275\u0275pureFunction2(6, _c018, ctx.locale().yearText, ctx.selectableData.year));
          \u0275\u0275advance();
          \u0275\u0275property("ngTemplateOutlet", carouselItem_r8)("ngTemplateOutletContext", \u0275\u0275pureFunction2(9, _c110, ctx.locale().quarterText, ctx.selectableData.quarter));
          \u0275\u0275advance();
          \u0275\u0275property("ngTemplateOutlet", carouselItem_r8)("ngTemplateOutletContext", \u0275\u0275pureFunction2(12, _c27, ctx.locale().monthText, ctx.selectableData.month));
        }
      },
      dependencies: [NgTemplateOutlet, ThyButton, ThyIcon, NgClass, DatePickerAdvancedShowYearTipPipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateCarousel, [{
    type: Component,
    args: [{
      selector: "date-carousel",
      changeDetection: ChangeDetectionStrategy.OnPush,
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => DateCarousel)
      }],
      host: {
        class: "thy-date-picker-advanced-carousel"
      },
      imports: [NgTemplateOutlet, ThyButton, ThyIcon, NgClass, DatePickerAdvancedShowYearTipPipe],
      template: `<ng-container
  *ngTemplateOutlet="carouselItem; context: { title: locale().yearText, type: 'year', selectableData: selectableData.year }"></ng-container>

<ng-container
  *ngTemplateOutlet="
    carouselItem;
    context: { title: locale().quarterText, type: 'quarter', selectableData: selectableData.quarter }
  "></ng-container>

<ng-container
  *ngTemplateOutlet="
    carouselItem;
    context: { title: locale().monthText, type: 'month', selectableData: selectableData.month }
  "></ng-container>

<ng-template #carouselItem let-title="title" let-selectableData="selectableData" let-type="type">
  <div class="carousel-item carousel-item-{{ type }}">
    <p class="carousel-item-title">{{ title }}</p>
    <div class="carousel-item-content">
      <button thyButton="outline-default" thySize="sm" class="right-space" (click)="prevClick(type)">
        <thy-icon thyIconName="angle-left"></thy-icon>
      </button>
      @for (item of selectableData; track $index) {
        <div
          class="selectable-button right-space"
          (click)="selectDate(type, item)"
          (mouseenter)="onMouseenter($event, type, item)"
          (mouseleave)="onMouseleave($event, type, item)"
          [ngClass]="item.classMap">
          @if (item | showYearTip: type) {
            <span class="year-tip">{{ item?.startValue?.getYear() }}</span>
          }
          @if (item.isInRange && isSelected(item)) {
            <thy-icon thyIconName="close"></thy-icon>
          }
          @if (item.isInRange && !isSelected(item)) {
            <thy-icon thyIconName="plus"></thy-icon>
          }
          @if (!item.isInRange) {
            <span>{{ item?.content }}</span>
          }
        </div>
      }
      <button thyButton="outline-default" thySize="sm" (click)="nextClick(type)">
        <thy-icon thyIconName="angle-right"></thy-icon>
      </button>
    </div>
  </div>
</ng-template>
`
    }]
  }], null, {
    activeDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "activeDate",
        required: false
      }]
    }]
  });
})();
var DateHeader = class _DateHeader extends CalendarHeader {
  getSelectors() {
    const yearFormat = this.locale().yearFormat;
    const monthFormat = this.locale().monthFormat;
    return [{
      className: `${this.prefixCls}-year-btn`,
      title: "",
      onClick: () => this.changePanel("year"),
      label: this.formatDateTime(yearFormat)
    }, {
      className: `${this.prefixCls}-month-btn`,
      title: "",
      onClick: () => this.changePanel("month"),
      label: this.formatDateTime(monthFormat)
    }];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275DateHeader_BaseFactory;
      return function DateHeader_Factory(__ngFactoryType__) {
        return (\u0275DateHeader_BaseFactory || (\u0275DateHeader_BaseFactory = \u0275\u0275getInheritedFactory(_DateHeader)))(__ngFactoryType__ || _DateHeader);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DateHeader,
      selectors: [["date-header"]],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 13,
      vars: 26,
      consts: [[2, "position", "relative"], ["role", "button", 3, "click", "ngClass", "title"], ["thyIconName", "angle-double-left"], ["thyIconName", "angle-left"], ["role", "button", 3, "class", "title"], ["thyIconName", "angle-right"], ["thyIconName", "angle-double-right"], ["role", "button", 3, "click", "title"]],
      template: function DateHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "a", 1);
          \u0275\u0275listener("click", function DateHeader_Template_a_click_2_listener() {
            return ctx.superPrevious();
          });
          \u0275\u0275element(3, "thy-icon", 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(4, "a", 1);
          \u0275\u0275listener("click", function DateHeader_Template_a_click_4_listener() {
            return ctx.previous();
          });
          \u0275\u0275element(5, "thy-icon", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "span");
          \u0275\u0275repeaterCreate(7, DateHeader_For_8_Template, 2, 5, "a", 4, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "a", 1);
          \u0275\u0275listener("click", function DateHeader_Template_a_click_9_listener() {
            return ctx.next();
          });
          \u0275\u0275element(10, "thy-icon", 5);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(11, "a", 1);
          \u0275\u0275listener("click", function DateHeader_Template_a_click_11_listener() {
            return ctx.superNext();
          });
          \u0275\u0275element(12, "thy-icon", 6);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-header"));
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousYear);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-month-btn"));
          \u0275\u0275property("ngClass", ctx.showPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-my-select"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.selectors);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-month-btn"));
          \u0275\u0275property("ngClass", ctx.showNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextYear);
        }
      },
      dependencies: [NgClass, ThyIcon],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateHeader, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "date-header",
      imports: [NgClass, ThyIcon],
      template: `<div class="{{ prefixCls }}-header">
  <div style="position: relative">
    <a
      class="{{ prefixCls }}-prev-year-btn"
      [ngClass]="showSuperPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superPrevious()"
      [title]="locale().previousYear">
      <thy-icon thyIconName="angle-double-left"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-prev-month-btn"
      [ngClass]="showPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="previous()"
      [title]="locale().previousMonth">
      <thy-icon thyIconName="angle-left"></thy-icon>
    </a>

    <span class="{{ prefixCls }}-my-select">
      @for (selector of selectors; track $index) {
        <a class="{{ selector.className }}" role="button" (click)="selectorClick($event, selector)" title="{{ selector.title || null }}">
          {{ selector.label }}
        </a>
      }
    </span>

    <a
      class="{{ prefixCls }}-next-month-btn"
      [ngClass]="showNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="next()"
      [title]="locale().nextMonth">
      <thy-icon thyIconName="angle-right"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-next-year-btn"
      [ngClass]="showSuperNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superNext()"
      [title]="locale().nextYear">
      <thy-icon thyIconName="angle-double-right"></thy-icon>
    </a>
  </div>
</div>
`
    }]
  }], null, null);
})();
var CalendarTable = class _CalendarTable {
  constructor() {
    this.locale = injectLocale("datePicker");
    this.isTemplateRef = isTemplateRef;
    this.headRow = [];
    this.bodyRows = [];
    this.MAX_ROW = 6;
    this.MAX_COL = 7;
    this.prefixCls = input("thy-calendar", ...ngDevMode ? [{
      debugName: "prefixCls"
    }] : []);
    this.value = model(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.activeDate = model(new TinyDate(), ...ngDevMode ? [{
      debugName: "activeDate"
    }] : []);
    this.showWeek = input(false, ...ngDevMode ? [{
      debugName: "showWeek",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.selectedValue = input([], ...ngDevMode ? [{
      debugName: "selectedValue"
    }] : []);
    this.hoverValue = input([], ...ngDevMode ? [{
      debugName: "hoverValue"
    }] : []);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.disabledDate = input(...ngDevMode ? [void 0, {
      debugName: "disabledDate"
    }] : []);
    this.cellRender = input(...ngDevMode ? [void 0, {
      debugName: "cellRender"
    }] : []);
    this.valueChange = output();
    this.cellHover = output();
  }
  render() {
    if (this.activeDate()) {
      this.headRow = this.makeHeadRow();
      this.bodyRows = this.makeBodyRows();
    }
  }
  trackByBodyRow(_index, item) {
    return item.trackByIndex;
  }
  trackByBodyColumn(_index, item) {
    return item.trackByIndex;
  }
  hasRangeValue() {
    return this.selectedValue()?.length > 0 || this.hoverValue()?.length > 0;
  }
  ngOnInit() {
    this.render();
  }
  ngOnChanges(changes) {
    if (changes.activeDate && !changes.activeDate.currentValue) {
      this.activeDate.set(new TinyDate(void 0, this.timeZone()));
    }
    if (changes.disabledDate || changes.locale || changes.showWeek || this.isDateRealChange(changes.activeDate) || this.isDateRealChange(changes.value) || this.isDateRealChange(changes.selectedValue) || this.isDateRealChange(changes.hoverValue)) {
      this.render();
    }
  }
  isDateRealChange(change) {
    if (change) {
      const previousValue = change.previousValue;
      const currentValue = change.currentValue;
      if (Array.isArray(currentValue)) {
        return !Array.isArray(previousValue) || currentValue.length !== previousValue.length || currentValue.some((value, index2) => {
          const previousCandyDate = previousValue[index2];
          return previousCandyDate instanceof TinyDate ? previousCandyDate.isSameDay(value) : previousCandyDate !== value;
        });
      } else {
        return !this.isSameDate(previousValue, currentValue);
      }
    }
    return false;
  }
  isSameDate(left, right) {
    return !left && !right || left && right && right.isSameDay(left);
  }
  static {
    this.\u0275fac = function CalendarTable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CalendarTable)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _CalendarTable,
      inputs: {
        prefixCls: [1, "prefixCls"],
        value: [1, "value"],
        activeDate: [1, "activeDate"],
        showWeek: [1, "showWeek"],
        selectedValue: [1, "selectedValue"],
        hoverValue: [1, "hoverValue"],
        timeZone: [1, "timeZone"],
        disabledDate: [1, "disabledDate"],
        cellRender: [1, "cellRender"]
      },
      outputs: {
        value: "valueChange",
        activeDate: "activeDateChange",
        valueChange: "valueChange",
        cellHover: "cellHover"
      },
      features: [\u0275\u0275NgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CalendarTable, [{
    type: Directive
  }], null, {
    prefixCls: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "prefixCls",
        required: false
      }]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }, {
      type: Output,
      args: ["valueChange"]
    }],
    activeDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "activeDate",
        required: false
      }]
    }, {
      type: Output,
      args: ["activeDateChange"]
    }],
    showWeek: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showWeek",
        required: false
      }]
    }],
    selectedValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "selectedValue",
        required: false
      }]
    }],
    hoverValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "hoverValue",
        required: false
      }]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    disabledDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disabledDate",
        required: false
      }]
    }],
    cellRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "cellRender",
        required: false
      }]
    }],
    valueChange: [{
      type: Output,
      args: ["valueChange"]
    }],
    cellHover: [{
      type: Output,
      args: ["cellHover"]
    }]
  });
})();
var DateTableCell = class _DateTableCell {
  constructor() {
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
    this.isTemplateRef = isTemplateRef;
    this.prefixCls = input(...ngDevMode ? [void 0, {
      debugName: "prefixCls"
    }] : []);
    this.cell = input(...ngDevMode ? [void 0, {
      debugName: "cell"
    }] : []);
    this.isNonEmptyString = (v) => isEmpty(v) && isString(v);
    this.functionRenderResult = computed(() => {
      const renderFn = this.cellRender();
      if (!isFunction(renderFn)) {
        return false;
      }
      const result = renderFn(this.cell().value);
      return !isUndefinedOrNull(result);
    }, ...ngDevMode ? [{
      debugName: "functionRenderResult"
    }] : []);
    this.cellRender = computed(() => {
      return this.cell()?.dateCellRender || this.datePickerConfigService.config?.dateCellRender;
    }, ...ngDevMode ? [{
      debugName: "cellRender"
    }] : []);
  }
  cellClick(event) {
    event.stopPropagation();
    this.cell()?.onClick();
  }
  static {
    this.\u0275fac = function DateTableCell_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DateTableCell)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DateTableCell,
      selectors: [["", "date-table-cell", ""]],
      inputs: {
        prefixCls: [1, "prefixCls"],
        cell: [1, "cell"]
      },
      exportAs: ["dateTableCell"],
      attrs: _c36,
      decls: 5,
      vars: 4,
      consts: [["tabindex", "0", 3, "class", "thy-calendar-full-calendar-date-today"], [3, "innerHTML"], [3, "class"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "click", "innerHTML"], ["tabindex", "0"]],
      template: function DateTableCell_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0)(1)(2);
          \u0275\u0275conditionalCreate(3, DateTableCell_Case_3_Template, 4, 1)(4, DateTableCell_Case_4_Template, 3, 6, "div", 0);
        }
        if (rf & 2) {
          let tmp_3_0;
          const prefixClass_r7 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275storeLet(ctx.cell());
          \u0275\u0275advance();
          \u0275\u0275storeLet(ctx.cellRender());
          \u0275\u0275advance();
          \u0275\u0275conditional((tmp_3_0 = prefixClass_r7) === "thy-calendar" ? 3 : tmp_3_0 === "thy-calendar-full" ? 4 : -1);
        }
      },
      dependencies: [NgTemplateOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTableCell, [{
    type: Component,
    args: [{
      selector: "[date-table-cell]",
      exportAs: "dateTableCell",
      imports: [NgTemplateOutlet],
      template: `@let prefixClass = prefixCls();
@let dateCell = cell();
@let dateCellRender = cellRender();

@switch (prefixClass) {
  @case ('thy-calendar') {
    @switch (true) {
      @case (isTemplateRef(dateCellRender)) {
        <ng-container *ngTemplateOutlet="dateCellRender; context: { $implicit: dateCell.value }"></ng-container>
      }
      @case (isNonEmptyString(dateCellRender)) {
        <span (click)="cellClick($event)" [innerHTML]="dateCellRender"></span>
      }
      @case (functionRenderResult()) {
        <span (click)="cellClick($event)" [innerHTML]="$any(dateCellRender)(dateCell.value)"></span>
      }
      @default {
        <div class="{{ prefixClass }}-date" [attr.aria-selected]="dateCell.isSelected" [attr.aria-disabled]="dateCell.isDisabled">
          {{ dateCell.content }}
        </div>
      }
    }
  }
  @case ('thy-calendar-full') {
    <div
      tabindex="0"
      class="{{ prefixClass }}-date thy-calendar-full-cell-inner"
      [class.thy-calendar-full-calendar-date-today]="dateCell.isToday">
      @if (isTemplateRef(dateCell.fullCellRender)) {
        <ng-container *ngTemplateOutlet="$any(dateCell.fullCellRender); context: { $implicit: dateCell.value }"> </ng-container>
      } @else {
        <div class="{{ prefixClass }}-date-value">
          <span class="{{ prefixClass }}-date-value-today-text">
            <span class="{{ prefixClass }}-date-value-text">{{ dateCell.content }}</span>
          </span>
        </div>
        <div class="{{ prefixClass }}-date-content">
          @if (isTemplateRef(dateCellRender)) {
            <ng-container *ngTemplateOutlet="$any(dateCellRender); context: { $implicit: dateCell.value }"> </ng-container>
          }
        </div>
      }
    </div>
  }
}
`
    }]
  }], null, {
    prefixCls: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "prefixCls",
        required: false
      }]
    }],
    cell: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "cell",
        required: false
      }]
    }]
  });
})();
var DateTable = class _DateTable extends CalendarTable {
  constructor() {
    super();
    this.dateHelper = inject(DateHelperService);
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
    this.dayHover = output();
  }
  chooseDate(value) {
    const activeDate = this.activeDate();
    const timeZone = this.timeZone();
    const date = new TinyDate(TinyDate.createDateInTimeZone(value.getFullYear(), value.getMonth(), value.getDate(), activeDate?.getHours(), activeDate?.getMinutes(), activeDate?.getSeconds(), timeZone), timeZone);
    this.activeDate.set(date.clone());
    this.valueChange.emit(date);
  }
  makeHeadRow() {
    const weekDays = [];
    const start = this.activeDate().calendarStart({
      weekStartsOn: this.datePickerConfigService.config.weekStartsOn
    });
    for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
      const day = start.addDays(colIndex);
      weekDays[colIndex] = {
        title: this.dateHelper.format(day.nativeDate, this.dateHelper.relyOnDatePipe ? "E" : "ddd"),
        content: this.dateHelper.format(day.nativeDate, this.getVeryShortWeekFormat()),
        isSelected: false,
        isDisabled: false,
        onClick() {
        },
        onMouseEnter() {
        }
      };
    }
    return weekDays;
  }
  getVeryShortWeekFormat() {
    if (this.dateHelper.relyOnDatePipe) {
      const locale2 = this.locale();
      const prefixCls = this.prefixCls();
      return prefixCls === "thy-calendar-full" ? locale2.fullWeekFormat : locale2.weekFormat;
    }
    return "dd";
  }
  makeBodyRows() {
    const dateRows = [];
    const firstDayOfMonth = this.activeDate().calendarStart({
      weekStartsOn: this.datePickerConfigService.config.weekStartsOn
    });
    for (let week = 0; week < this.MAX_ROW; week++) {
      const weekStart = firstDayOfMonth.addDays(week * 7);
      const row = {
        isActive: false,
        isCurrent: false,
        dateCells: [],
        year: weekStart.getYear()
      };
      for (let day = 0; day < 7; day++) {
        const date = weekStart.addDays(day);
        const dateFormat = this.dateHelper.relyOnDatePipe ? "longDate" : "YYYY-MM-DD";
        const title = this.dateHelper.format(date.nativeDate, dateFormat);
        const label2 = this.dateHelper.format(date.nativeDate, this.dateHelper.relyOnDatePipe ? "dd" : "DD");
        const cell = {
          value: date.nativeDate,
          label: label2,
          isSelected: false,
          isDisabled: false,
          isToday: false,
          title,
          dateCellRender: valueFunctionProp(this.cellRender(), date),
          content: `${date.getDate()}`,
          onClick: () => this.chooseDate(date),
          onMouseEnter: () => this.dayHover.emit(date)
        };
        this.addCellProperty(cell, date);
        if (this.showWeek() && !row.weekNum) {
          row.weekNum = this.dateHelper.getISOWeek(date.nativeDate);
        }
        if (date.isToday()) {
          cell.isToday = true;
          row.isCurrent = true;
        }
        const selectedValue = this.selectedValue();
        if (selectedValue?.length > 0) {
          const [startSelected, endSelected] = selectedValue;
          if (date.isSameDay(startSelected)) {
            row.isActive = true;
          }
          if (date.isSameDay(endSelected)) {
            row.isActive = true;
          }
        } else if (date.isSameDay(this.value())) {
          row.isActive = true;
        }
        row.dateCells.push(cell);
      }
      const prefixCls = this.prefixCls();
      row.classMap = {
        [`${prefixCls}-current-week`]: row.isCurrent,
        [`${prefixCls}-active-week`]: row.isActive
      };
      dateRows.push(row);
    }
    return dateRows;
  }
  addCellProperty(cell, date) {
    const selectedValue = this.selectedValue();
    if (selectedValue?.length > 0) {
      const [startSelected, endSelected] = selectedValue;
      if (startSelected?.isSameDay(date)) {
        cell.isSelected = true;
      }
      if (endSelected?.isSameDay(date)) {
        cell.isSelected = true;
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && !!endSelected;
      cell.isInRange = startSelected?.isBeforeDay(date) && date.isBeforeDay(endSelected);
    } else {
      cell.isSelected = date.isSameDay(this.value());
    }
    const activeDate = this.activeDate();
    cell.isLastMonthCell = date.isBeforeMonth(activeDate);
    cell.isNextMonthCell = date.isAfterMonth(activeDate);
    cell.isToday = date.isToday();
    cell.isDisabled = !!this.disabledDate()?.(date.nativeDate);
    cell.classMap = this.getClassMap(cell);
  }
  getClassMap(cell) {
    const prefixCls = this.prefixCls();
    return {
      [`${prefixCls}-cell`]: true,
      [`${prefixCls}-today`]: !!cell.isToday,
      [`${prefixCls}-last-month-cell`]: !!cell.isLastMonthCell,
      [`${prefixCls}-next-month-btn-day`]: !!cell.isNextMonthCell,
      [`${prefixCls}-selected-day`]: !!cell.isSelected,
      [`${prefixCls}-disabled-cell`]: !!cell.isDisabled,
      [`${prefixCls}-selected-start-date`]: !!cell.isSelectedStartDate,
      [`${prefixCls}-selected-end-date`]: !!cell.isSelectedEndDate,
      [`${prefixCls}-in-range-cell`]: !!cell.isInRange
    };
  }
  static {
    this.\u0275fac = function DateTable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DateTable)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DateTable,
      selectors: [["date-table"]],
      outputs: {
        dayHover: "dayHover"
      },
      exportAs: ["dateTable"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 10,
      vars: 8,
      consts: [["cellSpacing", "0", "role", "grid"], ["role", "row"], ["role", "columnheader", 3, "title", "class"], ["role", "row", 3, "ngClass"], ["role", "columnheader", 3, "title"], [3, "class"], ["role", "gridcell", 3, "class"], ["role", "gridcell", "date-table-cell", "", 3, "ngClass", "prefixCls", "cell"], ["role", "gridcell"], ["role", "gridcell", "date-table-cell", "", 3, "click", "ngClass", "prefixCls", "cell"]],
      template: function DateTable_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275elementStart(1, "table", 0)(2, "thead")(3, "tr", 1);
          \u0275\u0275conditionalCreate(4, DateTable_Conditional_4_Template, 3, 9, "th", 2);
          \u0275\u0275repeaterCreate(5, DateTable_For_6_Template, 3, 7, "th", 2, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(7, "tbody");
          \u0275\u0275repeaterCreate(8, DateTable_For_9_Template, 4, 2, "tr", 3, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          const prefixClass_r7 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r7, "-table"));
          \u0275\u0275advance(3);
          \u0275\u0275conditional(ctx.showWeek() ? 4 : -1);
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.headRow);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r7, "-tbody"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.bodyRows);
        }
      },
      dependencies: [NgClass, DateTableCell],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DateTable, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "date-table",
      exportAs: "dateTable",
      imports: [NgClass, DateTableCell],
      template: `@let prefixClass = prefixCls();
<table class="{{ prefixClass }}-table" cellSpacing="0" role="grid">
  <thead>
    <tr role="row">
      @if (showWeek()) {
        <th role="columnheader" [title]="locale().week" class="{{ prefixClass }}-column-header {{ prefixClass }}-week-number-header">
          <span class="{{ prefixClass }}-column-header-inner">{{ locale().prefixWeek }}</span>
        </th>
      }
      @for (cell of headRow; track $index) {
        <th role="columnheader" title="{{ cell.title }}" class="{{ prefixClass }}-column-header">
          @if (prefixClass === 'thy-calendar') {
            <span class="{{ prefixClass }}-column-header-inner">{{ cell.content }}</span>
          }
          @if (prefixClass === 'thy-calendar-full') {
            <span class="{{ prefixClass }}-column-header-inner">{{ cell.content }}</span>
          }
        </th>
      }
    </tr>
  </thead>
  <tbody class="{{ prefixClass }}-tbody">
    @for (row of bodyRows; track $index) {
      <tr [ngClass]="row.classMap" role="row">
        @if (row.weekNum) {
          <td role="gridcell" class="{{ prefixClass }}-week-number-cell">
            {{ row.weekNum }}
          </td>
        }
        @for (cell of row.dateCells; track $index) {
          <td
            role="gridcell"
            [ngClass]="cell.classMap"
            (click)="cell.isDisabled ? null : cell.onClick()"
            date-table-cell
            [prefixCls]="prefixClass"
            [cell]="cell"></td>
        }
      </tr>
    }
  </tbody>
</table>
`
    }]
  }], () => [], {
    dayHover: [{
      type: Output,
      args: ["dayHover"]
    }]
  });
})();
var DecadeHeader = class _DecadeHeader extends CalendarHeader {
  constructor() {
    super(...arguments);
    this.startYear = computed(() => parseInt(`${this.value().getYear() / 100}`, 10) * 100, ...ngDevMode ? [{
      debugName: "startYear"
    }] : []);
    this.endYear = computed(() => this.startYear() + 99, ...ngDevMode ? [{
      debugName: "endYear"
    }] : []);
  }
  superPrevious() {
    const newValue = this.value().addYears(-100);
    this.changeValue(newValue);
  }
  superNext() {
    const newValue = this.value().addYears(100);
    this.changeValue(newValue);
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-decade-btn`,
      title: "",
      onClick: () => {
      },
      label: `${this.startYear()}-${this.endYear()}`
    }];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275DecadeHeader_BaseFactory;
      return function DecadeHeader_Factory(__ngFactoryType__) {
        return (\u0275DecadeHeader_BaseFactory || (\u0275DecadeHeader_BaseFactory = \u0275\u0275getInheritedFactory(_DecadeHeader)))(__ngFactoryType__ || _DecadeHeader);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DecadeHeader,
      selectors: [["decade-header"]],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 13,
      vars: 26,
      consts: [[2, "position", "relative"], ["role", "button", 3, "click", "ngClass", "title"], ["thyIconName", "angle-double-left"], ["thyIconName", "angle-left"], ["role", "button", 3, "class", "title"], ["thyIconName", "angle-right"], ["thyIconName", "angle-double-right"], ["role", "button", 3, "click", "title"]],
      template: function DecadeHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "a", 1);
          \u0275\u0275listener("click", function DecadeHeader_Template_a_click_2_listener() {
            return ctx.superPrevious();
          });
          \u0275\u0275element(3, "thy-icon", 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(4, "a", 1);
          \u0275\u0275listener("click", function DecadeHeader_Template_a_click_4_listener() {
            return ctx.previous();
          });
          \u0275\u0275element(5, "thy-icon", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "span");
          \u0275\u0275repeaterCreate(7, DecadeHeader_For_8_Template, 2, 5, "a", 4, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "a", 1);
          \u0275\u0275listener("click", function DecadeHeader_Template_a_click_9_listener() {
            return ctx.next();
          });
          \u0275\u0275element(10, "thy-icon", 5);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(11, "a", 1);
          \u0275\u0275listener("click", function DecadeHeader_Template_a_click_11_listener() {
            return ctx.superNext();
          });
          \u0275\u0275element(12, "thy-icon", 6);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-header"));
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousYear);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-month-btn"));
          \u0275\u0275property("ngClass", ctx.showPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-my-select"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.selectors);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-month-btn"));
          \u0275\u0275property("ngClass", ctx.showNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextYear);
        }
      },
      dependencies: [NgClass, ThyIcon],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeHeader, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "decade-header",
      imports: [NgClass, ThyIcon],
      template: `<div class="{{ prefixCls }}-header">
  <div style="position: relative">
    <a
      class="{{ prefixCls }}-prev-year-btn"
      [ngClass]="showSuperPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superPrevious()"
      [title]="locale().previousYear">
      <thy-icon thyIconName="angle-double-left"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-prev-month-btn"
      [ngClass]="showPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="previous()"
      [title]="locale().previousMonth">
      <thy-icon thyIconName="angle-left"></thy-icon>
    </a>

    <span class="{{ prefixCls }}-my-select">
      @for (selector of selectors; track $index) {
        <a class="{{ selector.className }}" role="button" (click)="selectorClick($event, selector)" title="{{ selector.title || null }}">
          {{ selector.label }}
        </a>
      }
    </span>

    <a
      class="{{ prefixCls }}-next-month-btn"
      [ngClass]="showNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="next()"
      [title]="locale().nextMonth">
      <thy-icon thyIconName="angle-right"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-next-year-btn"
      [ngClass]="showSuperNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superNext()"
      [title]="locale().nextYear">
      <thy-icon thyIconName="angle-double-right"></thy-icon>
    </a>
  </div>
</div>
`
    }]
  }], null, null);
})();
var DecadeTable = class _DecadeTable extends CalendarTable {
  constructor() {
    super(...arguments);
    this.MAX_ROW = 4;
    this.MAX_COL = 3;
    this.startYear = computed(() => parseInt(`${this.activeDate().getYear() / 100}`, 10) * 100, ...ngDevMode ? [{
      debugName: "startYear"
    }] : []);
    this.endYear = computed(() => this.startYear() + 99, ...ngDevMode ? [{
      debugName: "endYear"
    }] : []);
  }
  chooseDecade(startYear) {
    const newValue = (this.value() || new TinyDate()).setYear(startYear);
    this.value.set(newValue);
    this.valueChange.emit(newValue);
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const decades = [];
    const currentYear = this.value() && this.value().getYear();
    const startYear = this.startYear();
    const endYear = this.endYear();
    const previousYear = startYear - 10;
    let index2 = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const start = previousYear + index2 * 10;
        const end = previousYear + index2 * 10 + 9;
        const content = `${start}-${end}`;
        const cell = {
          content,
          title: content,
          isSelected: currentYear >= start && currentYear <= end,
          isLowerThanStart: end < startYear,
          isBiggerThanEnd: start > endYear,
          classMap: null,
          onClick: () => this.chooseDecade(start),
          onMouseEnter() {
          }
        };
        cell.classMap = this.getClassMap(cell);
        index2++;
        row.dateCells.push(cell);
      }
      decades.push(row);
    }
    return decades;
  }
  getClassMap(cell) {
    const prefixCls = this.prefixCls();
    return {
      [`${prefixCls}-decade-panel-cell`]: true,
      [`${prefixCls}-decade-panel-selected-cell`]: !!cell.isSelected,
      [`${prefixCls}-decade-panel-last-century-cell`]: !!cell.isLowerThanStart,
      [`${prefixCls}-decade-panel-next-century-cell`]: !!cell.isBiggerThanEnd
    };
  }
  cellClick(event, cell) {
    event.stopPropagation();
    cell.onClick();
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275DecadeTable_BaseFactory;
      return function DecadeTable_Factory(__ngFactoryType__) {
        return (\u0275DecadeTable_BaseFactory || (\u0275DecadeTable_BaseFactory = \u0275\u0275getInheritedFactory(_DecadeTable)))(__ngFactoryType__ || _DecadeTable);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DecadeTable,
      selectors: [["decade-table"]],
      exportAs: ["decadeTable"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 7,
      consts: [["cellSpacing", "0", "role", "grid"], ["role", "row"], ["role", "gridcell", 3, "title", "ngClass"], ["role", "gridcell", 3, "click", "title", "ngClass"]],
      template: function DecadeTable_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275elementStart(1, "table", 0)(2, "tbody");
          \u0275\u0275repeaterCreate(3, DecadeTable_For_4_Template, 3, 0, "tr", 1, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          const prefixClass_r6 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-decade-panel-table"));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-decade-panel-tbody"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.bodyRows);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DecadeTable, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "decade-table",
      exportAs: "decadeTable",
      imports: [NgClass],
      template: '@let prefixClass = prefixCls();\n<table class="{{ prefixClass }}-decade-panel-table" cellSpacing="0" role="grid">\n  <tbody class="{{ prefixClass }}-decade-panel-tbody">\n    @for (row of bodyRows; track $index) {\n      <tr role="row">\n        @for (cell of row.dateCells; track $index) {\n          <td role="gridcell" title="{{ cell.title }}" (click)="cellClick($event, cell)" [ngClass]="cell.classMap">\n            <a class="{{ prefixClass }}-decade-panel-decade">{{ cell.content }}</a>\n          </td>\n        }\n      </tr>\n    }\n  </tbody>\n</table>\n'
    }]
  }], null, null);
})();
var MonthTable = class _MonthTable extends CalendarTable {
  constructor() {
    super();
    this.dateHelper = inject(DateHelperService);
    this.MAX_ROW = 4;
    this.MAX_COL = 3;
  }
  chooseMonth(month) {
    const newValue = this.activeDate().setMonth(month);
    this.value.set(newValue);
    this.valueChange.emit(newValue);
    this.render();
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const months = [];
    let monthValue = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const month = this.activeDate().setMonth(monthValue);
        const monthFormat = this.locale().monthFormat;
        const isDisabled = this.disabledDate() ? this.disabledDate()(this.activeDate().setMonth(monthValue).nativeDate) : false;
        const content = this.dateHelper.format(month.nativeDate, monthFormat);
        const cell = {
          trackByIndex: colIndex,
          value: month.nativeDate,
          isDisabled,
          content,
          title: content,
          classMap: null,
          isSelected: month.isSameMonth(this.value()),
          onClick: () => this.chooseMonth(cell.value.getMonth()),
          onMouseEnter: () => {
          }
        };
        this.addCellProperty(cell, month);
        row.dateCells.push(cell);
        monthValue++;
      }
      months.push(row);
    }
    return months;
  }
  addCellProperty(cell, month) {
    if (this.selectedValue()?.length > 0) {
      const [startSelected, endSelected] = this.selectedValue();
      if (startSelected?.isSameMonth(month)) {
        cell.isSelectedStartDate = true;
        cell.isSelected = true;
      }
      if (endSelected?.isSameMonth(month)) {
        cell.isSelectedEndDate = true;
        cell.isSelected = true;
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && !!endSelected;
      cell.isInRange = startSelected?.isBeforeMonth(month) && month?.isBeforeMonth(endSelected);
    } else if (month.isSameMonth(this.value())) {
      cell.isSelected = true;
    }
    cell.classMap = this.getClassMap(cell);
  }
  monthCellClick(event, monthCell) {
    event.stopPropagation();
    return monthCell.isDisabled ? null : monthCell.onClick();
  }
  getClassMap(cell) {
    const prefixCls = this.prefixCls();
    return {
      [`${prefixCls}-month-panel-cell`]: true,
      [`${prefixCls}-month-panel-cell-disabled`]: !!cell.isDisabled,
      [`${prefixCls}-month-panel-selected-cell`]: !!cell.isSelected,
      [`${prefixCls}-in-range-cell`]: !!cell.isInRange,
      [`${prefixCls}-month-panel-current-cell`]: new TinyDate().getYear() === this.activeDate().getYear() && cell.value.getMonth() === new TinyDate().getMonth()
    };
  }
  static {
    this.\u0275fac = function MonthTable_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _MonthTable)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _MonthTable,
      selectors: [["month-table"]],
      exportAs: ["monthTable"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 7,
      consts: [["cellSpacing", "0", "role", "grid"], ["role", "row"], ["role", "gridcell", 3, "title", "ngClass"], ["role", "gridcell", 3, "click", "title", "ngClass"], [3, "class"]],
      template: function MonthTable_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275elementStart(1, "table", 0)(2, "tbody");
          \u0275\u0275repeaterCreate(3, MonthTable_For_4_Template, 3, 0, "tr", 1, ctx.trackByBodyRow, true);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          const prefixClass_r6 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-month-panel-table"));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-month-panel-tbody"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.bodyRows);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(MonthTable, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "month-table",
      exportAs: "monthTable",
      imports: [NgClass],
      template: `@let prefixClass = prefixCls();
<table class="{{ prefixClass }}-month-panel-table" cellSpacing="0" role="grid">
  <tbody class="{{ prefixClass }}-month-panel-tbody">
    @for (row of bodyRows; track trackByBodyRow($index, row)) {
      <tr role="row">
        @for (monthCell of row.dateCells; track trackByBodyColumn($index, monthCell)) {
          <td role="gridcell" title="{{ monthCell.title }}" (click)="monthCellClick($event, monthCell)" [ngClass]="monthCell.classMap">
            @switch (prefixClass) {
              @case ('thy-calendar') {
                <div class="{{ prefixClass }}-month-panel-month">{{ monthCell.content }}</div>
              }
            }
          </td>
        }
      </tr>
    }
  </tbody>
</table>
`
    }]
  }], () => [], null);
})();
var QuarterTable = class _QuarterTable extends CalendarTable {
  constructor() {
    super(...arguments);
    this.MAX_ROW = 1;
    this.MAX_COL = 4;
  }
  chooseQuarter(quarter) {
    const newValue = this.activeDate().setQuarter(quarter);
    this.value.set(newValue);
    this.valueChange.emit(newValue);
    this.render();
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const quarters = [];
    let quarterValue = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const quarter = this.activeDate().setQuarter(quarterValue + 1);
        const isDisabled = this.disabledDate() ? this.disabledDate()(quarter.nativeDate) : false;
        const content = `${quarter.format(QUARTER_FORMAT)}`;
        const cell = {
          trackByIndex: colIndex,
          value: quarter.nativeDate,
          isDisabled,
          content,
          title: content,
          classMap: null,
          isSelected: quarter.isSameQuarter(this.value()),
          onClick: () => {
            this.chooseQuarter(quarter.getQuarter());
          },
          onMouseEnter: () => {
          }
        };
        this.addCellProperty(cell, quarter);
        row.dateCells.push(cell);
        quarterValue++;
      }
      quarters.push(row);
    }
    return quarters;
  }
  addCellProperty(cell, quarter) {
    const selectedValue = this.selectedValue();
    if (selectedValue?.length > 0) {
      const [startSelected, endSelected] = selectedValue;
      if (startSelected?.isSameQuarter(quarter)) {
        cell.isSelectedStartDate = true;
        cell.isSelected = true;
      }
      if (endSelected?.isSameQuarter(quarter)) {
        cell.isSelectedEndDate = true;
        cell.isSelected = true;
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && !!endSelected;
      cell.isInRange = startSelected?.isBeforeQuarter(quarter) && quarter?.isBeforeQuarter(endSelected);
    } else if (quarter.isSameQuarter(this.value())) {
      cell.isSelected = true;
    }
    cell.classMap = this.getClassMap(cell, quarter);
  }
  quarterCellClick(event, quarterCell) {
    event.stopPropagation();
    return quarterCell.isDisabled ? null : quarterCell.onClick();
  }
  getClassMap(cell, quarter) {
    const prefixCls = this.prefixCls();
    return {
      [`${prefixCls}-quarter-panel-cell`]: true,
      [`${prefixCls}-quarter-panel-cell-disabled`]: !!cell.isDisabled,
      [`${prefixCls}-quarter-panel-selected-cell`]: !!cell.isSelected,
      [`${prefixCls}-in-range-cell`]: !!cell.isInRange,
      [`${prefixCls}-quarter-panel-current-cell`]: new TinyDate().getYear() === this.activeDate().getYear() && quarter.getQuarter() === new TinyDate().getQuarter()
    };
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275QuarterTable_BaseFactory;
      return function QuarterTable_Factory(__ngFactoryType__) {
        return (\u0275QuarterTable_BaseFactory || (\u0275QuarterTable_BaseFactory = \u0275\u0275getInheritedFactory(_QuarterTable)))(__ngFactoryType__ || _QuarterTable);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _QuarterTable,
      selectors: [["quarter-table"]],
      exportAs: ["quarterTable"],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 7,
      consts: [["cellSpacing", "0", "role", "grid"], ["role", "row"], ["role", "gridcell", 3, "title", "ngClass"], ["role", "gridcell", 3, "click", "title", "ngClass"]],
      template: function QuarterTable_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275elementStart(1, "table", 0)(2, "tbody");
          \u0275\u0275repeaterCreate(3, QuarterTable_For_4_Template, 3, 0, "tr", 1, ctx.trackByBodyRow, true);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          const prefixClass_r6 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-quarter-panel-table"));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-quarter-panel-tbody"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.bodyRows);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(QuarterTable, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "quarter-table",
      exportAs: "quarterTable",
      imports: [NgClass],
      template: '@let prefixClass = prefixCls();\n<table class="{{ prefixClass }}-quarter-panel-table" cellSpacing="0" role="grid">\n  <tbody class="{{ prefixClass }}-quarter-panel-tbody">\n    @for (row of bodyRows; track trackByBodyRow($index, row)) {\n      <tr role="row">\n        @for (quarterCell of row.dateCells; track trackByBodyColumn($index, quarterCell)) {\n          <td\n            role="gridcell"\n            title="{{ quarterCell.title }}"\n            (click)="quarterCellClick($event, quarterCell)"\n            [ngClass]="quarterCell.classMap">\n            <a class="{{ prefixClass }}-quarter-panel-quarter">{{ quarterCell.content }}</a>\n          </td>\n        }\n      </tr>\n    }\n  </tbody>\n</table>\n'
    }]
  }], null, null);
})();
var YearHeader = class _YearHeader extends CalendarHeader {
  constructor() {
    super(...arguments);
    this.startYear = computed(() => parseInt(`${this.value().getYear() / 10}`, 10) * 10, ...ngDevMode ? [{
      debugName: "startYear"
    }] : []);
    this.endYear = computed(() => this.startYear() + 9, ...ngDevMode ? [{
      debugName: "endYear"
    }] : []);
  }
  superPrevious() {
    const newValue = this.value().addYears(-10);
    this.changeValue(newValue);
  }
  superNext() {
    const newValue = this.value().addYears(10);
    this.changeValue(newValue);
  }
  getSelectors() {
    return [{
      className: `${this.prefixCls}-year-btn`,
      title: "",
      onClick: () => this.changePanel("decade"),
      label: `${this.startYear()}-${this.endYear()}`
    }];
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275YearHeader_BaseFactory;
      return function YearHeader_Factory(__ngFactoryType__) {
        return (\u0275YearHeader_BaseFactory || (\u0275YearHeader_BaseFactory = \u0275\u0275getInheritedFactory(_YearHeader)))(__ngFactoryType__ || _YearHeader);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _YearHeader,
      selectors: [["year-header"]],
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 13,
      vars: 26,
      consts: [[2, "position", "relative"], ["role", "button", 3, "click", "ngClass", "title"], ["thyIconName", "angle-double-left"], ["thyIconName", "angle-left"], ["role", "button", 3, "class", "title"], ["thyIconName", "angle-right"], ["thyIconName", "angle-double-right"], ["role", "button", 3, "click", "title"]],
      template: function YearHeader_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div", 0)(2, "a", 1);
          \u0275\u0275listener("click", function YearHeader_Template_a_click_2_listener() {
            return ctx.superPrevious();
          });
          \u0275\u0275element(3, "thy-icon", 2);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(4, "a", 1);
          \u0275\u0275listener("click", function YearHeader_Template_a_click_4_listener() {
            return ctx.previous();
          });
          \u0275\u0275element(5, "thy-icon", 3);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(6, "span");
          \u0275\u0275repeaterCreate(7, YearHeader_For_8_Template, 2, 5, "a", 4, \u0275\u0275repeaterTrackByIndex);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "a", 1);
          \u0275\u0275listener("click", function YearHeader_Template_a_click_9_listener() {
            return ctx.next();
          });
          \u0275\u0275element(10, "thy-icon", 5);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(11, "a", 1);
          \u0275\u0275listener("click", function YearHeader_Template_a_click_11_listener() {
            return ctx.superNext();
          });
          \u0275\u0275element(12, "thy-icon", 6);
          \u0275\u0275elementEnd()()();
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-header"));
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousYear);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-prev-month-btn"));
          \u0275\u0275property("ngClass", ctx.showPreBtn() ? "d-block" : "d-none")("title", ctx.locale().previousMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-my-select"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.selectors);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-month-btn"));
          \u0275\u0275property("ngClass", ctx.showNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextMonth);
          \u0275\u0275advance(2);
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-next-year-btn"));
          \u0275\u0275property("ngClass", ctx.showSuperNextBtn() ? "d-block" : "d-none")("title", ctx.locale().nextYear);
        }
      },
      dependencies: [NgClass, ThyIcon],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearHeader, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "year-header",
      imports: [NgClass, ThyIcon],
      template: `<div class="{{ prefixCls }}-header">
  <div style="position: relative">
    <a
      class="{{ prefixCls }}-prev-year-btn"
      [ngClass]="showSuperPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superPrevious()"
      [title]="locale().previousYear">
      <thy-icon thyIconName="angle-double-left"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-prev-month-btn"
      [ngClass]="showPreBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="previous()"
      [title]="locale().previousMonth">
      <thy-icon thyIconName="angle-left"></thy-icon>
    </a>

    <span class="{{ prefixCls }}-my-select">
      @for (selector of selectors; track $index) {
        <a class="{{ selector.className }}" role="button" (click)="selectorClick($event, selector)" title="{{ selector.title || null }}">
          {{ selector.label }}
        </a>
      }
    </span>

    <a
      class="{{ prefixCls }}-next-month-btn"
      [ngClass]="showNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="next()"
      [title]="locale().nextMonth">
      <thy-icon thyIconName="angle-right"></thy-icon>
    </a>
    <a
      class="{{ prefixCls }}-next-year-btn"
      [ngClass]="showSuperNextBtn() ? 'd-block' : 'd-none'"
      role="button"
      (click)="superNext()"
      [title]="locale().nextYear">
      <thy-icon thyIconName="angle-double-right"></thy-icon>
    </a>
  </div>
</div>
`
    }]
  }], null, null);
})();
var YearTable = class _YearTable extends CalendarTable {
  constructor() {
    super(...arguments);
    this.MAX_ROW = 4;
    this.MAX_COL = 3;
    this.decadePanelShow = output();
  }
  chooseYear(year) {
    const newValue = this.activeDate().setYear(year);
    this.value.set(newValue);
    this.valueChange.emit(newValue);
    this.render();
  }
  makeHeadRow() {
    return [];
  }
  makeBodyRows() {
    const years = [];
    const activeDate = this.activeDate();
    const currentYear = activeDate && activeDate.getYear();
    const startYear = parseInt(`${currentYear / 10}`, 10) * 10;
    const endYear = startYear + 9;
    const previousYear = startYear - 1;
    let yearValue = 0;
    for (let rowIndex = 0; rowIndex < this.MAX_ROW; rowIndex++) {
      const row = {
        dateCells: [],
        trackByIndex: rowIndex
      };
      for (let colIndex = 0; colIndex < this.MAX_COL; colIndex++) {
        const yearNum = previousYear + yearValue;
        const year = activeDate.setYear(yearNum);
        const content = String(yearNum);
        const disabledDate = this.disabledDate();
        const isDisabled = disabledDate ? disabledDate(year.nativeDate) : false;
        const value = this.value();
        const cell = {
          trackByIndex: colIndex,
          isDisabled,
          content,
          value: year.nativeDate,
          title: content,
          isSelected: yearNum === (value && value.getYear()),
          isSameDecade: yearNum >= startYear && yearNum <= endYear,
          classMap: {},
          onClick: () => this.chooseYear(cell.value.getFullYear()),
          onMouseEnter: () => {
          }
        };
        this.addCellProperty(cell, year);
        row.dateCells.push(cell);
        yearValue++;
      }
      years.push(row);
    }
    return years;
  }
  addCellProperty(cell, year) {
    const selectedValue = this.selectedValue();
    if (selectedValue?.length > 0) {
      const [startSelected, endSelected] = selectedValue;
      if (startSelected?.isSameYear(year)) {
        cell.isSelected = true;
      }
      if (endSelected?.isSameYear(year)) {
        cell.isSelected = true;
      }
      cell.isStartSingle = startSelected && !endSelected;
      cell.isEndSingle = !startSelected && !!endSelected;
      cell.isInRange = startSelected?.isBeforeYear(year) && year?.isBeforeYear(endSelected);
    } else if (year.isSameYear(this.value())) {
      cell.isSelected = true;
    }
    cell.classMap = this.getClassMap(cell);
  }
  yearCellClick(event, yearCell) {
    event.stopPropagation();
    return yearCell.isDisabled ? null : yearCell.onClick();
  }
  getClassMap(cell) {
    const prefixCls = this.prefixCls();
    return {
      [`${prefixCls}-year-panel-cell`]: true,
      [`${prefixCls}-year-panel-selected-cell`]: !!cell.isSelected,
      [`${prefixCls}-year-panel-cell-disabled`]: !!cell.isDisabled,
      [`${prefixCls}-year-panel-cell-in-view`]: !!cell.isSameDecade,
      [`${prefixCls}-in-range-cell`]: !!cell.isInRange
    };
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275YearTable_BaseFactory;
      return function YearTable_Factory(__ngFactoryType__) {
        return (\u0275YearTable_BaseFactory || (\u0275YearTable_BaseFactory = \u0275\u0275getInheritedFactory(_YearTable)))(__ngFactoryType__ || _YearTable);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _YearTable,
      selectors: [["year-table"]],
      outputs: {
        decadePanelShow: "decadePanelShow"
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 5,
      vars: 7,
      consts: [["cellSpacing", "0", "role", "grid"], ["role", "row"], ["role", "gridcell", 3, "title", "ngClass"], ["role", "gridcell", 3, "click", "title", "ngClass"]],
      template: function YearTable_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275declareLet(0);
          \u0275\u0275elementStart(1, "table", 0)(2, "tbody");
          \u0275\u0275repeaterCreate(3, YearTable_For_4_Template, 3, 0, "tr", 1, ctx.trackByBodyRow, true);
          \u0275\u0275elementEnd()();
        }
        if (rf & 2) {
          const prefixClass_r6 = \u0275\u0275storeLet(ctx.prefixCls());
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-year-panel-table"));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", prefixClass_r6, "-year-panel-tbody"));
          \u0275\u0275advance();
          \u0275\u0275repeater(ctx.bodyRows);
        }
      },
      dependencies: [NgClass],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(YearTable, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "year-table",
      imports: [NgClass],
      template: '@let prefixClass = prefixCls();\n<table class="{{ prefixClass }}-year-panel-table" cellSpacing="0" role="grid">\n  <tbody class="{{ prefixClass }}-year-panel-tbody">\n    @for (row of bodyRows; track trackByBodyRow($index, row)) {\n      <tr role="row">\n        @for (yearCell of row.dateCells; track trackByBodyColumn($index, yearCell)) {\n          <td role="gridcell" title="{{ yearCell.title }}" (click)="yearCellClick($event, yearCell)" [ngClass]="yearCell.classMap">\n            <a class="{{ prefixClass }}-year-panel-year">{{ yearCell.content }}</a>\n          </td>\n        }\n      </tr>\n    }\n  </tbody>\n</table>\n'
    }]
  }], null, {
    decadePanelShow: [{
      type: Output,
      args: ["decadePanelShow"]
    }]
  });
})();
var InnerPopup = class _InnerPopup {
  constructor() {
    this.dateHelper = inject(DateHelperService);
    this.locale = injectLocale("datePicker");
    this.showWeek = input(false, ...ngDevMode ? [{
      debugName: "showWeek",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.isRange = input(false, ...ngDevMode ? [{
      debugName: "isRange",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.activeDate = model.required(...ngDevMode ? [{
      debugName: "activeDate"
    }] : []);
    this.rangeActiveDate = input(...ngDevMode ? [void 0, {
      debugName: "rangeActiveDate"
    }] : []);
    this.disabledDate = input(...ngDevMode ? [void 0, {
      debugName: "disabledDate"
    }] : []);
    this.dateRender = input(...ngDevMode ? [void 0, {
      debugName: "dateRender"
    }] : []);
    this.selectedValue = input(...ngDevMode ? [void 0, {
      debugName: "selectedValue"
    }] : []);
    this.hoverValue = input(...ngDevMode ? [void 0, {
      debugName: "hoverValue"
    }] : []);
    this.panelMode = input(null, ...ngDevMode ? [{
      debugName: "panelMode",
      transform: (value) => {
        if (value === "time") {
          return "date";
        }
        return value;
      }
    }] : [{
      transform: (value) => {
        if (value === "time") {
          return "date";
        }
        return value;
      }
    }]);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.showDateRangeInput = input(false, ...ngDevMode ? [{
      debugName: "showDateRangeInput",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.partType = input(...ngDevMode ? [void 0, {
      debugName: "partType"
    }] : []);
    this.endPanelMode = input(...ngDevMode ? [void 0, {
      debugName: "endPanelMode"
    }] : []);
    this.value = model(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.panelModeChange = output();
    this.headerChange = output();
    this.selectDate = output();
    this.dayHover = output();
    this.prefixCls = "thy-calendar";
    effect(() => {
      if (!this.activeDate()) {
        this.activeDate.set(new TinyDate(void 0, this.timeZone()));
      }
    });
  }
  getReadableValue(value) {
    return value ? this.dateHelper.format(value.nativeDate, "yyyy-MM-dd") : "";
  }
  onSelectDate(date) {
    const value = date instanceof TinyDate ? date : new TinyDate(date, this.timeZone());
    this.selectDate.emit(value);
  }
  onChooseMonth(value) {
    const activeDate = this.activeDate().setMonth(value.getMonth());
    const endPanelMode = this.endPanelMode();
    this.activeDate.set(activeDate);
    if (endPanelMode === "month") {
      this.value.set(value);
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit(endPanelMode);
    }
  }
  onChooseQuarter(value) {
    const activeDate = this.activeDate().setQuarter(value.getQuarter());
    const endPanelMode = this.endPanelMode();
    this.activeDate.set(activeDate);
    if (endPanelMode === "quarter") {
      this.value.set(value);
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit(endPanelMode);
    }
  }
  onChooseYear(value) {
    const activeDate = this.activeDate().setYear(value.getYear());
    const endPanelMode = this.endPanelMode();
    this.activeDate.set(activeDate);
    if (endPanelMode === "year") {
      this.value.set(value);
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit(endPanelMode);
    }
  }
  onChooseDecade(value) {
    const activeDate = this.activeDate().setYear(value.getYear());
    const endPanelMode = this.endPanelMode();
    this.activeDate.set(activeDate);
    if (endPanelMode === "decade") {
      this.value.set(value);
      this.selectDate.emit(value);
    } else {
      this.headerChange.emit(value);
      this.panelModeChange.emit("year");
    }
  }
  enablePrevNext(direction, mode) {
    if (this.isRange()) {
      const partType = this.partType();
      if (partType === "left" && direction === "next" || partType === "right" && direction === "prev") {
        const [headerLeftDate, headerRightDate] = this.rangeActiveDate();
        return isAfterMoreThanOneMonth(headerRightDate, headerLeftDate);
      } else {
        return true;
      }
    } else {
      return true;
    }
  }
  enableSuperPrevNext(direction, panelMode) {
    if (this.isRange()) {
      const partType = this.partType();
      if (partType === "left" && direction === "next" || partType === "right" && direction === "prev") {
        const [headerLeftDate, headerRightDate] = this.rangeActiveDate();
        if (panelMode === "date") {
          return isAfterMoreThanLessOneYear(headerRightDate, headerLeftDate);
        } else if (panelMode === "month" || panelMode === "quarter") {
          return isAfterMoreThanOneYear(headerRightDate, headerLeftDate);
        } else if (panelMode === "year") {
          return isAfterMoreThanOneDecade(headerRightDate, headerLeftDate);
        }
      } else {
        return true;
      }
    } else {
      return true;
    }
  }
  static {
    this.\u0275fac = function InnerPopup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _InnerPopup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _InnerPopup,
      selectors: [["inner-popup"]],
      hostAttrs: [1, "thy-calendar-picker-inner-popup"],
      hostVars: 2,
      hostBindings: function InnerPopup_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("thy-calendar-picker-inner-popup-with-range-input", ctx.showDateRangeInput());
        }
      },
      inputs: {
        showWeek: [1, "showWeek"],
        isRange: [1, "isRange"],
        activeDate: [1, "activeDate"],
        rangeActiveDate: [1, "rangeActiveDate"],
        disabledDate: [1, "disabledDate"],
        dateRender: [1, "dateRender"],
        selectedValue: [1, "selectedValue"],
        hoverValue: [1, "hoverValue"],
        panelMode: [1, "panelMode"],
        timeZone: [1, "timeZone"],
        showDateRangeInput: [1, "showDateRangeInput"],
        partType: [1, "partType"],
        endPanelMode: [1, "endPanelMode"],
        value: [1, "value"]
      },
      outputs: {
        activeDate: "activeDateChange",
        value: "valueChange",
        panelModeChange: "panelModeChange",
        headerChange: "headerChange",
        selectDate: "selectDate",
        dayHover: "dayHover"
      },
      exportAs: ["innerPopup"],
      decls: 6,
      vars: 2,
      consts: [[3, "class"], ["thyInput", "", "thySize", "sm", 3, "value", "placeholder"], [1, "split"], [3, "valueChange", "panelModeChange", "value", "showSuperPreBtn", "showSuperNextBtn", "showNextBtn", "showPreBtn"], [3, "valueChange", "value", "activeDate"], [3, "valueChange", "value", "activeDate", "disabledDate", "selectedValue"], [3, "valueChange", "panelModeChange", "value", "showSuperPreBtn", "showSuperNextBtn", "showPreBtn", "showNextBtn"], ["showWeekNumber", "false", 3, "valueChange", "dayHover", "showWeek", "value", "activeDate", "disabledDate", "cellRender", "selectedValue", "hoverValue", "timeZone"]],
      template: function InnerPopup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, InnerPopup_Conditional_0_Template, 4, 7, "div", 0);
          \u0275\u0275conditionalCreate(1, InnerPopup_Case_1_Template, 4, 13, "div", 0)(2, InnerPopup_Case_2_Template, 4, 15, "div", 0)(3, InnerPopup_Case_3_Template, 4, 15, "div", 0)(4, InnerPopup_Case_4_Template, 4, 15, "div", 0)(5, InnerPopup_Case_5_Template, 3, 16);
        }
        if (rf & 2) {
          let tmp_1_0;
          \u0275\u0275conditional(ctx.showDateRangeInput() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional((tmp_1_0 = ctx.panelMode()) === "decade" ? 1 : tmp_1_0 === "year" ? 2 : tmp_1_0 === "month" ? 3 : tmp_1_0 === "quarter" ? 4 : 5);
        }
      },
      dependencies: [ThyInputDirective, DecadeHeader, DecadeTable, YearHeader, YearTable, MonthHeader, MonthTable, QuarterTable, DateHeader, DateTable],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InnerPopup, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "inner-popup",
      exportAs: "innerPopup",
      imports: [ThyInputDirective, DecadeHeader, DecadeTable, YearHeader, YearTable, MonthHeader, MonthTable, QuarterTable, DateHeader, DateTable],
      host: {
        class: "thy-calendar-picker-inner-popup",
        "[class.thy-calendar-picker-inner-popup-with-range-input]": "showDateRangeInput()"
      },
      template: `@if (showDateRangeInput()) {
  <div class="{{ prefixCls }}-picker-inner-popup-range-input">
    <input thyInput thySize="sm" [value]="getReadableValue(selectedValue()[0])" [placeholder]="locale().startDate" />
    <span class="split"></span>
    <input thyInput thySize="sm" [value]="getReadableValue(selectedValue()[1])" [placeholder]="locale().endDate" />
  </div>
}
@switch (panelMode()) {
  @case ('decade') {
    <div class="{{ prefixCls }}-decade">
      <decade-header
        [(value)]="activeDate"
        [showSuperPreBtn]="enableSuperPrevNext('prev', 'decade')"
        [showSuperNextBtn]="enableSuperPrevNext('next', 'decade')"
        [showNextBtn]="false"
        [showPreBtn]="false"
        (panelModeChange)="panelModeChange.emit($event)"
        (valueChange)="headerChange.emit($event)">
      </decade-header>
      <div class="{{ prefixCls }}-body">
        <decade-table [value]="value()" [activeDate]="activeDate()" (valueChange)="onChooseDecade($event)"></decade-table>
      </div>
    </div>
  }
  @case ('year') {
    <div class="{{ prefixCls }}-year">
      <year-header
        [(value)]="activeDate"
        [showSuperPreBtn]="enableSuperPrevNext('prev', 'year')"
        [showSuperNextBtn]="enableSuperPrevNext('next', 'year')"
        [showNextBtn]="false"
        [showPreBtn]="false"
        (panelModeChange)="panelModeChange.emit($event)"
        (valueChange)="headerChange.emit($event)">
      </year-header>
      <div class="{{ prefixCls }}-body">
        <year-table
          [value]="value()"
          [activeDate]="activeDate()"
          [disabledDate]="disabledDate()"
          (valueChange)="onChooseYear($event)"
          [selectedValue]="selectedValue()">
        </year-table>
      </div>
    </div>
  }
  @case ('month') {
    <div class="{{ prefixCls }}-month">
      <month-header
        [(value)]="activeDate"
        [showSuperPreBtn]="enableSuperPrevNext('prev', 'month')"
        [showSuperNextBtn]="enableSuperPrevNext('next', 'month')"
        [showNextBtn]="false"
        [showPreBtn]="false"
        (panelModeChange)="panelModeChange.emit($event)"
        (valueChange)="headerChange.emit($event)">
      </month-header>
      <div class="{{ prefixCls }}-body">
        <month-table
          [value]="value()"
          [activeDate]="activeDate()"
          [disabledDate]="disabledDate()"
          (valueChange)="onChooseMonth($event)"
          [selectedValue]="selectedValue()">
        </month-table>
      </div>
    </div>
  }
  @case ('quarter') {
    <div class="{{ prefixCls }}-quarter">
      <month-header
        [(value)]="activeDate"
        [showSuperPreBtn]="enableSuperPrevNext('prev', 'month')"
        [showSuperNextBtn]="enableSuperPrevNext('next', 'month')"
        [showNextBtn]="false"
        [showPreBtn]="false"
        (panelModeChange)="panelModeChange.emit($event)"
        (valueChange)="headerChange.emit($event)">
      </month-header>
      <div class="{{ prefixCls }}-body">
        <quarter-table
          [value]="value()"
          [activeDate]="activeDate()"
          [disabledDate]="disabledDate()"
          (valueChange)="onChooseQuarter($event)"
          [selectedValue]="selectedValue()">
        </quarter-table>
      </div>
    </div>
  }
  @default {
    <date-header
      [(value)]="activeDate"
      [showSuperPreBtn]="enableSuperPrevNext('prev', 'date')"
      [showSuperNextBtn]="enableSuperPrevNext('next', 'date')"
      [showPreBtn]="enablePrevNext('prev', 'date')"
      [showNextBtn]="enablePrevNext('next', 'date')"
      (panelModeChange)="panelModeChange.emit($event)"
      (valueChange)="headerChange.emit($event)"></date-header>
    <div class="{{ prefixCls }}-body">
      <date-table
        [showWeek]="showWeek()"
        [value]="value()"
        [activeDate]="activeDate()"
        (valueChange)="onSelectDate($event)"
        showWeekNumber="false"
        [disabledDate]="disabledDate()"
        [cellRender]="dateRender()"
        [selectedValue]="selectedValue()"
        [hoverValue]="hoverValue()"
        [timeZone]="timeZone()"
        (dayHover)="dayHover.emit($event)"></date-table>
    </div>
  }
}
`
    }]
  }], () => [], {
    showWeek: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showWeek",
        required: false
      }]
    }],
    isRange: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "isRange",
        required: false
      }]
    }],
    activeDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "activeDate",
        required: true
      }]
    }, {
      type: Output,
      args: ["activeDateChange"]
    }],
    rangeActiveDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "rangeActiveDate",
        required: false
      }]
    }],
    disabledDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disabledDate",
        required: false
      }]
    }],
    dateRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "dateRender",
        required: false
      }]
    }],
    selectedValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "selectedValue",
        required: false
      }]
    }],
    hoverValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "hoverValue",
        required: false
      }]
    }],
    panelMode: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "panelMode",
        required: false
      }]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    showDateRangeInput: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showDateRangeInput",
        required: false
      }]
    }],
    partType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "partType",
        required: false
      }]
    }],
    endPanelMode: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "endPanelMode",
        required: false
      }]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }, {
      type: Output,
      args: ["valueChange"]
    }],
    panelModeChange: [{
      type: Output,
      args: ["panelModeChange"]
    }],
    headerChange: [{
      type: Output,
      args: ["headerChange"]
    }],
    selectDate: [{
      type: Output,
      args: ["selectDate"]
    }],
    dayHover: [{
      type: Output,
      args: ["dayHover"]
    }]
  });
})();
var DatePopup = class _DatePopup {
  constructor() {
    this.cdr = inject(ChangeDetectorRef);
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
    this.locale = injectLocale("datePicker");
    this.isRange = input(false, ...ngDevMode ? [{
      debugName: "isRange",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showWeek = input(false, ...ngDevMode ? [{
      debugName: "showWeek",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.format = input(...ngDevMode ? [void 0, {
      debugName: "format"
    }] : []);
    this.disabledDate = model(...ngDevMode ? [void 0, {
      debugName: "disabledDate"
    }] : []);
    this.minDate = input(...ngDevMode ? [void 0, {
      debugName: "minDate"
    }] : []);
    this.maxDate = input(...ngDevMode ? [void 0, {
      debugName: "maxDate"
    }] : []);
    this.showToday = input(false, ...ngDevMode ? [{
      debugName: "showToday",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showTime = input(...ngDevMode ? [void 0, {
      debugName: "showTime"
    }] : []);
    this.mustShowTime = input(false, ...ngDevMode ? [{
      debugName: "mustShowTime",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.dateRender = input(...ngDevMode ? [void 0, {
      debugName: "dateRender"
    }] : []);
    this.className = input(...ngDevMode ? [void 0, {
      debugName: "className"
    }] : []);
    this.panelMode = model(...ngDevMode ? [void 0, {
      debugName: "panelMode"
    }] : []);
    this.value = model(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.defaultPickerValue = input(...ngDevMode ? [void 0, {
      debugName: "defaultPickerValue"
    }] : []);
    this.showShortcut = model(...ngDevMode ? [void 0, {
      debugName: "showShortcut"
    }] : []);
    this.shortcutPresets = model(...ngDevMode ? [void 0, {
      debugName: "shortcutPresets"
    }] : []);
    this.shortcutPosition = input(...ngDevMode ? [void 0, {
      debugName: "shortcutPosition"
    }] : []);
    this.flexible = input(false, ...ngDevMode ? [{
      debugName: "flexible",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.flexibleDateGranularity = model(...ngDevMode ? [void 0, {
      debugName: "flexibleDateGranularity"
    }] : []);
    this.timestampPrecision = input(...ngDevMode ? [void 0, {
      debugName: "timestampPrecision"
    }] : []);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.panelModeChange = output();
    this.calendarChange = output();
    this.valueChange = output();
    this.resultOk = output();
    this.showTimePickerChange = output();
    this.dateValueChange = output();
    this.prefixCls = "thy-calendar";
    this.showTimePicker = false;
    this.selectedValue = [];
    this.hoverValue = [];
    this.flexibleActiveTab = "advanced";
    this.partTypeMap = {
      left: 0,
      right: 1
    };
    this.endPanelMode = signal(void 0, ...ngDevMode ? [{
      debugName: "endPanelMode"
    }] : []);
    this.disableTimeConfirm = signal(false, ...ngDevMode ? [{
      debugName: "disableTimeConfirm"
    }] : []);
  }
  setProperty(key, value) {
    this[key] = value;
    this.cdr.markForCheck();
  }
  ngOnInit() {
    this.initShortcutPresets();
    this.initPanelMode();
    if (this.flexible() && this.flexibleDateGranularity() === "day") {
      this.flexibleActiveTab = "custom";
    }
    if (this.defaultPickerValue() && !hasValue(this.value())) {
      this.value.set(this.getDefaultPickerValue());
    }
    this.updateActiveDate();
    this.initDisabledDate();
    if (this.isRange() && this.flexible() && this.value()) {
      this.advancedSelectedValue = {
        begin: this.value()[0],
        end: this.value()[1],
        dateGranularity: this.flexibleDateGranularity()
      };
    }
  }
  ngOnChanges(changes) {
    if (changes.panelMode) {
      if (index.isArray(this.panelMode())) {
        this.endPanelMode.set([...this.panelMode()]);
      } else {
        this.endPanelMode.set(this.panelMode());
      }
    }
    if (changes.defaultPickerValue) {
      this.updateActiveDate();
    }
    if (changes.value && changes.value.currentValue) {
      this.updateActiveDate();
    }
  }
  initShortcutPresets() {
    const {
      shortcutRangesPresets,
      shortcutDatePresets,
      showShortcut
    } = this.datePickerConfigService;
    this.showShortcut.set(["date", "date,date"].includes(this.panelMode().toString()) && isUndefinedOrNull(this.showShortcut()) ? showShortcut : this.showShortcut());
    if (this.showShortcut()) {
      if (!this.shortcutPresets()) {
        this.shortcutPresets.set(this.isRange() ? shortcutRangesPresets : shortcutDatePresets);
      }
      this.innerShortcutPresets = isFunction(this.shortcutPresets()) ? this.shortcutPresets()() : this.shortcutPresets();
      if (this.innerShortcutPresets.length) {
        const minDate = this.getMinTinyDate();
        const maxDate = this.getMaxTinyDate();
        const minTime = minDate ? minDate.getTime() : null;
        const maxTime = maxDate ? maxDate.getTime() : null;
        if (this.isRange()) {
          this.innerShortcutPresets.forEach((preset) => {
            const begin = getShortcutValue(preset.value[0]);
            const beginTime = new TinyDate(startOfDay2(begin), this.timeZone()).getTime();
            const end = getShortcutValue(preset.value[1]);
            const endTime = new TinyDate(endOfDay2(end), this.timeZone()).getTime();
            if (minDate && endTime < minTime || maxDate && beginTime > maxTime) {
              preset.disabled = true;
            } else {
              preset.disabled = false;
            }
          });
        } else {
          this.innerShortcutPresets.forEach((preset) => {
            const singleValue = getShortcutValue(preset.value);
            const singleTime = new TinyDate(singleValue, this.timeZone()).getTime();
            if (minDate && singleTime < minTime || maxDate && singleTime > maxTime) {
              preset.disabled = true;
            } else {
              preset.disabled = false;
            }
          });
        }
      }
    }
  }
  updateActiveDate() {
    this.clearHoverValue();
    if (!this.value()) {
      this.value.set(this.getDefaultPickerValue());
    }
    if (this.isRange()) {
      if (!this.flexible() || this.flexibleDateGranularity() === "day") {
        this.selectedValue = this.value();
      }
      this.activeDate = this.normalizeRangeValue(this.value(), this.getPanelMode(this.endPanelMode()));
    } else {
      this.activeDate = this.value();
    }
    this.isDisableTimeConfirm();
  }
  getDefaultPickerValue() {
    const {
      value
    } = transformDateValue(this.defaultPickerValue());
    return makeValue(value, this.isRange(), true, this.timeZone());
  }
  initPanelMode() {
    if (!this.endPanelMode()) {
      if (index.isArray(this.panelMode())) {
        this.endPanelMode.set([...this.panelMode()]);
      } else {
        this.endPanelMode.set(this.panelMode());
      }
    } else {
      if (index.isArray(this.endPanelMode())) {
        this.panelMode.set([...this.endPanelMode()]);
      } else {
        this.panelMode.set(this.endPanelMode());
      }
    }
  }
  initDisabledDate() {
    let minDate;
    let maxDate;
    let disabledDateFn;
    if (this.minDate()) {
      const {
        value
      } = transformDateValue(this.minDate());
      minDate = new TinyDate(value, this.timeZone());
    }
    if (this.maxDate()) {
      const {
        value
      } = transformDateValue(this.maxDate());
      maxDate = new TinyDate(value, this.timeZone());
    }
    if (this.disabledDate()) {
      disabledDateFn = this.disabledDate();
    }
    this.disabledDate.set((d) => {
      let expression = false;
      if (minDate) {
        expression = d < minDate.startOfDay().nativeDate;
      }
      if (maxDate && !expression) {
        expression = d > maxDate.endOfDay().nativeDate;
      }
      if (disabledDateFn && typeof disabledDateFn === "function" && !expression) {
        expression = disabledDateFn(d);
      }
      return expression;
    });
  }
  onShowTimePickerChange(show) {
    this.showTimePicker = show;
    this.showTimePickerChange.emit(show);
  }
  onClickOk() {
    this.setValue(this.value());
    this.valueChange.emit(this.value());
    this.resultOk.emit();
  }
  onClickRemove() {
    this.value.set(this.isRange() ? [] : null);
    this.valueChange.emit(this.value());
  }
  onDayHover(value) {
    if (this.isRange() && this.selectedValue[0] && !this.selectedValue[1]) {
      const base = this.selectedValue[0];
      if (base.isBeforeDay(value)) {
        this.hoverValue = [base, value];
      } else {
        this.hoverValue = [value, base];
      }
    }
  }
  onPanelModeChange(mode, partType) {
    if (this.isRange()) {
      this.panelMode()[this.getPartTypeIndex(partType)] = mode;
    } else {
      this.panelMode.set(mode);
    }
    this.panelModeChange.emit(this.panelMode());
  }
  onHeaderChange(value, partType) {
    if (this.isRange()) {
      this.activeDate[this.getPartTypeIndex(partType)] = value;
      this.activeDate = this.normalizeRangeValue(this.activeDate, this.getPanelMode(this.endPanelMode(), partType));
    } else {
      this.activeDate = value;
    }
  }
  onSelectTime(value, partType) {
    if (this.isRange()) {
    } else {
      this.setValue(new TinyDate(value.nativeDate, this.timeZone()));
    }
  }
  selectTab(active) {
    this.flexibleActiveTab = active;
  }
  clearFlexibleValue() {
    this.flexibleDateGranularity.set(null);
    if (this.flexibleActiveTab === "advanced") {
      this.advancedSelectedValue = {};
    } else {
      this.selectedValue = [];
    }
    this.valueChange.emit({
      begin: void 0,
      end: void 0,
      dateGranularity: this.flexibleDateGranularity()
    });
  }
  changeValueFromAdvancedSelect(value) {
    this.valueChange.emit(value);
    this.selectedValue = [];
    this.dateValueChange.emit({
      value: [value.begin, value.end]
    });
  }
  changeValueFromSelect(value, partType) {
    if (this.isRange()) {
      this.advancedSelectedValue = {};
      const [left, right] = this.selectedValue;
      if (!left && !right || left && right) {
        this.hoverValue = this.selectedValue = [value];
        this.selectedValue = [this.selectedValue[0].startOfDay()];
        this.calendarChange.emit([this.selectedValue[0].clone()]);
      } else if (left && !right) {
        this.clearHoverValue();
        this.setRangeValue("right", value);
        this.selectedValue = sortRangeValue(this.selectedValue);
        this.selectedValue = this.getSelectedRangeValueByMode(this.selectedValue);
        this.activeDate = this.normalizeRangeValue(this.selectedValue, this.getPanelMode(this.endPanelMode(), partType));
        this.setValue(this.cloneRangeDate(this.selectedValue));
        this.calendarChange.emit(this.cloneRangeDate(this.selectedValue));
        this.dateValueChange.emit({
          value: this.cloneRangeDate(this.selectedValue)
        });
      }
    } else {
      const updatedValue = this.updateHourMinute(value);
      this.setValue(updatedValue);
      this.dateValueChange.emit({
        value: updatedValue
      });
    }
  }
  getSelectedRangeValueByMode(value) {
    const panelMode = this.getPanelMode(this.endPanelMode());
    if (panelMode === "year") {
      return [value[0].startOfYear(), value[1].endOfYear()];
    } else if (panelMode === "quarter") {
      return [value[0].startOfQuarter(), value[1].endOfQuarter()];
    } else if (panelMode === "month") {
      return [value[0].startOfMonth(), value[1].endOfMonth()];
    } else if (panelMode === "week") {
      return [value[0].startOfISOWeek(), value[1].endOfISOWeek()];
    } else {
      return [value[0].startOfDay(), value[1].endOfDay()];
    }
  }
  updateHourMinute(value) {
    if (!this.value()) {
      return value;
    }
    const originDate = this.value();
    const dateTime = [value.getHours(), value.getMinutes(), value.getSeconds()];
    const originDateTime = [originDate.getHours(), originDate.getMinutes(), originDate.getSeconds()];
    const isEqualTime = dateTime.toString() === originDateTime.toString();
    if (isEqualTime) {
      return value;
    } else {
      return value.setHms(originDateTime[0], originDateTime[1], originDateTime[2]);
    }
  }
  enablePrevNext(direction, partType) {
    if (this.isRange() && this.panelMode() === this.endPanelMode()) {
      const [start, end] = this.activeDate;
      const showMiddle = !start.addMonths(1).isSame(end, "month");
      if (partType === "left" && direction === "next" || partType === "right" && direction === "prev") {
        return showMiddle;
      }
      return true;
    } else {
      return true;
    }
  }
  getPanelMode(panelMode, partType) {
    if (this.isRange()) {
      return panelMode[this.getPartTypeIndex(partType)];
    } else {
      return panelMode;
    }
  }
  getValueBySelector(partType) {
    if (this.isRange()) {
      const valueShow = this.selectedValue;
      return valueShow[this.getPartTypeIndex(partType)];
    } else {
      return this.value();
    }
  }
  getActiveDate(partType) {
    if (this.isRange()) {
      return this.activeDate[this.getPartTypeIndex(partType)];
    } else {
      return this.activeDate;
    }
  }
  getPartTypeIndex(partType = "left") {
    return this.partTypeMap[partType];
  }
  getMinTinyDate() {
    return this.minDate() ? new TinyDate(transformDateValue(this.minDate()).value, this.timeZone()) : null;
  }
  getMaxTinyDate() {
    return this.maxDate() ? new TinyDate(transformDateValue(this.maxDate()).value, this.timeZone()) : null;
  }
  clearHoverValue() {
    this.hoverValue = [];
  }
  setValue(value) {
    this.value.set(value);
    if (this.isRange() && this.flexible()) {
      this.flexibleDateGranularity.set("day");
      this.valueChange.emit({
        begin: value[0],
        end: value[1],
        dateGranularity: this.flexibleDateGranularity()
      });
    } else {
      if (!this.showTime() || !this.showTimePicker) {
        this.valueChange.emit(this.value());
      }
    }
    this.isDisableTimeConfirm();
  }
  normalizeRangeValue(value, mode = "month") {
    const headerModes = {
      week: "month",
      date: "month",
      month: "year",
      quarter: "year",
      year: "decade"
    };
    const headerMode = headerModes[mode];
    const [start, end] = value;
    const newStart = start || new TinyDate(void 0, this.timeZone());
    let newEnd = end;
    if (!newEnd || newStart.isSame(end, headerMode)) {
      newEnd = dateAddAmount(newStart, 1, headerMode);
    }
    return [newStart, newEnd];
  }
  setRangeValue(partType, value) {
    const ref = this.selectedValue = this.cloneRangeDate(this.selectedValue);
    ref[this.getPartTypeIndex(partType)] = value;
  }
  cloneRangeDate(value) {
    return [value[0] && value[0].clone(), value[1] && value[1].clone()];
  }
  isDisableTimeConfirm() {
    if (this.isRange() || !this.showTime()) {
      return;
    }
    const date = this.value() ? this.value() : new TinyDate(void 0, this.timeZone());
    const minDate = this.getMinTinyDate();
    const maxDate = this.getMaxTinyDate();
    if (minDate && date.getTime() < minDate.getTime() || maxDate && date.getTime() > maxDate.getTime()) {
      this.disableTimeConfirm.set(true);
    } else {
      this.disableTimeConfirm.set(false);
    }
  }
  getSelectedShortcutPreset(date) {
    const minDate = this.getMinTinyDate();
    const maxDate = this.getMaxTinyDate();
    const minTime = minDate && minDate.getTime() || null;
    const maxTime = maxDate && maxDate.getTime() || null;
    if (index.isArray(date)) {
      const startDate = date[0];
      const endDate = date[1];
      const startTime = startDate.getTime();
      const endTime = endDate.getTime();
      if (maxDate && startTime > maxTime || minDate && endTime < minTime) {
        return [];
      }
      if (minDate && startTime < minTime && maxDate && endTime > maxTime) {
        return [minDate, maxDate];
      }
      if (minDate && startTime < minTime) {
        return [minDate, endDate];
      }
      if (maxDate && endTime > maxTime) {
        return [startDate, maxDate];
      }
      return date;
    } else {
      const singleTime = date.getTime();
      if (minDate && singleTime < minTime || maxDate && singleTime > maxTime) {
        return null;
      }
      return date;
    }
  }
  shortcutSetValue(shortcutPresets) {
    if (shortcutPresets.disabled) {
      return;
    }
    const {
      value
    } = shortcutPresets;
    if (!value) {
      return;
    }
    let selectedPresetValue;
    if (index.isArray(value)) {
      const begin = getShortcutValue(value[0]);
      const end = getShortcutValue(value[1]);
      if (begin && end) {
        this.selectedValue = this.getSelectedShortcutPreset([new TinyDate(begin, this.timeZone()).startOfDay(), new TinyDate(end, this.timeZone()).endOfDay()]);
        selectedPresetValue = this.cloneRangeDate(this.selectedValue);
      }
    } else {
      const originDate = this.value();
      const zonedTime = this.createInZoneTime(new TinyDate(getShortcutValue(value), this.timeZone()), originDate?.getHours() ?? 0, originDate?.getMinutes() ?? 0, originDate?.getSeconds() ?? 0);
      const singleTinyDate = this.updateHourMinute(new TinyDate(zonedTime, this.timeZone()));
      selectedPresetValue = this.getSelectedShortcutPreset(singleTinyDate);
    }
    this.setValue(selectedPresetValue);
    const shortcutPresetsValue = setValueByTimestampPrecision(shortcutPresets?.value, this.isRange(), this.timestampPrecision(), this.timeZone());
    this.dateValueChange.emit({
      value: index.isArray(value) ? this.selectedValue : selectedPresetValue,
      triggerPreset: Object.assign({}, shortcutPresets, {
        value: shortcutPresetsValue
      })
    });
    if (!index.isArray(value) && this.showTime() && this.showTimePicker) {
      this.updateActiveDate();
    }
  }
  createInZoneTime(date, hours, minutes, seconds) {
    return TinyDate.createDateInTimeZone(date.getYear(), date.getMonth(), date.getDate(), hours, minutes, seconds, this.timeZone());
  }
  static {
    this.\u0275fac = function DatePopup_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DatePopup)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DatePopup,
      selectors: [["date-popup"]],
      inputs: {
        isRange: [1, "isRange"],
        showWeek: [1, "showWeek"],
        format: [1, "format"],
        disabledDate: [1, "disabledDate"],
        minDate: [1, "minDate"],
        maxDate: [1, "maxDate"],
        showToday: [1, "showToday"],
        showTime: [1, "showTime"],
        mustShowTime: [1, "mustShowTime"],
        dateRender: [1, "dateRender"],
        className: [1, "className"],
        panelMode: [1, "panelMode"],
        value: [1, "value"],
        defaultPickerValue: [1, "defaultPickerValue"],
        showShortcut: [1, "showShortcut"],
        shortcutPresets: [1, "shortcutPresets"],
        shortcutPosition: [1, "shortcutPosition"],
        flexible: [1, "flexible"],
        flexibleDateGranularity: [1, "flexibleDateGranularity"],
        timestampPrecision: [1, "timestampPrecision"],
        timeZone: [1, "timeZone"]
      },
      outputs: {
        disabledDate: "disabledDateChange",
        panelMode: "panelModeChange",
        value: "valueChange",
        showShortcut: "showShortcutChange",
        shortcutPresets: "shortcutPresetsChange",
        flexibleDateGranularity: "flexibleDateGranularityChange",
        panelModeChange: "panelModeChange",
        calendarChange: "calendarChange",
        valueChange: "valueChange",
        resultOk: "resultOk",
        showTimePickerChange: "showTimePickerChange",
        dateValueChange: "dateValueChange"
      },
      exportAs: ["datePopup"],
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 13,
      vars: 19,
      consts: [["tplInnerPopup", ""], ["tplFooter", ""], ["tplRangePart", ""], [3, "class"], [3, "class", "disabled"], [3, "click"], ["thyType", "pulled", "thySize", "sm"], ["href", "javascript:;", "thyNavLink", "", 3, "click", "thyNavLinkActive"], ["thyButtonIcon", "sweep", "thySize", "sm", 1, "clear-date-button", 3, "click"], [3, "hidden"], ["name", "dateCarousel", 3, "ngModelChange", "ngModel", "activeDate"], [4, "ngTemplateOutlet"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "panelModeChange", "dayHover", "selectDate", "headerChange", "showWeek", "isRange", "panelMode", "endPanelMode", "partType", "showDateRangeInput", "value", "selectedValue", "activeDate", "rangeActiveDate", "disabledDate", "dateRender", "hoverValue", "timeZone"], [3, "showTimePickerChange", "selectTime", "clickOk", "clickRemove", "showTime", "mustShowTime", "value", "timeZone", "disableTimeConfirm"], [2, "outline", "none"]],
      template: function DatePopup_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div")(1, "div");
          \u0275\u0275conditionalCreate(2, DatePopup_Conditional_2_Template, 3, 3, "div", 3);
          \u0275\u0275elementStart(3, "div")(4, "div");
          \u0275\u0275conditionalCreate(5, DatePopup_Conditional_5_Template, 13, 18, "div", 3)(6, DatePopup_Conditional_6_Template, 3, 2);
          \u0275\u0275elementEnd()()()();
          \u0275\u0275template(7, DatePopup_ng_template_7_Template, 1, 14, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(9, DatePopup_ng_template_9_Template, 1, 5, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(11, DatePopup_ng_template_11_Template, 3, 9, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          \u0275\u0275classMap(\u0275\u0275interpolate2("", ctx.prefixCls, "-picker-container ", ctx.className()));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate5("", ctx.prefixCls, " ", ctx.showWeek() ? ctx.prefixCls + "-week-number" : "", "\n     ", ctx.isRange() ? ctx.prefixCls + "-range" : "", " ", ctx.prefixCls, "-picker-shortcut-", ctx.shortcutPosition() === "left" ? "left" : "bottom"));
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.showShortcut() ? 2 : -1);
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-panel"));
          \u0275\u0275advance();
          \u0275\u0275classMap(\u0275\u0275interpolate1("", ctx.prefixCls, "-date-panel"));
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.flexible() ? 5 : 6);
        }
      },
      dependencies: [ThyNav, ThyNavItemDirective, ThyButtonIcon, DateCarousel, FormsModule, NgControlStatus, NgModel, NgTemplateOutlet, InnerPopup, CalendarFooter],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePopup, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "date-popup",
      exportAs: "datePopup",
      imports: [ThyNav, ThyNavItemDirective, ThyButtonIcon, DateCarousel, FormsModule, NgTemplateOutlet, InnerPopup, CalendarFooter],
      template: `<div class="{{ prefixCls }}-picker-container {{ className() }}">
  <div
    class="{{ prefixCls }} {{ showWeek() ? prefixCls + '-week-number' : '' }}
     {{ isRange() ? prefixCls + '-range' : '' }} {{ prefixCls }}-picker-shortcut-{{ shortcutPosition() === 'left' ? 'left' : 'bottom' }}">
    @if (showShortcut()) {
      <div class="{{ prefixCls }}-picker-shortcut">
        @for (item of innerShortcutPresets; track $index) {
          <div class="{{ prefixCls }}-picker-shortcut-item" [class.disabled]="item.disabled" (click)="shortcutSetValue(item)">
            {{ item.title }}
          </div>
        }
      </div>
    }
    <div class="{{ prefixCls }}-panel">
      <div class="{{ prefixCls }}-date-panel">
        @if (flexible()) {
          <div class="{{ prefixCls }}-date-panel-flexible">
            <div class="{{ prefixCls }}-date-panel-flexible-tab">
              <thy-nav thyType="pulled" thySize="sm">
                <a href="javascript:;" thyNavLink [thyNavLinkActive]="flexibleActiveTab === 'advanced'" (click)="selectTab('advanced')">{{
                  locale().advance
                }}</a>
                <a href="javascript:;" thyNavLink [thyNavLinkActive]="flexibleActiveTab === 'custom'" (click)="selectTab('custom')">{{
                  locale().custom
                }}</a>
              </thy-nav>
              <button thyButtonIcon="sweep" thySize="sm" class="clear-date-button" (click)="clearFlexibleValue()"></button>
            </div>
            <ng-container>
              <div class="{{ prefixCls }}-date-panel-advanced" [hidden]="flexibleActiveTab !== 'advanced'">
                <date-carousel
                  name="dateCarousel"
                  (ngModelChange)="changeValueFromAdvancedSelect($event)"
                  [(ngModel)]="advancedSelectedValue"
                  [activeDate]="selectedValue[0]"></date-carousel>
              </div>
            </ng-container>
            <div [hidden]="flexibleActiveTab !== 'custom'">
              <ng-container *ngTemplateOutlet="tplInnerPopup"></ng-container>
            </div>
          </div>
        } @else {
          @if (isRange()) {
            <ng-container *ngTemplateOutlet="tplRangePart; context: { partType: 'left' }"></ng-container>
            <ng-container *ngTemplateOutlet="tplRangePart; context: { partType: 'right' }"></ng-container>
          } @else {
            <div>
              <ng-container *ngTemplateOutlet="tplInnerPopup"></ng-container>
            </div>
          }
          @if (!isRange()) {
            <ng-container *ngTemplateOutlet="tplFooter"></ng-container>
          }
        }
      </div>
    </div>
  </div>
</div>

<ng-template #tplInnerPopup let-partType="partType">
  <inner-popup
    [showWeek]="showWeek()"
    [isRange]="isRange()"
    [panelMode]="getPanelMode(panelMode(), partType)"
    [endPanelMode]="getPanelMode(endPanelMode(), partType)"
    [partType]="partType"
    [showDateRangeInput]="flexible() && flexibleActiveTab === 'custom'"
    (panelModeChange)="onPanelModeChange($event, partType)"
    [value]="getValueBySelector(partType)"
    [selectedValue]="selectedValue"
    [activeDate]="getActiveDate(partType)"
    [rangeActiveDate]="activeDate"
    [disabledDate]="disabledDate()"
    [dateRender]="dateRender()"
    [hoverValue]="hoverValue"
    [timeZone]="timeZone()"
    (dayHover)="onDayHover($event)"
    (selectDate)="changeValueFromSelect($event, partType)"
    (headerChange)="onHeaderChange($event, partType)"></inner-popup>
</ng-template>

<ng-template #tplFooter>
  <calendar-footer
    [showTime]="showTime()"
    [mustShowTime]="mustShowTime()"
    [value]="value()"
    [timeZone]="timeZone()"
    [disableTimeConfirm]="disableTimeConfirm()"
    (showTimePickerChange)="onShowTimePickerChange($event)"
    (selectTime)="onSelectTime($event)"
    (clickOk)="onClickOk()"
    (clickRemove)="onClickRemove()"></calendar-footer>
</ng-template>

<!-- Single ONLY -->

<!-- Range ONLY -->
<ng-template #tplRangePart let-partType="partType">
  <div class="{{ prefixCls }}-range-part {{ prefixCls }}-range-{{ partType }}">
    <div style="outline: none">
      <ng-container *ngTemplateOutlet="tplInnerPopup; context: { partType: partType }"></ng-container>
    </div>
  </div>
</ng-template>
`
    }]
  }], null, {
    isRange: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "isRange",
        required: false
      }]
    }],
    showWeek: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showWeek",
        required: false
      }]
    }],
    format: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "format",
        required: false
      }]
    }],
    disabledDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disabledDate",
        required: false
      }]
    }, {
      type: Output,
      args: ["disabledDateChange"]
    }],
    minDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "minDate",
        required: false
      }]
    }],
    maxDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "maxDate",
        required: false
      }]
    }],
    showToday: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showToday",
        required: false
      }]
    }],
    showTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showTime",
        required: false
      }]
    }],
    mustShowTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "mustShowTime",
        required: false
      }]
    }],
    dateRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "dateRender",
        required: false
      }]
    }],
    className: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "className",
        required: false
      }]
    }],
    panelMode: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "panelMode",
        required: false
      }]
    }, {
      type: Output,
      args: ["panelModeChange"]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }, {
      type: Output,
      args: ["valueChange"]
    }],
    defaultPickerValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "defaultPickerValue",
        required: false
      }]
    }],
    showShortcut: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "showShortcut",
        required: false
      }]
    }, {
      type: Output,
      args: ["showShortcutChange"]
    }],
    shortcutPresets: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "shortcutPresets",
        required: false
      }]
    }, {
      type: Output,
      args: ["shortcutPresetsChange"]
    }],
    shortcutPosition: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "shortcutPosition",
        required: false
      }]
    }],
    flexible: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "flexible",
        required: false
      }]
    }],
    flexibleDateGranularity: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "flexibleDateGranularity",
        required: false
      }]
    }, {
      type: Output,
      args: ["flexibleDateGranularityChange"]
    }],
    timestampPrecision: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timestampPrecision",
        required: false
      }]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    panelModeChange: [{
      type: Output,
      args: ["panelModeChange"]
    }],
    calendarChange: [{
      type: Output,
      args: ["calendarChange"]
    }],
    valueChange: [{
      type: Output,
      args: ["valueChange"]
    }],
    resultOk: [{
      type: Output,
      args: ["resultOk"]
    }],
    showTimePickerChange: [{
      type: Output,
      args: ["showTimePickerChange"]
    }],
    dateValueChange: [{
      type: Output,
      args: ["dateValueChange"]
    }]
  });
})();
var LibPackerModule = class _LibPackerModule {
  static {
    this.\u0275fac = function LibPackerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LibPackerModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _LibPackerModule,
      imports: [CommonModule, FormsModule, ThyButtonModule, ThyIconModule, ThyTimePickerModule, ThyNavModule, ThyInputModule, CalendarFooter, DateTable, DateHeader, YearTable, YearHeader, MonthTable, MonthHeader, QuarterTable, DecadeHeader, DecadeTable, InnerPopup, DatePopup, DateTableCell, DateCarousel, DatePickerAdvancedShowYearTipPipe],
      exports: [CalendarFooter, DateTable, DateHeader, YearTable, YearHeader, MonthTable, MonthHeader, QuarterTable, DecadeHeader, DecadeTable, InnerPopup, DatePopup, DateTableCell, DateCarousel]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule, FormsModule, ThyButtonModule, ThyIconModule, ThyTimePickerModule, ThyNavModule, ThyInputModule, CalendarFooter, DateHeader, YearHeader, MonthHeader, DecadeHeader, InnerPopup, DatePopup, DateCarousel]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LibPackerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, FormsModule, ThyButtonModule, ThyIconModule, ThyTimePickerModule, ThyNavModule, ThyInputModule, CalendarFooter, DateTable, DateHeader, YearTable, YearHeader, MonthTable, MonthHeader, QuarterTable, DecadeHeader, DecadeTable, InnerPopup, DatePopup, DateTableCell, DateCarousel, DatePickerAdvancedShowYearTipPipe],
      exports: [CalendarFooter, DateTable, DateHeader, YearTable, YearHeader, MonthTable, MonthHeader, QuarterTable, DecadeHeader, DecadeTable, InnerPopup, DatePopup, DateTableCell, DateCarousel]
    }]
  }], null, null);
})();
var ThyPicker = class _ThyPicker {
  get realOpenState() {
    return this.isOpenHandledByUser() ? !!this.opened() : this.overlayOpen;
  }
  get readonlyState() {
    return this.isRange() || this.readonly() || this.mode() !== "date";
  }
  constructor() {
    this.changeDetector = inject(ChangeDetectorRef);
    this.dateHelper = inject(DateHelperService);
    this.i18n = inject(ThyI18nService);
    this.isRange = input(false, ...ngDevMode ? [{
      debugName: "isRange",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.opened = input(void 0, ...ngDevMode ? [{
      debugName: "opened"
    }] : []);
    this.disabled = input(false, ...ngDevMode ? [{
      debugName: "disabled",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.placeholder = input(...ngDevMode ? [void 0, {
      debugName: "placeholder"
    }] : []);
    this.readonly = input(false, ...ngDevMode ? [{
      debugName: "readonly",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.allowClear = input(false, ...ngDevMode ? [{
      debugName: "allowClear",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.autoFocus = input(false, ...ngDevMode ? [{
      debugName: "autoFocus",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.className = input(...ngDevMode ? [void 0, {
      debugName: "className"
    }] : []);
    this.size = input(...ngDevMode ? [void 0, {
      debugName: "size"
    }] : []);
    this.suffixIcon = input(...ngDevMode ? [void 0, {
      debugName: "suffixIcon"
    }] : []);
    this.placement = input("bottomLeft", ...ngDevMode ? [{
      debugName: "placement"
    }] : []);
    this.flexible = input(false, ...ngDevMode ? [{
      debugName: "flexible",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.mode = input(...ngDevMode ? [void 0, {
      debugName: "mode"
    }] : []);
    this.hasBackdrop = input(false, ...ngDevMode ? [{
      debugName: "hasBackdrop",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.separator = input(...ngDevMode ? [void 0, {
      debugName: "separator"
    }] : []);
    this.timeZone = input(...ngDevMode ? [void 0, {
      debugName: "timeZone"
    }] : []);
    this.blur = output();
    this.valueChange = output();
    this.openChange = output();
    this.inputChange = output();
    this.origin = viewChild("origin", ...ngDevMode ? [{
      debugName: "origin"
    }] : []);
    this.cdkConnectedOverlay = viewChild(CdkConnectedOverlay, ...ngDevMode ? [{
      debugName: "cdkConnectedOverlay"
    }] : []);
    this.pickerInput = viewChild("pickerInput", ...ngDevMode ? [{
      debugName: "pickerInput"
    }] : []);
    this.overlayContainer = viewChild("overlayContainer", ...ngDevMode ? [{
      debugName: "overlayContainer"
    }] : []);
    this.format = input(...ngDevMode ? [void 0, {
      debugName: "format"
    }] : []);
    this.flexibleDateGranularity = input(...ngDevMode ? [void 0, {
      debugName: "flexibleDateGranularity"
    }] : []);
    this.value = input(...ngDevMode ? [void 0, {
      debugName: "value"
    }] : []);
    this.entering = false;
    this.prefixCls = "thy-calendar";
    this.isShowDatePopup = false;
    this.overlayOpen = false;
    this.overlayPositions = getFlexiblePositions(this.placement(), 4);
    effect(() => {
      this.innerValue = this.value();
      if (!this.entering) {
        this.updateReadableDate(this.innerValue);
      }
    });
    effect(() => {
      this.innerFormat = this.format();
      if (this.innerFormat) {
        this.updateReadableDate(this.innerValue);
      }
    });
    effect(() => {
      this.innerflexibleDateGranularity = this.flexibleDateGranularity();
      if (this.innerflexibleDateGranularity) {
        this.updateReadableDate(this.innerValue);
      }
    });
    effect(() => {
      if (this.timeZone()) {
        this.formatDate(this.innerValue);
      }
    });
    effect(() => {
      const openedState = this.opened();
      if (openedState != void 0) {
        if (openedState) {
          this.showDatePopup();
        } else {
          this.closeDatePopup();
        }
      }
    });
  }
  ngAfterViewInit() {
    this.overlayPositions = getFlexiblePositions(this.placement(), 4);
    if (this.autoFocus()) {
      this.focus();
    }
  }
  focus() {
    this.pickerInput()?.nativeElement.focus();
  }
  onBlur(event) {
    this.blur.emit(event);
    if (this.entering) {
      this.valueChange.emit(this.pickerInput()?.nativeElement.value);
    }
    this.entering = false;
  }
  onInput(event) {
    this.entering = true;
    const inputValue = event.target["value"];
    this.inputChange.emit(inputValue);
  }
  onEnter() {
    if (this.readonlyState) {
      return;
    }
    this.valueChange.emit(this.pickerInput()?.nativeElement.value || this.getReadableValue(new TinyDate(void 0, this.timeZone())));
    this.entering = false;
  }
  showOverlay() {
    if (!this.realOpenState) {
      this.overlayOpen = true;
      this.showDatePopup();
      this.openChange.emit(this.overlayOpen);
      setTimeout(() => {
        if (this.cdkConnectedOverlay() && this.cdkConnectedOverlay()?.overlayRef) {
          this.cdkConnectedOverlay()?.overlayRef.updatePosition();
        }
      });
    }
  }
  hideOverlay() {
    if (this.realOpenState) {
      this.overlayOpen = false;
      this.closeDatePopup();
      this.openChange.emit(this.overlayOpen);
      this.focus();
    }
  }
  showDatePopup() {
    this.isShowDatePopup = true;
    this.changeDetector.markForCheck();
  }
  closeDatePopup() {
    setTimeout(() => {
      this.isShowDatePopup = false;
      this.changeDetector.markForCheck();
    }, 200);
  }
  onClickInputBox() {
    if (!this.disabled() && !this.readonly() && !this.isOpenHandledByUser()) {
      this.showOverlay();
    }
  }
  onClickBackdrop() {
    this.hideOverlay();
  }
  onOverlayDetach() {
    this.hideOverlay();
  }
  onPositionChange(position) {
    this.changeDetector.detectChanges();
  }
  onClickClear(event) {
    event.preventDefault();
    event.stopPropagation();
    this.innerValue = this.isRange() ? [] : null;
    this.valueChange.emit(this.innerValue);
  }
  getPartTypeIndex(partType) {
    return {
      left: 0,
      right: 1
    }[partType];
  }
  isEmptyValue(value) {
    if (value === null) {
      return true;
    } else if (this.isRange()) {
      return !value || !Array.isArray(value) || value.every((val) => !val);
    } else {
      return !value;
    }
  }
  // Whether open state is permanently controlled by user himself
  isOpenHandledByUser() {
    return this.opened() !== void 0;
  }
  getReadableValue(tinyDate) {
    let value;
    if (this.isRange()) {
      if (this.flexible() && this.innerflexibleDateGranularity !== "day") {
        return getFlexibleAdvancedReadableValue(tinyDate, this.innerflexibleDateGranularity, this.separator(), this.i18n.getLocale());
      } else {
        const start = tinyDate[0] ? this.formatDate(tinyDate[0]) : "";
        const end = tinyDate[1] ? this.formatDate(tinyDate[1]) : "";
        return start && end ? `${start}${this.separator()}${end}` : null;
      }
    } else {
      value = tinyDate;
      return value ? this.formatDate(value) : null;
    }
  }
  formatDate(value) {
    if (this.innerFormat && (this.innerFormat.includes("q") || this.innerFormat.includes("Q"))) {
      return value.format(this.innerFormat);
    } else {
      return this.dateHelper.format(value?.nativeDate, this.innerFormat);
    }
  }
  getPlaceholder() {
    return this.isRange() && this.placeholder() && Array.isArray(this.placeholder()) ? this.placeholder().join(this.separator()) : this.placeholder();
  }
  updateReadableDate(setValue) {
    const readableValue = this.getReadableValue(setValue);
    if (readableValue === this.pickerInput()?.nativeElement["value"]) {
      return;
    }
    this.pickerInput().nativeElement.value = readableValue;
  }
  static {
    this.\u0275fac = function ThyPicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyPicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyPicker,
      selectors: [["thy-picker"]],
      viewQuery: function ThyPicker_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.origin, _c8, 5)(ctx.cdkConnectedOverlay, CdkConnectedOverlay, 5)(ctx.pickerInput, _c9, 5)(ctx.overlayContainer, _c10, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance(4);
        }
      },
      inputs: {
        isRange: [1, "isRange"],
        opened: [1, "opened"],
        disabled: [1, "disabled"],
        placeholder: [1, "placeholder"],
        readonly: [1, "readonly"],
        allowClear: [1, "allowClear"],
        autoFocus: [1, "autoFocus"],
        className: [1, "className"],
        size: [1, "size"],
        suffixIcon: [1, "suffixIcon"],
        placement: [1, "placement"],
        flexible: [1, "flexible"],
        mode: [1, "mode"],
        hasBackdrop: [1, "hasBackdrop"],
        separator: [1, "separator"],
        timeZone: [1, "timeZone"],
        format: [1, "format"],
        flexibleDateGranularity: [1, "flexibleDateGranularity"],
        value: [1, "value"]
      },
      outputs: {
        blur: "blur",
        valueChange: "valueChange",
        openChange: "openChange",
        inputChange: "inputChange"
      },
      exportAs: ["thyPicker"],
      ngContentSelectors: _c11,
      decls: 9,
      vars: 27,
      consts: [["origin", "cdkOverlayOrigin"], ["pickerInput", ""], ["tplRightRest", ""], ["overlayContainer", ""], ["cdkOverlayOrigin", "", 3, "click"], ["thyInput", "", "thyEnter", "", 3, "blur", "input", "thyEnter", "ngClass", "thySize", "tabindex", "disabled", "readonly", "placeholder"], [4, "ngTemplateOutlet"], ["cdkConnectedOverlay", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", "cdkConnectedOverlayTransformOriginOn", ".thy-picker-container", 3, "positionChange", "backdropClick", "detach", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayHasBackdrop", "cdkConnectedOverlayPositions"], ["thyIconName", "close-circle-bold-fill", 3, "ngClass"], [3, "thyIconName", "ngClass"], ["thyIconName", "close-circle-bold-fill", 3, "click", "ngClass"], [1, "thy-picker-container", 2, "position", "relative"]],
      template: function ThyPicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275projectionDef();
          \u0275\u0275elementStart(0, "span", 4, 0);
          \u0275\u0275listener("click", function ThyPicker_Template_span_click_0_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onClickInputBox());
          });
          \u0275\u0275elementContainerStart(2);
          \u0275\u0275elementStart(3, "input", 5, 1);
          \u0275\u0275listener("blur", function ThyPicker_Template_input_blur_3_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("input", function ThyPicker_Template_input_input_3_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInput($event));
          })("thyEnter", function ThyPicker_Template_input_thyEnter_3_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onEnter());
          });
          \u0275\u0275elementEnd();
          \u0275\u0275template(5, ThyPicker_ng_container_5_Template, 1, 0, "ng-container", 6);
          \u0275\u0275elementContainerEnd();
          \u0275\u0275elementEnd();
          \u0275\u0275template(6, ThyPicker_ng_template_6_Template, 4, 10, "ng-template", null, 2, \u0275\u0275templateRefExtractor)(8, ThyPicker_ng_template_8_Template, 3, 3, "ng-template", 7);
          \u0275\u0275listener("positionChange", function ThyPicker_Template_ng_template_positionChange_8_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onPositionChange($event));
          })("backdropClick", function ThyPicker_Template_ng_template_backdropClick_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onClickBackdrop());
          })("detach", function ThyPicker_Template_ng_template_detach_8_listener() {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOverlayDetach());
          });
        }
        if (rf & 2) {
          const origin_r4 = \u0275\u0275reference(1);
          const tplRightRest_r5 = \u0275\u0275reference(7);
          \u0275\u0275classMap(\u0275\u0275interpolate3("", ctx.prefixCls, "-picker ", ctx.size() ? ctx.prefixCls + "-picker-" + ctx.size() : "", " ", ctx.className()));
          \u0275\u0275advance(3);
          \u0275\u0275classMap(\u0275\u0275interpolate2("form-control-", ctx.size(), " form-control ", ctx.prefixCls, "-picker-input"));
          \u0275\u0275classProp("thy-input-disabled", ctx.disabled())("thy-input-readonly", ctx.readonly());
          \u0275\u0275property("placeholder", \u0275\u0275interpolate(ctx.getPlaceholder()))("ngClass", \u0275\u0275pureFunction1(25, _c122, ctx.realOpenState))("thySize", ctx.size())("tabindex", -1)("disabled", ctx.disabled())("readonly", ctx.readonlyState);
          \u0275\u0275advance(2);
          \u0275\u0275property("ngTemplateOutlet", tplRightRest_r5);
          \u0275\u0275advance(3);
          \u0275\u0275property("cdkConnectedOverlayOrigin", origin_r4)("cdkConnectedOverlayOpen", ctx.realOpenState)("cdkConnectedOverlayHasBackdrop", ctx.hasBackdrop())("cdkConnectedOverlayPositions", ctx.overlayPositions);
        }
      },
      dependencies: [CdkOverlayOrigin, ThyInputDirective, ThyEnterDirective, NgTemplateOutlet, ThyIcon, NgClass, CdkConnectedOverlay],
      encapsulation: 2,
      data: {
        animation: [scaleXMotion, scaleYMotion, scaleMotion]
      },
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyPicker, [{
    type: Component,
    args: [{
      selector: "thy-picker",
      exportAs: "thyPicker",
      changeDetection: ChangeDetectionStrategy.OnPush,
      imports: [CdkOverlayOrigin, ThyInputDirective, ThyEnterDirective, NgTemplateOutlet, ThyIcon, NgClass, CdkConnectedOverlay],
      animations: [scaleXMotion, scaleYMotion, scaleMotion],
      template: `<span
  cdkOverlayOrigin
  #origin="cdkOverlayOrigin"
  class="{{ prefixCls }}-picker {{ size() ? prefixCls + '-picker-' + size() : '' }} {{ className() }}"
  (click)="onClickInputBox()">
  <ng-container>
    <input
      #pickerInput
      thyInput
      class="form-control-{{ size() }} form-control {{ prefixCls }}-picker-input"
      [ngClass]="{ 'panel-is-opened': realOpenState }"
      [thySize]="size()"
      [tabindex]="-1"
      [class.thy-input-disabled]="disabled()"
      [class.thy-input-readonly]="readonly()"
      [disabled]="disabled()"
      [readonly]="readonlyState"
      (blur)="onBlur($event)"
      (input)="onInput($event)"
      placeholder="{{ getPlaceholder() }}"
      thyEnter
      (thyEnter)="onEnter()" />
    <ng-container *ngTemplateOutlet="tplRightRest"></ng-container>
  </ng-container>
</span>

<!-- Right operator icons -->
<ng-template #tplRightRest>
  <span class="{{ prefixCls }}-picker-clear">
    @if (!disabled() && !isEmptyValue(value()) && allowClear() && !readonly()) {
      <thy-icon
        thyIconName="close-circle-bold-fill"
        (click)="onClickClear($event)"
        ngClass="remove-link remove-link-{{ size() }}"></thy-icon>
    }
  </span>
  <span class="{{ prefixCls }}-picker-icon">
    <thy-icon [thyIconName]="suffixIcon()" ngClass="remove-link-{{ size() ? size() : 'default' }}"></thy-icon>
  </span>
</ng-template>

<!-- Overlay -->
<ng-template
  cdkConnectedOverlay
  [cdkConnectedOverlayOrigin]="origin"
  [cdkConnectedOverlayOpen]="realOpenState"
  [cdkConnectedOverlayHasBackdrop]="hasBackdrop()"
  [cdkConnectedOverlayPositions]="overlayPositions"
  cdkConnectedOverlayBackdropClass="cdk-overlay-transparent-backdrop"
  cdkConnectedOverlayTransformOriginOn=".thy-picker-container"
  (positionChange)="onPositionChange($event)"
  (backdropClick)="onClickBackdrop()"
  (detach)="onOverlayDetach()">
  <div
    #overlayContainer
    style="position: relative"
    class="thy-picker-container"
    [@scaleXMotion]="placement() === 'left' || placement() === 'right' ? 'enter' : 'void'"
    [@scaleYMotion]="placement() === 'top' || placement() === 'bottom' ? 'enter' : 'void'"
    [@scaleMotion]="
      placement() !== 'left' && placement() !== 'right' && placement() !== 'top' && placement() !== 'bottom' ? 'enter' : 'void'
    ">
    <!-- Compatible for overlay that not support offset dynamically and immediately -->
    <ng-content></ng-content>
  </div>
</ng-template>
`
    }]
  }], () => [], {
    isRange: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "isRange",
        required: false
      }]
    }],
    opened: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "opened",
        required: false
      }]
    }],
    disabled: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "disabled",
        required: false
      }]
    }],
    placeholder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "placeholder",
        required: false
      }]
    }],
    readonly: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "readonly",
        required: false
      }]
    }],
    allowClear: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "allowClear",
        required: false
      }]
    }],
    autoFocus: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "autoFocus",
        required: false
      }]
    }],
    className: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "className",
        required: false
      }]
    }],
    size: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "size",
        required: false
      }]
    }],
    suffixIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "suffixIcon",
        required: false
      }]
    }],
    placement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "placement",
        required: false
      }]
    }],
    flexible: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "flexible",
        required: false
      }]
    }],
    mode: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "mode",
        required: false
      }]
    }],
    hasBackdrop: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "hasBackdrop",
        required: false
      }]
    }],
    separator: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "separator",
        required: false
      }]
    }],
    timeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "timeZone",
        required: false
      }]
    }],
    blur: [{
      type: Output,
      args: ["blur"]
    }],
    valueChange: [{
      type: Output,
      args: ["valueChange"]
    }],
    openChange: [{
      type: Output,
      args: ["openChange"]
    }],
    inputChange: [{
      type: Output,
      args: ["inputChange"]
    }],
    origin: [{
      type: ViewChild,
      args: ["origin", {
        isSignal: true
      }]
    }],
    cdkConnectedOverlay: [{
      type: ViewChild,
      args: [forwardRef(() => CdkConnectedOverlay), {
        isSignal: true
      }]
    }],
    pickerInput: [{
      type: ViewChild,
      args: ["pickerInput", {
        isSignal: true
      }]
    }],
    overlayContainer: [{
      type: ViewChild,
      args: ["overlayContainer", {
        isSignal: true
      }]
    }],
    format: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "format",
        required: false
      }]
    }],
    flexibleDateGranularity: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "flexibleDateGranularity",
        required: false
      }]
    }],
    value: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "value",
        required: false
      }]
    }]
  });
})();
var AbstractPickerComponent = class _AbstractPickerComponent extends TabIndexDisabledControlValueAccessorMixin {
  /**
   * 模式
   * @type decade | year | month | date | week | flexible
   */
  set thyMode(value) {
    this._panelMode = value ?? "date";
  }
  get thyMode() {
    return this._panelMode;
  }
  /**
   * 是否禁用
   * @default false
   */
  set thyDisabled(value) {
    this.disabled = value;
  }
  get thyDisabled() {
    return this.disabled;
  }
  get realOpenState() {
    return this.picker().realOpenState;
  }
  get isShowDatePopup() {
    return this.picker().isShowDatePopup;
  }
  initValue() {
    this.thyValue = this.isRange ? [] : null;
  }
  constructor() {
    super();
    this.destroyRef = inject(DestroyRef);
    this.cdr = inject(ChangeDetectorRef);
    this.locale = injectLocale("datePicker");
    this.thyValue = null;
    this._panelMode = "date";
    this.datePickerConfigService = inject(ThyDatePickerConfigService);
    this.thyAllowClear = input(true, ...ngDevMode ? [{
      debugName: "thyAllowClear",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyAutoFocus = input(false, ...ngDevMode ? [{
      debugName: "thyAutoFocus",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyOpen = input(void 0, ...ngDevMode ? [{
      debugName: "thyOpen",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.opened = linkedSignal(this.thyOpen, ...ngDevMode ? [{
      debugName: "opened"
    }] : []);
    this.thyDisabledDate = input(...ngDevMode ? [void 0, {
      debugName: "thyDisabledDate"
    }] : []);
    this.thyMinDate = input(...ngDevMode ? [void 0, {
      debugName: "thyMinDate"
    }] : []);
    this.thyMaxDate = input(...ngDevMode ? [void 0, {
      debugName: "thyMaxDate"
    }] : []);
    this.thyPlaceHolder = input(...ngDevMode ? [void 0, {
      debugName: "thyPlaceHolder"
    }] : []);
    this.placeholder = signal(void 0, ...ngDevMode ? [{
      debugName: "placeholder"
    }] : []);
    this.thyReadonly = input(false, ...ngDevMode ? [{
      debugName: "thyReadonly",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyOriginClassName = input(...ngDevMode ? [void 0, {
      debugName: "thyOriginClassName"
    }] : []);
    this.thyPanelClassName = input(...ngDevMode ? [void 0, {
      debugName: "thyPanelClassName"
    }] : []);
    this.thySize = input("default", ...ngDevMode ? [{
      debugName: "thySize"
    }] : []);
    this.thyTimestampPrecision = input(this.datePickerConfigService.config?.timestampPrecision || "seconds", ...ngDevMode ? [{
      debugName: "thyTimestampPrecision"
    }] : []);
    this.thyFormat = model(...ngDevMode ? [void 0, {
      debugName: "thyFormat"
    }] : []);
    this.thySeparator = input(this.datePickerConfigService.config?.separator, ...ngDevMode ? [{
      debugName: "thySeparator"
    }] : []);
    this.separator = computed(() => {
      return ` ${this.thySeparator()?.trim()} `;
    }, ...ngDevMode ? [{
      debugName: "separator"
    }] : []);
    this.thyAutoStartAndEnd = input(false, ...ngDevMode ? [{
      debugName: "thyAutoStartAndEnd",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyDefaultPickerValue = input(null, ...ngDevMode ? [{
      debugName: "thyDefaultPickerValue"
    }] : []);
    this.thySuffixIcon = input("calendar", ...ngDevMode ? [{
      debugName: "thySuffixIcon"
    }] : []);
    this.thyShowShortcut = input(void 0, ...ngDevMode ? [{
      debugName: "thyShowShortcut",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.thyShortcutPosition = input("left", ...ngDevMode ? [{
      debugName: "thyShortcutPosition",
      transform: (value) => value || "left"
    }] : [{
      transform: (value) => value || "left"
    }]);
    this.thyShortcutPresets = input(...ngDevMode ? [void 0, {
      debugName: "thyShortcutPresets"
    }] : []);
    this.thyShowTime = input(false, ...ngDevMode ? [{
      debugName: "thyShowTime",
      transform: (value) => typeof value === "object" ? value : coerceBooleanProperty2(value)
    }] : [{
      transform: (value) => typeof value === "object" ? value : coerceBooleanProperty2(value)
    }]);
    this.thyMustShowTime = input(false, ...ngDevMode ? [{
      debugName: "thyMustShowTime",
      transform: coerceBooleanProperty2
    }] : [{
      transform: coerceBooleanProperty2
    }]);
    this.showWeek = computed(() => this.thyMode === "week", ...ngDevMode ? [{
      debugName: "showWeek"
    }] : []);
    this.flexible = computed(() => this.thyMode === "flexible", ...ngDevMode ? [{
      debugName: "flexible"
    }] : []);
    this.thyDateChange = output();
    this.thyOpenChange = output();
    this.picker = viewChild.required(ThyPicker);
    this.thyTimeZone = input(...ngDevMode ? [void 0, {
      debugName: "thyTimeZone"
    }] : []);
    this.disabled = false;
    this.isCustomPlaceHolder = false;
    this.onlyEmitDate = false;
    this.onChangeFn = () => void 0;
    effect(() => {
      if (this.isCustomPlaceHolder) {
        this.placeholder.set(this.thyPlaceHolder());
      }
    });
    effect(() => {
      if (this.thyTimeZone()) {
        this.setValue(this.innerValue);
      }
    });
  }
  ngOnInit() {
    this.setDefaultPlaceHolder();
    this.setDefaultTimePickerState();
    this.initValue();
  }
  onDateValueChange(event) {
    this.thyDateChange.emit(event);
  }
  ngOnChanges(changes) {
    if (changes.thyPlaceHolder && changes.thyPlaceHolder.firstChange && typeof changes.thyPlaceHolder.currentValue !== "undefined") {
      this.isCustomPlaceHolder = true;
    }
  }
  closeOverlay() {
    this.picker().hideOverlay();
  }
  getAutoStartAndEndValue(begin, end) {
    let value;
    switch (this.thyMode) {
      case "date":
        value = {
          begin: begin.startOfDay().getUnixTime(),
          end: end.endOfDay().getUnixTime()
        };
        break;
      case "week":
        value = {
          begin: begin.startOfWeek().getUnixTime(),
          end: end.endOfWeek().getUnixTime()
        };
        break;
      case "month":
        value = {
          begin: begin.startOfMonth().getUnixTime(),
          end: end.endOfMonth().getUnixTime()
        };
        break;
      case "year":
        value = {
          begin: begin.startOfYear().getUnixTime(),
          end: end.endOfYear().getUnixTime()
        };
        break;
      default:
        value = {
          begin: begin.startOfDay().getUnixTime(),
          end: end.endOfDay().getUnixTime()
        };
        break;
    }
    return value;
  }
  onValueChange(originalValue) {
    this.setFormatRule();
    const {
      value,
      flexibleDateGranularity
    } = transformDateValue(originalValue);
    this.flexibleDateGranularity = flexibleDateGranularity;
    this.setValue(value);
    if (this.isRange) {
      const vAsRange = this.thyValue;
      let value2 = {
        begin: null,
        end: null
      };
      if (vAsRange.length) {
        const [begin, end] = vAsRange;
        if (this.thyAutoStartAndEnd()) {
          value2 = this.getAutoStartAndEndValue(begin, end);
        } else {
          value2 = {
            begin: begin.getUnixTime(),
            end: end.getUnixTime()
          };
        }
      }
      const [beginUnixTime, endUnixTime] = this.setValueByPrecision(value2);
      this.onChangeFn(Object.assign({
        begin: beginUnixTime,
        end: endUnixTime
      }, this.flexible() ? {
        granularity: flexibleDateGranularity
      } : {}));
    } else {
      const value2 = {
        date: null,
        with_time: this.withTime ? 1 : 0
      };
      if (this.thyValue) {
        value2.date = this.thyValue.getUnixTime();
      }
      if (this.onlyEmitDate) {
        this.onChangeFn(this.setValueByPrecision(value2.date));
      } else {
        this.onChangeFn(Object.assign(value2, {
          date: this.setValueByPrecision(value2.date)
        }));
      }
    }
  }
  setFormatRule() {
    if (!this.thyFormat()) {
      if (this.withTime) {
        this.thyFormat.set("yyyy-MM-dd HH:mm");
      } else {
        if (!this.onlyEmitDate) {
          this.thyFormat.set("yyyy-MM-dd");
        }
      }
    }
  }
  onOpenChange(open) {
    this.opened.set(open);
    this.thyOpenChange.emit(open);
  }
  writeValue(originalValue) {
    const {
      value,
      withTime,
      flexibleDateGranularity
    } = transformDateValue(originalValue);
    this.flexibleDateGranularity = flexibleDateGranularity;
    this.innerValue = value;
    if (this.flexible() && value && value.length) {
      if (!this.flexibleDateGranularity) {
        this.flexibleDateGranularity = "day";
      }
    }
    this.onlyEmitDate = typeof withTime === "undefined";
    this.setTimePickerState(this.onlyEmitDate ? !!(value && !!this.thyShowTime()) : !!withTime);
    this.setValue(value);
    this.setFormatRule();
    this.cdr.markForCheck();
  }
  setTimePickerState(withTime) {
    this.withTime = !!withTime;
  }
  // Displays the time directly when the time must be displayed by default
  setDefaultTimePickerState() {
    this.withTime = this.thyMustShowTime();
  }
  // Restore after clearing time to select whether the original picker time is displayed or not
  restoreTimePickerState(value) {
    if (!value) {
      this.withTime = this.thyMustShowTime();
    } else if (this.onlyEmitDate) {
      this.withTime = !!this.thyShowTime();
    }
  }
  setPanelMode() {
    const mode = this.thyMode ?? "date";
    if (this.isRange) {
      this.panelMode = this.flexible() ? ["date", "date"] : [mode, mode];
    } else {
      this.panelMode = mode;
    }
  }
  setDisabledState(disabled) {
    this.thyDisabled = disabled;
    this.cdr.markForCheck();
  }
  setDefaultPlaceHolder() {
    if (!this.isCustomPlaceHolder) {
      const placeholder = this.isRange ? [this.locale().startDate, this.locale().endDate] : this.locale().placeholder;
      this.placeholder.set(placeholder);
    }
  }
  setValue(value) {
    this.thyValue = makeValue(value, this.isRange, this.withTime, this.thyTimeZone());
  }
  setValueByPrecision(value) {
    return setValueByTimestampPrecision(value, this.isRange, this.thyTimestampPrecision(), this.thyTimeZone());
  }
  static {
    this.\u0275fac = function AbstractPickerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AbstractPickerComponent)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _AbstractPickerComponent,
      viewQuery: function AbstractPickerComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.picker, ThyPicker, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      inputs: {
        thyMode: "thyMode",
        thyAllowClear: [1, "thyAllowClear"],
        thyAutoFocus: [1, "thyAutoFocus"],
        thyOpen: [1, "thyOpen"],
        thyDisabledDate: [1, "thyDisabledDate"],
        thyMinDate: [1, "thyMinDate"],
        thyMaxDate: [1, "thyMaxDate"],
        thyPlaceHolder: [1, "thyPlaceHolder"],
        thyReadonly: [1, "thyReadonly"],
        thyOriginClassName: [1, "thyOriginClassName"],
        thyPanelClassName: [1, "thyPanelClassName"],
        thySize: [1, "thySize"],
        thyTimestampPrecision: [1, "thyTimestampPrecision"],
        thyFormat: [1, "thyFormat"],
        thySeparator: [1, "thySeparator"],
        thyAutoStartAndEnd: [1, "thyAutoStartAndEnd"],
        thyDefaultPickerValue: [1, "thyDefaultPickerValue"],
        thySuffixIcon: [1, "thySuffixIcon"],
        thyShowShortcut: [1, "thyShowShortcut"],
        thyShortcutPosition: [1, "thyShortcutPosition"],
        thyShortcutPresets: [1, "thyShortcutPresets"],
        thyShowTime: [1, "thyShowTime"],
        thyMustShowTime: [1, "thyMustShowTime"],
        thyDisabled: [2, "thyDisabled", "thyDisabled", coerceBooleanProperty2],
        thyTimeZone: [1, "thyTimeZone"]
      },
      outputs: {
        thyFormat: "thyFormatChange",
        thyDateChange: "thyDateChange",
        thyOpenChange: "thyOpenChange"
      },
      features: [\u0275\u0275InheritDefinitionFeature, \u0275\u0275NgOnChangesFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AbstractPickerComponent, [{
    type: Directive
  }], () => [], {
    thyMode: [{
      type: Input
    }],
    thyAllowClear: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAllowClear",
        required: false
      }]
    }],
    thyAutoFocus: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutoFocus",
        required: false
      }]
    }],
    thyOpen: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyOpen",
        required: false
      }]
    }],
    thyDisabledDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDisabledDate",
        required: false
      }]
    }],
    thyMinDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMinDate",
        required: false
      }]
    }],
    thyMaxDate: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMaxDate",
        required: false
      }]
    }],
    thyPlaceHolder: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlaceHolder",
        required: false
      }]
    }],
    thyReadonly: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyReadonly",
        required: false
      }]
    }],
    thyOriginClassName: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyOriginClassName",
        required: false
      }]
    }],
    thyPanelClassName: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPanelClassName",
        required: false
      }]
    }],
    thySize: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySize",
        required: false
      }]
    }],
    thyTimestampPrecision: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTimestampPrecision",
        required: false
      }]
    }],
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }, {
      type: Output,
      args: ["thyFormatChange"]
    }],
    thySeparator: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySeparator",
        required: false
      }]
    }],
    thyAutoStartAndEnd: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyAutoStartAndEnd",
        required: false
      }]
    }],
    thyDefaultPickerValue: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDefaultPickerValue",
        required: false
      }]
    }],
    thySuffixIcon: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thySuffixIcon",
        required: false
      }]
    }],
    thyShowShortcut: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowShortcut",
        required: false
      }]
    }],
    thyShortcutPosition: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShortcutPosition",
        required: false
      }]
    }],
    thyShortcutPresets: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShortcutPresets",
        required: false
      }]
    }],
    thyShowTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyShowTime",
        required: false
      }]
    }],
    thyMustShowTime: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyMustShowTime",
        required: false
      }]
    }],
    thyDateChange: [{
      type: Output,
      args: ["thyDateChange"]
    }],
    thyOpenChange: [{
      type: Output,
      args: ["thyOpenChange"]
    }],
    picker: [{
      type: ViewChild,
      args: [forwardRef(() => ThyPicker), {
        isSignal: true
      }]
    }],
    thyDisabled: [{
      type: Input,
      args: [{
        transform: coerceBooleanProperty2
      }]
    }],
    thyTimeZone: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyTimeZone",
        required: false
      }]
    }]
  });
})();
var BasePicker = class _BasePicker extends AbstractPickerComponent {
  constructor() {
    super(...arguments);
    this.element = inject(ElementRef);
    this.innerPreviousDate = null;
    this.thyPicker = viewChild.required("thyPicker");
    this.thyDateRender = input(...ngDevMode ? [void 0, {
      debugName: "thyDateRender"
    }] : []);
    this.thyHasBackdrop = input(true, ...ngDevMode ? [{
      debugName: "thyHasBackdrop",
      transform: coerceBooleanProperty
    }] : [{
      transform: coerceBooleanProperty
    }]);
    this.thyPlacement = input("bottomLeft", ...ngDevMode ? [{
      debugName: "thyPlacement"
    }] : []);
    this.thyOnPanelChange = output();
    this.thyOnCalendarChange = output();
    this.thyOnOk = output();
    this.thyClickDispatcher = inject(ThyClickDispatcher);
    this.platformId = inject(PLATFORM_ID);
    this.ngZone = inject(NgZone);
  }
  set thyMode(value) {
    this._panelMode = value ?? "date";
    if (this.initialized) {
      this.setPanelMode();
      this.setFormat();
    }
  }
  get thyMode() {
    return this._panelMode;
  }
  open() {
    this.thyPicker().focus();
    this.thyPicker().onClickInputBox();
  }
  ngOnInit() {
    super.ngOnInit();
    this.setPanelMode();
    this.setFormat();
    this.initialized = true;
    if (isPlatformBrowser(this.platformId)) {
      this.thyClickDispatcher.clicked(0).pipe(takeUntilDestroyed(this.destroyRef)).subscribe((event) => {
        if (!this.element.nativeElement.contains(event.target) && !this.thyPicker()?.overlayContainer()?.nativeElement.contains(event.target) && this.realOpenState) {
          this.ngZone.run(() => {
            this.closeOverlay();
            this.cdr.markForCheck();
          });
        }
      });
    }
  }
  onValueChange(value) {
    this.thyPicker().entering = false;
    this.restoreTimePickerState(value);
    super.onValueChange(value);
    if (!this.flexible()) {
      this.closeOverlay();
    }
    this.innerPreviousDate = this.thyPicker().getReadableValue(this.thyValue);
  }
  onInputValueChange(formatDate2) {
    if (!formatDate2 || !formatDate2.length) {
      const compatibleValue = formatDate2 ? formatDate2 : null;
      this.restoreTimePickerState(compatibleValue);
      super.onValueChange(compatibleValue);
      return;
    }
    let value = formatDate2;
    const valueValid = isValidStringDate(value, this.thyTimeZone());
    const valueLimitValid = valueValid ? this.isValidDateLimit(parseStringDate(value, this.thyTimeZone())) : false;
    if (valueValid && valueLimitValid) {
      this.innerPreviousDate = value;
    } else {
      value = this.innerPreviousDate;
    }
    const tinyDate = value ? this.thyShowTime() ? parseStringDate(value, this.thyTimeZone()) : parseStringDate(value, this.thyTimeZone()).startOfDay() : null;
    this.restoreTimePickerState(tinyDate);
    super.onValueChange(tinyDate);
  }
  setFormat() {
    if (!this.thyFormat()) {
      const inputFormats = {
        year: "yyyy",
        quarter: `yyyy-${QUARTER_FORMAT}`,
        month: "yyyy-MM",
        week: this.locale().weekThFormat,
        date: this.thyShowTime() ? "yyyy-MM-dd HH:mm" : "yyyy-MM-dd"
      };
      this.thyFormat.set(this.flexible() ? inputFormats["date"] : inputFormats[this.thyMode]);
    }
  }
  // Emit thyOnCalendarChange when select date by thy-range-picker
  onCalendarChange(value) {
    if (this.isRange) {
      const rangeValue = value.map((x) => x.nativeDate);
      this.thyOnCalendarChange.emit(rangeValue);
    }
  }
  onShowTimePickerChange(show) {
    this.withTime = show;
  }
  onResultOk() {
    if (this.isRange) {
      const value = this.thyValue;
      if (value.length) {
        this.thyOnOk.emit([value[0].nativeDate, value[1].nativeDate]);
      } else {
        this.thyOnOk.emit([]);
      }
    } else {
      if (this.thyValue) {
        this.thyOnOk.emit(this.thyValue.nativeDate);
      } else {
        this.thyOnOk.emit(null);
      }
    }
    this.closeOverlay();
  }
  onOpenChange(open) {
    this.thyOpenChange.emit(open);
    if (!open) {
      this.onTouchedFn();
    }
  }
  onFocus(event) {
    this.picker().focus();
  }
  onBlur(event) {
    if (elementMatchClosest(event?.relatedTarget, ["date-popup", "thy-picker"])) {
      return;
    }
    this.onTouchedFn();
  }
  onInputDate(value) {
    if (value && isValidStringDate(value, this.thyTimeZone())) {
      if (this.thyShowTime()) {
        this.withTime = hasTimeInStringDate2(value, this.thyTimeZone());
      }
      this.thyValue = parseStringDate(value, this.thyTimeZone());
    }
  }
  isValidDateLimit(date) {
    let disable = false;
    if (this.thyDisabledDate() !== void 0) {
      disable = this.thyDisabledDate()(date.nativeDate);
    }
    const minDate = this.thyMinDate() ? new TinyDate(transformDateValue(this.thyMinDate()).value, this.thyTimeZone()) : null;
    const maxDate = this.thyMaxDate() ? new TinyDate(transformDateValue(this.thyMaxDate()).value, this.thyTimeZone()) : null;
    return (!minDate || date.startOfDay().nativeDate >= minDate.startOfDay().nativeDate) && (!maxDate || date.startOfDay().nativeDate <= maxDate.startOfDay().nativeDate) && !disable;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275BasePicker_BaseFactory;
      return function BasePicker_Factory(__ngFactoryType__) {
        return (\u0275BasePicker_BaseFactory || (\u0275BasePicker_BaseFactory = \u0275\u0275getInheritedFactory(_BasePicker)))(__ngFactoryType__ || _BasePicker);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _BasePicker,
      selectors: [["ng-component"]],
      viewQuery: function BasePicker_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.thyPicker, _c132, 5);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostVars: 1,
      hostBindings: function BasePicker_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("focus", function BasePicker_focus_HostBindingHandler($event) {
            return ctx.onFocus($event);
          })("blur", function BasePicker_blur_HostBindingHandler($event) {
            return ctx.onBlur($event);
          });
        }
        if (rf & 2) {
          \u0275\u0275attribute("tabindex", ctx.tabIndex);
        }
      },
      inputs: {
        thyDateRender: [1, "thyDateRender"],
        thyMode: "thyMode",
        thyHasBackdrop: [1, "thyHasBackdrop"],
        thyPlacement: [1, "thyPlacement"]
      },
      outputs: {
        thyOnPanelChange: "thyOnPanelChange",
        thyOnCalendarChange: "thyOnCalendarChange",
        thyOnOk: "thyOnOk"
      },
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 0,
      vars: 0,
      template: function BasePicker_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BasePicker, [{
    type: Component,
    args: [{
      template: ``,
      host: {
        "[attr.tabindex]": `tabIndex`,
        "(focus)": "onFocus($event)",
        "(blur)": "onBlur($event)"
      }
    }]
  }], null, {
    thyPicker: [{
      type: ViewChild,
      args: ["thyPicker", {
        isSignal: true
      }]
    }],
    thyDateRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDateRender",
        required: false
      }]
    }],
    thyMode: [{
      type: Input
    }],
    thyHasBackdrop: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHasBackdrop",
        required: false
      }]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlacement",
        required: false
      }]
    }],
    thyOnPanelChange: [{
      type: Output,
      args: ["thyOnPanelChange"]
    }],
    thyOnCalendarChange: [{
      type: Output,
      args: ["thyOnCalendarChange"]
    }],
    thyOnOk: [{
      type: Output,
      args: ["thyOnOk"]
    }]
  });
})();
var ThyDatePicker = class _ThyDatePicker extends BasePicker {
  constructor() {
    super();
    this.isRange = false;
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
  }
  static {
    this.\u0275fac = function ThyDatePicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDatePicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyDatePicker,
      selectors: [["thy-date-picker"]],
      hostVars: 1,
      hostBindings: function ThyDatePicker_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275attribute("tabindex", ctx.tabIndex);
        }
      },
      exportAs: ["thyDatePicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyDatePicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyDatePicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyDatePicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyDatePicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyDatePicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyDatePicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyDatePicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-date-picker",
      exportAs: "thyDatePicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyDatePicker)
      }],
      imports: [ThyPicker, DatePopup],
      host: {
        "[attr.tabindex]": "tabIndex"
      },
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], null);
})();
var ThyMonthPicker = class _ThyMonthPicker extends BasePicker {
  constructor() {
    super();
    this.thyFormat = model("yyyy-MM", ...ngDevMode ? [{
      debugName: "thyFormat"
    }] : []);
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
    this.thyMode = "month";
  }
  static {
    this.\u0275fac = function ThyMonthPicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyMonthPicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyMonthPicker,
      selectors: [["thy-month-picker"]],
      inputs: {
        thyFormat: [1, "thyFormat"]
      },
      outputs: {
        thyFormat: "thyFormatChange"
      },
      exportAs: ["thyMonthPicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyMonthPicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyMonthPicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyMonthPicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyMonthPicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyMonthPicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyMonthPicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyMonthPicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyMonthPicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-month-picker",
      exportAs: "thyMonthPicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyMonthPicker)
      }],
      imports: [ThyPicker, DatePopup],
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], {
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }, {
      type: Output,
      args: ["thyFormatChange"]
    }]
  });
})();
var ThyRangePicker = class _ThyRangePicker extends BasePicker {
  constructor() {
    super();
    this.isRange = true;
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
  }
  static {
    this.\u0275fac = function ThyRangePicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyRangePicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyRangePicker,
      selectors: [["thy-range-picker"]],
      exportAs: ["thyRangePicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyRangePicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyRangePicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyRangePicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyRangePicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyRangePicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyRangePicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyRangePicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyRangePicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-range-picker",
      exportAs: "thyRangePicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyRangePicker)
      }],
      imports: [ThyPicker, DatePopup],
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], null);
})();
var ThyWeekPicker = class _ThyWeekPicker extends BasePicker {
  constructor() {
    super();
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
    this.thyMode = "week";
  }
  static {
    this.\u0275fac = function ThyWeekPicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyWeekPicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyWeekPicker,
      selectors: [["thy-week-picker"]],
      exportAs: ["thyWeekPicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyWeekPicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyWeekPicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyWeekPicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyWeekPicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyWeekPicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyWeekPicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyWeekPicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyWeekPicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-week-picker",
      exportAs: "thyWeekPicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyWeekPicker)
      }],
      imports: [ThyPicker, DatePopup],
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], null);
})();
var ThyYearPicker = class _ThyYearPicker extends BasePicker {
  constructor() {
    super();
    this.thyFormat = model("yyyy", ...ngDevMode ? [{
      debugName: "thyFormat"
    }] : []);
    this.isRange = false;
    this.endPanelMode = "year";
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
    this.thyMode = "year";
  }
  static {
    this.\u0275fac = function ThyYearPicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyYearPicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyYearPicker,
      selectors: [["thy-year-picker"]],
      inputs: {
        thyFormat: [1, "thyFormat"]
      },
      outputs: {
        thyFormat: "thyFormatChange"
      },
      exportAs: ["thyYearPicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyYearPicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyYearPicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyYearPicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyYearPicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyYearPicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyYearPicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyYearPicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyYearPicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-year-picker",
      exportAs: "thyYearPicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyYearPicker)
      }],
      imports: [ThyPicker, DatePopup],
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], {
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }, {
      type: Output,
      args: ["thyFormatChange"]
    }]
  });
})();
var DATE_PICKER_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => DatePickerRequiredValidator),
  multi: true
};
var DatePickerRequiredValidator = class _DatePickerRequiredValidator {
  constructor() {
    this.required = input(false, ...ngDevMode ? [{
      debugName: "required",
      transform: (value) => {
        return value != null && value !== false && `${value}` !== "false";
      }
    }] : [{
      transform: (value) => {
        return value != null && value !== false && `${value}` !== "false";
      }
    }]);
  }
  validate(control) {
    return this.required() ? this.validateRequired(control) : null;
  }
  validateRequired(control) {
    return isEmptyInputDateValue(control.value) ? {
      required: true
    } : null;
  }
  static {
    this.\u0275fac = function DatePickerRequiredValidator_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DatePickerRequiredValidator)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _DatePickerRequiredValidator,
      selectors: [["", "thyDatePicker", "", "required", "", "formControlName", ""], ["", "thyDatePicker", "", "required", "", "formControl", ""], ["", "thyDatePicker", "", "required", "", "ngModel", ""], ["thy-date-picker", "required", "", "formControlName", ""], ["thy-date-picker", "required", "", "formControl", ""], ["thy-date-picker", "required", "", "ngModel", ""]],
      inputs: {
        required: [1, "required"]
      },
      features: [\u0275\u0275ProvidersFeature([DATE_PICKER_REQUIRED_VALIDATOR])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DatePickerRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "[thyDatePicker][required][formControlName],[thyDatePicker][required][formControl],[thyDatePicker][required][ngModel],thy-date-picker[required][formControlName],thy-date-picker[required][formControl],thy-date-picker[required][ngModel]",
      providers: [DATE_PICKER_REQUIRED_VALIDATOR]
    }]
  }], null, {
    required: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "required",
        required: false
      }]
    }]
  });
})();
var RANGE_PICKER_REQUIRED_VALIDATOR = {
  provide: NG_VALIDATORS,
  useExisting: forwardRef(() => RangePickerRequiredValidator),
  multi: true
};
var RangePickerRequiredValidator = class _RangePickerRequiredValidator {
  constructor() {
    this.required = input(false, ...ngDevMode ? [{
      debugName: "required",
      transform: (value) => {
        return value != null && value !== false && `${value}` !== "false";
      }
    }] : [{
      transform: (value) => {
        return value != null && value !== false && `${value}` !== "false";
      }
    }]);
  }
  validate(control) {
    return this.required() ? this.validateRequired(control) : null;
  }
  validateRequired(control) {
    return isEmptyInputRangeValue(control.value) ? {
      required: true
    } : null;
  }
  static {
    this.\u0275fac = function RangePickerRequiredValidator_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _RangePickerRequiredValidator)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _RangePickerRequiredValidator,
      selectors: [["", "thyRangePicker", "", "required", "", "formControlName", ""], ["", "thyRangePicker", "", "required", "", "formControl", ""], ["", "thyRangePicker", "", "required", "", "ngModel", ""], ["thy-range-picker", "required", "", "formControlName", ""], ["thy-range-picker", "required", "", "formControl", ""], ["thy-range-picker", "required", "", "ngModel", ""]],
      inputs: {
        required: [1, "required"]
      },
      features: [\u0275\u0275ProvidersFeature([RANGE_PICKER_REQUIRED_VALIDATOR])]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RangePickerRequiredValidator, [{
    type: Directive,
    args: [{
      selector: "[thyRangePicker][required][formControlName],[thyRangePicker][required][formControl],[thyRangePicker][required][ngModel],thy-range-picker[required][formControlName],thy-range-picker[required][formControl],thy-range-picker[required][ngModel]",
      providers: [RANGE_PICKER_REQUIRED_VALIDATOR]
    }]
  }], null, {
    required: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "required",
        required: false
      }]
    }]
  });
})();
function isEmptyInputRangeValue(value) {
  return value == null || instanceOfRangeEntry(value) && (value.begin == null || value.end == null);
}
function isEmptyInputDateValue(value) {
  return value == null || instanceOfDateEntry(value) && value.date == null;
}
var PickerDirective = class _PickerDirective extends AbstractPickerComponent {
  constructor() {
    super(...arguments);
    this.elementRef = inject(ElementRef);
    this.cdr = inject(ChangeDetectorRef);
    this.thyPopover = inject(ThyPopover);
    this.thyDateRender = input(...ngDevMode ? [void 0, {
      debugName: "thyDateRender"
    }] : []);
    this.thyOnPanelChange = output();
    this.thyOnCalendarChange = output();
    this.thyPlacement = input("bottom", ...ngDevMode ? [{
      debugName: "thyPlacement"
    }] : []);
    this.thyOffset = input(4, ...ngDevMode ? [{
      debugName: "thyOffset",
      transform: (value) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          warnDeprecation(`thyOffset parameter will be deprecated, please use thyPopoverOptions instead.`);
        }
        return numberAttribute(value);
      }
    }] : [{
      transform: (value) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          warnDeprecation(`thyOffset parameter will be deprecated, please use thyPopoverOptions instead.`);
        }
        return numberAttribute(value);
      }
    }]);
    this.thyHasBackdrop = input(true, ...ngDevMode ? [{
      debugName: "thyHasBackdrop",
      transform: (value) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          warnDeprecation(`thyOffset parameter will be deprecated, please use thyPopoverOptions instead.`);
        }
        return coerceBooleanProperty(value);
      }
    }] : [{
      transform: (value) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          warnDeprecation(`thyOffset parameter will be deprecated, please use thyPopoverOptions instead.`);
        }
        return coerceBooleanProperty(value);
      }
    }]);
    this.thyPopoverOptions = input(...ngDevMode ? [void 0, {
      debugName: "thyPopoverOptions"
    }] : []);
    this.thyStopPropagation = input(true, ...ngDevMode ? [{
      debugName: "thyStopPropagation",
      transform: coerceBooleanProperty
    }] : [{
      transform: coerceBooleanProperty
    }]);
    this.el = this.elementRef.nativeElement;
    this.$click = fromEvent(this.el, "click").pipe(tap((e) => {
      if (this.thyStopPropagation()) {
        e.stopPropagation();
      }
    }), mapTo(true));
  }
  ngOnInit() {
    this.setPanelMode();
  }
  openOverlay() {
    this.setPanelMode();
    const popoverRef = this.thyPopover.open(DatePopup, Object.assign({
      origin: this.el,
      hasBackdrop: this.thyHasBackdrop(),
      backdropClass: "thy-overlay-transparent-backdrop",
      offset: this.thyOffset(),
      outsideClosable: true,
      initialState: {
        isRange: this.isRange,
        panelMode: this.panelMode,
        showWeek: this.showWeek(),
        value: this.thyValue,
        showTime: this.thyShowTime(),
        mustShowTime: this.withTime,
        format: this.thyFormat(),
        dateRender: this.thyDateRender(),
        disabledDate: this.thyDisabledDate(),
        placeholder: this.placeholder(),
        className: this.thyPanelClassName(),
        defaultPickerValue: this.thyDefaultPickerValue(),
        minDate: this.thyMinDate(),
        maxDate: this.thyMaxDate(),
        showShortcut: this.thyShowShortcut(),
        shortcutPresets: this.thyShortcutPresets(),
        shortcutPosition: this.thyShortcutPosition(),
        flexible: this.flexible(),
        flexibleDateGranularity: this.flexibleDateGranularity,
        timestampPrecision: this.thyTimestampPrecision()
      },
      placement: this.thyPlacement()
    }, this.thyPopoverOptions()));
    if (popoverRef) {
      const componentInstance = popoverRef.componentInstance;
      if (this.valueChangeSubscription) {
        this.valueChangeSubscription.unsubscribe();
      }
      this.valueChangeSubscription = componentInstance.valueChange?.subscribe((event) => this.onValueChange(event));
      if (this.calendarChangeSubscription) {
        this.calendarChangeSubscription.unsubscribe();
      }
      this.calendarChangeSubscription = componentInstance?.calendarChange?.subscribe((event) => {
        const rangeValue = coerceArray(event).map((x) => x.nativeDate);
        this.thyOnCalendarChange.emit(rangeValue);
      });
      if (this.showTimePickerChangeSubscription) {
        this.showTimePickerChangeSubscription.unsubscribe();
      }
      this.showTimePickerChangeSubscription = componentInstance?.showTimePickerChange?.subscribe((event) => this.onShowTimePickerChange(event));
      componentInstance?.ngOnChanges({
        value: {}
      });
      if (this.dateValueChangeSubscription) {
        this.dateValueChangeSubscription.unsubscribe();
      }
      this.dateValueChangeSubscription = componentInstance?.dateValueChange?.subscribe((event) => {
        this.thyDateChange.emit(event);
      });
      popoverRef.afterOpened().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.thyOpenChange.emit(true));
      popoverRef.afterClosed().pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this.thyOpenChange.emit(false));
    }
  }
  closeOverlay() {
    this.thyPopover.close();
  }
  initActionSubscribe() {
    this.$click.pipe(debounceTime(50), takeUntilDestroyed(this.destroyRef)).subscribe(() => {
      if (!this.thyDisabled && !this.thyReadonly()) {
        this.openOverlay();
      }
    });
  }
  ngAfterViewInit() {
    this.initActionSubscribe();
  }
  ngOnDestroy() {
    if (this.valueChangeSubscription) {
      this.valueChangeSubscription.unsubscribe();
    }
    if (this.calendarChangeSubscription) {
      this.calendarChangeSubscription.unsubscribe();
    }
    if (this.showTimePickerChangeSubscription) {
      this.showTimePickerChangeSubscription.unsubscribe();
    }
    if (this.dateValueChangeSubscription) {
      this.dateValueChangeSubscription.unsubscribe();
    }
  }
  onValueChange(value) {
    this.restoreTimePickerState(value);
    super.onValueChange(value);
    if (!this.flexible()) {
      this.closeOverlay();
    }
  }
  onShowTimePickerChange(show) {
    this.withTime = show;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275PickerDirective_BaseFactory;
      return function PickerDirective_Factory(__ngFactoryType__) {
        return (\u0275PickerDirective_BaseFactory || (\u0275PickerDirective_BaseFactory = \u0275\u0275getInheritedFactory(_PickerDirective)))(__ngFactoryType__ || _PickerDirective);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _PickerDirective,
      inputs: {
        thyDateRender: [1, "thyDateRender"],
        thyPlacement: [1, "thyPlacement"],
        thyOffset: [1, "thyOffset"],
        thyHasBackdrop: [1, "thyHasBackdrop"],
        thyPopoverOptions: [1, "thyPopoverOptions"],
        thyStopPropagation: [1, "thyStopPropagation"]
      },
      outputs: {
        thyOnPanelChange: "thyOnPanelChange",
        thyOnCalendarChange: "thyOnCalendarChange"
      },
      features: [\u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PickerDirective, [{
    type: Directive
  }], null, {
    thyDateRender: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyDateRender",
        required: false
      }]
    }],
    thyOnPanelChange: [{
      type: Output,
      args: ["thyOnPanelChange"]
    }],
    thyOnCalendarChange: [{
      type: Output,
      args: ["thyOnCalendarChange"]
    }],
    thyPlacement: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPlacement",
        required: false
      }]
    }],
    thyOffset: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyOffset",
        required: false
      }]
    }],
    thyHasBackdrop: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyHasBackdrop",
        required: false
      }]
    }],
    thyPopoverOptions: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyPopoverOptions",
        required: false
      }]
    }],
    thyStopPropagation: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyStopPropagation",
        required: false
      }]
    }]
  });
})();
var ThyDatePickerDirective = class _ThyDatePickerDirective extends PickerDirective {
  constructor() {
    super(...arguments);
    this.isRange = false;
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275ThyDatePickerDirective_BaseFactory;
      return function ThyDatePickerDirective_Factory(__ngFactoryType__) {
        return (\u0275ThyDatePickerDirective_BaseFactory || (\u0275ThyDatePickerDirective_BaseFactory = \u0275\u0275getInheritedFactory(_ThyDatePickerDirective)))(__ngFactoryType__ || _ThyDatePickerDirective);
      };
    })();
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyDatePickerDirective,
      selectors: [["", "thyDatePicker", ""]],
      exportAs: ["thyDatePicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyDatePickerDirective)
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePickerDirective, [{
    type: Directive,
    args: [{
      selector: "[thyDatePicker]",
      exportAs: "thyDatePicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyDatePickerDirective)
      }]
    }]
  }], null, null);
})();
var ThyRangePickerDirective = class _ThyRangePickerDirective extends PickerDirective {
  constructor() {
    super();
    this.isRange = true;
  }
  static {
    this.\u0275fac = function ThyRangePickerDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyRangePickerDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ThyRangePickerDirective,
      selectors: [["", "thyRangePicker", ""]],
      exportAs: ["thyRangePicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyRangePickerDirective)
      }]), \u0275\u0275InheritDefinitionFeature]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyRangePickerDirective, [{
    type: Directive,
    args: [{
      selector: "[thyRangePicker]",
      exportAs: "thyRangePicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyRangePickerDirective)
      }]
    }]
  }], () => [], null);
})();
var ThyQuarterPicker = class _ThyQuarterPicker extends BasePicker {
  constructor() {
    super();
    this.thyFormat = model(`yyyy-${QUARTER_FORMAT}`, ...ngDevMode ? [{
      debugName: "thyFormat"
    }] : []);
    this.isRange = false;
    this.endPanelMode = "quarter";
    this.hostRenderer = useHostRenderer();
    this.hostRenderer.addClass("thy-calendar-picker");
    this.thyMode = "quarter";
  }
  static {
    this.\u0275fac = function ThyQuarterPicker_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyQuarterPicker)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThyQuarterPicker,
      selectors: [["thy-quarter-picker"]],
      inputs: {
        thyFormat: [1, "thyFormat"]
      },
      outputs: {
        thyFormat: "thyFormatChange"
      },
      exportAs: ["thyQuarterPicker"],
      features: [\u0275\u0275ProvidersFeature([{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => _ThyQuarterPicker)
      }]), \u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 20,
      consts: [["thyPicker", ""], [3, "valueChange", "openChange", "blur", "inputChange", "isRange", "value", "flexible", "flexibleDateGranularity", "opened", "disabled", "format", "separator", "mode", "allowClear", "className", "autoFocus", "placeholder", "readonly", "size", "timeZone", "suffixIcon", "placement", "hasBackdrop"], [3, "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"], [3, "panelModeChange", "showTimePickerChange", "valueChange", "calendarChange", "dateValueChange", "resultOk", "isRange", "showWeek", "panelMode", "flexible", "flexibleDateGranularity", "defaultPickerValue", "value", "showTime", "mustShowTime", "format", "dateRender", "disabledDate", "minDate", "maxDate", "showShortcut", "shortcutPresets", "shortcutPosition", "timestampPrecision", "className", "timeZone"]],
      template: function ThyQuarterPicker_Template(rf, ctx) {
        if (rf & 1) {
          const _r1 = \u0275\u0275getCurrentView();
          \u0275\u0275elementStart(0, "thy-picker", 1, 0);
          \u0275\u0275listener("valueChange", function ThyQuarterPicker_Template_thy_picker_valueChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputValueChange($event));
          })("openChange", function ThyQuarterPicker_Template_thy_picker_openChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onOpenChange($event));
          })("blur", function ThyQuarterPicker_Template_thy_picker_blur_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onBlur($event));
          })("inputChange", function ThyQuarterPicker_Template_thy_picker_inputChange_0_listener($event) {
            \u0275\u0275restoreView(_r1);
            return \u0275\u0275resetView(ctx.onInputDate($event));
          });
          \u0275\u0275conditionalCreate(2, ThyQuarterPicker_Conditional_2_Template, 1, 21, "date-popup", 2);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275property("isRange", ctx.isRange)("value", ctx.thyValue)("flexible", ctx.flexible())("flexibleDateGranularity", ctx.flexibleDateGranularity)("opened", ctx.opened())("disabled", ctx.thyDisabled)("format", ctx.thyFormat())("separator", ctx.separator())("mode", ctx.thyMode)("allowClear", ctx.thyAllowClear())("className", ctx.thyOriginClassName())("autoFocus", ctx.thyAutoFocus())("placeholder", ctx.placeholder())("readonly", ctx.thyReadonly())("size", ctx.thySize())("timeZone", ctx.thyTimeZone())("suffixIcon", ctx.thySuffixIcon())("placement", ctx.thyPlacement())("hasBackdrop", ctx.thyHasBackdrop());
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.isShowDatePopup ? 2 : -1);
        }
      },
      dependencies: [ThyPicker, DatePopup],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyQuarterPicker, [{
    type: Component,
    args: [{
      changeDetection: ChangeDetectionStrategy.OnPush,
      selector: "thy-quarter-picker",
      exportAs: "thyQuarterPicker",
      providers: [{
        provide: NG_VALUE_ACCESSOR,
        multi: true,
        useExisting: forwardRef(() => ThyQuarterPicker)
      }],
      imports: [ThyPicker, DatePopup],
      template: '<thy-picker\n  #thyPicker\n  [isRange]="isRange"\n  [value]="thyValue"\n  [flexible]="flexible()"\n  [flexibleDateGranularity]="flexibleDateGranularity"\n  (valueChange)="onInputValueChange($event)"\n  [opened]="opened()"\n  [disabled]="thyDisabled"\n  [format]="thyFormat()"\n  [separator]="separator()"\n  [mode]="thyMode"\n  [allowClear]="thyAllowClear()"\n  [className]="thyOriginClassName()"\n  [autoFocus]="thyAutoFocus()"\n  [placeholder]="placeholder()"\n  [readonly]="thyReadonly()"\n  [size]="thySize()"\n  [timeZone]="thyTimeZone()"\n  [suffixIcon]="thySuffixIcon()"\n  [placement]="thyPlacement()"\n  [hasBackdrop]="thyHasBackdrop()"\n  (openChange)="onOpenChange($event)"\n  (blur)="onBlur($event)"\n  (inputChange)="onInputDate($event)">\n  @if (isShowDatePopup) {\n    <date-popup\n      [attr.tabindex]="-1"\n      [isRange]="isRange"\n      [showWeek]="showWeek()"\n      [panelMode]="panelMode"\n      [flexible]="flexible()"\n      [flexibleDateGranularity]="flexibleDateGranularity"\n      [defaultPickerValue]="thyDefaultPickerValue()"\n      (panelModeChange)="thyOnPanelChange.emit($event)"\n      (showTimePickerChange)="onShowTimePickerChange($event)"\n      [value]="thyValue"\n      (valueChange)="onValueChange($event)"\n      (calendarChange)="onCalendarChange($event)"\n      [showTime]="thyShowTime()"\n      [mustShowTime]="withTime"\n      [format]="thyFormat()"\n      [dateRender]="thyDateRender()"\n      [disabledDate]="thyDisabledDate()"\n      [minDate]="thyMinDate()"\n      [maxDate]="thyMaxDate()"\n      [showShortcut]="thyShowShortcut()"\n      [shortcutPresets]="thyShortcutPresets()"\n      [shortcutPosition]="thyShortcutPosition()"\n      [timestampPrecision]="thyTimestampPrecision()"\n      (dateValueChange)="onDateValueChange($event)"\n      [className]="thyPanelClassName()"\n      (resultOk)="onResultOk()"\n      [timeZone]="thyTimeZone()"></date-popup>\n  }\n</thy-picker>\n'
    }]
  }], () => [], {
    thyFormat: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "thyFormat",
        required: false
      }]
    }, {
      type: Output,
      args: ["thyFormatChange"]
    }]
  });
})();
registerLocaleData(zh_Hans_default, "zh-Hans");
var ThyDatePickerModule = class _ThyDatePickerModule {
  static {
    this.\u0275fac = function ThyDatePickerModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThyDatePickerModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _ThyDatePickerModule,
      imports: [CommonModule, OverlayModule, LibPackerModule, ThyIconModule, ThyInputModule, ThyPopoverModule, BasePicker, ThyPicker, ThyDatePicker, ThyMonthPicker, ThyYearPicker, ThyQuarterPicker, ThyWeekPicker, ThyRangePicker, DatePickerRequiredValidator, RangePickerRequiredValidator, ThyDatePickerFormatPipe, ThyQuarterPickerFormatPipe, ThyDatePickerFormatStringPipe, ThyDatePickerDirective, ThyRangePickerDirective],
      exports: [ThyDatePicker, ThyRangePicker, ThyMonthPicker, ThyYearPicker, ThyQuarterPicker, ThyWeekPicker, DatePickerRequiredValidator, RangePickerRequiredValidator, ThyDatePickerFormatPipe, ThyQuarterPickerFormatPipe, ThyDatePickerFormatStringPipe, ThyDatePickerDirective, ThyRangePickerDirective]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [ThyDatePickerConfigService],
      imports: [CommonModule, OverlayModule, LibPackerModule, ThyIconModule, ThyInputModule, ThyPopoverModule, ThyPicker, ThyDatePicker, ThyMonthPicker, ThyYearPicker, ThyQuarterPicker, ThyWeekPicker, ThyRangePicker]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThyDatePickerModule, [{
    type: NgModule,
    args: [{
      imports: [CommonModule, OverlayModule, LibPackerModule, ThyIconModule, ThyInputModule, ThyPopoverModule, BasePicker, ThyPicker, ThyDatePicker, ThyMonthPicker, ThyYearPicker, ThyQuarterPicker, ThyWeekPicker, ThyRangePicker, DatePickerRequiredValidator, RangePickerRequiredValidator, ThyDatePickerFormatPipe, ThyQuarterPickerFormatPipe, ThyDatePickerFormatStringPipe, ThyDatePickerDirective, ThyRangePickerDirective],
      exports: [ThyDatePicker, ThyRangePicker, ThyMonthPicker, ThyYearPicker, ThyQuarterPicker, ThyWeekPicker, DatePickerRequiredValidator, RangePickerRequiredValidator, ThyDatePickerFormatPipe, ThyQuarterPickerFormatPipe, ThyDatePickerFormatStringPipe, ThyDatePickerDirective, ThyRangePickerDirective],
      providers: [ThyDatePickerConfigService]
    }]
  }], null, null);
})();

// packages/gantt/src/components/bar/placeholder.component.ts
var NgxGanttPlaceholderComponent = class _NgxGanttPlaceholderComponent extends GanttItemUpper {
  constructor() {
    super();
  }
  static {
    this.\u0275fac = function NgxGanttPlaceholderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttPlaceholderComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttPlaceholderComponent, selectors: [["ngx-gantt-bar-placeholder"], ["gantt-bar-placeholder"]], hostAttrs: [1, "gantt-bar-placeholder"], features: [\u0275\u0275InheritDefinitionFeature], decls: 0, vars: 0, template: function NgxGanttPlaceholderComponent_Template(rf, ctx) {
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttPlaceholderComponent, [{
    type: Component,
    args: [{
      selector: "ngx-gantt-bar-placeholder,gantt-bar-placeholder",
      template: "",
      host: {
        class: "gantt-bar-placeholder"
      }
    }]
  }], () => [], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttPlaceholderComponent, { className: "NgxGanttPlaceholderComponent", filePath: "packages/gantt/src/components/bar/placeholder.component.ts", lineNumber: 11 });
})();

// packages/gantt/src/components/baseline/baseline.component.ts
var _c019 = (a0, a1) => ({ item: a0, refs: a1 });
function NgxGanttBaselineComponent_Conditional_0_ng_template_2_Template(rf, ctx) {
}
function NgxGanttBaselineComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1, 0);
    \u0275\u0275template(2, NgxGanttBaselineComponent_Conditional_0_ng_template_2_Template, 0, 0, "ng-template", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.template())("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c019, ctx_r0.baselineItem().origin, ctx_r0.baselineItem().refs));
  }
}
var NgxGanttBaselineComponent = class _NgxGanttBaselineComponent {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.baselineItem = input(void 0, ...ngDevMode ? [{ debugName: "baselineItem" }] : []);
    this.template = input(void 0, ...ngDevMode ? [{ debugName: "template" }] : []);
    this.unsubscribe$ = new Subject();
    this.ganttBaselineClass = true;
  }
  ngOnInit() {
    this.baselineItem().refs$.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.setPositions();
    });
  }
  setPositions() {
    const itemElement = this.elementRef.nativeElement;
    itemElement.style.left = this.baselineItem().refs.x + "px";
    itemElement.style.bottom = "2px";
    itemElement.style.width = this.baselineItem().refs.width + "px";
  }
  static {
    this.\u0275fac = function NgxGanttBaselineComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttBaselineComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttBaselineComponent, selectors: [["ngx-gantt-baseline"], ["gantt-baseline"]], hostVars: 2, hostBindings: function NgxGanttBaselineComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-baseline", ctx.ganttBaselineClass);
      }
    }, inputs: { baselineItem: [1, "baselineItem"], template: [1, "template"] }, decls: 1, vars: 1, consts: [["content", ""], [1, "baseline-content"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"]], template: function NgxGanttBaselineComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275conditionalCreate(0, NgxGanttBaselineComponent_Conditional_0_Template, 3, 5, "div", 1);
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.baselineItem() ? 0 : -1);
      }
    }, dependencies: [NgTemplateOutlet], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttBaselineComponent, [{
    type: Component,
    args: [{ selector: "ngx-gantt-baseline,gantt-baseline", imports: [NgTemplateOutlet], template: '@if (baselineItem()) {\n  <div #content class="baseline-content">\n    <ng-template\n      [ngTemplateOutlet]="template()"\n      [ngTemplateOutletContext]="{ item: baselineItem().origin, refs: baselineItem().refs }"\n    ></ng-template>\n  </div>\n}\n' }]
  }], () => [], { baselineItem: [{ type: Input, args: [{ isSignal: true, alias: "baselineItem", required: false }] }], template: [{ type: Input, args: [{ isSignal: true, alias: "template", required: false }] }], ganttBaselineClass: [{
    type: HostBinding,
    args: ["class.gantt-baseline"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttBaselineComponent, { className: "NgxGanttBaselineComponent", filePath: "packages/gantt/src/components/baseline/baseline.component.ts", lineNumber: 13 });
})();

// packages/gantt/src/components/calendar/grid/calendar-grid.component.ts
var _forTrack03 = ($index, $item) => $item.rect.x;
function GanttCalendarGridComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domElement(0, "span", 1);
  }
}
function GanttCalendarGridComponent_For_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElement(0, "rect", 5);
  }
  if (rf & 2) {
    const tick_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("x", tick_r1.rect.x)("width", tick_r1.rect.width)("height", ctx_r1.mainHeight)("fill", tick_r1.rect.background);
  }
}
function GanttCalendarGridComponent_For_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttCalendarGridComponent_For_5_Conditional_0_Template, 1, 4, ":svg:rect", 5);
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    \u0275\u0275conditional(tick_r1.rect.background ? 0 : -1);
  }
}
function GanttCalendarGridComponent_Conditional_8_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElement(0, "line", 6);
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275attribute("x1", tick_r3.rect.x + tick_r3.rect.width)("x2", tick_r3.rect.x + tick_r3.rect.width)("y1", 0)("y2", ctx_r1.mainHeight);
  }
}
function GanttCalendarGridComponent_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElementStart(0, "g");
    \u0275\u0275repeaterCreate(1, GanttCalendarGridComponent_Conditional_8_For_2_Template, 1, 4, ":svg:line", 6, _forTrack03);
    \u0275\u0275domElementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.view.unitTicks);
  }
}
function GanttCalendarGridComponent_For_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElement(0, "line", 4);
  }
  if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    const rightX_r5 = tick_r4.rect.x + tick_r4.rect.width;
    \u0275\u0275attribute("x1", rightX_r5)("x2", rightX_r5)("y1", 0)("y2", ctx_r1.mainHeight);
  }
}
var mainHeight = 5e3;
var GanttCalendarGridComponent = class _GanttCalendarGridComponent {
  get view() {
    return this.ganttUpper.view;
  }
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.elementRef = inject(ElementRef);
    this.unsubscribe$ = new Subject();
    this.mainHeight = mainHeight;
    this.todayBorderRadius = todayBorderRadius;
    this.viewTypes = GanttViewType;
    this.className = `gantt-calendar gantt-calendar-grid`;
    afterNextRender(() => {
      merge(outputToObservable(this.ganttUpper.viewChange), this.ganttUpper.view.start$).pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
        this.setTodayPoint();
      });
    });
  }
  setTodayPoint() {
    const x = this.view.getNowX();
    const todayEle = this.elementRef.nativeElement.getElementsByClassName("gantt-calendar-today-overlay")[0];
    const line = this.elementRef.nativeElement.getElementsByClassName("today-line")[0];
    if (isNumber(x)) {
      if (line) {
        line.style.left = `${x}px`;
        line.style.top = `0px`;
        line.style.bottom = `${-mainHeight}px`;
      }
    } else {
      todayEle.style.display = "none";
    }
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  static {
    this.\u0275fac = function GanttCalendarGridComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttCalendarGridComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttCalendarGridComponent, selectors: [["gantt-calendar-grid"]], hostVars: 2, hostBindings: function GanttCalendarGridComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.className);
      }
    }, decls: 12, vars: 8, consts: [[1, "gantt-calendar-today-overlay"], [1, "today-line"], [1, "gantt-calendar-grid-fill"], [1, "gantt-calendar-grid-main"], [1, "primary-line"], ["y", "0"], [1, "secondary-line"]], template: function GanttCalendarGridComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275domElementStart(0, "div", 0);
        \u0275\u0275conditionalCreate(1, GanttCalendarGridComponent_Conditional_1_Template, 1, 0, "span", 1);
        \u0275\u0275domElementEnd();
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(2, "svg", 2)(3, "g");
        \u0275\u0275repeaterCreate(4, GanttCalendarGridComponent_For_5_Template, 1, 1, null, null, _forTrack03);
        \u0275\u0275domElementEnd()();
        \u0275\u0275domElementStart(6, "svg", 3)(7, "g");
        \u0275\u0275conditionalCreate(8, GanttCalendarGridComponent_Conditional_8_Template, 3, 0, ":svg:g");
        \u0275\u0275domElementStart(9, "g");
        \u0275\u0275repeaterCreate(10, GanttCalendarGridComponent_For_11_Template, 1, 4, ":svg:line", 4, _forTrack03);
        \u0275\u0275domElementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275styleProp("width", ctx.view.width, "px");
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.ganttUpper.showTodayLine() ? 1 : -1);
        \u0275\u0275advance();
        \u0275\u0275attribute("width", ctx.view.width)("height", 1);
        \u0275\u0275advance(2);
        \u0275\u0275repeater(ctx.view.unitTicks);
        \u0275\u0275advance(2);
        \u0275\u0275attribute("width", ctx.view.width)("height", ctx.ganttUpper.styles().headerHeight - 1);
        \u0275\u0275advance(2);
        \u0275\u0275conditional(ctx.view.showNowIndicator ? 8 : -1);
        \u0275\u0275advance(2);
        \u0275\u0275repeater(ctx.view.periodTicks);
      }
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttCalendarGridComponent, [{
    type: Component,
    args: [{ selector: "gantt-calendar-grid", template: '<div class="gantt-calendar-today-overlay" [style.width.px]="view.width">\n  @if (ganttUpper.showTodayLine()) {\n    <span class="today-line"> </span>\n  }\n</div>\n<svg class="gantt-calendar-grid-fill" [attr.width]="view.width" [attr.height]="1">\n  <g>\n    @for (tick of view.unitTicks; track tick.rect.x) {\n      @if (tick.rect.background) {\n        <rect [attr.x]="tick.rect.x" y="0" [attr.width]="tick.rect.width" [attr.height]="mainHeight" [attr.fill]="tick.rect.background" />\n      }\n    }\n  </g>\n</svg>\n\n<svg class="gantt-calendar-grid-main" [attr.width]="view.width" [attr.height]="ganttUpper.styles().headerHeight - 1">\n  <g>\n    @if (view.showNowIndicator) {\n      <g>\n        @for (tick of view.unitTicks; track tick.rect.x) {\n          <line\n            [attr.x1]="tick.rect.x + tick.rect.width"\n            [attr.x2]="tick.rect.x + tick.rect.width"\n            [attr.y1]="0"\n            [attr.y2]="mainHeight"\n            class="secondary-line"\n          ></line>\n        }\n      </g>\n    }\n    <g>\n      @for (tick of view.periodTicks; track tick.rect.x) {\n        @let rightX = tick.rect.x + tick.rect.width;\n        <line [attr.x1]="rightX" [attr.x2]="rightX" [attr.y1]="0" [attr.y2]="mainHeight" class="primary-line"></line>\n      }\n    </g>\n  </g>\n</svg>\n' }]
  }], () => [], { className: [{
    type: HostBinding,
    args: ["class"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttCalendarGridComponent, { className: "GanttCalendarGridComponent", filePath: "packages/gantt/src/components/calendar/grid/calendar-grid.component.ts", lineNumber: 15 });
})();

// packages/gantt/src/components/calendar/header/calendar-header.component.ts
var _c020 = (a0, a1, a2) => ({ fill: a0, fontSize: a1, fontWeight: a2 });
var _forTrack04 = ($index, $item) => $item.rect.x;
function GanttCalendarHeaderComponent_For_5_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "rect", 5);
  }
  if (rf & 2) {
    const tick_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275attribute("x", tick_r1.rect.x)("width", tick_r1.rect.width)("height", ctx_r1.ganttUpper.styles().headerHeight)("fill", tick_r1.rect.background);
  }
}
function GanttCalendarHeaderComponent_For_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttCalendarHeaderComponent_For_5_Conditional_0_Template, 1, 4, ":svg:rect", 5);
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(1, "text", 6);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r1 = ctx.$implicit;
    \u0275\u0275conditional(tick_r1.rect.background ? 0 : -1);
    \u0275\u0275advance();
    \u0275\u0275classProp("today", tick_r1.metadata == null ? null : tick_r1.metadata.isToday)("weekend", tick_r1.metadata == null ? null : tick_r1.metadata.isWeekend);
    \u0275\u0275property("ngStyle", \u0275\u0275pureFunction3(9, _c020, tick_r1.label.style == null ? null : tick_r1.label.style.color, tick_r1.label.style == null ? null : tick_r1.label.style.fontSize, tick_r1.label.style == null ? null : tick_r1.label.style.fontWeight));
    \u0275\u0275attribute("x", tick_r1.label.x)("y", tick_r1.label.y);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tick_r1.label.text, " ");
  }
}
function GanttCalendarHeaderComponent_For_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "text", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tick_r3 = ctx.$implicit;
    \u0275\u0275classProp("today", tick_r3.metadata == null ? null : tick_r3.metadata.isToday)("weekend", tick_r3.metadata == null ? null : tick_r3.metadata.isWeekend);
    \u0275\u0275property("ngStyle", tick_r3.label.style);
    \u0275\u0275attribute("x", tick_r3.label.x)("y", tick_r3.label.y);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", tick_r3.label.text, " ");
  }
}
function GanttCalendarHeaderComponent_For_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275element(0, "line", 3);
  }
  if (rf & 2) {
    const tick_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    const rightX_r5 = tick_r4.rect.x + tick_r4.rect.width;
    \u0275\u0275attribute("x1", rightX_r5)("x2", rightX_r5)("y1", 0)("y2", ctx_r1.ganttUpper.styles().headerHeight);
  }
}
var GanttCalendarHeaderComponent = class _GanttCalendarHeaderComponent {
  get view() {
    return this.ganttUpper.view;
  }
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.elementRef = inject(ElementRef);
    this.unsubscribe$ = new Subject();
    this.viewTypes = GanttViewType;
    this.className = `gantt-calendar gantt-calendar-header`;
  }
  ngOnInit() {
    merge(outputToObservable(this.ganttUpper.viewChange), this.ganttUpper.view.start$).pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      if (this.ganttUpper.viewType() === GanttViewType.day)
        this.setTodayPoint();
    });
  }
  setTodayPoint() {
    const x = this.view.getNowX();
    const today = new GanttDate().getDate();
    const todayEle = this.elementRef.nativeElement.getElementsByClassName("gantt-calendar-today-overlay")[0];
    const rect = this.elementRef.nativeElement.getElementsByClassName("today-rect")[0];
    if (isNumber(x)) {
      if (rect) {
        rect.style.left = `${x - todayWidth / 2}px`;
        rect.style.top = `${this.ganttUpper.styles().headerHeight - todayHeight}px`;
        rect.innerHTML = today.toString();
      }
    } else {
      todayEle.style.display = "none";
    }
  }
  static {
    this.\u0275fac = function GanttCalendarHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttCalendarHeaderComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttCalendarHeaderComponent, selectors: [["gantt-calendar-header"]], hostVars: 2, hostBindings: function GanttCalendarHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.className);
      }
    }, decls: 13, vars: 9, consts: [[1, "gantt-calendar-today-overlay"], [1, "today-rect", 3, "hidden"], [1, "primary-text", 3, "ngStyle", "today", "weekend"], [1, "primary-line"], [1, "header-line"], ["y", "0"], [1, "secondary-text", 3, "ngStyle"], [1, "primary-text", 3, "ngStyle"]], template: function GanttCalendarHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0);
        \u0275\u0275element(1, "span", 1);
        \u0275\u0275elementEnd();
        \u0275\u0275namespaceSVG();
        \u0275\u0275elementStart(2, "svg")(3, "g");
        \u0275\u0275repeaterCreate(4, GanttCalendarHeaderComponent_For_5_Template, 3, 13, null, null, _forTrack04);
        \u0275\u0275repeaterCreate(6, GanttCalendarHeaderComponent_For_7_Template, 2, 8, ":svg:text", 2, _forTrack04);
        \u0275\u0275elementStart(8, "g");
        \u0275\u0275repeaterCreate(9, GanttCalendarHeaderComponent_For_10_Template, 1, 4, ":svg:line", 3, _forTrack04);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(11, "g");
        \u0275\u0275element(12, "line", 4);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275styleProp("width", ctx.view.width, "px");
        \u0275\u0275advance();
        \u0275\u0275property("hidden", ctx.ganttUpper.viewType() !== ctx.viewTypes.day);
        \u0275\u0275advance();
        \u0275\u0275attribute("width", ctx.view.width)("height", ctx.ganttUpper.styles().headerHeight);
        \u0275\u0275advance(2);
        \u0275\u0275repeater(ctx.view.unitTicks);
        \u0275\u0275advance(2);
        \u0275\u0275repeater(ctx.view.periodTicks);
        \u0275\u0275advance(3);
        \u0275\u0275repeater(ctx.view.periodTicks);
        \u0275\u0275advance(3);
        \u0275\u0275attribute("x1", 0)("x2", ctx.view.width)("y1", ctx.ganttUpper.styles().headerHeight)("y2", ctx.ganttUpper.styles().headerHeight);
      }
    }, dependencies: [NgStyle], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttCalendarHeaderComponent, [{
    type: Component,
    args: [{ selector: "gantt-calendar-header", imports: [NgStyle], template: '<div class="gantt-calendar-today-overlay" [style.width.px]="view.width">\n  <span class="today-rect" [hidden]="ganttUpper.viewType() !== viewTypes.day"> </span>\n</div>\n<svg [attr.width]="view.width" [attr.height]="ganttUpper.styles().headerHeight">\n  <g>\n    @for (tick of view.unitTicks; track tick.rect.x) {\n      @if (tick.rect.background) {\n        <rect\n          [attr.x]="tick.rect.x"\n          y="0"\n          [attr.width]="tick.rect.width"\n          [attr.height]="ganttUpper.styles().headerHeight"\n          [attr.fill]="tick.rect.background"\n        />\n      }\n      <text\n        class="secondary-text"\n        [ngStyle]="{\n          fill: tick.label.style?.color,\n          fontSize: tick.label.style?.fontSize,\n          fontWeight: tick.label.style?.fontWeight\n        }"\n        [class.today]="tick.metadata?.isToday"\n        [class.weekend]="tick.metadata?.isWeekend"\n        [attr.x]="tick.label.x"\n        [attr.y]="tick.label.y"\n      >\n        {{ tick.label.text }}\n      </text>\n    }\n\n    @for (tick of view.periodTicks; track tick.rect.x) {\n      <text\n        class="primary-text"\n        [ngStyle]="tick.label.style"\n        [class.today]="tick.metadata?.isToday"\n        [class.weekend]="tick.metadata?.isWeekend"\n        [attr.x]="tick.label.x"\n        [attr.y]="tick.label.y"\n      >\n        {{ tick.label.text }}\n      </text>\n    }\n\n    <g>\n      @for (tick of view.periodTicks; track tick.rect.x) {\n        @let rightX = tick.rect.x + tick.rect.width;\n        <line [attr.x1]="rightX" [attr.x2]="rightX" [attr.y1]="0" [attr.y2]="ganttUpper.styles().headerHeight" class="primary-line"></line>\n      }\n    </g>\n\n    <g>\n      <line\n        [attr.x1]="0"\n        [attr.x2]="view.width"\n        [attr.y1]="ganttUpper.styles().headerHeight"\n        [attr.y2]="ganttUpper.styles().headerHeight"\n        class="header-line"\n      ></line>\n    </g>\n  </g>\n</svg>\n' }]
  }], () => [], { className: [{
    type: HostBinding,
    args: ["class"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttCalendarHeaderComponent, { className: "GanttCalendarHeaderComponent", filePath: "packages/gantt/src/components/calendar/header/calendar-header.component.ts", lineNumber: 17 });
})();

// packages/gantt/src/components/drag-backdrop/drag-backdrop.component.ts
var GanttDragBackdropComponent = class _GanttDragBackdropComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
  }
  static {
    this.\u0275fac = function GanttDragBackdropComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttDragBackdropComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttDragBackdropComponent, selectors: [["gantt-drag-backdrop"]], hostAttrs: [1, "gantt-drag-backdrop"], decls: 4, vars: 0, consts: [[1, "gantt-drag-mask"], [1, "date-range"], [1, "start"], [1, "end"]], template: function GanttDragBackdropComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275domElementStart(0, "div", 0)(1, "div", 1);
        \u0275\u0275domElement(2, "span", 2)(3, "span", 3);
        \u0275\u0275domElementEnd()();
      }
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttDragBackdropComponent, [{
    type: Component,
    args: [{ selector: "gantt-drag-backdrop", host: {
      class: "gantt-drag-backdrop"
    }, template: '<div class="gantt-drag-mask">\n  <div class="date-range">\n    <span class="start"></span>\n    <span class="end"></span>\n  </div>\n</div>\n' }]
  }], () => [], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttDragBackdropComponent, { className: "GanttDragBackdropComponent", filePath: "packages/gantt/src/components/drag-backdrop/drag-backdrop.component.ts", lineNumber: 10 });
})();

// packages/gantt/src/components/loader/loader.component.ts
var GanttLoaderComponent = class _GanttLoaderComponent {
  static {
    this.\u0275fac = function GanttLoaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttLoaderComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttLoaderComponent, selectors: [["gantt-loader"]], hostAttrs: [1, "gantt-loader", "gantt-loader-overlay"], decls: 3, vars: 0, consts: [[1, "gantt-loader-wrapper"], [1, "gantt-loader-loading"], [1, "gantt-loader-loading-spot"]], template: function GanttLoaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275domElementStart(0, "div", 0)(1, "div", 1);
        \u0275\u0275domElement(2, "span", 2);
        \u0275\u0275domElementEnd()();
      }
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttLoaderComponent, [{
    type: Component,
    args: [{
      selector: "gantt-loader",
      template: `
        <div class="gantt-loader-wrapper">
            <div class="gantt-loader-loading">
                <span class="gantt-loader-loading-spot"></span>
            </div>
        </div>
    `,
      host: {
        class: "gantt-loader gantt-loader-overlay"
      }
    }]
  }], null, null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttLoaderComponent, { className: "GanttLoaderComponent", filePath: "packages/gantt/src/components/loader/loader.component.ts", lineNumber: 16 });
})();

// packages/gantt/src/gantt-sync-scroll.service.ts
var GanttSyncScrollService = class _GanttSyncScrollService {
  constructor() {
    this.ngZone = inject(NgZone);
    this.scrollGroupsMap = /* @__PURE__ */ new Map();
  }
  registerScrollEvent(groupName, element, direction) {
    const group2 = this.scrollGroupsMap.get(groupName) || { elements: [], destroy$: new Subject(), direction };
    group2.elements.push(element);
    this.scrollGroupsMap.set(groupName, group2);
    this.monitorScrollChange(group2);
  }
  unregisterScrollEvent(groupName, element) {
    const group2 = this.scrollGroupsMap.get(groupName);
    if (group2) {
      group2.elements = group2.elements.filter((el) => el !== element);
      if (!group2.elements.length) {
        this.scrollGroupsMap.delete(groupName);
      } else {
        this.scrollGroupsMap.set(groupName, group2);
      }
      this.monitorScrollChange(group2);
    }
  }
  monitorScrollChange(group2) {
    const { elements, destroy$, direction } = group2;
    destroy$.next();
    destroy$.complete();
    if (elements.length) {
      const scrollObservers = elements.map((el) => fromEvent(el, "scroll", passiveListenerOptions));
      this.ngZone.runOutsideAngular(() => merge(...scrollObservers).pipe(takeUntil(destroy$)).subscribe((event) => {
        elements.forEach((el) => {
          if (direction === "x") {
            el.scrollLeft = event.currentTarget.scrollLeft;
          } else {
            el.scrollTop = event.currentTarget.scrollTop;
          }
        });
      }));
    }
  }
  static {
    this.\u0275fac = function GanttSyncScrollService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttSyncScrollService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _GanttSyncScrollService, factory: _GanttSyncScrollService.\u0275fac });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttSyncScrollService, [{
    type: Injectable
  }], () => [], null);
})();

// packages/gantt/src/directives/sync-scroll.directive.ts
var GanttSyncScrollXDirective = class _GanttSyncScrollXDirective {
  constructor() {
    this.syncScrollX = input(...ngDevMode ? [void 0, { debugName: "syncScrollX" }] : []);
    this.elementRef = inject(ElementRef);
    this.syncScrollService = inject(GanttSyncScrollService);
  }
  ngOnInit() {
    this.syncScrollService.registerScrollEvent(this.syncScrollX(), this.elementRef.nativeElement, "x");
  }
  ngOnDestroy() {
    this.syncScrollService.unregisterScrollEvent(this.syncScrollX(), this.elementRef.nativeElement);
  }
  static {
    this.\u0275fac = function GanttSyncScrollXDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttSyncScrollXDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _GanttSyncScrollXDirective, selectors: [["", "syncScrollX", ""]], inputs: { syncScrollX: [1, "syncScrollX"] } });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttSyncScrollXDirective, [{
    type: Directive,
    args: [{
      selector: "[syncScrollX]"
    }]
  }], () => [], { syncScrollX: [{ type: Input, args: [{ isSignal: true, alias: "syncScrollX", required: false }] }] });
})();
var GanttSyncScrollYDirective = class _GanttSyncScrollYDirective {
  constructor() {
    this.syncScrollY = input(...ngDevMode ? [void 0, { debugName: "syncScrollY" }] : []);
    this.syncScrollService = inject(GanttSyncScrollService);
    this.elementRef = inject(ElementRef);
  }
  ngOnInit() {
    this.syncScrollService.registerScrollEvent(this.syncScrollY(), this.elementRef.nativeElement, "y");
  }
  ngOnDestroy() {
    this.syncScrollService.unregisterScrollEvent(this.syncScrollY(), this.elementRef.nativeElement);
  }
  static {
    this.\u0275fac = function GanttSyncScrollYDirective_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttSyncScrollYDirective)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({ type: _GanttSyncScrollYDirective, selectors: [["", "syncScrollY", ""]], inputs: { syncScrollY: [1, "syncScrollY"] } });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttSyncScrollYDirective, [{
    type: Directive,
    args: [{
      selector: "[syncScrollY]"
    }]
  }], () => [], { syncScrollY: [{ type: Input, args: [{ isSignal: true, alias: "syncScrollY", required: false }] }] });
})();

// packages/gantt/src/components/scrollbar/scrollbar.component.ts
var _c021 = (a0) => ({ "gantt-scrollbar-bg": a0 });
var GanttScrollbarComponent = class _GanttScrollbarComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.hasFooter = input(false, ...ngDevMode ? [{ debugName: "hasFooter" }] : []);
    this.tableWidth = input(...ngDevMode ? [void 0, { debugName: "tableWidth" }] : []);
    this.ganttRoot = input(...ngDevMode ? [void 0, { debugName: "ganttRoot" }] : []);
    this.tableScrollWidth = input(0, ...ngDevMode ? [{ debugName: "tableScrollWidth" }] : []);
  }
  static {
    this.\u0275fac = function GanttScrollbarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttScrollbarComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttScrollbarComponent, selectors: [["gantt-scrollbar"]], inputs: { hasFooter: [1, "hasFooter"], tableWidth: [1, "tableWidth"], ganttRoot: [1, "ganttRoot"], tableScrollWidth: [1, "tableScrollWidth"] }, decls: 5, vars: 15, consts: [[1, "gantt-scrollbar", 3, "ngClass"], ["syncScrollX", "ganttTableXScroll", 1, "gantt-table-scrollbar"], [1, "h-100"], ["syncScrollX", "ganttMainXScroll", 1, "gantt-main-scrollbar"]], template: function GanttScrollbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0)(1, "div", 1);
        \u0275\u0275element(2, "div", 2);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(3, "div", 3);
        \u0275\u0275element(4, "div", 2);
        \u0275\u0275elementEnd()();
      }
      if (rf & 2) {
        let tmp_0_0;
        let tmp_1_0;
        let tmp_4_0;
        let tmp_6_0;
        \u0275\u0275styleProp("height", ((tmp_0_0 = ctx.ganttRoot()) == null ? null : tmp_0_0.horizontalScrollbarHeight) + 1, "px")("right", (tmp_1_0 = ctx.ganttRoot()) == null ? null : tmp_1_0.verticalScrollbarWidth, "px");
        \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(13, _c021, ctx.hasFooter()));
        \u0275\u0275advance();
        \u0275\u0275styleProp("width", ctx.tableWidth(), "px");
        \u0275\u0275classProp("with-scrollbar", (tmp_4_0 = ctx.ganttRoot()) == null ? null : tmp_4_0.horizontalScrollbarHeight);
        \u0275\u0275advance();
        \u0275\u0275styleProp("width", ctx.tableScrollWidth() - 1, "px");
        \u0275\u0275advance(2);
        \u0275\u0275styleProp("width", (tmp_6_0 = ctx.ganttRoot()["view"]) == null ? null : tmp_6_0.width, "px");
      }
    }, dependencies: [NgClass, GanttSyncScrollXDirective], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttScrollbarComponent, [{
    type: Component,
    args: [{ selector: "gantt-scrollbar", imports: [NgClass, GanttSyncScrollXDirective], template: `<div
  class="gantt-scrollbar"
  [ngClass]="{ 'gantt-scrollbar-bg': hasFooter() }"
  [style.height.px]="ganttRoot()?.horizontalScrollbarHeight + 1"
  [style.right.px]="ganttRoot()?.verticalScrollbarWidth"
>
  <div
    class="gantt-table-scrollbar"
    syncScrollX="ganttTableXScroll"
    [class.with-scrollbar]="ganttRoot()?.horizontalScrollbarHeight"
    [style.width.px]="tableWidth()"
  >
    <div class="h-100" [style.width.px]="tableScrollWidth() - 1"></div>
  </div>
  <div class="gantt-main-scrollbar" syncScrollX="ganttMainXScroll">
    <div class="h-100" [style.width.px]="ganttRoot()['view']?.width"></div>
  </div>
</div>
` }]
  }], () => [], { hasFooter: [{ type: Input, args: [{ isSignal: true, alias: "hasFooter", required: false }] }], tableWidth: [{ type: Input, args: [{ isSignal: true, alias: "tableWidth", required: false }] }], ganttRoot: [{ type: Input, args: [{ isSignal: true, alias: "ganttRoot", required: false }] }], tableScrollWidth: [{ type: Input, args: [{ isSignal: true, alias: "tableScrollWidth", required: false }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttScrollbarComponent, { className: "GanttScrollbarComponent", filePath: "packages/gantt/src/components/scrollbar/scrollbar.component.ts", lineNumber: 12 });
})();

// packages/gantt/src/components/toolbar/toolbar.component.ts
function NgxGanttToolbarComponent_Conditional_1_Conditional_0_For_2_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275listener("click", function NgxGanttToolbarComponent_Conditional_1_Conditional_0_For_2_Conditional_0_Template_div_click_0_listener() {
      \u0275\u0275restoreView(_r1);
      const viewType_r2 = \u0275\u0275nextContext().$implicit;
      const ctx_r2 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r2.selectView(viewType_r2));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const viewType_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275classProp("active", viewType_r2 === ctx_r2.ganttUpper.viewType());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", ctx_r2.views[viewType_r2].label, " ");
  }
}
function NgxGanttToolbarComponent_Conditional_1_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, NgxGanttToolbarComponent_Conditional_1_Conditional_0_For_2_Conditional_0_Template, 2, 3, "div", 3);
  }
  if (rf & 2) {
    const viewType_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(3);
    \u0275\u0275conditional(ctx_r2.views[viewType_r2] ? 0 : -1);
  }
}
function NgxGanttToolbarComponent_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275repeaterCreate(1, NgxGanttToolbarComponent_Conditional_1_Conditional_0_For_2_Template, 1, 1, null, null, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275repeater((tmp_2_0 = ctx_r2.ganttUpper.toolbarOptions()) == null ? null : tmp_2_0.viewTypes);
  }
}
function NgxGanttToolbarComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, NgxGanttToolbarComponent_Conditional_1_Conditional_0_Template, 3, 0, "div", 2);
  }
  if (rf & 2) {
    let tmp_1_0;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275conditional(((tmp_1_0 = ctx_r2.ganttUpper.toolbarOptions()) == null ? null : tmp_1_0.viewTypes == null ? null : tmp_1_0.viewTypes.length) ? 0 : -1);
  }
}
function NgxGanttToolbarComponent_ng_template_2_Template(rf, ctx) {
}
var NgxGanttToolbarComponent = class _NgxGanttToolbarComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.template = input(...ngDevMode ? [void 0, { debugName: "template" }] : []);
    this.ganttItemClass = true;
    this.views = inject(GanttConfigService).getViewsLocale();
  }
  selectView(view) {
    this.ganttUpper.viewType.set(view);
  }
  static {
    this.\u0275fac = function NgxGanttToolbarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttToolbarComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttToolbarComponent, selectors: [["ngx-gantt-toolbar"], ["gantt-toolbar"]], hostVars: 2, hostBindings: function NgxGanttToolbarComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-toolbar", ctx.ganttItemClass);
      }
    }, inputs: { template: [1, "template"] }, decls: 3, vars: 2, consts: [[1, "toolbar-container"], [3, "ngTemplateOutlet"], [1, "toolbar-views"], [1, "toolbar-view", 3, "active"], [1, "toolbar-view", 3, "click"]], template: function NgxGanttToolbarComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0);
        \u0275\u0275conditionalCreate(1, NgxGanttToolbarComponent_Conditional_1_Template, 1, 1);
        \u0275\u0275template(2, NgxGanttToolbarComponent_ng_template_2_Template, 0, 0, "ng-template", 1);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275advance();
        \u0275\u0275conditional(!ctx.template() ? 1 : -1);
        \u0275\u0275advance();
        \u0275\u0275property("ngTemplateOutlet", ctx.template());
      }
    }, dependencies: [NgTemplateOutlet], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttToolbarComponent, [{
    type: Component,
    args: [{ selector: "ngx-gantt-toolbar,gantt-toolbar", imports: [NgTemplateOutlet], template: '<div class="toolbar-container">\n  @if (!template()) {\n    @if (this.ganttUpper.toolbarOptions()?.viewTypes?.length) {\n      <div class="toolbar-views">\n        @for (viewType of this.ganttUpper.toolbarOptions()?.viewTypes; track viewType) {\n          @if (views[viewType]) {\n            <div class="toolbar-view" [class.active]="viewType === this.ganttUpper.viewType()" (click)="selectView(viewType)">\n              {{ views[viewType].label }}\n            </div>\n          }\n        }\n      </div>\n    }\n  }\n  <ng-template [ngTemplateOutlet]="template()"></ng-template>\n</div>\n' }]
  }], () => [], { template: [{ type: Input, args: [{ isSignal: true, alias: "template", required: false }] }], ganttItemClass: [{
    type: HostBinding,
    args: ["class.gantt-toolbar"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttToolbarComponent, { className: "NgxGanttToolbarComponent", filePath: "packages/gantt/src/components/toolbar/toolbar.component.ts", lineNumber: 12 });
})();

// packages/gantt/src/gantt-print.service.ts
var GanttPrintService = class _GanttPrintService {
  constructor() {
  }
  setInlineStyles(targetElem) {
    const svgElements = Array.from(targetElem.getElementsByTagName("svg"));
    for (const svgElement of svgElements) {
      this.recursElementChildren(svgElement);
    }
  }
  recursElementChildren(node) {
    const transformProperties = [
      "fill",
      "color",
      "font-size",
      "stroke",
      "font",
      "text-anchor",
      "stroke-dasharray",
      "shape-rendering",
      "stroke-width"
    ];
    if (!node.style) {
      return;
    }
    const styles = getComputedStyle(node);
    for (const transformProperty of transformProperties) {
      node.style[transformProperty] = styles[transformProperty];
    }
    for (const child of Array.from(node.childNodes)) {
      this.recursElementChildren(child);
    }
  }
  register(root) {
    this.root = root.nativeElement;
    this.mainContainer = this.root.getElementsByClassName("gantt-main-container")[0];
  }
  html2canvas(ignoreElementClass) {
    return __async(this, null, function* () {
      const root = this.root;
      const mainContainer = this.mainContainer;
      const printWidth = root.offsetWidth;
      const printHeight = root.offsetHeight - mainContainer.offsetHeight + mainContainer.scrollHeight;
      const html2canvas = (yield import(
        /* webpackChunkName: 'html2canvas' */
        "./html2canvas-NOOWUBIV.js"
      )).default;
      return html2canvas(root, {
        logging: false,
        allowTaint: true,
        useCORS: true,
        width: printWidth,
        height: printHeight,
        ignoreElements: (element) => {
          if (ignoreElementClass && element.classList.contains(ignoreElementClass)) {
            return true;
          }
          if (element.classList.contains("gantt-calendar-today-overlay")) {
            return true;
          }
        },
        onclone: (cloneDocument) => {
          const ganttClass = root.className;
          const cloneGanttDom = cloneDocument.querySelector(`.${ganttClass.replace(/\s+/g, ".")}`);
          const cloneGanttContainerDom = cloneDocument.querySelector(".gantt-container");
          const cloneCalendarOverlay = cloneDocument.querySelector(".gantt-calendar-grid-main");
          const cloneLinksOverlay = cloneDocument.querySelector(".gantt-links-overlay-main");
          cloneGanttDom.style.width = `${printWidth}px`;
          cloneGanttDom.style.height = `${printHeight}px`;
          cloneGanttDom.style.overflow = `unset`;
          cloneGanttContainerDom.style.backgroundColor = "#fff";
          cloneCalendarOverlay.setAttribute("height", `${printHeight}`);
          cloneCalendarOverlay.setAttribute("style", `background: transparent`);
          if (cloneLinksOverlay) {
            cloneLinksOverlay.setAttribute("height", `${printHeight}`);
            cloneLinksOverlay.setAttribute("style", `height: ${printHeight}px`);
          }
          this.setInlineStyles(cloneGanttDom);
        }
      });
    });
  }
  print(name = "download", ignoreElementClass) {
    return __async(this, null, function* () {
      this.html2canvas(ignoreElementClass).then((canvas) => {
        const link = document.createElement("a");
        const dataUrl = canvas.toDataURL("image/png");
        link.download = `${name}.png`;
        link.href = dataUrl;
        link.click();
      });
    });
  }
  static {
    this.\u0275fac = function GanttPrintService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttPrintService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _GanttPrintService, factory: _GanttPrintService.\u0275fac });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttPrintService, [{
    type: Injectable
  }], () => [], null);
})();

// packages/gantt/src/gantt.pipe.ts
var IsGanttRangeItemPipe = class _IsGanttRangeItemPipe {
  transform(value) {
    return value === GanttItemType.range;
  }
  static {
    this.\u0275fac = function IsGanttRangeItemPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsGanttRangeItemPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "isGanttRangeItem", type: _IsGanttRangeItemPipe, pure: true });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsGanttRangeItemPipe, [{
    type: Pipe,
    args: [{
      name: "isGanttRangeItem"
    }]
  }], null, null);
})();
var IsGanttBarItemPipe = class _IsGanttBarItemPipe {
  transform(value) {
    return value === GanttItemType.bar;
  }
  static {
    this.\u0275fac = function IsGanttBarItemPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsGanttBarItemPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "isGanttBarItem", type: _IsGanttBarItemPipe, pure: true });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsGanttBarItemPipe, [{
    type: Pipe,
    args: [{
      name: "isGanttBarItem"
    }]
  }], null, null);
})();
var IsGanttCustomItemPipe = class _IsGanttCustomItemPipe {
  transform(value) {
    return value === GanttItemType.custom;
  }
  static {
    this.\u0275fac = function IsGanttCustomItemPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsGanttCustomItemPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "isGanttCustomItem", type: _IsGanttCustomItemPipe, pure: true });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsGanttCustomItemPipe, [{
    type: Pipe,
    args: [{
      name: "isGanttCustomItem"
    }]
  }], null, null);
})();
var IsGanttGroupPipe = class _IsGanttGroupPipe {
  transform(data) {
    return !!data.items;
  }
  static {
    this.\u0275fac = function IsGanttGroupPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsGanttGroupPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "isGanttGroup", type: _IsGanttGroupPipe, pure: true });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsGanttGroupPipe, [{
    type: Pipe,
    args: [{
      name: "isGanttGroup"
    }]
  }], null, null);
})();

// packages/gantt/src/components/links/lines/line.ts
var GanttLinkLine = class {
  constructor() {
  }
  generatePath(source, target, type) {
    if (source.before && source.after && target.before && target.after) {
      let path = "";
      switch (type) {
        case GanttLinkType.ss:
          path = this.generateSSPath(source, target);
          break;
        case GanttLinkType.ff:
          path = this.generateFFPath(source, target);
          break;
        case GanttLinkType.sf:
          path = this.generateFSAndSFPath(source, target, type);
          break;
        default:
          path = this.generateFSAndSFPath(source, target);
      }
      return path;
    }
  }
};

// packages/gantt/src/components/links/lines/curve.ts
var GanttLinkLineCurve = class GanttLinkLineCurve2 extends GanttLinkLine {
  constructor(ganttUpper) {
    super();
    this.ganttUpper = ganttUpper;
  }
  generateSSPath(source, target) {
    const x1 = source.before.x;
    const y1 = source.before.y;
    const x4 = target.before.x;
    const y4 = target.before.y;
    const isMirror = y4 > y1 ? 0 : 1;
    const radius = Math.abs(y4 - y1) / 2;
    if (x4 > x1) {
      return `M ${x1} ${y1}
                    A ${radius} ${radius} 0 1 ${isMirror} ${x1} ${y4}
                    L ${x4} ${y4}`;
    } else {
      return `M ${x1} ${y1}
                    L ${x4} ${y1}
                    A ${radius} ${radius} 0 1 ${isMirror} ${x4} ${y4}`;
    }
  }
  generateFFPath(source, target) {
    const x1 = source.after.x;
    const y1 = source.after.y;
    const x4 = target.after.x;
    const y4 = target.after.y;
    const isMirror = y4 > y1 ? 1 : 0;
    const radius = Math.abs(y4 - y1) / 2;
    if (x4 > x1) {
      return `M ${x1} ${y1}
                    L ${x4} ${y1}
                    A ${radius} ${radius} 0 1 ${isMirror} ${x4} ${y4}`;
    } else {
      return `M ${x1} ${y1}
                    A ${radius} ${radius} 0 1 ${isMirror} ${x1} ${y4}
                    L ${x4} ${y4}`;
    }
  }
  generateFSAndSFPath(source, target, type) {
    let x1 = source.after.x;
    let y1 = source.after.y;
    let x4 = target.before.x;
    let y4 = target.before.y;
    const bezierWeight = 0.5;
    if (type === GanttLinkType.sf) {
      x1 = target.after.x;
      y1 = target.after.y;
      x4 = source.before.x;
      y4 = source.before.y;
    }
    let dx = Math.abs(x4 - x1) * bezierWeight;
    let x2 = x1 + dx;
    let x3 = x4 - dx;
    const centerX = (x1 + x4) / 2;
    const centerY = (y1 + y4) / 2;
    let controlX = this.ganttUpper.styles().rowHeight / 2;
    const controlY = this.ganttUpper.styles().rowHeight / 2;
    if (x1 >= x4) {
      if (Math.abs(y4 - y1) <= this.ganttUpper.styles().rowHeight) {
        return `M ${x1} ${y1}
                    C ${x1 + controlX} ${y1} ${x1 + controlX} ${y4 > y1 ? y1 + controlX : y1 - controlX} ${x1} ${y4 > y1 ? y1 + controlY : y1 - controlY}
                    L ${x4} ${y4 > y1 ? y4 - controlY : y4 + controlY}
                    C ${x4 - controlY} ${y4 > y1 ? y4 - controlY : y4 + controlY}  ${x4 - controlX} ${y4} ${x4} ${y4}
                    `;
      } else {
        controlX = this.ganttUpper.styles().rowHeight;
        return `M ${x1} ${y1}
                    C ${x1 + controlX} ${y1} ${x1 + controlX} ${y4 > y1 ? y1 + controlX : y1 - controlX} ${centerX} ${centerY}
                    C ${x4 - controlX} ${y4 > y1 ? y4 - controlX : y4 + controlX} ${x4 - controlX} ${y4} ${x4} ${y4}
                    `;
      }
    } else if (this.ganttUpper.linkOptions()?.showArrow && x4 - x1 < 200) {
      dx = Math.max(Math.abs(y4 - y1) * bezierWeight, 60);
      x2 = x1 + dx;
      x3 = x4 - dx;
      return `M ${x1} ${y1} C ${x2} ${y1} ${x3} ${y4} ${x4} ${y4}`;
    }
    return `M ${x1} ${y1} C ${x2} ${y1} ${x3} ${y4} ${x4} ${y4}`;
  }
};
GanttLinkLineCurve = __decorate([
  __param(0, Inject(GANTT_UPPER_TOKEN))
], GanttLinkLineCurve);

// packages/gantt/src/components/links/lines/straight.ts
var GanttLinkLineStraight = class extends GanttLinkLine {
  constructor() {
    super();
    this.pathControl = 20;
  }
  generateSSPath(source, target) {
    const x1 = source.before.x;
    const y1 = source.before.y;
    const x4 = target.before.x;
    const y4 = target.before.y;
    const control = this.pathControl;
    return `M ${x1} ${y1}
                        L ${x4 > x1 ? x1 - control : x4 - control} ${y1}
                        L ${x4 > x1 ? x1 - control : x4 - control} ${y4}
                        L ${x4} ${y4}`;
  }
  generateFFPath(source, target) {
    const x1 = source.after.x;
    const y1 = source.after.y;
    const x4 = target.after.x;
    const y4 = target.after.y;
    const control = this.pathControl;
    return `M ${x1} ${y1}
                        L ${x4 > x1 ? x4 + control : x1 + control} ${y1}
                        L ${x4 > x1 ? x4 + control : x1 + control} ${y4}
                        L ${x4} ${y4}`;
  }
  generateFSAndSFPath(source, target, type) {
    let x1 = source.after.x;
    let y1 = source.after.y;
    let x4 = target.before.x;
    let y4 = target.before.y;
    const control = this.pathControl;
    if (type === GanttLinkType.sf) {
      x1 = target.after.x;
      y1 = target.after.y;
      x4 = source.before.x;
      y4 = source.before.y;
    }
    if (x4 - x1 >= 40) {
      return `M ${x1} ${y1}
                        L ${x1 + control} ${y1}
                        L ${x1 + control} ${y4}
                        L ${x4} ${y4}`;
    } else {
      return `M ${x1} ${y1}
                        L ${x1 + control} ${y1}
                        L ${x1 + control} ${y4 > y1 ? y1 + control : y1 - control}
                        L ${x4 - control} ${y4 > y1 ? y1 + control : y1 - control}
                        L ${x4 - control} ${y4}
                        L ${x4} ${y4}`;
    }
  }
};

// packages/gantt/src/components/links/lines/factory.ts
function createLineGenerator(type, ganttUpper) {
  switch (type) {
    case GanttLinkLineType.curve:
      return new GanttLinkLineCurve(ganttUpper);
    case GanttLinkLineType.straight:
      return new GanttLinkLineStraight();
    default:
      throw new Error("gantt link path type invalid");
  }
}

// packages/gantt/src/components/links/links.component.ts
function GanttLinksComponent_For_2_Conditional_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElementStart(0, "marker", 4);
    \u0275\u0275domElement(1, "path", 6);
    \u0275\u0275domElementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    const link_r2 = ctx_r5.$implicit;
    const \u0275$index_3_r5 = ctx_r5.$index;
    \u0275\u0275domProperty("id", "triangle" + \u0275$index_3_r5);
    \u0275\u0275advance();
    \u0275\u0275attribute("fill", link_r2.color)("stroke", link_r2.color);
  }
}
function GanttLinksComponent_For_2_Conditional_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElementStart(0, "marker", 5);
    \u0275\u0275domElement(1, "path", 6);
    \u0275\u0275domElementEnd();
  }
  if (rf & 2) {
    const ctx_r5 = \u0275\u0275nextContext(2);
    const link_r2 = ctx_r5.$implicit;
    const \u0275$index_3_r5 = ctx_r5.$index;
    \u0275\u0275domProperty("id", "triangle" + \u0275$index_3_r5);
    \u0275\u0275advance();
    \u0275\u0275attribute("fill", link_r2.color)("stroke", link_r2.color);
  }
}
function GanttLinksComponent_For_2_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElementStart(0, "defs");
    \u0275\u0275conditionalCreate(1, GanttLinksComponent_For_2_Conditional_4_Conditional_1_Template, 2, 3, ":svg:marker", 4)(2, GanttLinksComponent_For_2_Conditional_4_Conditional_2_Template, 2, 3, ":svg:marker", 5);
    \u0275\u0275domElementEnd();
  }
  if (rf & 2) {
    const link_r2 = \u0275\u0275nextContext().$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275conditional(link_r2.type === ctx_r2.ganttLinkTypes.sf ? 1 : 2);
  }
}
function GanttLinksComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275namespaceSVG();
    \u0275\u0275domElementContainerStart(0);
    \u0275\u0275domElement(1, "path", 2);
    \u0275\u0275domElementStart(2, "g")(3, "path", 3);
    \u0275\u0275domListener("click", function GanttLinksComponent_For_2_Template_path_click_3_listener($event) {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onLineClick($event, link_r2));
    })("mouseenter", function GanttLinksComponent_For_2_Template_path_mouseenter_3_listener() {
      const ctx_r3 = \u0275\u0275restoreView(_r1);
      const link_r2 = ctx_r3.$implicit;
      const \u0275$index_3_r5 = ctx_r3.$index;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.mouseEnterPath(link_r2, \u0275$index_3_r5));
    })("mouseleave", function GanttLinksComponent_For_2_Template_path_mouseleave_3_listener() {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.mouseLeavePath(link_r2));
    });
    \u0275\u0275domElementEnd()();
    \u0275\u0275conditionalCreate(4, GanttLinksComponent_For_2_Conditional_4_Template, 3, 1, ":svg:defs");
    \u0275\u0275domElementContainerEnd();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const \u0275$index_3_r5 = ctx.$index;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275attribute("d", link_r2.path)("stroke", link_r2.color)("style", link_r2.type === ctx_r2.ganttLinkTypes.sf ? "marker-start: url(#triangle" + \u0275$index_3_r5 + ")" : "marker-end: url(#triangle" + \u0275$index_3_r5 + ")", \u0275\u0275sanitizeStyle);
    \u0275\u0275advance(2);
    \u0275\u0275attribute("d", link_r2.path);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r2.showArrow ? 4 : -1);
  }
}
var GanttLinksComponent = class _GanttLinksComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.cdr = inject(ChangeDetectorRef);
    this.elementRef = inject(ElementRef);
    this.ganttDragContainer = inject(GanttDragContainer);
    this.flatItems = input([], ...ngDevMode ? [{ debugName: "flatItems" }] : []);
    this.lineClick = output();
    this.links = [];
    this.ganttLinkTypes = GanttLinkType;
    this.showArrow = false;
    this.linkItems = [];
    this.unsubscribe$ = new Subject();
    this.ganttLinksOverlay = true;
    effect(() => {
      this.buildLinks();
    });
  }
  ngOnInit() {
    const linkOptions = this.ganttUpper.linkOptions();
    this.linkLine = createLineGenerator(linkOptions.lineType, this.ganttUpper);
    this.showArrow = linkOptions.showArrow;
    this.ganttDragContainer.dragStarted.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.elementRef.nativeElement.style.visibility = "hidden";
    });
    merge(outputToObservable(this.ganttUpper.viewChange), outputToObservable(this.ganttUpper.expandChange), this.ganttUpper.view.start$, outputToObservable(this.ganttUpper.dragEnded), this.ganttUpper.linkDragEnded ? outputToObservable(this.ganttUpper.linkDragEnded) : EMPTY, outputToObservable(this.ganttUpper.table()?.dragDropped) || EMPTY).pipe(skip(1), debounceTime(0), takeUntil(this.unsubscribe$)).subscribe(() => {
      this.elementRef.nativeElement.style.visibility = "visible";
      this.buildLinks();
      this.cdr.detectChanges();
    });
  }
  computeItemPosition() {
    const rowHeight = this.ganttUpper.styles().rowHeight;
    const barHeight = this.ganttUpper.styles().barHeight;
    this.linkItems = [];
    this.flatItems().forEach((item, itemIndex) => {
      if (!item.hasOwnProperty("items")) {
        const ganttItem = item;
        if (ganttItem.refs && ganttItem.refs.width > 0) {
          const y = itemIndex * rowHeight + ganttItem.refs.y + barHeight / 2;
          this.linkItems.push(__spreadProps(__spreadValues({}, ganttItem), {
            before: {
              x: ganttItem.refs.x,
              y
            },
            after: {
              x: ganttItem.refs.x + ganttItem.refs.width,
              y
            }
          }));
        }
      }
    });
  }
  buildLinks() {
    this.computeItemPosition();
    this.links = [];
    this.linkItems.forEach((source) => {
      if (source.origin.start || source.origin.end) {
        source.links.forEach((link) => {
          const target = this.linkItems.find((item) => item.id === link.link);
          if (target && (target.origin.start || target.origin.end)) {
            const linkColors = {
              default: this.ganttUpper.colors().gray[600],
              active: this.ganttUpper.colors().primary,
              blocked: this.ganttUpper.colors().danger
            };
            let defaultColor = linkColors.default;
            let activeColor = linkColors.active;
            if (link.type === GanttLinkType.ff && source.end.getTime() > target.end.getTime()) {
              defaultColor = linkColors.blocked;
              activeColor = linkColors.blocked;
            } else if (link.type === GanttLinkType.fs && source.end.getTime() > target.start.getTime()) {
              defaultColor = linkColors.blocked;
              activeColor = linkColors.blocked;
            } else if (link.type === GanttLinkType.sf && source.start.getTime() > target.end.getTime()) {
              defaultColor = linkColors.blocked;
              activeColor = linkColors.blocked;
            } else if (link.type === GanttLinkType.ss && source.start.getTime() > target.start.getTime()) {
              defaultColor = linkColors.blocked;
              activeColor = linkColors.blocked;
            }
            if (link.color) {
              if (typeof link.color === "string") {
                defaultColor = link.color;
                activeColor = link.color;
              } else {
                defaultColor = link.color.default;
                activeColor = link.color.active;
              }
            }
            this.links.push({
              path: this.linkLine.generatePath(source, target, link.type),
              source: source.origin,
              target: target.origin,
              type: link.type,
              color: defaultColor,
              defaultColor,
              activeColor
            });
          }
        });
      }
    });
  }
  trackBy(index2) {
    return index2;
  }
  onLineClick(event, link) {
    this.lineClick.emit({
      event,
      source: link.source,
      target: link.target
    });
  }
  mouseEnterPath(link, index2) {
    link.color = link.activeColor || link.defaultColor;
    if (index2 < this.links.length - 1) {
      this.links.splice(index2, 1);
      this.links.push(link);
    }
  }
  mouseLeavePath(link) {
    link.color = link.defaultColor;
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  static {
    this.\u0275fac = function GanttLinksComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttLinksComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttLinksComponent, selectors: [["gantt-links-overlay"]], hostVars: 2, hostBindings: function GanttLinksComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-links-overlay", ctx.ganttLinksOverlay);
      }
    }, inputs: { flatItems: [1, "flatItems"] }, outputs: { lineClick: "lineClick" }, decls: 4, vars: 1, consts: [[1, "gantt-links-overlay-main"], [1, "link-dragging-line"], ["fill", "transparent", "stroke-width", "2", "pointer-events", "none"], ["stroke", "transparent", "stroke-width", "9", "fill", "none", "cursor", "pointer", 1, "link-line", 3, "click", "mouseenter", "mouseleave"], ["markerUnits", "strokeWidth", "markerWidth", "5", "markerHeight", "4", "refX", "5", "refY", "2", "orient", "180", 3, "id"], ["markerUnits", "strokeWidth", "markerWidth", "5", "markerHeight", "4", "refX", "5", "refY", "2", "orient", "auto", 3, "id"], ["d", "M 0 0 L 5 2 L 0 4 z"]], template: function GanttLinksComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275namespaceSVG();
        \u0275\u0275domElementStart(0, "svg", 0);
        \u0275\u0275repeaterCreate(1, GanttLinksComponent_For_2_Template, 5, 5, ":svg:ng-container", null, ctx.trackBy, true);
        \u0275\u0275domElement(3, "line", 1);
        \u0275\u0275domElementEnd();
      }
      if (rf & 2) {
        \u0275\u0275attribute("width", ctx.ganttUpper.view.width);
        \u0275\u0275advance();
        \u0275\u0275repeater(ctx.links);
      }
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttLinksComponent, [{
    type: Component,
    args: [{ selector: "gantt-links-overlay", imports: [], template: `<svg [attr.width]="ganttUpper.view.width" class="gantt-links-overlay-main">
  @for (link of links; track trackBy(i); let i = $index) {
    <ng-container>
      <path
        [attr.d]="link.path"
        fill="transparent"
        stroke-width="2"
        [attr.stroke]="link.color"
        pointer-events="none"
        [attr.style]="link.type === ganttLinkTypes.sf ? 'marker-start: url(#triangle' + i + ')' : 'marker-end: url(#triangle' + i + ')'"
      ></path>
      <g>
        <path
          class="link-line"
          (click)="onLineClick($event, link)"
          [attr.d]="link.path"
          (mouseenter)="mouseEnterPath(link, i)"
          (mouseleave)="mouseLeavePath(link)"
          stroke="transparent"
          stroke-width="9"
          fill="none"
          cursor="pointer"
        ></path>
      </g>
      @if (showArrow) {
        <defs>
          @if (link.type === ganttLinkTypes.sf) {
            <marker [id]="'triangle' + i" markerUnits="strokeWidth" markerWidth="5" markerHeight="4" refX="5" refY="2" orient="180">
              <path [attr.fill]="link.color" [attr.stroke]="link.color" d="M 0 0 L 5 2 L 0 4 z" />
            </marker>
          } @else {
            <marker [id]="'triangle' + i" markerUnits="strokeWidth" markerWidth="5" markerHeight="4" refX="5" refY="2" orient="auto">
              <path [attr.fill]="link.color" [attr.stroke]="link.color" d="M 0 0 L 5 2 L 0 4 z" />
            </marker>
          }
        </defs>
      }
    </ng-container>
  }
  <line class="link-dragging-line"></line>
</svg>
` }]
  }], () => [], { flatItems: [{ type: Input, args: [{ isSignal: true, alias: "flatItems", required: false }] }], lineClick: [{ type: Output, args: ["lineClick"] }], ganttLinksOverlay: [{
    type: HostBinding,
    args: ["class.gantt-links-overlay"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttLinksComponent, { className: "GanttLinksComponent", filePath: "packages/gantt/src/components/links/links.component.ts", lineNumber: 19 });
})();

// packages/gantt/src/components/icon/icons.ts
var angleRight = `<svg xmlns="http://www.w3.org/2000/svg" fit=""  preserveAspectRatio="xMidYMid meet" focusable="false"><g id="amnavigation/angle-right" stroke-width="1" fill-rule="evenodd"><path d="M7.978 11.498l-.005.005L2.3 5.831 3.13 5l4.848 4.848L12.826 5l.83.831-5.673 5.672-.005-.005z"   transform="rotate(-90 7.978 8.252)"></path></g></svg>`;
var angleDown = `<svg xmlns="http://www.w3.org/2000/svg" fit=""  preserveAspectRatio="xMidYMid meet" focusable="false"><g id="aknavigation/angle-down" stroke-width="1" fill-rule="evenodd"><path d="M7.978 11.997l-.005.006L2.3 6.33l.83-.831 4.848 4.848L12.826 5.5l.83.83-5.673 5.673-.005-.006z" ></path></g></svg>`;
var plusSquare = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit=""   preserveAspectRatio="xMidYMid meet" focusable="false"><g id="kxaction/plus-square" stroke-width="1" fill-rule="evenodd"><path d="M2 0h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2zm0 1.2a.8.8 0 0 0-.8.8v12a.8.8 0 0 0 .8.8h12a.8.8 0 0 0 .8-.8V2a.8.8 0 0 0-.8-.8H2zm5.45 6.2V4.75h1.2V7.4h2.65v1.2H8.65v2.65h-1.2V8.6H4.8V7.4h2.65z"></path></g></svg>`;
var minusSquare = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="jnaction/minus-square" stroke-width="1" fill-rule="evenodd"><path d="M2 0h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2zm0 1.2a.8.8 0 0 0-.8.8v12a.8.8 0 0 0 .8.8h12a.8.8 0 0 0 .8-.8V2a.8.8 0 0 0-.8-.8H2zm2.8 6.2h6.5v1.2H4.8V7.4z"></path></g></svg>`;
var loadingIcon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve">
<path fill="#aaa" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)">
    <animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform>
</path>
</svg>`;
var emptyIcon = `<svg
width="148px"
height="134px"
viewBox="0 0 148 134"
version="1.1"
xmlns="http://www.w3.org/2000/svg"
xmlns:xlink="http://www.w3.org/1999/xlink"
>
<defs>
  <filter x="0.0%" y="0.0%" width="100.0%" height="100.0%" filterUnits="objectBoundingBox" id="filter-1">
    <feGaussianBlur stdDeviation="0" in="SourceGraphic"></feGaussianBlur>
  </filter>
</defs>
<g id="148x134" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
  <g id="\u7F16\u7EC4-6" transform="translate(1.000000, 1.000000)">
    <ellipse
      id="\u692D\u5706\u5F62"
      fill="#EDEEF2"
      opacity="0.3"
      filter="url(#filter-1)"
      cx="73.0800017"
      cy="115.920003"
      rx="73.0800017"
      ry="16.8000004"
    ></ellipse>
    <g id="\u7F16\u7EC4-5" transform="translate(15.120000, 0.000000)">
      <polygon
        id="\u77E9\u5F62"
        fill="#E2E4E9"
        points="19.2789848 49.5600011 99.1200023 48.7200011 117.600003 75.9297673 117.600003 92.313049 0 92.313049 0 75.0356267"
      ></polygon>
      <path
        d="M23.5200005,0 L94.0800002,0 C97.7913538,2.06413823e-16 100.8,3.00864655 100.8,6.72000015 L100.8,99.1200023 L100.8,99.1200023 L16.8000004,99.1200023 L16.8000004,6.72000015 C16.8000004,3.00864655 19.8086469,1.56994302e-15 23.5200005,0 Z"
        id="\u77E9\u5F62"
        fill="#F9FAFB"
      ></path>
      <path
        d="M30.9200007,12.4400003 L86.6800019,12.4400003 C88.5356787,12.4400003 90.040002,13.9443236 90.040002,15.8000004 L90.040002,42.000001 C90.040002,43.8556778 88.5356787,45.360001 86.6800019,45.360001 L30.9200007,45.360001 C29.0643239,45.360001 27.5600006,43.8556778 27.5600006,42.000001 L27.5600006,15.8000004 C27.5600006,13.9443236 29.0643239,12.4400003 30.9200007,12.4400003 Z"
        id="\u77E9\u5F62"
        fill="#E8EAEE"
      ></path>
      <text
        id="&lt;/null&gt;"
        font-family="PingFangSC-Medium, PingFang SC"
        font-size="15.1200003"
        font-weight="400"
        fill="#BCBECD"
      >
        <tspan x="33.6000008" y="32.8000004">&lt;/null&gt;</tspan>
      </text>
      <rect id="\u77E9\u5F62" fill="#E8EAEE" x="27.5600006" y="52.0800012" width="61.4800014" height="5.04000011" rx="2.52000006"></rect>
      <rect
        id="\u77E9\u5F62\u5907\u4EFD"
        fill="#E8EAEE"
        x="27.5600006"
        y="63.8400014"
        width="61.4800014"
        height="5.04000011"
        rx="2.52000006"
      ></rect>
      <path
        d="M0,75.6000017 L29.280235,75.6000017 C32.0637502,75.6000017 34.3202352,77.8564866 34.3202352,80.6400018 L34.3202352,86.2591426 C34.3202352,89.0426578 36.5767201,91.2991427 39.3602353,91.2991427 L78.4136737,91.2991427 C81.1971889,91.2991427 83.4536738,89.0426578 83.4536738,86.2591426 L83.4536738,80.6400018 C83.4536738,77.8564866 85.7101587,75.6000017 88.4936739,75.6000017 L117.600003,75.6000017 L117.600003,75.6000017 L117.600003,110.880003 C117.600003,115.519195 113.839194,119.280003 109.200002,119.280003 L8.40000019,119.280003 C3.76080819,119.280003 -6.53729019e-15,115.519195 0,110.880003 L0,75.6000017 L0,75.6000017 Z"
        id="\u77E9\u5F62"
        fill="#EDEFF2"
      ></path>
    </g>
  </g>
</g>
</svg>`;
var dragIcon = `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="aijaction/drag--" stroke-width="1" fill-rule="evenodd"><g id="aij\u62D6\u52A8" transform="translate(5 1)" fill-rule="nonzero"><path d="M1 2a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm4 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2zM1 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm4 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm-4 4a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm4 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm-4 4a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm4 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2z" id="aij\u5F62\u72B6\u7ED3\u5408"></path></g></g></svg>`;
var arrowLeftIcon = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="adinavigation/arrow-left" stroke-width="1" fill-rule="evenodd"><path d="M7.4 4.15L4.438 7.315a.6.6 0 0 1-.876-.82l3.97-4.243a.598.598 0 0 1 .93-.057l3.97 4.323a.6.6 0 1 1-.885.812L8.6 4.118v9.149c0 .404-.269.733-.6.733-.332 0-.6-.329-.6-.733V4.15z" id="adi\u5F62\u72B6\u7ED3\u5408" transform="rotate(-90 7.995 8)"></path></g></svg>`;
var arrowRightIcon = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="adlnavigation/arrow-right" stroke-width="1" fill-rule="evenodd"><path d="M7.4 4.15L4.438 7.315a.6.6 0 0 1-.876-.82l3.97-4.243a.598.598 0 0 1 .93-.057l3.97 4.323a.6.6 0 1 1-.885.812L8.6 4.118v9.149c0 .404-.269.733-.6.733-.332 0-.6-.329-.6-.733V4.15z" id="adl\u5F62\u72B6\u7ED3\u5408" transform="rotate(90 7.995 8)"></path></g></svg>`;
var icons = {
  "angle-right": angleRight,
  "angle-down": angleDown,
  "plus-square": plusSquare,
  "minus-square": minusSquare,
  loading: loadingIcon,
  empty: emptyIcon,
  drag: dragIcon,
  "arrow-left": arrowLeftIcon,
  "arrow-right": arrowRightIcon
};

// packages/gantt/src/components/icon/icon.component.ts
var GanttIconComponent = class _GanttIconComponent {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.isIcon = true;
    this.iconName = input(...ngDevMode ? [void 0, { debugName: "iconName" }] : []);
    effect(() => {
      this.setSvg(this.iconName());
    });
  }
  setSvg(name) {
    const iconSvg = icons[name];
    if (iconSvg) {
      this.elementRef.nativeElement.innerHTML = iconSvg;
    } else {
      this.elementRef.nativeElement.innerHTML = "";
    }
  }
  static {
    this.\u0275fac = function GanttIconComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttIconComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttIconComponent, selectors: [["gantt-icon"]], hostVars: 2, hostBindings: function GanttIconComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-icon", ctx.isIcon);
      }
    }, inputs: { iconName: [1, "iconName"] }, decls: 0, vars: 0, template: function GanttIconComponent_Template(rf, ctx) {
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttIconComponent, [{
    type: Component,
    args: [{
      selector: "gantt-icon",
      template: ""
    }]
  }], () => [], { isIcon: [{
    type: HostBinding,
    args: ["class.gantt-icon"]
  }], iconName: [{ type: Input, args: [{ isSignal: true, alias: "iconName", required: false }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttIconComponent, { className: "GanttIconComponent", filePath: "packages/gantt/src/components/icon/icon.component.ts", lineNumber: 8 });
})();

// packages/gantt/src/components/main/gantt-main.component.ts
var GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Defer_2_DepsFn = () => [import("./range.component-D6J2OQHO.js").then((m) => m.NgxGanttRangeComponent)];
var GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Defer_2_DepsFn = () => [import("./bar.component-GR2NSYV5.js").then((m) => m.NgxGanttBarComponent)];
var _c022 = (a0) => ({ group: a0 });
var _c111 = (a0, a1, a2, a3) => ({ item: a0, refs: a1, baseline: a2, baselineRefs: a3 });
var _c28 = (a0) => ({ "gantt-quick-time-focus-item-hide": a0 });
function GanttMainComponent_For_3_Conditional_0_ng_template_1_Template(rf, ctx) {
}
function GanttMainComponent_For_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275template(1, GanttMainComponent_For_3_Conditional_0_ng_template_1_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", data_r1.class);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.groupHeaderTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(3, _c022, data_r1));
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_1_ng_template_0_Template(rf, ctx) {
}
function GanttMainComponent_For_3_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, GanttMainComponent_For_3_Conditional_2_Conditional_1_ng_template_0_Template, 0, 0, "ng-template", 5);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.itemTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction4(2, _c111, data_r1.origin, data_r1.refs, ctx_r1.ganttUpper.baselineItemsMap[data_r1.id] == null ? null : ctx_r1.ganttUpper.baselineItemsMap[data_r1.id].origin, ctx_r1.ganttUpper.baselineItemsMap[data_r1.id] == null ? null : ctx_r1.ganttUpper.baselineItemsMap[data_r1.id].refs));
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-range", 8);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("template", ctx_r1.rangeTemplate())("item", data_r1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-bar-placeholder", 9);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(4).$implicit;
    \u0275\u0275property("item", data_r1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domTemplate(0, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Defer_0_Template, 1, 2)(1, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_DeferPlaceholder_1_Template, 1, 1);
    \u0275\u0275defer(2, 0, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Defer_2_DepsFn, null, 1);
    \u0275\u0275deferOnViewport(0, -1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Defer_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "gantt-bar", 10);
    \u0275\u0275listener("barClick", function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Defer_0_Template_gantt_bar_barClick_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.barClick.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("item", data_r1)("template", ctx_r1.barTemplate());
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_DeferPlaceholder_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-bar-placeholder", 11);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(4).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("height", ctx_r1.ganttUpper.styles().lineHeight, "px");
    \u0275\u0275property("item", data_r1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275domTemplate(0, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Defer_0_Template, 1, 2)(1, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_DeferPlaceholder_1_Template, 1, 3);
    \u0275\u0275defer(2, 0, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Defer_2_DepsFn, null, 1);
    \u0275\u0275deferOnViewport(0, -1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-baseline", 7);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("baselineItem", ctx_r1.ganttUpper.baselineItemsMap[data_r1.id])("template", ctx_r1.baselineTemplate());
  }
}
function GanttMainComponent_For_3_Conditional_2_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_0_Template, 4, 0);
    \u0275\u0275pipe(1, "isGanttRangeItem");
    \u0275\u0275conditionalCreate(2, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_2_Template, 4, 0);
    \u0275\u0275pipe(3, "isGanttBarItem");
    \u0275\u0275conditionalCreate(4, GanttMainComponent_For_3_Conditional_2_Conditional_3_Conditional_4_Template, 1, 2, "gantt-baseline", 7);
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 3, data_r1.type) ? 0 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(\u0275\u0275pipeBind1(3, 5, data_r1.type) ? 2 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r1.ganttUpper.baselineItemsMap[data_r1.id] ? 4 : -1);
  }
}
function GanttMainComponent_For_3_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 6);
    \u0275\u0275conditionalCreate(1, GanttMainComponent_For_3_Conditional_2_Conditional_1_Template, 1, 7, null, 5);
    \u0275\u0275pipe(2, "isGanttCustomItem");
    \u0275\u0275conditionalCreate(3, GanttMainComponent_For_3_Conditional_2_Conditional_3_Template, 5, 7);
    \u0275\u0275pipe(4, "isGanttRangeItem");
    \u0275\u0275pipe(5, "isGanttBarItem");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const data_r1 = \u0275\u0275nextContext().$implicit;
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleMap(data_r1.laneStyle);
    \u0275\u0275classProp("gantt-main-item-active", ctx_r1.ganttUpper.isSelected(data_r1.id));
    \u0275\u0275advance();
    \u0275\u0275conditional(\u0275\u0275pipeBind1(2, 6, data_r1.type) ? 1 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(\u0275\u0275pipeBind1(4, 8, data_r1.type) || \u0275\u0275pipeBind1(5, 10, data_r1.type) ? 3 : -1);
  }
}
function GanttMainComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttMainComponent_For_3_Conditional_0_Template, 2, 5, "div", 3);
    \u0275\u0275pipe(1, "isGanttGroup");
    \u0275\u0275conditionalCreate(2, GanttMainComponent_For_3_Conditional_2_Template, 6, 12, "div", 4);
    \u0275\u0275pipe(3, "isGanttGroup");
  }
  if (rf & 2) {
    const data_r1 = ctx.$implicit;
    \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 2, data_r1) ? 0 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!\u0275\u0275pipeBind1(3, 4, data_r1) ? 2 : -1);
  }
}
function GanttMainComponent_Conditional_4_For_3_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 18);
    \u0275\u0275listener("click", function GanttMainComponent_Conditional_4_For_3_Conditional_3_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r4);
      \u0275\u0275nextContext();
      const item_r5 = \u0275\u0275readContextLet(0);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.quickTime(item_r5.origin, "left"));
    });
    \u0275\u0275element(1, "gantt-icon", 19);
    \u0275\u0275elementEnd();
  }
}
function GanttMainComponent_Conditional_4_For_3_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    const _r6 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 18);
    \u0275\u0275listener("click", function GanttMainComponent_Conditional_4_For_3_Conditional_5_Template_a_click_0_listener() {
      \u0275\u0275restoreView(_r6);
      \u0275\u0275nextContext();
      const item_r5 = \u0275\u0275readContextLet(0);
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.quickTime(item_r5.origin, "right"));
    });
    \u0275\u0275element(1, "gantt-icon", 20);
    \u0275\u0275elementEnd();
  }
}
function GanttMainComponent_Conditional_4_For_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275declareLet(0);
    \u0275\u0275elementStart(1, "div", 14)(2, "span", 15);
    \u0275\u0275conditionalCreate(3, GanttMainComponent_Conditional_4_For_3_Conditional_3_Template, 2, 0, "a", 16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "span", 17);
    \u0275\u0275conditionalCreate(5, GanttMainComponent_Conditional_4_For_3_Conditional_5_Template, 2, 0, "a", 16);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const data_r7 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    const item_r8 = \u0275\u0275storeLet(ctx_r1.toItemType(data_r7));
    \u0275\u0275advance();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(4, _c28, !(item_r8 == null ? null : item_r8.refs == null ? null : item_r8.refs.width)));
    \u0275\u0275advance(2);
    \u0275\u0275conditional((item_r8.refs == null ? null : item_r8.refs.x) < ctx_r1.dom.visibleRangeX().min && (item_r8.refs == null ? null : item_r8.refs.width) ? 3 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional((item_r8.refs == null ? null : item_r8.refs.x) + (item_r8.refs == null ? null : item_r8.refs.width) > ctx_r1.dom.visibleRangeX().max && (item_r8.refs == null ? null : item_r8.refs.width) ? 5 : -1);
  }
}
function GanttMainComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12)(1, "div", 13);
    \u0275\u0275repeaterCreate(2, GanttMainComponent_Conditional_4_For_3_Template, 6, 6, "div", 14, \u0275\u0275componentInstance().trackBy, true);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r1.ganttUpper.view.width, "px");
    \u0275\u0275advance();
    \u0275\u0275styleProp("width", ctx_r1.dom.visibleRangeX().max - ctx_r1.dom.visibleRangeX().min, "px");
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.viewportItems());
  }
}
var GanttMainComponent = class _GanttMainComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.dom = inject(GanttDomService);
    this.ngZone = inject(NgZone);
    this.viewportItems = input(void 0, ...ngDevMode ? [{ debugName: "viewportItems" }] : []);
    this.flatItems = input(void 0, ...ngDevMode ? [{ debugName: "flatItems" }] : []);
    this.groupHeaderTemplate = input(void 0, ...ngDevMode ? [{ debugName: "groupHeaderTemplate" }] : []);
    this.itemTemplate = input(void 0, ...ngDevMode ? [{ debugName: "itemTemplate" }] : []);
    this.barTemplate = input(void 0, ...ngDevMode ? [{ debugName: "barTemplate" }] : []);
    this.rangeTemplate = input(void 0, ...ngDevMode ? [{ debugName: "rangeTemplate" }] : []);
    this.baselineTemplate = input(void 0, ...ngDevMode ? [{ debugName: "baselineTemplate" }] : []);
    this.ganttRoot = input(void 0, ...ngDevMode ? [{ debugName: "ganttRoot" }] : []);
    this.quickTimeFocus = input(void 0, ...ngDevMode ? [{ debugName: "quickTimeFocus" }] : []);
    this.barClick = output();
    this.lineClick = output();
    this.ganttMainClass = true;
    this.unsubscribe$ = new Subject();
    afterNextRender(() => {
      this.ngZone.runOutsideAngular(() => {
        this.setupResize();
      });
    });
  }
  toItemType(data) {
    return data;
  }
  trackBy(index2, item) {
    return item.id || index2;
  }
  setupResize() {
    combineLatest([this.dom.getResize(), this.dom.getResizeByElement(this.dom.mainContainer)]).pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.dom.setVisibleRangeX();
    });
  }
  quickTime(item, type) {
    const date = type === "left" ? item.start || item.end : item.end || item.start;
    this.ganttRoot().scrollToDate(date);
  }
  static {
    this.\u0275fac = function GanttMainComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttMainComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttMainComponent, selectors: [["gantt-main"]], hostVars: 2, hostBindings: function GanttMainComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-main-container", ctx.ganttMainClass);
      }
    }, inputs: { viewportItems: [1, "viewportItems"], flatItems: [1, "flatItems"], groupHeaderTemplate: [1, "groupHeaderTemplate"], itemTemplate: [1, "itemTemplate"], barTemplate: [1, "barTemplate"], rangeTemplate: [1, "rangeTemplate"], baselineTemplate: [1, "baselineTemplate"], ganttRoot: [1, "ganttRoot"], quickTimeFocus: [1, "quickTimeFocus"] }, outputs: { barClick: "barClick", lineClick: "lineClick" }, decls: 5, vars: 4, consts: [[3, "lineClick", "flatItems"], [1, "gantt-main-groups"], [1, "gantt-quick-time-focus-container", 3, "width"], [1, "gantt-group", 3, "ngClass"], [1, "gantt-item", 3, "style", "gantt-main-item-active"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "gantt-item"], [3, "baselineItem", "template"], [3, "template", "item"], [1, "gantt-bar-placeholder-range", 3, "item"], [3, "barClick", "item", "template"], [3, "item"], [1, "gantt-quick-time-focus-container"], [1, "gantt-quick-time-focus"], [1, "gantt-quick-time-focus-item", 3, "ngClass"], [1, "ml-2"], ["href", "javascript:;", 1, "gantt-quick-time-focus-item-arrow", "link-secondary"], [1, "mr-2"], ["href", "javascript:;", 1, "gantt-quick-time-focus-item-arrow", "link-secondary", 3, "click"], ["iconName", "arrow-left"], ["iconName", "arrow-right"]], template: function GanttMainComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "gantt-links-overlay", 0);
        \u0275\u0275listener("lineClick", function GanttMainComponent_Template_gantt_links_overlay_lineClick_0_listener($event) {
          return ctx.lineClick.emit($event);
        });
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(1, "div", 1);
        \u0275\u0275repeaterCreate(2, GanttMainComponent_For_3_Template, 4, 6, null, null, ctx.trackBy, true);
        \u0275\u0275elementEnd();
        \u0275\u0275conditionalCreate(4, GanttMainComponent_Conditional_4_Template, 4, 4, "div", 2);
      }
      if (rf & 2) {
        \u0275\u0275property("flatItems", ctx.flatItems());
        \u0275\u0275advance();
        \u0275\u0275styleProp("width", ctx.ganttUpper.view.width, "px");
        \u0275\u0275advance();
        \u0275\u0275repeater(ctx.viewportItems());
        \u0275\u0275advance(2);
        \u0275\u0275conditional(ctx.quickTimeFocus() ? 4 : -1);
      }
    }, dependencies: [
      GanttLinksComponent,
      NgClass,
      NgTemplateOutlet,
      NgxGanttBaselineComponent,
      GanttIconComponent,
      NgxGanttPlaceholderComponent,
      IsGanttRangeItemPipe,
      IsGanttBarItemPipe,
      IsGanttCustomItemPipe,
      IsGanttGroupPipe
    ], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadataAsync(GanttMainComponent, () => [import("./range.component-D6J2OQHO.js").then((m) => m.NgxGanttRangeComponent), import("./bar.component-GR2NSYV5.js").then((m) => m.NgxGanttBarComponent)], (NgxGanttRangeComponent2, NgxGanttBarComponent2) => {
    setClassMetadata(GanttMainComponent, [{
      type: Component,
      args: [{ selector: "gantt-main", imports: [
        GanttLinksComponent,
        NgClass,
        NgTemplateOutlet,
        NgxGanttRangeComponent2,
        NgxGanttBarComponent2,
        NgxGanttBaselineComponent,
        IsGanttRangeItemPipe,
        IsGanttBarItemPipe,
        IsGanttCustomItemPipe,
        IsGanttGroupPipe,
        GanttIconComponent,
        NgxGanttPlaceholderComponent
      ], template: `<gantt-links-overlay [flatItems]="flatItems()" (lineClick)="lineClick.emit($event)"></gantt-links-overlay>
<div class="gantt-main-groups" [style.width.px]="ganttUpper.view.width">
  @for (data of viewportItems(); track trackBy($index, data)) {
    @if (data | isGanttGroup) {
      <div class="gantt-group" [ngClass]="data.class">
        <ng-template [ngTemplateOutlet]="groupHeaderTemplate()" [ngTemplateOutletContext]="{ group: data }"></ng-template>
      </div>
    }
    @if (!(data | isGanttGroup)) {
      <div class="gantt-item" [style]="data.laneStyle" [class.gantt-main-item-active]="ganttUpper.isSelected(data.id)">
        @if (data.type | isGanttCustomItem) {
          <ng-template
            [ngTemplateOutlet]="itemTemplate()"
            [ngTemplateOutletContext]="{
              item: data.origin,
              refs: data.refs,
              baseline: ganttUpper.baselineItemsMap[data.id]?.origin,
              baselineRefs: ganttUpper.baselineItemsMap[data.id]?.refs
            }"
          >
          </ng-template>
        }
        @if ((data.type | isGanttRangeItem) || (data.type | isGanttBarItem)) {
          @if (data.type | isGanttRangeItem) {
            @defer (on viewport) {
              <gantt-range [template]="rangeTemplate()" [item]="data"></gantt-range>
            } @placeholder {
              <gantt-bar-placeholder class="gantt-bar-placeholder-range" [item]="data"></gantt-bar-placeholder>
            }
          }
          @if (data.type | isGanttBarItem) {
            @defer (on viewport) {
              <gantt-bar [item]="data" [template]="barTemplate()" (barClick)="barClick.emit($event)"></gantt-bar>
            } @placeholder {
              <gantt-bar-placeholder [item]="data" [style.height.px]="ganttUpper.styles().lineHeight"></gantt-bar-placeholder>
            }
          }
          @if (ganttUpper.baselineItemsMap[data.id]) {
            <gantt-baseline [baselineItem]="ganttUpper.baselineItemsMap[data.id]" [template]="baselineTemplate()"></gantt-baseline>
          }
        }
      </div>
    }
  }
</div>

@if (quickTimeFocus()) {
  <div class="gantt-quick-time-focus-container" [style.width.px]="ganttUpper.view.width">
    <div class="gantt-quick-time-focus" [style.width.px]="dom.visibleRangeX().max - dom.visibleRangeX().min">
      @for (data of viewportItems(); track trackBy(i, data); let i = $index) {
        @let item = toItemType(data);
        <div class="gantt-quick-time-focus-item" [ngClass]="{ 'gantt-quick-time-focus-item-hide': !item?.refs?.width }">
          <span class="ml-2">
            @if (item.refs?.x < dom.visibleRangeX().min && item.refs?.width) {
              <a class="gantt-quick-time-focus-item-arrow link-secondary" href="javascript:;" (click)="quickTime(item.origin, 'left')">
                <gantt-icon iconName="arrow-left"></gantt-icon>
              </a>
            }
          </span>
          <span class="mr-2">
            @if (item.refs?.x + item.refs?.width > dom.visibleRangeX().max && item.refs?.width) {
              <a class="gantt-quick-time-focus-item-arrow link-secondary" href="javascript:;" (click)="quickTime(item.origin, 'right')">
                <gantt-icon iconName="arrow-right"></gantt-icon>
              </a>
            }
          </span>
        </div>
      }
    </div>
  </div>
}
` }]
    }], () => [], { viewportItems: [{ type: Input, args: [{ isSignal: true, alias: "viewportItems", required: false }] }], flatItems: [{ type: Input, args: [{ isSignal: true, alias: "flatItems", required: false }] }], groupHeaderTemplate: [{ type: Input, args: [{ isSignal: true, alias: "groupHeaderTemplate", required: false }] }], itemTemplate: [{ type: Input, args: [{ isSignal: true, alias: "itemTemplate", required: false }] }], barTemplate: [{ type: Input, args: [{ isSignal: true, alias: "barTemplate", required: false }] }], rangeTemplate: [{ type: Input, args: [{ isSignal: true, alias: "rangeTemplate", required: false }] }], baselineTemplate: [{ type: Input, args: [{ isSignal: true, alias: "baselineTemplate", required: false }] }], ganttRoot: [{ type: Input, args: [{ isSignal: true, alias: "ganttRoot", required: false }] }], quickTimeFocus: [{ type: Input, args: [{ isSignal: true, alias: "quickTimeFocus", required: false }] }], barClick: [{ type: Output, args: ["barClick"] }], lineClick: [{ type: Output, args: ["lineClick"] }], ganttMainClass: [{
      type: HostBinding,
      args: ["class.gantt-main-container"]
    }] });
  });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttMainComponent, { className: "GanttMainComponent", filePath: "packages/gantt/src/components/main/gantt-main.component.ts", lineNumber: 34 });
})();

// packages/gantt/src/gantt-abstract.ts
var GANTT_ABSTRACT_TOKEN = new InjectionToken("gantt-abstract-token");

// packages/gantt/src/utils/set-style-with-vendor-prefix.ts
var supports = typeof window !== "undefined" && !!window.CSS && CSS.supports || (() => false);
function setStyleWithVendorPrefix({ element, style: style2, value }) {
  element.style[style2] = value;
  if (supports(`-webkit-${style2}: ${value}`)) {
    element.style[`-webkit-${style2}`] = value;
  }
}

// packages/gantt/src/components/table/header/gantt-table-header.component.ts
var _c023 = ["resizeLine"];
function GanttTableHeaderComponent_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0, 4);
  }
  if (rf & 2) {
    const column_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("ngTemplateOutlet", column_r3.headerTemplateRef());
  }
}
function GanttTableHeaderComponent_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const column_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", column_r3.name(), " ");
  }
}
function GanttTableHeaderComponent_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 7);
    \u0275\u0275conditionalCreate(1, GanttTableHeaderComponent_For_2_Conditional_1_Template, 1, 1, "ng-container", 4)(2, GanttTableHeaderComponent_For_2_Conditional_2_Template, 1, 1);
    \u0275\u0275elementStart(3, "div", 8);
    \u0275\u0275listener("cdkDragMoved", function GanttTableHeaderComponent_For_2_Template_div_cdkDragMoved_3_listener($event) {
      const column_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onResizeMoved($event, column_r3));
    })("cdkDragStarted", function GanttTableHeaderComponent_For_2_Template_div_cdkDragStarted_3_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onResizeStarted($event));
    })("cdkDragEnded", function GanttTableHeaderComponent_For_2_Template_div_cdkDragEnded_3_listener($event) {
      const column_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.onResizeEnded($event, column_r3));
    });
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const column_r3 = ctx.$implicit;
    \u0275\u0275styleProp("width", column_r3.columnWidth());
    \u0275\u0275advance();
    \u0275\u0275conditional(column_r3.headerTemplateRef() ? 1 : 2);
  }
}
function GanttTableHeaderComponent_Conditional_4_ng_template_0_Template(rf, ctx) {
}
function GanttTableHeaderComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, GanttTableHeaderComponent_Conditional_4_ng_template_0_Template, 0, 0, "ng-template", 4);
  }
  if (rf & 2) {
    let tmp_2_0;
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275property("ngTemplateOutlet", ctx_r3.gantt == null ? null : (tmp_2_0 = ctx_r3.gantt.table()) == null ? null : tmp_2_0.settingsSlot());
  }
}
var defaultColumnWidth = 100;
var minColumnWidth = 80;
var GanttTableHeaderComponent = class _GanttTableHeaderComponent {
  constructor() {
    this.elementRef = inject(ElementRef);
    this.gantt = inject(GANTT_ABSTRACT_TOKEN);
    this.tableWidth = 0;
    this.unsubscribe$ = new Subject();
    this.columns = input(...ngDevMode ? [void 0, { debugName: "columns" }] : []);
    this.resizeLineElementRef = viewChild("resizeLine", ...ngDevMode ? [{ debugName: "resizeLineElementRef" }] : []);
    this.className = `gantt-table-header `;
  }
  ngOnInit() {
    this.columnsChange();
    this.columns()?.changes?.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      if (!this.gantt?.table()?.width() && !this.customWidth) {
        this.columnsChange();
      }
    });
  }
  columnsChange() {
    let tableWidth = 0;
    this.columns().forEach((column) => {
      if (!column.columnWidth()) {
        column.columnWidth.set(coerceCssPixelValue(defaultColumnWidth));
      }
      tableWidth += Number(column.columnWidth().replace("px", ""));
    });
    this.tableWidth = this.gantt?.table()?.width() ?? this.customWidth ?? this.getCalcWidth(tableWidth);
    this.gantt.cdr.detectChanges();
  }
  dragFixed(config2) {
    if (config2.movedWidth < config2.minWidth) {
      setStyleWithVendorPrefix({
        element: config2.target,
        style: "transform",
        value: `translate3d(${config2.minWidth - config2.originWidth}px, 0, 0)`
      });
    }
  }
  onResizeStarted(event) {
    const target = event.source.element.nativeElement;
    this.dragStartLeft = target.getBoundingClientRect().left;
  }
  onResizeMoved(event, column) {
    const target = event.source.element.nativeElement;
    const left = target.getBoundingClientRect().left;
    let originWidth;
    let movedWidth;
    let minWidth;
    if (column) {
      originWidth = parseInt(column.columnWidth(), 10);
      movedWidth = originWidth + (left - this.dragStartLeft);
      minWidth = minColumnWidth;
    } else {
      originWidth = this.elementRef.nativeElement.getBoundingClientRect().width;
      movedWidth = originWidth + (left - this.dragStartLeft);
      minWidth = minColumnWidth * this.columns().length;
    }
    this.dragFixed({
      target,
      originWidth,
      movedWidth,
      minWidth
    });
    this.showAuxiliaryLine(event);
  }
  onResizeEnded(event, column) {
    const beforeWidth = parseInt(column.columnWidth(), 10);
    const target = event.source.element.nativeElement;
    const left = target.getBoundingClientRect().left;
    const width = parseInt(column.columnWidth(), 10) + (left - this.dragStartLeft);
    const columnWidth = Math.max(width || 0, minColumnWidth);
    column.columnWidth.set(coerceCssPixelValue(columnWidth));
    if (this.gantt.table()) {
      this.gantt.table()?.columnChanges.emit({ columns: this.columns() });
    }
    this.tableWidth = this.gantt?.table()?.width() ?? this.customWidth ?? this.getCalcWidth(this.tableWidth - beforeWidth + columnWidth);
    this.hideAuxiliaryLine();
    event.source.reset();
  }
  onOverallResizeEnded(event) {
    const target = event.source.element.nativeElement;
    const left = target.getBoundingClientRect().left;
    const tableWidth = this.elementRef.nativeElement.getBoundingClientRect().width;
    const dragWidth = left - this.dragStartLeft;
    this.tableWidth = this.getCalcWidth(parseInt(tableWidth + dragWidth, 10));
    this.customWidth = this.tableWidth;
    if (this.gantt.table()) {
      this.gantt.table()?.resizeChange.emit(this.tableWidth);
    }
    this.hideAuxiliaryLine();
    event.source.reset();
  }
  showAuxiliaryLine(event) {
    const tableRect = this.elementRef.nativeElement.getBoundingClientRect();
    const targetRect = event.source.element.nativeElement.getBoundingClientRect();
    const distance = { x: targetRect.left - tableRect.left, y: targetRect.top - tableRect.top };
    const resizeLineElementRef = this.resizeLineElementRef();
    resizeLineElementRef.nativeElement.style.left = `${distance.x}px`;
    resizeLineElementRef.nativeElement.style.display = "block";
  }
  hideAuxiliaryLine() {
    this.resizeLineElementRef().nativeElement.style.display = "none";
  }
  getCalcWidth(width) {
    const maxWidth = this.gantt.table()?.maxWidth();
    return maxWidth && width > maxWidth ? maxWidth : width;
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
    this.unsubscribe$.complete();
  }
  static {
    this.\u0275fac = function GanttTableHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttTableHeaderComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttTableHeaderComponent, selectors: [["gantt-table-header"]], viewQuery: function GanttTableHeaderComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuerySignal(ctx.resizeLineElementRef, _c023, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance();
      }
    }, hostVars: 2, hostBindings: function GanttTableHeaderComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classMap(ctx.className);
      }
    }, inputs: { columns: [1, "columns"] }, decls: 8, vars: 3, consts: [["resizeLine", ""], ["syncScrollX", "ganttTableXScroll", "cdkScrollable", "", 1, "gantt-table-header-container"], [1, "gantt-table-column", 3, "width"], [1, "gantt-table-column", "gantt-table-column-placeholder"], [3, "ngTemplateOutlet"], ["cdkDrag", "", "cdkDragLockAxis", "x", "cdkDragBoundary", ".gantt", 1, "table-resize-handle", 3, "cdkDragMoved", "cdkDragStarted", "cdkDragEnded"], [1, "table-resize-auxiliary-line"], [1, "gantt-table-column"], ["cdkDrag", "", "cdkDragLockAxis", "x", "cdkDragBoundary", ".gantt", 1, "column-resize-handle", 3, "cdkDragMoved", "cdkDragStarted", "cdkDragEnded"]], template: function GanttTableHeaderComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "div", 1);
        \u0275\u0275repeaterCreate(1, GanttTableHeaderComponent_For_2_Template, 4, 3, "div", 2, \u0275\u0275repeaterTrackByIndex);
        \u0275\u0275element(3, "div", 3);
        \u0275\u0275elementEnd();
        \u0275\u0275conditionalCreate(4, GanttTableHeaderComponent_Conditional_4_Template, 1, 1, null, 4);
        \u0275\u0275elementStart(5, "div", 5);
        \u0275\u0275listener("cdkDragMoved", function GanttTableHeaderComponent_Template_div_cdkDragMoved_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onResizeMoved($event));
        })("cdkDragStarted", function GanttTableHeaderComponent_Template_div_cdkDragStarted_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onResizeStarted($event));
        })("cdkDragEnded", function GanttTableHeaderComponent_Template_div_cdkDragEnded_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onOverallResizeEnded($event));
        });
        \u0275\u0275elementEnd();
        \u0275\u0275element(6, "div", 6, 0);
      }
      if (rf & 2) {
        let tmp_3_0;
        \u0275\u0275styleProp("width", ctx.tableWidth, "px");
        \u0275\u0275advance();
        \u0275\u0275repeater(ctx.columns());
        \u0275\u0275advance(3);
        \u0275\u0275conditional((ctx.gantt == null ? null : (tmp_3_0 = ctx.gantt.table()) == null ? null : tmp_3_0.settingsSlot()) ? 4 : -1);
      }
    }, dependencies: [NgTemplateOutlet, CdkDrag, GanttSyncScrollXDirective], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttTableHeaderComponent, [{
    type: Component,
    args: [{ selector: "gantt-table-header", imports: [NgTemplateOutlet, CdkDrag, GanttSyncScrollXDirective], template: '<div class="gantt-table-header-container" syncScrollX="ganttTableXScroll" [style.width.px]="tableWidth" cdkScrollable>\n  @for (column of columns(); track $index) {\n    <div class="gantt-table-column" [style.width]="column.columnWidth()">\n      @if (column.headerTemplateRef()) {\n        <ng-container [ngTemplateOutlet]="column.headerTemplateRef()"> </ng-container>\n      } @else {\n        {{ column.name() }}\n      }\n      <div\n        class="column-resize-handle"\n        cdkDrag\n        cdkDragLockAxis="x"\n        cdkDragBoundary=".gantt"\n        (cdkDragMoved)="onResizeMoved($event, column)"\n        (cdkDragStarted)="onResizeStarted($event)"\n        (cdkDragEnded)="onResizeEnded($event, column)"\n      ></div>\n    </div>\n  }\n  <div class="gantt-table-column gantt-table-column-placeholder"></div>\n</div>\n\n@if (gantt?.table()?.settingsSlot()) {\n  <ng-template [ngTemplateOutlet]="gantt?.table()?.settingsSlot()"></ng-template>\n}\n\n<div\n  class="table-resize-handle"\n  cdkDrag\n  cdkDragLockAxis="x"\n  cdkDragBoundary=".gantt"\n  (cdkDragMoved)="onResizeMoved($event)"\n  (cdkDragStarted)="onResizeStarted($event)"\n  (cdkDragEnded)="onOverallResizeEnded($event)"\n></div>\n\n<div #resizeLine class="table-resize-auxiliary-line"></div>\n' }]
  }], () => [], { columns: [{ type: Input, args: [{ isSignal: true, alias: "columns", required: false }] }], resizeLineElementRef: [{ type: ViewChild, args: ["resizeLine", { isSignal: true }] }], className: [{
    type: HostBinding,
    args: ["class"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttTableHeaderComponent, { className: "GanttTableHeaderComponent", filePath: "packages/gantt/src/components/table/header/gantt-table-header.component.ts", lineNumber: 23 });
})();

// packages/gantt/src/components/table/body/gantt-table-body.component.ts
var _c024 = (a0, a1) => ({ $implicit: a0, group: a1 });
var _c112 = (a0, a1) => ({ $implicit: a0, item: a1 });
function GanttTableBodyComponent_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-icon", 2);
    \u0275\u0275elementStart(1, "div", 3);
    \u0275\u0275text(2, "\u6CA1\u6709\u6570\u636E");
    \u0275\u0275elementEnd();
  }
}
function GanttTableBodyComponent_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function GanttTableBodyComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttTableBodyComponent_Conditional_1_Conditional_0_Template, 3, 0);
    \u0275\u0275template(1, GanttTableBodyComponent_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 1);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(!ctx_r0.emptyTemplate() ? 0 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.emptyTemplate());
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_3_ng_template_0_Template(rf, ctx) {
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_3_ng_template_0_Template, 0, 0, "ng-template", 8);
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.groupTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction2(2, _c024, item_r3.origin, item_r3.origin));
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r3.title);
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 4)(1, "div", 6);
    \u0275\u0275listener("click", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Template_div_click_1_listener() {
      \u0275\u0275restoreView(_r2);
      const item_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.expandGroup(item_r3));
    });
    \u0275\u0275element(2, "gantt-icon", 7);
    \u0275\u0275conditionalCreate(3, GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_3_Template, 1, 5, null, 8)(4, GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Conditional_4_Template, 2, 1, "span", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", item_r3.class);
    \u0275\u0275advance();
    \u0275\u0275classProp("expanded", item_r3.expanded);
    \u0275\u0275advance();
    \u0275\u0275property("iconName", item_r3.expanded ? "angle-down" : "angle-right");
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.groupTemplate() ? 3 : 4);
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_ng_template_2_Template(rf, ctx) {
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-icon", 14);
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("cdkDragHandleDisabled", ctx_r0.draggable() && item_r3.itemDraggable === false || !ctx_r0.draggable());
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "gantt-icon", 19);
    \u0275\u0275listener("click", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Conditional_0_Template_gantt_icon_click_0_listener($event) {
      \u0275\u0275restoreView(_r5);
      const item_r3 = \u0275\u0275nextContext(5).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.expandChildren($event, item_r3));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(5).$implicit;
    \u0275\u0275property("iconName", item_r3.expanded ? "angle-down" : "angle-right");
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-icon", 18);
  }
  if (rf & 2) {
    \u0275\u0275property("iconName", "loading");
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Conditional_0_Template, 1, 1, "gantt-icon", 7);
    \u0275\u0275conditionalCreate(1, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Conditional_1_Template, 1, 1, "gantt-icon", 18);
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(4).$implicit;
    \u0275\u0275conditional(!item_r3.loading ? 0 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r3.loading ? 1 : -1);
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275conditionalCreate(1, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Conditional_1_Template, 2, 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext(3).$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("margin-left", item_r3.level * 20, "px");
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r3.level < ctx_r0.gantt.maxLevel() - 1 && (ctx_r0.gantt.async() && item_r3.expandable || (item_r3.children == null ? null : item_r3.children.length) > 0) ? 1 : -1);
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_ng_template_4_Template(rf, ctx) {
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275conditionalCreate(1, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_1_Template, 1, 1, "gantt-icon", 14);
    \u0275\u0275conditionalCreate(2, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Conditional_2_Template, 2, 3, "div", 15);
    \u0275\u0275elementStart(3, "div", 16);
    \u0275\u0275template(4, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_ng_template_4_Template, 0, 0, "ng-template", 8);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const column_r6 = ctx.$implicit;
    const \u0275$index_36_r7 = ctx.$index;
    const item_r3 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("width", column_r6.columnWidth());
    \u0275\u0275property("classList", column_r6.classList);
    \u0275\u0275advance();
    \u0275\u0275conditional(\u0275$index_36_r7 === 0 && ctx_r0.draggable() ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional((column_r6 == null ? null : column_r6.showExpandIcon()) || !ctx_r0.hasExpandIcon && \u0275$index_36_r7 === 0 ? 2 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", column_r6.templateRef())("ngTemplateOutletContext", \u0275\u0275pureFunction2(7, _c112, item_r3.origin, item_r3.origin));
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_ng_template_6_Template(rf, ctx) {
}
function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275pipe(1, "isGanttRangeItem");
    \u0275\u0275listener("click", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template_div_click_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const item_r3 = \u0275\u0275nextContext().$implicit;
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.itemClick.emit({ event: $event, current: item_r3.origin, selectedValue: item_r3.origin }));
    })("cdkDragStarted", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template_div_cdkDragStarted_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onItemDragStarted($event));
    })("cdkDragEnded", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template_div_cdkDragEnded_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.onItemDragEnded($event));
    })("cdkDragMoved", function GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template_div_cdkDragMoved_0_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r0 = \u0275\u0275nextContext(3);
      return \u0275\u0275resetView(ctx_r0.emitItemDragMoved($event));
    });
    \u0275\u0275template(2, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_ng_template_2_Template, 0, 0, "ng-template", 8);
    \u0275\u0275repeaterCreate(3, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_For_4_Template, 5, 10, "div", 11, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275element(5, "div", 12);
    \u0275\u0275template(6, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_ng_template_6_Template, 0, 0, "ng-template", 8);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("gantt-table-item-with-group", ctx_r0.hasGroup())("gantt-table-item-first-level-group", item_r3.level === 0 && \u0275\u0275pipeBind1(1, 12, item_r3.type))("gantt-table-item-active", ctx_r0.ganttUpper.isSelected(item_r3.id));
    \u0275\u0275property("cdkDragData", item_r3)("cdkDragDisabled", ctx_r0.draggable() && item_r3.itemDraggable === false || !ctx_r0.draggable());
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.rowBeforeTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction2(14, _c112, item_r3.origin, item_r3.origin));
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r0.columns());
    \u0275\u0275advance(3);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.rowAfterTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction2(17, _c112, item_r3.origin, item_r3.origin));
  }
}
function GanttTableBodyComponent_Conditional_2_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, GanttTableBodyComponent_Conditional_2_For_1_Conditional_0_Template, 5, 5, "div", 4);
    \u0275\u0275pipe(1, "isGanttGroup");
    \u0275\u0275conditionalCreate(2, GanttTableBodyComponent_Conditional_2_For_1_Conditional_2_Template, 7, 20, "div", 5);
    \u0275\u0275pipe(3, "isGanttGroup");
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 2, item_r3) ? 0 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!\u0275\u0275pipeBind1(3, 4, item_r3) ? 2 : -1);
  }
}
function GanttTableBodyComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, GanttTableBodyComponent_Conditional_2_For_1_Template, 4, 6, null, null, \u0275\u0275componentInstance().trackBy, true);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275repeater(ctx_r0.viewportItems());
  }
}
var GanttTableBodyComponent = class _GanttTableBodyComponent {
  constructor() {
    this.gantt = inject(GANTT_ABSTRACT_TOKEN);
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.cdr = inject(ChangeDetectorRef);
    this.document = inject(DOCUMENT);
    this.elementRef = inject(ElementRef);
    this.viewportItems = input(...ngDevMode ? [void 0, { debugName: "viewportItems" }] : []);
    this.hasGroup = computed(() => {
      const firstData = this.viewportItems()[0];
      return firstData && firstData.hasOwnProperty("items");
    }, ...ngDevMode ? [{ debugName: "hasGroup" }] : []);
    this.ganttTableEmptyClass = computed(() => !this.viewportItems()?.length, ...ngDevMode ? [{ debugName: "ganttTableEmptyClass" }] : []);
    this.flatItems = input(...ngDevMode ? [void 0, { debugName: "flatItems" }] : []);
    this.columns = input(...ngDevMode ? [void 0, { debugName: "columns" }] : []);
    this.groupTemplate = input(...ngDevMode ? [void 0, { debugName: "groupTemplate" }] : []);
    this.emptyTemplate = input(...ngDevMode ? [void 0, { debugName: "emptyTemplate" }] : []);
    this.rowBeforeTemplate = input(...ngDevMode ? [void 0, { debugName: "rowBeforeTemplate" }] : []);
    this.rowAfterTemplate = input(...ngDevMode ? [void 0, { debugName: "rowAfterTemplate" }] : []);
    this.draggable = input(false, ...ngDevMode ? [{ debugName: "draggable" }] : []);
    this.dropEnterPredicate = input(void 0, ...ngDevMode ? [{ debugName: "dropEnterPredicate" }] : []);
    this.dragDropped = output();
    this.dragStarted = output();
    this.dragEnded = output();
    this.itemClick = output();
    this.hasExpandIcon = false;
    this.itemDragsMap = /* @__PURE__ */ new Map();
    this.itemDragMoved = new Subject();
    this.destroy$ = new Subject();
    this.ganttTableDragging = false;
  }
  ngOnInit() {
    this.columns()?.changes?.pipe(startWith(this.columns()), takeUntil(this.destroy$)).subscribe(() => {
      this.hasExpandIcon = false;
      this.columns().forEach((column) => {
        if (!column.columnWidth()) {
          column.columnWidth.set(coerceCssPixelValue(defaultColumnWidth));
        }
        if (column.showExpandIcon()) {
          this.hasExpandIcon = true;
        }
      });
      this.cdr.detectChanges();
    });
  }
  ngAfterViewInit() {
    this.cdkDrags.changes.pipe(startWith(this.cdkDrags), takeUntil(this.destroy$)).subscribe((drags) => {
      this.itemDragsMap.clear();
      drags.forEach((drag) => {
        if (drag.data) {
          this.itemDragsMap.set(drag.element.nativeElement, drag);
        }
      });
    });
    this.itemDragMoved.pipe(
      auditTime(30),
      //  auditTime 可能会导致拖动结束后仍然执行 moved ，所以通过判断 dragging 状态来过滤无效 moved
      filter((event) => event.source._dragRef.isDragging()),
      takeUntil(this.destroy$)
    ).subscribe((event) => {
      this.onItemDragMoved(event);
    });
  }
  expandGroup(group2) {
    this.gantt.expandGroup(group2);
  }
  expandChildren(event, item) {
    event.stopPropagation();
    this.gantt.expandChildren(item);
  }
  onItemDragStarted(event) {
    this.ganttTableDragging = true;
    const children = this.getChildrenElementsByElement(event.source.element.nativeElement);
    children.forEach((element) => {
      element.classList.add("drag-item-hide");
    });
    this.dragStarted.emit({
      source: event.source.data?.origin,
      sourceParent: this.getParentByItem(event.source.data)?.origin
    });
  }
  emitItemDragMoved(event) {
    this.itemDragMoved.next(event);
  }
  onItemDragMoved(event) {
    let currentPointElement = this.document.elementFromPoint(event.pointerPosition.x, event.pointerPosition.y);
    if (!currentPointElement) {
      this.cleanupDragArtifacts();
      return;
    }
    let targetElement = currentPointElement.classList.contains("gantt-table-item") ? currentPointElement : currentPointElement.closest(".gantt-table-item");
    if (!targetElement) {
      this.cleanupDragArtifacts();
      return;
    }
    this.itemDropTarget = {
      id: this.itemDragsMap.get(targetElement)?.data.id,
      position: this.getTargetPosition(targetElement, event)
    };
    const dropEnterPredicate = this.dropEnterPredicate();
    if (dropEnterPredicate) {
      const targetDragRef = this.itemDragsMap.get(targetElement);
      if (dropEnterPredicate({
        source: event.source.data.origin,
        target: targetDragRef.data.origin,
        dropPosition: this.itemDropTarget.position
      })) {
        this.showDropPositionPlaceholder(targetElement);
      } else {
        this.itemDropTarget = null;
        this.cleanupDragArtifacts(false);
      }
    } else {
      this.showDropPositionPlaceholder(targetElement);
    }
  }
  onItemDragEnded(event) {
    this.ganttTableDragging = false;
    this.dragEnded.emit({
      source: event.source.data?.origin,
      sourceParent: this.getParentByItem(event.source.data)?.origin
    });
    const children = this.getChildrenElementsByElement(event.source.element.nativeElement);
    children.forEach((element) => {
      element.classList.remove("drag-item-hide");
    });
  }
  onListDropped(event) {
    if (!this.itemDropTarget) {
      return;
    }
    const sourceItem = event.item.data;
    const sourceParent = this.getParentByItem(sourceItem);
    const sourceChildren = this.getExpandChildrenByDrag(event.item);
    const targetDragRef = this.cdkDrags.find((item) => item.data?.id === this.itemDropTarget.id);
    const targetItem = targetDragRef?.data;
    const targetParent = this.getParentByItem(targetItem);
    this.removeItem(sourceItem, sourceChildren);
    switch (this.itemDropTarget.position) {
      case "before":
      case "after":
        this.insertItem(targetItem, sourceItem, sourceChildren, this.itemDropTarget.position);
        sourceItem.updateLevel(targetItem.level);
        break;
      case "inside":
        this.insertChildrenItem(targetItem, sourceItem, sourceChildren);
        sourceItem.updateLevel(targetItem.level + 1);
        break;
    }
    this.dragDropped.emit({
      source: sourceItem.origin,
      sourceParent: sourceParent?.origin,
      target: targetItem.origin,
      targetParent: targetParent?.origin,
      dropPosition: this.itemDropTarget.position
    });
    this.cleanupDragArtifacts(true);
  }
  trackBy(index2, item) {
    return item.id || index2;
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  removeItem(item, children) {
    this.viewportItems().splice(this.viewportItems().indexOf(item), 1 + children.length);
    this.flatItems().splice(this.flatItems().indexOf(item), 1 + children.length);
  }
  insertItem(target, inserted, children, position) {
    if (position === "before") {
      this.viewportItems().splice(this.viewportItems().indexOf(target), 0, inserted, ...children);
      this.flatItems().splice(this.flatItems().indexOf(target), 0, inserted, ...children);
    } else {
      const dragRef = this.cdkDrags.find((drag) => drag.data === target);
      let childrenCount = 0;
      if (target.expanded) {
        childrenCount = this.getChildrenElementsByElement(dragRef.element.nativeElement)?.length || 0;
      }
      this.viewportItems().splice(this.viewportItems().indexOf(target) + 1 + childrenCount, 0, inserted, ...children);
      this.flatItems().splice(this.flatItems().indexOf(target) + 1 + childrenCount, 0, inserted, ...children);
    }
  }
  insertChildrenItem(target, inserted, children) {
    if (target.expanded) {
      this.viewportItems().splice(this.viewportItems().indexOf(target) + target.children.length + 1, 0, inserted, ...children);
      this.flatItems().splice(this.flatItems().indexOf(target) + target.children.length + 1, 0, inserted, ...children);
    }
    target.children.push(inserted);
  }
  getParentByItem(item) {
    return (this.flatItems() || []).find((n) => {
      return n.children?.includes(item);
    });
  }
  getExpandChildrenByDrag(dragRef) {
    if (!dragRef.data.expanded) {
      return [];
    } else {
      const childrenElements = this.getChildrenElementsByElement(dragRef.element.nativeElement);
      return childrenElements.map((element) => this.itemDragsMap.get(element).data);
    }
  }
  getChildrenElementsByElement(dragElement) {
    const children = [];
    const dragRef = this.itemDragsMap.get(dragElement);
    let nextElement = (dragRef.getPlaceholderElement() || dragElement).nextElementSibling;
    let nextDragRef = this.itemDragsMap.get(nextElement);
    while (nextDragRef && nextDragRef.data.level > dragRef.data.level) {
      children.push(nextElement);
      nextElement = nextElement.nextElementSibling;
      nextDragRef = this.itemDragsMap.get(nextElement);
    }
    return children;
  }
  getTargetPosition(target, event) {
    const targetRect = target.getBoundingClientRect();
    const beforeOrAfterGap = targetRect.height * 0.3;
    if (event.pointerPosition.y - targetRect.top < beforeOrAfterGap) {
      return "before";
    } else if (event.pointerPosition.y >= targetRect.bottom - beforeOrAfterGap) {
      return "after";
    } else {
      return "inside";
    }
  }
  showDropPositionPlaceholder(targetElement) {
    this.cleanupDragArtifacts();
    if (this.itemDropTarget && targetElement) {
      targetElement.classList.add(`drop-position-${this.itemDropTarget.position}`);
    }
  }
  cleanupDragArtifacts(dropped = false) {
    if (dropped) {
      this.itemDropTarget = null;
      this.document.querySelectorAll(".drag-item-hide").forEach((element) => element.classList.remove("drag-item-hide"));
    }
    this.document.querySelectorAll(".drop-position-before").forEach((element) => element.classList.remove("drop-position-before"));
    this.document.querySelectorAll(".drop-position-after").forEach((element) => element.classList.remove("drop-position-after"));
    this.document.querySelectorAll(".drop-position-inside").forEach((element) => element.classList.remove("drop-position-inside"));
  }
  static {
    this.\u0275fac = function GanttTableBodyComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttTableBodyComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _GanttTableBodyComponent, selectors: [["gantt-table-body"]], viewQuery: function GanttTableBodyComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(CdkDrag, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.cdkDrags = _t);
      }
    }, hostAttrs: [1, "gantt-table-body"], hostVars: 6, hostBindings: function GanttTableBodyComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-table-empty", ctx.ganttTableEmptyClass())("gantt-table-dragging", ctx.ganttTableDragging)("gantt-table-draggable", ctx.draggable());
      }
    }, inputs: { viewportItems: [1, "viewportItems"], flatItems: [1, "flatItems"], columns: [1, "columns"], groupTemplate: [1, "groupTemplate"], emptyTemplate: [1, "emptyTemplate"], rowBeforeTemplate: [1, "rowBeforeTemplate"], rowAfterTemplate: [1, "rowAfterTemplate"], draggable: [1, "draggable"], dropEnterPredicate: [1, "dropEnterPredicate"] }, outputs: { dragDropped: "dragDropped", dragStarted: "dragStarted", dragEnded: "dragEnded", itemClick: "itemClick" }, decls: 3, vars: 5, consts: [["cdkDropList", "", 1, "gantt-table-body-container", 3, "cdkDropListDropped", "cdkDropListAutoScrollStep", "cdkDropListData", "cdkDropListSortingDisabled"], [3, "ngTemplateOutlet"], ["iconName", "empty", 1, "empty-icon"], [1, "empty-text"], [1, "gantt-table-group", 3, "ngClass"], ["cdkDrag", "", 1, "gantt-table-item", 3, "cdkDragData", "cdkDragDisabled", "gantt-table-item-with-group", "gantt-table-item-first-level-group", "gantt-table-item-active"], [1, "gantt-table-group-title", 3, "click"], [1, "expand-icon", 3, "iconName"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "group-title"], ["cdkDrag", "", 1, "gantt-table-item", 3, "click", "cdkDragStarted", "cdkDragEnded", "cdkDragMoved", "cdkDragData", "cdkDragDisabled"], [3, "classList", "width"], [1, "gantt-table-column", "gantt-table-column-placeholder"], [3, "classList"], ["iconName", "drag", "cdkDragHandle", "", 1, "gantt-drag-handle", 3, "cdkDragHandleDisabled"], [1, "gantt-expand-icon", 3, "marginLeft"], [1, "gantt-table-column-content"], [1, "gantt-expand-icon"], [3, "iconName"], [1, "expand-icon", 3, "click", "iconName"]], template: function GanttTableBodyComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0);
        \u0275\u0275listener("cdkDropListDropped", function GanttTableBodyComponent_Template_div_cdkDropListDropped_0_listener($event) {
          return ctx.onListDropped($event);
        });
        \u0275\u0275conditionalCreate(1, GanttTableBodyComponent_Conditional_1_Template, 2, 2);
        \u0275\u0275conditionalCreate(2, GanttTableBodyComponent_Conditional_2_Template, 2, 0);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        let tmp_3_0;
        \u0275\u0275property("cdkDropListAutoScrollStep", 6)("cdkDropListData", ctx.viewportItems())("cdkDropListSortingDisabled", true);
        \u0275\u0275advance();
        \u0275\u0275conditional(!((tmp_3_0 = ctx.viewportItems()) == null ? null : tmp_3_0.length) ? 1 : -1);
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.viewportItems() && ctx.viewportItems().length > 0 ? 2 : -1);
      }
    }, dependencies: [CdkDropList, GanttIconComponent, NgTemplateOutlet, NgClass, CdkDrag, CdkDragHandle, IsGanttRangeItemPipe, IsGanttGroupPipe], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttTableBodyComponent, [{
    type: Component,
    args: [{ selector: "gantt-table-body", host: {
      class: "gantt-table-body",
      "[class.gantt-table-empty]": "ganttTableEmptyClass()",
      "[class.gantt-table-dragging]": "ganttTableDragging",
      "[class.gantt-table-draggable]": "draggable()"
    }, imports: [CdkDropList, GanttIconComponent, NgTemplateOutlet, NgClass, CdkDrag, CdkDragHandle, IsGanttRangeItemPipe, IsGanttGroupPipe], template: `<div
  class="gantt-table-body-container"
  cdkDropList
  [cdkDropListAutoScrollStep]="6"
  [cdkDropListData]="viewportItems()"
  [cdkDropListSortingDisabled]="true"
  (cdkDropListDropped)="onListDropped($event)"
>
  @if (!viewportItems()?.length) {
    @if (!emptyTemplate()) {
      <gantt-icon class="empty-icon" iconName="empty"></gantt-icon>
      <div class="empty-text">\u6CA1\u6709\u6570\u636E</div>
    }
    <ng-template [ngTemplateOutlet]="emptyTemplate()"></ng-template>
  }

  @if (viewportItems() && viewportItems().length > 0) {
    @for (item of viewportItems(); track trackBy($index, item)) {
      @if (item | isGanttGroup) {
        <div class="gantt-table-group" [ngClass]="item.class">
          <div class="gantt-table-group-title" [class.expanded]="item.expanded" (click)="expandGroup(item)">
            <gantt-icon class="expand-icon" [iconName]="item.expanded ? 'angle-down' : 'angle-right'"></gantt-icon>
            @if (groupTemplate()) {
              <ng-template
                [ngTemplateOutlet]="groupTemplate()"
                [ngTemplateOutletContext]="{ $implicit: item.origin, group: item.origin }"
              ></ng-template>
            } @else {
              <span class="group-title">{{ item.title }}</span>
            }
          </div>
        </div>
      }
      @if (!(item | isGanttGroup)) {
        <div
          (click)="itemClick.emit({ event: $event, current: item.origin, selectedValue: item.origin })"
          cdkDrag
          [cdkDragData]="item"
          [cdkDragDisabled]="(draggable() && item.itemDraggable === false) || !draggable()"
          (cdkDragStarted)="onItemDragStarted($event)"
          (cdkDragEnded)="onItemDragEnded($event)"
          (cdkDragMoved)="emitItemDragMoved($event)"
          class="gantt-table-item"
          [class.gantt-table-item-with-group]="hasGroup()"
          [class.gantt-table-item-first-level-group]="item.level === 0 && (item.type | isGanttRangeItem)"
          [class.gantt-table-item-active]="ganttUpper.isSelected(item.id)"
        >
          <ng-template
            [ngTemplateOutlet]="rowBeforeTemplate()"
            [ngTemplateOutletContext]="{ $implicit: item.origin, item: item.origin }"
          ></ng-template>
          @for (column of columns(); track $index; let first = $first) {
            <div [classList]="column.classList" [style.width]="column.columnWidth()">
              <!-- drag icon -->
              @if (first && draggable()) {
                <gantt-icon
                  class="gantt-drag-handle"
                  iconName="drag"
                  cdkDragHandle
                  [cdkDragHandleDisabled]="(draggable() && item.itemDraggable === false) || !draggable()"
                ></gantt-icon>
              }
              <!-- expand icon -->
              @if (column?.showExpandIcon() || (!hasExpandIcon && first)) {
                <div class="gantt-expand-icon" [style.marginLeft.px]="item.level * 20">
                  @if (item.level < gantt.maxLevel() - 1 && ((gantt.async() && item.expandable) || item.children?.length > 0)) {
                    @if (!item.loading) {
                      <gantt-icon
                        class="expand-icon"
                        [iconName]="item.expanded ? 'angle-down' : 'angle-right'"
                        (click)="expandChildren($event, item)"
                      >
                      </gantt-icon>
                    }
                    @if (item.loading) {
                      <gantt-icon [iconName]="'loading'"></gantt-icon>
                    }
                  }
                </div>
              }
              <!-- column content -->
              <div class="gantt-table-column-content">
                <ng-template
                  [ngTemplateOutlet]="column.templateRef()"
                  [ngTemplateOutletContext]="{ $implicit: item.origin, item: item.origin }"
                ></ng-template>
              </div>
            </div>
          }
          <div class="gantt-table-column gantt-table-column-placeholder"></div>
          <ng-template
            [ngTemplateOutlet]="rowAfterTemplate()"
            [ngTemplateOutletContext]="{ $implicit: item.origin, item: item.origin }"
          ></ng-template>
        </div>
      }
    }
  }
</div>
` }]
  }], () => [], { viewportItems: [{ type: Input, args: [{ isSignal: true, alias: "viewportItems", required: false }] }], flatItems: [{ type: Input, args: [{ isSignal: true, alias: "flatItems", required: false }] }], columns: [{ type: Input, args: [{ isSignal: true, alias: "columns", required: false }] }], groupTemplate: [{ type: Input, args: [{ isSignal: true, alias: "groupTemplate", required: false }] }], emptyTemplate: [{ type: Input, args: [{ isSignal: true, alias: "emptyTemplate", required: false }] }], rowBeforeTemplate: [{ type: Input, args: [{ isSignal: true, alias: "rowBeforeTemplate", required: false }] }], rowAfterTemplate: [{ type: Input, args: [{ isSignal: true, alias: "rowAfterTemplate", required: false }] }], draggable: [{ type: Input, args: [{ isSignal: true, alias: "draggable", required: false }] }], dropEnterPredicate: [{ type: Input, args: [{ isSignal: true, alias: "dropEnterPredicate", required: false }] }], dragDropped: [{ type: Output, args: ["dragDropped"] }], dragStarted: [{ type: Output, args: ["dragStarted"] }], dragEnded: [{ type: Output, args: ["dragEnded"] }], itemClick: [{ type: Output, args: ["itemClick"] }], cdkDrags: [{
    type: ViewChildren,
    args: [CdkDrag]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(GanttTableBodyComponent, { className: "GanttTableBodyComponent", filePath: "packages/gantt/src/components/table/body/gantt-table-body.component.ts", lineNumber: 51 });
})();

// packages/gantt/src/root.component.ts
var _c025 = ["sideTemplate"];
var _c113 = ["mainTemplate"];
var _c29 = ["*"];
function NgxGanttRootComponent_Conditional_0_ng_template_2_Template(rf, ctx) {
}
function NgxGanttRootComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3)(1, "div", 4);
    \u0275\u0275template(2, NgxGanttRootComponent_Conditional_0_ng_template_2_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275styleProp("width", ctx_r0.sideWidth(), "px")("padding-bottom", ctx_r0.horizontalScrollbarHeight, "px");
    \u0275\u0275advance(2);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.sideTemplate());
  }
}
function NgxGanttRootComponent_Conditional_1_ng_template_6_Template(rf, ctx) {
}
function NgxGanttRootComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275element(1, "gantt-calendar-header", 6)(2, "gantt-calendar-grid", 6)(3, "gantt-drag-backdrop");
    \u0275\u0275elementStart(4, "div", 7)(5, "div", 8);
    \u0275\u0275template(6, NgxGanttRootComponent_Conditional_1_ng_template_6_Template, 0, 0, "ng-template", 5);
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275styleProp("padding-right", ctx_r0.verticalScrollbarWidth, "px");
    \u0275\u0275advance();
    \u0275\u0275styleProp("padding-right", ctx_r0.verticalScrollbarWidth, "px")("padding-bottom", ctx_r0.horizontalScrollbarHeight, "px");
    \u0275\u0275advance(4);
    \u0275\u0275property("ngTemplateOutlet", ctx_r0.mainTemplate());
  }
}
function NgxGanttRootComponent_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-toolbar", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("template", ctx_r0.ganttUpper.toolbarTemplate());
  }
}
var NgxGanttRootComponent = class _NgxGanttRootComponent {
  get view() {
    return this.ganttUpper.view;
  }
  onWindowResize() {
    this.computeScrollBarOffset();
  }
  constructor() {
    this.elementRef = inject(ElementRef);
    this.ngZone = inject(NgZone);
    this.dom = inject(GanttDomService);
    this.dragContainer = inject(GanttDragContainer);
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.printService = inject(GanttPrintService, { optional: true });
    this.cdr = inject(ChangeDetectorRef);
    this.sideWidth = input(void 0, ...ngDevMode ? [{ debugName: "sideWidth" }] : []);
    this.sideTemplate = contentChild("sideTemplate", ...ngDevMode ? [{ debugName: "sideTemplate" }] : []);
    this.mainTemplate = contentChild("mainTemplate", ...ngDevMode ? [{ debugName: "mainTemplate" }] : []);
    this.backdrop = viewChild(GanttDragBackdropComponent, __spreadProps(__spreadValues({}, ngDevMode ? { debugName: "backdrop" } : {}), { read: ElementRef }));
    this.verticalScrollbarWidth = 0;
    this.horizontalScrollbarHeight = 0;
    this.unsubscribe$ = new Subject();
    const dragContainer = this.dragContainer;
    this.ganttUpper.dragContainer = dragContainer;
    afterNextRender(() => {
      this.ngZone.runOutsideAngular(() => {
        this.dom.initialize(this.elementRef);
        if (this.printService) {
          this.printService.register(this.elementRef);
        }
        this.setupScrollClass();
        this.setupResize();
        this.setupViewScroll();
        this.elementRef.nativeElement.style.opacity = "1";
        outputToObservable(this.ganttUpper.viewChange).pipe(startWith(null), takeUntil(this.unsubscribe$)).subscribe(() => {
          this.scrollToToday();
        });
        this.computeScrollBarOffset();
        this.dom.applyCssVariables(this.elementRef.nativeElement, this.ganttUpper.styles());
      });
    });
  }
  computeScrollBarOffset() {
    const ganttMainContainer = this.dom.mainContainer;
    const ganttVerticalScrollContainer = this.dom.verticalScrollContainer;
    let verticalScrollbarWidth = 0;
    if (ganttVerticalScrollContainer) {
      verticalScrollbarWidth = ganttVerticalScrollContainer.offsetWidth - ganttVerticalScrollContainer.clientWidth;
    } else {
      verticalScrollbarWidth = ganttMainContainer?.offsetWidth - ganttMainContainer?.clientWidth;
    }
    const horizontalScrollbarHeight = ganttMainContainer?.offsetHeight - ganttMainContainer?.clientHeight;
    if (this.verticalScrollbarWidth !== verticalScrollbarWidth || this.horizontalScrollbarHeight !== horizontalScrollbarHeight) {
      this.verticalScrollbarWidth = verticalScrollbarWidth;
      this.horizontalScrollbarHeight = horizontalScrollbarHeight;
      this.cdr.markForCheck();
    }
  }
  ngOnDestroy() {
    this.unsubscribe$.next();
  }
  setupViewScroll() {
    if (this.ganttUpper.disableLoadOnScroll() && !this.ganttUpper.quickTimeFocus()) {
      return;
    }
    this.dom.getViewerScroll(passiveListenerOptions).pipe(takeUntil(this.unsubscribe$)).subscribe((event) => {
      if (event.direction === ScrollDirection.LEFT) {
        const dates = this.ganttUpper.view.extendStart();
        if (dates) {
          const offsetWidth = this.ganttUpper.view.calculateRangeWidth(dates.start, dates.end);
          const currentLeft = this.dom.mainContainer.scrollLeft;
          this.dom.syncHorizontalScroll(currentLeft + offsetWidth);
          this.cdr.markForCheck();
          if (this.ganttUpper.loadOnScroll) {
            this.ngZone.run(() => this.ganttUpper.loadOnScroll.emit({ start: dates.start.getUnixTime(), end: dates.end.getUnixTime() }));
          }
        }
      }
      if (event.direction === ScrollDirection.RIGHT) {
        const dates = this.ganttUpper.view.extendEnd();
        this.cdr.markForCheck();
        if (dates && this.ganttUpper.loadOnScroll) {
          this.ngZone.run(() => this.ganttUpper.loadOnScroll.emit({ start: dates.start.getUnixTime(), end: dates.end.getUnixTime() }));
        }
      }
    });
  }
  setupResize() {
    this.dom.getResize().pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.setupScrollClass();
    });
  }
  setupScrollClass() {
    const mainContainer = this.dom.mainContainer;
    const height = mainContainer.offsetHeight;
    const scrollHeight = mainContainer.scrollHeight;
    if (scrollHeight > height) {
      this.elementRef.nativeElement.className = "gantt gantt-scroll";
    } else {
      this.elementRef.nativeElement.className = "gantt";
    }
  }
  scrollToToday() {
    const x = this.view.getNowX();
    this.dom.scrollMainContainer(x);
  }
  scrollToDate(date) {
    let x;
    if (typeof date === "number" || date instanceof Date) {
      x = this.view.getXAtDate(new GanttDate(date));
    } else {
      x = this.view.getXAtDate(date);
    }
    this.dom.scrollMainContainer(x);
  }
  static {
    this.\u0275fac = function NgxGanttRootComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttRootComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttRootComponent, selectors: [["ngx-gantt-root"]], contentQueries: function NgxGanttRootComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuerySignal(dirIndex, ctx.sideTemplate, _c025, 5)(dirIndex, ctx.mainTemplate, _c113, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance(2);
      }
    }, viewQuery: function NgxGanttRootComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuerySignal(ctx.backdrop, GanttDragBackdropComponent, 5, ElementRef);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance();
      }
    }, hostBindings: function NgxGanttRootComponent_HostBindings(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275listener("resize", function NgxGanttRootComponent_resize_HostBindingHandler() {
          return ctx.onWindowResize();
        }, \u0275\u0275resolveWindow);
      }
    }, inputs: { sideWidth: [1, "sideWidth"] }, features: [\u0275\u0275ProvidersFeature([GanttDomService, GanttDragContainer, GanttSyncScrollService])], ngContentSelectors: _c29, decls: 4, vars: 3, consts: [[1, "gantt-side", 3, "width", "padding-bottom"], [1, "gantt-container"], [3, "template"], [1, "gantt-side"], ["syncScrollX", "ganttTableXScroll", "syncScrollY", "ganttMainYScroll", "cdkScrollable", "", 1, "gantt-side-container"], [3, "ngTemplateOutlet"], ["syncScrollX", "ganttMainXScroll"], [1, "gantt-main"], ["syncScrollX", "ganttMainXScroll", "syncScrollY", "ganttMainYScroll", 1, "gantt-main-container"]], template: function NgxGanttRootComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275projectionDef();
        \u0275\u0275conditionalCreate(0, NgxGanttRootComponent_Conditional_0_Template, 3, 5, "div", 0);
        \u0275\u0275conditionalCreate(1, NgxGanttRootComponent_Conditional_1_Template, 7, 7, "div", 1);
        \u0275\u0275projection(2);
        \u0275\u0275conditionalCreate(3, NgxGanttRootComponent_Conditional_3_Template, 1, 1, "gantt-toolbar", 2);
      }
      if (rf & 2) {
        \u0275\u0275conditional(ctx.sideTemplate() ? 0 : -1);
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.mainTemplate() ? 1 : -1);
        \u0275\u0275advance(2);
        \u0275\u0275conditional(ctx.ganttUpper.showToolbar() || ctx.ganttUpper.toolbarTemplate() ? 3 : -1);
      }
    }, dependencies: [
      CdkScrollable,
      NgTemplateOutlet,
      GanttCalendarHeaderComponent,
      GanttCalendarGridComponent,
      GanttDragBackdropComponent,
      NgxGanttToolbarComponent,
      GanttSyncScrollXDirective,
      GanttSyncScrollYDirective
    ], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttRootComponent, [{
    type: Component,
    args: [{ selector: "ngx-gantt-root", providers: [GanttDomService, GanttDragContainer, GanttSyncScrollService], imports: [
      CdkScrollable,
      NgTemplateOutlet,
      GanttCalendarHeaderComponent,
      GanttCalendarGridComponent,
      GanttDragBackdropComponent,
      NgxGanttToolbarComponent,
      GanttSyncScrollXDirective,
      GanttSyncScrollYDirective
    ], template: '@if (sideTemplate()) {\n  <div class="gantt-side" [style.width.px]="sideWidth()" [style.padding-bottom.px]="horizontalScrollbarHeight">\n    <div class="gantt-side-container" syncScrollX="ganttTableXScroll" syncScrollY="ganttMainYScroll" cdkScrollable>\n      <ng-template [ngTemplateOutlet]="sideTemplate()"></ng-template>\n    </div>\n  </div>\n}\n@if (mainTemplate()) {\n  <div class="gantt-container">\n    <gantt-calendar-header syncScrollX="ganttMainXScroll" [style.padding-right.px]="verticalScrollbarWidth"></gantt-calendar-header>\n    <gantt-calendar-grid\n      syncScrollX="ganttMainXScroll"\n      [style.padding-right.px]="verticalScrollbarWidth"\n      [style.padding-bottom.px]="horizontalScrollbarHeight"\n    ></gantt-calendar-grid>\n    <gantt-drag-backdrop></gantt-drag-backdrop>\n    <div class="gantt-main">\n      <div class="gantt-main-container" syncScrollX="ganttMainXScroll" syncScrollY="ganttMainYScroll">\n        <ng-template [ngTemplateOutlet]="mainTemplate()"></ng-template>\n      </div>\n    </div>\n  </div>\n}\n<ng-content></ng-content>\n@if (ganttUpper.showToolbar() || ganttUpper.toolbarTemplate()) {\n  <gantt-toolbar [template]="ganttUpper.toolbarTemplate()"> </gantt-toolbar>\n}\n' }]
  }], () => [], { sideWidth: [{ type: Input, args: [{ isSignal: true, alias: "sideWidth", required: false }] }], sideTemplate: [{ type: ContentChild, args: ["sideTemplate", { isSignal: true }] }], mainTemplate: [{ type: ContentChild, args: ["mainTemplate", { isSignal: true }] }], backdrop: [{ type: ViewChild, args: [forwardRef(() => GanttDragBackdropComponent), __spreadProps(__spreadValues({}, { read: ElementRef }), { isSignal: true })] }], onWindowResize: [{
    type: HostListener,
    args: ["window:resize"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttRootComponent, { className: "NgxGanttRootComponent", filePath: "packages/gantt/src/root.component.ts", lineNumber: 48 });
})();

// packages/gantt/src/table/gantt-column.component.ts
var _c026 = ["cell"];
var _c114 = ["header"];
var NgxGanttTableColumnComponent = class _NgxGanttTableColumnComponent {
  constructor() {
    this.ganttUpper = inject(GANTT_UPPER_TOKEN);
    this.elementRef = inject(ElementRef);
    this.width = input(...ngDevMode ? [void 0, { debugName: "width" }] : []);
    this.columnWidth = signal("", ...ngDevMode ? [{ debugName: "columnWidth" }] : []);
    this.name = input(...ngDevMode ? [void 0, { debugName: "name" }] : []);
    this.showExpandIcon = input(...ngDevMode ? [void 0, { debugName: "showExpandIcon" }] : []);
    this.templateRef = contentChild("cell", ...ngDevMode ? [{ debugName: "templateRef" }] : []);
    this.headerTemplateRef = contentChild("header", ...ngDevMode ? [{ debugName: "headerTemplateRef" }] : []);
    effect(() => {
      this.columnWidth.set(coerceCssPixelValue(this.width()));
    });
  }
  get classList() {
    return this.elementRef.nativeElement.classList;
  }
  static {
    this.\u0275fac = function NgxGanttTableColumnComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttTableColumnComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttTableColumnComponent, selectors: [["ngx-gantt-column"]], contentQueries: function NgxGanttTableColumnComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuerySignal(dirIndex, ctx.templateRef, _c026, 5)(dirIndex, ctx.headerTemplateRef, _c114, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance(2);
      }
    }, hostAttrs: [1, "gantt-table-column"], inputs: { width: [1, "width"], name: [1, "name"], showExpandIcon: [1, "showExpandIcon"] }, decls: 0, vars: 0, template: function NgxGanttTableColumnComponent_Template(rf, ctx) {
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttTableColumnComponent, [{
    type: Component,
    args: [{
      selector: "ngx-gantt-column",
      template: "",
      host: {
        class: "gantt-table-column"
      }
    }]
  }], () => [], { width: [{ type: Input, args: [{ isSignal: true, alias: "width", required: false }] }], name: [{ type: Input, args: [{ isSignal: true, alias: "name", required: false }] }], showExpandIcon: [{ type: Input, args: [{ isSignal: true, alias: "showExpandIcon", required: false }] }], templateRef: [{ type: ContentChild, args: ["cell", { isSignal: true }] }], headerTemplateRef: [{ type: ContentChild, args: ["header", { isSignal: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttTableColumnComponent, { className: "NgxGanttTableColumnComponent", filePath: "packages/gantt/src/table/gantt-column.component.ts", lineNumber: 24 });
})();

// packages/gantt/src/table/gantt-table.component.ts
var _c027 = ["rowBeforeSlot"];
var _c115 = ["rowAfterSlot"];
var _c210 = ["tableEmpty"];
var _c37 = ["tableFooter"];
var _c47 = ["settingsSlot"];
var NgxGanttTableComponent = class _NgxGanttTableComponent {
  constructor() {
    this.draggable = input(false, ...ngDevMode ? [{ debugName: "draggable" }] : []);
    this.maxWidth = input(void 0, ...ngDevMode ? [{ debugName: "maxWidth" }] : []);
    this.width = input(void 0, ...ngDevMode ? [{ debugName: "width" }] : []);
    this.dropEnterPredicate = input(void 0, ...ngDevMode ? [{ debugName: "dropEnterPredicate" }] : []);
    this.dragDropped = output();
    this.dragStarted = output();
    this.dragEnded = output();
    this.columnChanges = output();
    this.resizeChange = output();
    this.itemClick = output();
    this.rowBeforeTemplate = contentChild("rowBeforeSlot", ...ngDevMode ? [{ debugName: "rowBeforeTemplate" }] : []);
    this.rowAfterTemplate = contentChild("rowAfterSlot", ...ngDevMode ? [{ debugName: "rowAfterTemplate" }] : []);
    this.tableEmptyTemplate = contentChild("tableEmpty", ...ngDevMode ? [{ debugName: "tableEmptyTemplate" }] : []);
    this.tableFooterTemplate = contentChild("tableFooter", ...ngDevMode ? [{ debugName: "tableFooterTemplate" }] : []);
    this.settingsSlot = contentChild("settingsSlot", ...ngDevMode ? [{ debugName: "settingsSlot" }] : []);
  }
  static {
    this.\u0275fac = function NgxGanttTableComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttTableComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttTableComponent, selectors: [["ngx-gantt-table"]], contentQueries: function NgxGanttTableComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuerySignal(dirIndex, ctx.rowBeforeTemplate, _c027, 5)(dirIndex, ctx.rowAfterTemplate, _c115, 5)(dirIndex, ctx.tableEmptyTemplate, _c210, 5)(dirIndex, ctx.tableFooterTemplate, _c37, 5)(dirIndex, ctx.settingsSlot, _c47, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance(5);
      }
    }, inputs: { draggable: [1, "draggable"], maxWidth: [1, "maxWidth"], width: [1, "width"], dropEnterPredicate: [1, "dropEnterPredicate"] }, outputs: { dragDropped: "dragDropped", dragStarted: "dragStarted", dragEnded: "dragEnded", columnChanges: "columnChanges", resizeChange: "resizeChange", itemClick: "itemClick" }, decls: 0, vars: 0, template: function NgxGanttTableComponent_Template(rf, ctx) {
    }, encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttTableComponent, [{
    type: Component,
    args: [{
      selector: "ngx-gantt-table",
      template: ""
    }]
  }], null, { draggable: [{ type: Input, args: [{ isSignal: true, alias: "draggable", required: false }] }], maxWidth: [{ type: Input, args: [{ isSignal: true, alias: "maxWidth", required: false }] }], width: [{ type: Input, args: [{ isSignal: true, alias: "width", required: false }] }], dropEnterPredicate: [{ type: Input, args: [{ isSignal: true, alias: "dropEnterPredicate", required: false }] }], dragDropped: [{ type: Output, args: ["dragDropped"] }], dragStarted: [{ type: Output, args: ["dragStarted"] }], dragEnded: [{ type: Output, args: ["dragEnded"] }], columnChanges: [{ type: Output, args: ["columnChanges"] }], resizeChange: [{ type: Output, args: ["resizeChange"] }], itemClick: [{ type: Output, args: ["itemClick"] }], rowBeforeTemplate: [{ type: ContentChild, args: ["rowBeforeSlot", { isSignal: true }] }], rowAfterTemplate: [{ type: ContentChild, args: ["rowAfterSlot", { isSignal: true }] }], tableEmptyTemplate: [{ type: ContentChild, args: ["tableEmpty", { isSignal: true }] }], tableFooterTemplate: [{ type: ContentChild, args: ["tableFooter", { isSignal: true }] }], settingsSlot: [{ type: ContentChild, args: ["settingsSlot", { isSignal: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttTableComponent, { className: "NgxGanttTableComponent", filePath: "packages/gantt/src/table/gantt-table.component.ts", lineNumber: 15 });
})();

// packages/gantt/src/gantt.component.ts
var _c028 = ["footer"];
var _c116 = ["ganttRoot"];
var _c211 = ["ganttTableBody"];
var _c38 = (a0, a1, a2) => ({ "gantt-normal-viewport": a0, "gantt-scroll-container": a1, "with-footer": a2 });
var _c48 = (a0) => ({ columns: a0 });
function NgxGanttComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "gantt-loader");
  }
}
function NgxGanttComponent_ng_container_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function NgxGanttComponent_Conditional_20_Conditional_1_ng_template_1_Template(rf, ctx) {
}
function NgxGanttComponent_Conditional_20_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275template(1, NgxGanttComponent_Conditional_20_Conditional_1_ng_template_1_Template, 0, 0, "ng-template", 22);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_6_0;
    const ctx_r1 = \u0275\u0275nextContext(2);
    const tableHeader_r3 = \u0275\u0275reference(4);
    \u0275\u0275styleProp("width", tableHeader_r3.tableWidth + 1, "px");
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", (tmp_6_0 = ctx_r1.table()) == null ? null : tmp_6_0.tableFooterTemplate())("ngTemplateOutletContext", \u0275\u0275pureFunction1(4, _c48, ctx_r1.columns()));
  }
}
function NgxGanttComponent_Conditional_20_Conditional_2_ng_template_1_Template(rf, ctx) {
}
function NgxGanttComponent_Conditional_20_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 20);
    \u0275\u0275template(1, NgxGanttComponent_Conditional_20_Conditional_2_ng_template_1_Template, 0, 0, "ng-template", 23);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", ctx_r1.footerTemplate());
  }
}
function NgxGanttComponent_Conditional_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 18);
    \u0275\u0275conditionalCreate(1, NgxGanttComponent_Conditional_20_Conditional_1_Template, 2, 6, "div", 19);
    \u0275\u0275conditionalCreate(2, NgxGanttComponent_Conditional_20_Conditional_2_Template, 2, 1, "div", 20);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_6_0;
    const ctx_r1 = \u0275\u0275nextContext();
    const ganttRoot_r4 = \u0275\u0275reference(1);
    \u0275\u0275styleProp("right", ganttRoot_r4.verticalScrollbarWidth, "px")("bottom", ganttRoot_r4.horizontalScrollbarHeight, "px");
    \u0275\u0275advance();
    \u0275\u0275conditional(((tmp_6_0 = ctx_r1.table()) == null ? null : tmp_6_0.tableFooterTemplate()) ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.footerTemplate() ? 2 : -1);
  }
}
var NgxGanttComponent = class _NgxGanttComponent extends GanttUpper {
  constructor() {
    super();
    this.viewportRuler = inject(ViewportRuler);
    this.maxLevel = input(2, ...ngDevMode ? [{ debugName: "maxLevel" }] : []);
    this.async = input(...ngDevMode ? [void 0, { debugName: "async" }] : []);
    this.childrenResolve = input(...ngDevMode ? [void 0, { debugName: "childrenResolve" }] : []);
    this.linkable = input(...ngDevMode ? [void 0, { debugName: "linkable" }] : []);
    this.loading = input(...ngDevMode ? [void 0, { debugName: "loading" }] : []);
    this.virtualScrollEnabled = input(true, ...ngDevMode ? [{ debugName: "virtualScrollEnabled" }] : []);
    this.loadingDelay = input(0, ...ngDevMode ? [{ debugName: "loadingDelay" }] : []);
    this.linkDragStarted = output();
    this.linkDragEnded = output();
    this.lineClick = output();
    this.selectedChange = output();
    this.virtualScrolledIndexChange = output();
    this.table = contentChild(NgxGanttTableComponent, ...ngDevMode ? [{ debugName: "table" }] : []);
    this.columns = contentChildren(NgxGanttTableColumnComponent, __spreadProps(__spreadValues({}, ngDevMode ? { debugName: "columns" } : {}), { descendants: true }));
    this.ganttRoot = viewChild("ganttRoot", ...ngDevMode ? [{ debugName: "ganttRoot" }] : []);
    this.footerTemplate = contentChild("footer", ...ngDevMode ? [{ debugName: "footerTemplate" }] : []);
    this.virtualScroll = viewChild(CdkVirtualScrollViewport, ...ngDevMode ? [{ debugName: "virtualScroll" }] : []);
    this.ganttTableBody = viewChild("ganttTableBody", ...ngDevMode ? [{ debugName: "ganttTableBody" }] : []);
    this.realLoading = false;
    this.tableScrollWidth = signal(0, ...ngDevMode ? [{ debugName: "tableScrollWidth" }] : []);
    this.flatItems = [];
    this.viewportItems = [];
    this.loadingTimer = null;
    this.rangeStart = 0;
    this.rangeEnd = 0;
    afterEveryRender(() => {
      if (this.virtualScrollEnabled() && this.viewportRuler && this.virtualScroll().getRenderedRange().end > 0) {
        const ganttRoot = this.ganttRoot();
        if (!ganttRoot.verticalScrollbarWidth) {
          ganttRoot.computeScrollBarOffset();
        }
      }
    });
    effect(() => {
      const loading = this.loading();
      if (loading) {
        untracked(() => {
          if (this.loadingDelay() > 0) {
            this.loadingTimer = setTimeout(() => {
              this.realLoading = loading;
              this.cdr.markForCheck();
            }, this.loadingDelay());
          } else {
            this.realLoading = loading;
          }
        });
      } else {
        clearTimeout(this.loadingTimer);
        this.realLoading = loading;
      }
    });
  }
  ngOnInit() {
    super.ngOnInit();
    this.ngZone.runOutsideAngular(() => {
      this.dragContainer.linkDragStarted.pipe(takeUntil(this.unsubscribe$)).subscribe((event) => {
        this.linkDragStarted.emit(event);
      });
      this.dragContainer.linkDragEnded.pipe(takeUntil(this.unsubscribe$)).subscribe((event) => {
        this.linkDragEnded.emit(event);
      });
    });
    if (!this.virtualScrollEnabled()) {
      this.viewportItems = this.flatItems.slice(this.rangeStart, this.rangeEnd);
      this.computeRefs();
    }
  }
  computeRefs() {
    const tempItemData = [];
    this.viewportItems.forEach((data) => {
      if (!data.hasOwnProperty("items")) {
        const item = data;
        if (item.links) {
          item.links.forEach((link) => {
            if (this.flatItemsMap[link.link]) {
              tempItemData.push(this.flatItemsMap[link.link]);
            }
          });
        }
        tempItemData.push(data);
      }
    });
    this.computeItemsRefs(...uniqBy(tempItemData, "id"));
    this.flatItems = [...this.flatItems];
    this.viewportItems = [...this.viewportItems];
  }
  setupItems() {
    super.setupItems();
    this.buildFlatItems();
    this.viewportItems = this.flatItems.slice(this.rangeStart, this.rangeEnd);
  }
  ngAfterViewInit() {
    if (this.virtualScrollEnabled()) {
      this.virtualScroll().renderedRangeStream.pipe(takeUntil(this.unsubscribe$)).subscribe((range) => {
        const linksElement = this.elementRef.nativeElement.querySelector(".gantt-links-overlay");
        linksElement.style.top = `${-(this.styles().rowHeight * range.start)}px`;
        this.rangeStart = range.start;
        this.rangeEnd = range.end;
        this.viewportItems = this.flatItems.slice(range.start, range.end);
        this.appendDraggingItemToViewportItems();
        this.computeRefs();
      });
    }
    this.initScrollContainerObserver();
  }
  buildFlatItems() {
    const virtualData = [];
    if (this.groups.length) {
      this.groups.forEach((group2) => {
        virtualData.push(group2);
        if (group2.expanded) {
          const items = recursiveItems(group2.items);
          virtualData.push(...items);
        }
      });
    }
    if (this.items.length) {
      virtualData.push(...recursiveItems(this.items));
    }
    this.flatItems = [...virtualData];
    this.flatItemsMap = keyBy(this.flatItems, "id");
    if (!this.virtualScrollEnabled()) {
      this.rangeStart = 0;
      this.rangeEnd = this.flatItems.length;
    }
  }
  afterExpand() {
    this.buildFlatItems();
    this.viewportItems = this.flatItems.slice(this.rangeStart, this.rangeEnd);
  }
  appendDraggingItemToViewportItems() {
    if (this.draggingItem) {
      let flatItem = this.viewportItems.find((item) => {
        return item.id === this.draggingItem.id;
      });
      if (!flatItem) {
        flatItem = this.flatItems.find((item) => {
          return item.id === this.draggingItem.id;
        });
        if (flatItem) {
          this.viewportItems.push(flatItem);
        }
      }
    }
  }
  expandChildren(item) {
    if (!item.expanded) {
      item.setExpand(true);
      const childrenResolve = this.childrenResolve();
      if (this.async() && childrenResolve && item.children.length === 0) {
        item.loading = true;
        childrenResolve(item.origin).pipe(take(1), finalize(() => {
          item.loading = false;
          this.afterExpand();
          this.expandChange.emit(item);
          this.cdr.detectChanges();
        })).subscribe((items) => {
          item.addChildren(items);
          this.computeItemsRefs(...item.children);
        });
      } else {
        this.computeItemsRefs(...item.children);
        this.afterExpand();
        this.expandChange.emit(item);
      }
    } else {
      item.setExpand(false);
      this.afterExpand();
      this.expandChange.emit(item);
    }
  }
  selectItem(selectEvent) {
    this.table().itemClick.emit({
      event: selectEvent.event,
      current: selectEvent.current
    });
    if (!this.selectable()) {
      return;
    }
    const { event, selectedValue } = selectEvent;
    this.selectionModel.toggle(selectedValue.id);
    const selectedIds = this.selectionModel.selected;
    if (this.multiple()) {
      const _selectedValue = this.getGanttItems(selectedIds).map((item) => item.origin);
      this.selectedChange.emit({ event, current: selectedValue, selectedValue: _selectedValue });
    } else {
      const _selectedValue = this.getGanttItem(selectedIds[0])?.origin;
      this.selectedChange.emit({ event, current: selectedValue, selectedValue: _selectedValue });
    }
  }
  scrollToToday() {
    this.ganttRoot().scrollToToday();
  }
  scrollToDate(date) {
    this.ganttRoot().scrollToDate(date);
  }
  scrolledIndexChange(index2) {
    this.virtualScrolledIndexChange.emit({
      index: index2,
      renderedRange: {
        start: this.rangeStart,
        end: this.rangeEnd
      },
      count: this.flatItems.length
    });
  }
  expandGroups(expanded) {
    this.groups.forEach((group2) => {
      group2.setExpand(expanded);
    });
    this.afterExpand();
    this.expandChange.emit(this.groups);
    this.cdr.detectChanges();
  }
  expandGroup(group2) {
    group2.setExpand(!group2.expanded);
    this.afterExpand();
    this.expandChange.emit(group2);
    this.cdr.detectChanges();
  }
  itemDragStarted(event) {
    this.table().dragStarted.emit(event);
    this.draggingItem = event.source;
  }
  itemDragEnded(event) {
    this.table().dragEnded.emit(event);
    this.draggingItem = null;
  }
  initScrollContainerObserver() {
    const ganttTableBody = this.ganttTableBody();
    if (ganttTableBody && ganttTableBody["elementRef"]?.nativeElement) {
      this.tableScrollWidth.set(ganttTableBody["elementRef"].nativeElement.clientWidth);
      if (typeof ResizeObserver !== "undefined") {
        this.resizeObserver = new ResizeObserver((entries) => {
          const newWidth = entries[0].target.clientWidth;
          if (this.tableScrollWidth() !== newWidth) {
            this.tableScrollWidth.set(newWidth);
            this.cdr.markForCheck();
          }
        });
        this.resizeObserver.observe(ganttTableBody["elementRef"].nativeElement);
      }
    }
  }
  ngOnDestroy() {
    super.ngOnDestroy();
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
    }
  }
  static {
    this.\u0275fac = function NgxGanttComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _NgxGanttComponent, selectors: [["ngx-gantt"]], contentQueries: function NgxGanttComponent_ContentQueries(rf, ctx, dirIndex) {
      if (rf & 1) {
        \u0275\u0275contentQuerySignal(dirIndex, ctx.table, NgxGanttTableComponent, 5)(dirIndex, ctx.columns, NgxGanttTableColumnComponent, 5)(dirIndex, ctx.footerTemplate, _c028, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance(3);
      }
    }, viewQuery: function NgxGanttComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuerySignal(ctx.ganttRoot, _c116, 5)(ctx.virtualScroll, CdkVirtualScrollViewport, 5)(ctx.ganttTableBody, _c211, 5);
      }
      if (rf & 2) {
        \u0275\u0275queryAdvance(3);
      }
    }, inputs: { maxLevel: [1, "maxLevel"], async: [1, "async"], childrenResolve: [1, "childrenResolve"], linkable: [1, "linkable"], loading: [1, "loading"], virtualScrollEnabled: [1, "virtualScrollEnabled"], loadingDelay: [1, "loadingDelay"] }, outputs: { linkDragStarted: "linkDragStarted", linkDragEnded: "linkDragEnded", lineClick: "lineClick", selectedChange: "selectedChange", virtualScrolledIndexChange: "virtualScrolledIndexChange" }, features: [\u0275\u0275ProvidersFeature([
      {
        provide: GANTT_UPPER_TOKEN,
        useExisting: forwardRef(() => _NgxGanttComponent)
      },
      {
        provide: GANTT_ABSTRACT_TOKEN,
        useExisting: forwardRef(() => _NgxGanttComponent)
      }
    ]), \u0275\u0275InheritDefinitionFeature], decls: 22, vars: 47, consts: [["ganttRoot", ""], ["tableHeader", ""], ["ganttTableBody", ""], [1, "gantt-header"], [3, "columns"], [1, "gantt-container-header"], ["syncScrollX", "ganttMainXScroll"], [1, "gantt-virtual-scroll-viewport", 3, "scrolledIndexChange", "ngClass", "itemSize", "minBufferPx", "maxBufferPx"], [4, "cdkVirtualFor", "cdkVirtualForOf", "cdkVirtualForTrackBy"], [1, "gantt-side"], ["syncScrollX", "ganttTableXScroll", "syncScrollY", "ganttMainYScroll", 1, "gantt-side-container"], [1, "gantt-table"], [3, "dragDropped", "dragStarted", "dragEnded", "itemClick", "flatItems", "viewportItems", "columns", "groupTemplate", "emptyTemplate", "rowBeforeTemplate", "rowAfterTemplate", "draggable", "dropEnterPredicate"], [1, "gantt-container"], [1, "gantt-main"], ["syncScrollX", "ganttMainXScroll", "syncScrollY", "ganttMainYScroll", 3, "barClick", "lineClick", "ganttRoot", "flatItems", "viewportItems", "groupHeaderTemplate", "itemTemplate", "barTemplate", "rangeTemplate", "baselineTemplate", "quickTimeFocus"], ["cdkScrollable", "", 1, "gantt-footer", 3, "right", "bottom"], [3, "ganttRoot", "hasFooter", "tableWidth", "tableScrollWidth"], ["cdkScrollable", "", 1, "gantt-footer"], ["syncScrollX", "ganttTableXScroll", 1, "gantt-table-footer", 3, "width"], ["syncScrollX", "ganttMainXScroll", 1, "gantt-container-footer"], ["syncScrollX", "ganttTableXScroll", 1, "gantt-table-footer"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "ngTemplateOutlet"]], template: function NgxGanttComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "ngx-gantt-root", null, 0)(2, "div", 3);
        \u0275\u0275element(3, "gantt-table-header", 4, 1);
        \u0275\u0275elementStart(5, "div", 5);
        \u0275\u0275element(6, "gantt-calendar-header", 6);
        \u0275\u0275elementEnd()();
        \u0275\u0275conditionalCreate(7, NgxGanttComponent_Conditional_7_Template, 1, 0, "gantt-loader");
        \u0275\u0275elementStart(8, "cdk-virtual-scroll-viewport", 7);
        \u0275\u0275listener("scrolledIndexChange", function NgxGanttComponent_Template_cdk_virtual_scroll_viewport_scrolledIndexChange_8_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.scrolledIndexChange($event));
        });
        \u0275\u0275template(9, NgxGanttComponent_ng_container_9_Template, 1, 0, "ng-container", 8);
        \u0275\u0275elementStart(10, "div", 9)(11, "div", 10)(12, "div", 11)(13, "gantt-table-body", 12, 2);
        \u0275\u0275listener("dragDropped", function NgxGanttComponent_Template_gantt_table_body_dragDropped_13_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.table().dragDropped.emit($event));
        })("dragStarted", function NgxGanttComponent_Template_gantt_table_body_dragStarted_13_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.itemDragStarted($event));
        })("dragEnded", function NgxGanttComponent_Template_gantt_table_body_dragEnded_13_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.itemDragEnded($event));
        })("itemClick", function NgxGanttComponent_Template_gantt_table_body_itemClick_13_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.selectItem($event));
        });
        \u0275\u0275elementEnd()()()();
        \u0275\u0275elementStart(15, "div", 13);
        \u0275\u0275element(16, "gantt-calendar-grid", 6);
        \u0275\u0275elementStart(17, "div", 14)(18, "gantt-main", 15);
        \u0275\u0275listener("barClick", function NgxGanttComponent_Template_gantt_main_barClick_18_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.barClick.emit($event));
        })("lineClick", function NgxGanttComponent_Template_gantt_main_lineClick_18_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.lineClick.emit($event));
        });
        \u0275\u0275elementEnd()()()();
        \u0275\u0275element(19, "gantt-drag-backdrop");
        \u0275\u0275conditionalCreate(20, NgxGanttComponent_Conditional_20_Template, 3, 6, "div", 16);
        \u0275\u0275element(21, "gantt-scrollbar", 17);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        let tmp_6_0;
        let tmp_19_0;
        let tmp_20_0;
        let tmp_35_0;
        let tmp_37_0;
        const ganttRoot_r4 = \u0275\u0275reference(1);
        const tableHeader_r3 = \u0275\u0275reference(4);
        \u0275\u0275advance(3);
        \u0275\u0275property("columns", ctx.columns());
        \u0275\u0275advance(3);
        \u0275\u0275styleProp("padding-right", ganttRoot_r4.verticalScrollbarWidth, "px");
        \u0275\u0275advance();
        \u0275\u0275conditional(ctx.realLoading ? 7 : -1);
        \u0275\u0275advance();
        \u0275\u0275property("ngClass", \u0275\u0275pureFunction3(43, _c38, !ctx.virtualScrollEnabled(), ctx.virtualScrollEnabled(), ((tmp_6_0 = ctx.table()) == null ? null : tmp_6_0.tableFooterTemplate()) || ctx.footerTemplate()))("itemSize", ctx.styles().rowHeight)("minBufferPx", ctx.styles().rowHeight * 10)("maxBufferPx", ctx.styles().rowHeight * 20);
        \u0275\u0275advance();
        \u0275\u0275property("cdkVirtualForOf", ctx.flatItems)("cdkVirtualForTrackBy", ctx.trackBy);
        \u0275\u0275advance();
        \u0275\u0275styleProp("width", tableHeader_r3.tableWidth + 1, "px")("padding-bottom", ganttRoot_r4.horizontalScrollbarHeight, "px");
        \u0275\u0275advance(3);
        \u0275\u0275property("flatItems", ctx.flatItems)("viewportItems", ctx.viewportItems)("columns", ctx.columns())("groupTemplate", ctx.groupTemplate())("emptyTemplate", ctx.table().tableEmptyTemplate())("rowBeforeTemplate", (tmp_19_0 = ctx.table()) == null ? null : tmp_19_0.rowBeforeTemplate())("rowAfterTemplate", (tmp_20_0 = ctx.table()) == null ? null : tmp_20_0.rowAfterTemplate())("draggable", ctx.table().draggable())("dropEnterPredicate", ctx.table().dropEnterPredicate());
        \u0275\u0275advance(3);
        \u0275\u0275styleProp("padding-right", ganttRoot_r4.verticalScrollbarWidth, "px")("padding-bottom", ganttRoot_r4.horizontalScrollbarHeight, "px");
        \u0275\u0275advance(2);
        \u0275\u0275property("ganttRoot", ganttRoot_r4)("flatItems", ctx.flatItems)("viewportItems", ctx.viewportItems)("groupHeaderTemplate", ctx.groupHeaderTemplate())("itemTemplate", ctx.itemTemplate())("barTemplate", ctx.barTemplate())("rangeTemplate", ctx.rangeTemplate())("baselineTemplate", ctx.baselineTemplate())("quickTimeFocus", ctx.quickTimeFocus());
        \u0275\u0275advance();
        \u0275\u0275styleProp("left", tableHeader_r3.tableWidth + 1, "px");
        \u0275\u0275advance();
        \u0275\u0275conditional(((tmp_35_0 = ctx.table()) == null ? null : tmp_35_0.tableFooterTemplate()) || ctx.footerTemplate() ? 20 : -1);
        \u0275\u0275advance();
        \u0275\u0275property("ganttRoot", ganttRoot_r4)("hasFooter", !!((tmp_37_0 = ctx.table()) == null ? null : tmp_37_0.tableFooterTemplate()))("tableWidth", tableHeader_r3.tableWidth)("tableScrollWidth", ctx.tableScrollWidth());
      }
    }, dependencies: [
      NgxGanttRootComponent,
      GanttTableHeaderComponent,
      GanttCalendarHeaderComponent,
      GanttLoaderComponent,
      CdkVirtualScrollViewport,
      CdkFixedSizeVirtualScroll,
      NgClass,
      CdkVirtualForOf,
      GanttTableBodyComponent,
      GanttCalendarGridComponent,
      GanttMainComponent,
      GanttDragBackdropComponent,
      GanttScrollbarComponent,
      NgTemplateOutlet,
      GanttSyncScrollXDirective,
      GanttSyncScrollYDirective
    ], encapsulation: 2, changeDetection: 0 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttComponent, [{
    type: Component,
    args: [{ selector: "ngx-gantt", changeDetection: ChangeDetectionStrategy.OnPush, providers: [
      {
        provide: GANTT_UPPER_TOKEN,
        useExisting: forwardRef(() => NgxGanttComponent)
      },
      {
        provide: GANTT_ABSTRACT_TOKEN,
        useExisting: forwardRef(() => NgxGanttComponent)
      }
    ], imports: [
      NgxGanttRootComponent,
      GanttTableHeaderComponent,
      GanttCalendarHeaderComponent,
      GanttLoaderComponent,
      CdkVirtualScrollViewport,
      CdkFixedSizeVirtualScroll,
      NgClass,
      CdkVirtualForOf,
      GanttTableBodyComponent,
      GanttCalendarGridComponent,
      GanttMainComponent,
      GanttDragBackdropComponent,
      GanttScrollbarComponent,
      NgTemplateOutlet,
      GanttSyncScrollXDirective,
      GanttSyncScrollYDirective
    ], template: `<ngx-gantt-root #ganttRoot>
  <div class="gantt-header">
    <gantt-table-header #tableHeader [columns]="columns()"></gantt-table-header>
    <div class="gantt-container-header">
      <gantt-calendar-header
        syncScrollX="ganttMainXScroll"
        [style.padding-right.px]="ganttRoot.verticalScrollbarWidth"
      ></gantt-calendar-header>
    </div>
  </div>
  @if (realLoading) {
    <gantt-loader></gantt-loader>
  }

  <cdk-virtual-scroll-viewport
    class="gantt-virtual-scroll-viewport"
    [ngClass]="{
      'gantt-normal-viewport': !virtualScrollEnabled(),
      'gantt-scroll-container': virtualScrollEnabled(),
      'with-footer': table()?.tableFooterTemplate() || footerTemplate()
    }"
    [itemSize]="styles().rowHeight"
    [minBufferPx]="styles().rowHeight * 10"
    [maxBufferPx]="styles().rowHeight * 20"
    (scrolledIndexChange)="scrolledIndexChange($event)"
  >
    <ng-container *cdkVirtualFor="let item of flatItems; trackBy: trackBy"></ng-container>
    <div class="gantt-side" [style.width.px]="tableHeader.tableWidth + 1" [style.padding-bottom.px]="ganttRoot.horizontalScrollbarHeight">
      <div class="gantt-side-container" syncScrollX="ganttTableXScroll" syncScrollY="ganttMainYScroll">
        <div class="gantt-table">
          <gantt-table-body
            #ganttTableBody
            [flatItems]="flatItems"
            [viewportItems]="viewportItems"
            [columns]="columns()"
            [groupTemplate]="groupTemplate()"
            [emptyTemplate]="table().tableEmptyTemplate()"
            [rowBeforeTemplate]="table()?.rowBeforeTemplate()"
            [rowAfterTemplate]="table()?.rowAfterTemplate()"
            [draggable]="table().draggable()"
            [dropEnterPredicate]="table().dropEnterPredicate()"
            (dragDropped)="table().dragDropped.emit($event)"
            (dragStarted)="itemDragStarted($event)"
            (dragEnded)="itemDragEnded($event)"
            (itemClick)="selectItem($event)"
          >
          </gantt-table-body>
        </div>
      </div>
    </div>
    <div class="gantt-container">
      <gantt-calendar-grid
        syncScrollX="ganttMainXScroll"
        [style.padding-right.px]="ganttRoot.verticalScrollbarWidth"
        [style.padding-bottom.px]="ganttRoot.horizontalScrollbarHeight"
      ></gantt-calendar-grid>
      <div class="gantt-main">
        <gantt-main
          syncScrollX="ganttMainXScroll"
          syncScrollY="ganttMainYScroll"
          [ganttRoot]="ganttRoot"
          [flatItems]="flatItems"
          [viewportItems]="viewportItems"
          [groupHeaderTemplate]="groupHeaderTemplate()"
          [itemTemplate]="itemTemplate()"
          [barTemplate]="barTemplate()"
          [rangeTemplate]="rangeTemplate()"
          [baselineTemplate]="baselineTemplate()"
          [quickTimeFocus]="quickTimeFocus()"
          (barClick)="barClick.emit($event)"
          (lineClick)="lineClick.emit($event)"
        >
        </gantt-main>
      </div>
    </div>
  </cdk-virtual-scroll-viewport>

  <gantt-drag-backdrop [style.left.px]="tableHeader.tableWidth + 1"></gantt-drag-backdrop>

  @if (table()?.tableFooterTemplate() || footerTemplate()) {
    <div
      class="gantt-footer"
      cdkScrollable
      [style.right.px]="ganttRoot.verticalScrollbarWidth"
      [style.bottom.px]="ganttRoot.horizontalScrollbarHeight"
    >
      @if (table()?.tableFooterTemplate()) {
        <div class="gantt-table-footer" syncScrollX="ganttTableXScroll" [style.width.px]="tableHeader.tableWidth + 1">
          <ng-template [ngTemplateOutlet]="table()?.tableFooterTemplate()" [ngTemplateOutletContext]="{ columns: columns() }">
          </ng-template>
        </div>
      }
      @if (footerTemplate()) {
        <div class="gantt-container-footer" syncScrollX="ganttMainXScroll">
          <ng-template [ngTemplateOutlet]="footerTemplate()"> </ng-template>
        </div>
      }
    </div>
  }

  <gantt-scrollbar
    [ganttRoot]="ganttRoot"
    [hasFooter]="!!table()?.tableFooterTemplate()"
    [tableWidth]="tableHeader.tableWidth"
    [tableScrollWidth]="tableScrollWidth()"
  ></gantt-scrollbar>
</ngx-gantt-root>
` }]
  }], () => [], { maxLevel: [{ type: Input, args: [{ isSignal: true, alias: "maxLevel", required: false }] }], async: [{ type: Input, args: [{ isSignal: true, alias: "async", required: false }] }], childrenResolve: [{ type: Input, args: [{ isSignal: true, alias: "childrenResolve", required: false }] }], linkable: [{ type: Input, args: [{ isSignal: true, alias: "linkable", required: false }] }], loading: [{ type: Input, args: [{ isSignal: true, alias: "loading", required: false }] }], virtualScrollEnabled: [{ type: Input, args: [{ isSignal: true, alias: "virtualScrollEnabled", required: false }] }], loadingDelay: [{ type: Input, args: [{ isSignal: true, alias: "loadingDelay", required: false }] }], linkDragStarted: [{ type: Output, args: ["linkDragStarted"] }], linkDragEnded: [{ type: Output, args: ["linkDragEnded"] }], lineClick: [{ type: Output, args: ["lineClick"] }], selectedChange: [{ type: Output, args: ["selectedChange"] }], virtualScrolledIndexChange: [{ type: Output, args: ["virtualScrolledIndexChange"] }], table: [{ type: ContentChild, args: [forwardRef(() => NgxGanttTableComponent), { isSignal: true }] }], columns: [{ type: ContentChildren, args: [forwardRef(() => NgxGanttTableColumnComponent), __spreadProps(__spreadValues({}, { descendants: true }), { isSignal: true })] }], ganttRoot: [{ type: ViewChild, args: ["ganttRoot", { isSignal: true }] }], footerTemplate: [{ type: ContentChild, args: ["footer", { isSignal: true }] }], virtualScroll: [{ type: ViewChild, args: [forwardRef(() => CdkVirtualScrollViewport), { isSignal: true }] }], ganttTableBody: [{ type: ViewChild, args: ["ganttTableBody", { isSignal: true }] }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(NgxGanttComponent, { className: "NgxGanttComponent", filePath: "packages/gantt/src/gantt.component.ts", lineNumber: 85 });
})();

// packages/gantt/src/gantt.module.ts
var NgxGanttModule = class _NgxGanttModule {
  constructor() {
  }
  static {
    this.\u0275fac = function NgxGanttModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NgxGanttModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _NgxGanttModule });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ providers: [
      CdkVirtualScrollViewport,
      {
        provide: GANTT_GLOBAL_CONFIG,
        useValue: defaultConfig
      },
      ...i18nLocaleProvides
    ], imports: [
      CommonModule,
      DragDropModule,
      ScrollingModule,
      NgxGanttComponent
    ] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NgxGanttModule, [{
    type: NgModule,
    args: [{
      imports: [
        CommonModule,
        DragDropModule,
        ScrollingModule,
        NgxGanttComponent,
        NgxGanttTableComponent,
        NgxGanttTableColumnComponent,
        GanttTableHeaderComponent,
        GanttTableBodyComponent,
        GanttMainComponent,
        GanttCalendarHeaderComponent,
        GanttCalendarGridComponent,
        GanttLinksComponent,
        GanttLoaderComponent,
        NgxGanttBarComponent,
        GanttIconComponent,
        GanttDragBackdropComponent,
        NgxGanttRangeComponent,
        NgxGanttRootComponent,
        NgxGanttBaselineComponent,
        NgxGanttToolbarComponent,
        GanttScrollbarComponent,
        NgxGanttPlaceholderComponent,
        IsGanttRangeItemPipe,
        IsGanttBarItemPipe,
        IsGanttCustomItemPipe,
        IsGanttGroupPipe
      ],
      exports: [
        NgxGanttComponent,
        NgxGanttTableComponent,
        NgxGanttTableColumnComponent,
        NgxGanttRootComponent,
        NgxGanttBarComponent,
        NgxGanttRangeComponent,
        NgxGanttBaselineComponent,
        NgxGanttToolbarComponent,
        NgxGanttPlaceholderComponent,
        GanttCalendarHeaderComponent,
        GanttCalendarGridComponent,
        GanttDragBackdropComponent,
        GanttScrollbarComponent
      ],
      providers: [
        CdkVirtualScrollViewport,
        {
          provide: GANTT_GLOBAL_CONFIG,
          useValue: defaultConfig
        },
        ...i18nLocaleProvides
      ]
    }]
  }], () => [], null);
})();

// node_modules/@docgeni/template/fesm2022/docgeni-template.mjs
var _c029 = ["*"];
var _forTrack05 = ($index, $item) => $item.id;
function TableOfContentsComponent_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275domElementStart(0, "li")(1, "a", 2);
    \u0275\u0275domListener("click", function TableOfContentsComponent_For_3_Template_a_click_1_listener($event) {
      const link_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.onLinkClick($event, link_r2));
    });
    \u0275\u0275text(2);
    \u0275\u0275domElementEnd()();
  }
  if (rf & 2) {
    const link_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classMap(\u0275\u0275interpolate1("dg-level-", link_r2.type));
    \u0275\u0275attribute("data-level", link_r2.level - ctx_r2.tocService.highestLevel + 1);
    \u0275\u0275advance();
    \u0275\u0275classProp("active", link_r2 === ctx_r2.activeLink);
    \u0275\u0275domProperty("href", ctx_r2.rootUrl + "#" + link_r2.id, \u0275\u0275sanitizeUrl);
    \u0275\u0275attribute("data-level", link_r2.level - ctx_r2.tocService.highestLevel + 1);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", link_r2.name, " ");
  }
}
var _c117 = (a0) => ({
  active: a0
});
function LocalesSelectorComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "button", 0);
    \u0275\u0275element(1, "dg-icon", 2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(1, _c117, !!ctx_r0.isDropdownOpen));
  }
}
function LocalesSelectorComponent_Conditional_1_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275listener("click", function LocalesSelectorComponent_Conditional_1_For_3_Template_div_click_0_listener() {
      const item_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r0.selectLocale(item_r3.key));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(2, _c117, item_r3.key === ctx_r0.locale));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r3.name, " ");
  }
}
function LocalesSelectorComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1)(1, "div", 3);
    \u0275\u0275repeaterCreate(2, LocalesSelectorComponent_Conditional_1_For_3_Template, 2, 4, "div", 4, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r0.global.config.locales);
  }
}
var _c212 = ["logo"];
function LogoComponent_ng_template_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 2);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275property("src", ctx_r0.global.config.logoUrl, \u0275\u0275sanitizeUrl);
  }
}
function LogoComponent_ng_template_0_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 3)(1, "style", 4);
    \u0275\u0275text(2, " .st0 { fill: #00cc05; } .st1 { fill: #ffda00; } .st2 { fill: #246eff; } .st3 { fill: #004ab5; } .st4 { fill: #ff5050; } ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "g");
    \u0275\u0275element(4, "path", 5)(5, "path", 6);
    \u0275\u0275elementStart(6, "g");
    \u0275\u0275element(7, "path", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "path", 8)(9, "path", 9);
    \u0275\u0275elementEnd()();
  }
}
function LogoComponent_ng_template_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, LogoComponent_ng_template_0_Conditional_0_Template, 1, 1, "img", 2)(1, LogoComponent_ng_template_0_Conditional_1_Template, 10, 0, ":svg:svg", 3);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r0.global.config.logoUrl ? 0 : 1);
  }
}
function LogoComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275namespaceSVG();
    \u0275\u0275elementStart(0, "svg", 3)(1, "style", 4);
    \u0275\u0275text(2, " .st0 { fill: #00cc05; } .st1 { fill: #ffda00; } .st2 { fill: #246eff; } .st3 { fill: #004ab5; } .st4 { fill: #ff5050; } ");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "g");
    \u0275\u0275element(4, "path", 5)(5, "path", 6);
    \u0275\u0275elementStart(6, "g");
    \u0275\u0275element(7, "path", 7);
    \u0275\u0275elementEnd();
    \u0275\u0275element(8, "path", 8)(9, "path", 9);
    \u0275\u0275elementEnd()();
  }
}
function _forTrack1($index, $item) {
  return this.searchService.trackByFn($index, $item);
}
function SearchComponent_Conditional_4_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r2 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275textInterpolate1(" ", item_r2.parent.title, " > ");
  }
}
function SearchComponent_Conditional_4_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275listener("click", function SearchComponent_Conditional_4_For_2_Template_a_click_0_listener($event) {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.toRoute($event, item_r2));
    });
    \u0275\u0275conditionalCreate(1, SearchComponent_Conditional_4_For_2_Conditional_1_Template, 1, 1);
    \u0275\u0275element(2, "span", 8);
    \u0275\u0275pipe(3, "highlight");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("href", item_r2.path, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r2.parent ? 1 : -1);
    \u0275\u0275advance();
    \u0275\u0275property("innerHtml", \u0275\u0275pipeBind2(3, 3, ctx_r2.searchText, item_r2.title), \u0275\u0275sanitizeHtml);
  }
}
function SearchComponent_Conditional_4_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-icon", 6);
  }
}
function SearchComponent_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4);
    \u0275\u0275repeaterCreate(1, SearchComponent_Conditional_4_For_2_Template, 4, 6, "a", 5, _forTrack1, true);
    \u0275\u0275conditionalCreate(3, SearchComponent_Conditional_4_Conditional_3_Template, 1, 0, "dg-icon", 6);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275classProp("is-searching", ctx_r2.hasSearchText && ctx_r2.isFocus)("result-empty", ctx_r2.searchService.result.length === 0);
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r2.searchService.result);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r2.hasSearchText && ctx_r2.searchService.result.length === 0 ? 3 : -1);
  }
}
var _c39 = () => ["/"];
var _c49 = (a0) => ({
  $implicit: a0
});
var _c56 = (a0) => ({
  exact: a0
});
var _c64 = (a0) => [a0];
function SidebarComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 7);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.global.config.description);
  }
}
function SidebarComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275element(1, "dg-logo");
    \u0275\u0275elementStart(2, "a", 6);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(4, SidebarComponent_Conditional_0_Conditional_4_Template, 2, 1, "span", 7);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(3, _c39));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r0.global.config.title);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.global.config.description ? 4 : -1);
  }
}
function SidebarComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-search");
  }
}
function SidebarComponent_For_6_ng_container_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function SidebarComponent_For_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainerStart(0, 5);
    \u0275\u0275template(1, SidebarComponent_For_6_ng_container_1_Template, 1, 0, "ng-container", 8);
    \u0275\u0275elementContainerEnd();
  }
  if (rf & 2) {
    const menu_r2 = ctx.$implicit;
    \u0275\u0275nextContext();
    const navTemplate_r3 = \u0275\u0275reference(10);
    \u0275\u0275advance();
    \u0275\u0275property("ngTemplateOutlet", navTemplate_r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c49, menu_r2));
  }
}
function SidebarComponent_Conditional_7_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function SidebarComponent_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SidebarComponent_Conditional_7_ng_container_0_Template, 1, 0, "ng-container", 9);
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const changeLanguageTemplate_r4 = \u0275\u0275reference(12);
    \u0275\u0275property("ngTemplateOutlet", changeLanguageTemplate_r4);
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext(3).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", menu_r6.title, " ");
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 14);
    \u0275\u0275element(1, "dg-icon", 16);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275advance();
    \u0275\u0275property("iconName", "angleRight");
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_For_6_ng_container_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementContainer(0);
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_For_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, SidebarComponent_ng_template_9_Conditional_0_Conditional_0_For_6_ng_container_0_Template, 1, 0, "ng-container", 8);
  }
  if (rf & 2) {
    const menu_r7 = ctx.$implicit;
    \u0275\u0275nextContext(4);
    const navTemplate_r3 = \u0275\u0275reference(10);
    \u0275\u0275property("ngTemplateOutlet", navTemplate_r3)("ngTemplateOutletContext", \u0275\u0275pureFunction1(2, _c49, menu_r7));
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r5 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 11)(1, "div", 12);
    \u0275\u0275listener("click", function SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Template_div_click_1_listener() {
      \u0275\u0275restoreView(_r5);
      const menu_r6 = \u0275\u0275nextContext(2).$implicit;
      const ctx_r0 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r0.toggle(menu_r6));
    });
    \u0275\u0275conditionalCreate(2, SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Conditional_2_Template, 2, 1, "div", 13);
    \u0275\u0275conditionalCreate(3, SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Conditional_3_Template, 2, 1, "div", 14);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div", 15);
    \u0275\u0275repeaterCreate(5, SidebarComponent_ng_template_9_Conditional_0_Conditional_0_For_6_Template, 1, 4, "ng-container", null, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext(2).$implicit;
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275classProp("menu-group--open", ctx_r0.menuDisplayMap.get(menu_r6));
    \u0275\u0275advance(2);
    \u0275\u0275conditional(menu_r6.title ? 2 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(menu_r6.items && menu_r6.items.length ? 3 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(menu_r6.items);
  }
}
function SidebarComponent_ng_template_9_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, SidebarComponent_ng_template_9_Conditional_0_Conditional_0_Template, 7, 4, "div", 10);
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275conditional(menu_r6.items.length > 0 ? 0 : -1);
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5)(1, "a", 17);
    \u0275\u0275element(2, "dg-icon", 18);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("href", \u0275\u0275interpolate(menu_r6.path), \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", menu_r6.title, " ");
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 22);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext(3).$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(menu_r6.subtitle);
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "dg-label", 24);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext(3).$implicit;
    \u0275\u0275property("labelType", menu_r6.label.color);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(menu_r6.label.text);
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-toc", 25);
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19, 2)(2, "a", 20)(3, "div", 21);
    \u0275\u0275text(4);
    \u0275\u0275conditionalCreate(5, SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_5_Template, 2, 1, "span", 22);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 23);
    \u0275\u0275conditionalCreate(7, SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_7_Template, 2, 2, "dg-label", 24);
    \u0275\u0275elementEnd()()();
    \u0275\u0275conditionalCreate(8, SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Conditional_8_Template, 1, 0, "dg-toc", 25);
  }
  if (rf & 2) {
    const routerLinkActive_r8 = \u0275\u0275reference(1);
    const menu_r6 = \u0275\u0275nextContext(2).$implicit;
    \u0275\u0275property("routerLinkActiveOptions", \u0275\u0275pureFunction1(6, _c56, !menu_r6.examples));
    \u0275\u0275advance(2);
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(8, _c64, "./" + menu_r6.path));
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", menu_r6.title, " ");
    \u0275\u0275advance();
    \u0275\u0275conditional(menu_r6.subtitle ? 5 : -1);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(menu_r6.label ? 7 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(menu_r6.toc === "menu" && routerLinkActive_r8.isActive ? 8 : -1);
  }
}
function SidebarComponent_ng_template_9_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, SidebarComponent_ng_template_9_Conditional_1_Conditional_0_Template, 4, 3, "div", 5)(1, SidebarComponent_ng_template_9_Conditional_1_Conditional_1_Template, 9, 10);
  }
  if (rf & 2) {
    const menu_r6 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275conditional(menu_r6.isExternal ? 0 : 1);
  }
}
function SidebarComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, SidebarComponent_ng_template_9_Conditional_0_Template, 1, 1)(1, SidebarComponent_ng_template_9_Conditional_1_Template, 2, 1);
  }
  if (rf & 2) {
    const menu_r6 = ctx.$implicit;
    \u0275\u0275conditional(menu_r6.items ? 0 : 1);
  }
}
function SidebarComponent_ng_template_11_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26)(1, "div", 27);
    \u0275\u0275element(2, "dg-locales-selector");
    \u0275\u0275elementEnd()();
  }
}
function SidebarComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, SidebarComponent_ng_template_11_Conditional_0_Template, 3, 0, "div", 26);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r0.global.config.locales && ctx_r0.global.config.locales.length > 1 ? 0 : -1);
  }
}
function ChannelComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-sidebar", 0)(1, "router-outlet");
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("menus", ctx_r0.menus());
  }
}
function DocHeaderComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 4);
    \u0275\u0275listener("click", function DocHeaderComponent_Conditional_1_Template_a_click_0_listener($event) {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleSidebar($event));
    });
    \u0275\u0275element(1, "dg-icon", 5);
    \u0275\u0275elementEnd();
  }
}
function DocHeaderComponent_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 3);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(ctx_r1.subtitle);
  }
}
function ExampleRendererComponent_Conditional_0_ng_template_0_Template(rf, ctx) {
}
function ExampleRendererComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275template(0, ExampleRendererComponent_Conditional_0_ng_template_0_Template, 0, 0, "ng-template", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("ngComponentOutlet", ctx_r0.componentType());
  }
}
var _c73 = ["codeContent"];
var _c82 = (a0) => ({
  "dg-sources-show": a0
});
var _forTrack2 = ($index, $item) => $item.name;
function ExampleViewerComponent_Conditional_0_For_16_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "a", 17);
    \u0275\u0275listener("click", function ExampleViewerComponent_Conditional_0_For_16_Template_a_click_0_listener() {
      const tab_r4 = \u0275\u0275restoreView(_r3).$implicit;
      const ctx_r1 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r1.selectExampleTab(tab_r4));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const tab_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(2, _c117, tab_r4 === ctx_r1.selectedTab));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(tab_r4.name);
  }
}
function ExampleViewerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 1)(1, "div", 2)(2, "span", 3);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275element(4, "div", 4);
    \u0275\u0275elementStart(5, "div", 5);
    \u0275\u0275element(6, "a", 6);
    \u0275\u0275elementStart(7, "a", 7);
    \u0275\u0275listener("click", function ExampleViewerComponent_Conditional_0_Template_a_click_7_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.toggleSource());
    });
    \u0275\u0275element(8, "dg-icon", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(9, "a", 9);
    \u0275\u0275element(10, "dg-icon", 10);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "a", 11);
    \u0275\u0275listener("click", function ExampleViewerComponent_Conditional_0_Template_a_click_11_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r1 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r1.openStackBlitz());
    });
    \u0275\u0275element(12, "dg-icon", 12);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(13, "div", 13)(14, "div", 14);
    \u0275\u0275repeaterCreate(15, ExampleViewerComponent_Conditional_0_For_16_Template, 2, 4, "a", 15, _forTrack2);
    \u0275\u0275elementEnd();
    \u0275\u0275element(17, "pre", 16, 0);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const sourceCode_r5 = \u0275\u0275reference(18);
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.example().title);
    \u0275\u0275advance();
    \u0275\u0275classMap(ctx_r1.example().className);
    \u0275\u0275styleProp("background", ctx_r1.example().background);
    \u0275\u0275classProp("dg-example-viewer-compact", ctx_r1.example().compact);
    \u0275\u0275property("exampleModuleType", ctx_r1.exampleModuleType)("exampleComponentType", ctx_r1.exampleComponentType);
    \u0275\u0275advance();
    \u0275\u0275property("title", \u0275\u0275interpolate(ctx_r1.example().title));
    \u0275\u0275advance();
    \u0275\u0275property("dgCopy", sourceCode_r5 == null ? null : sourceCode_r5.textContent());
    \u0275\u0275advance(3);
    \u0275\u0275property("href", "~examples/" + ctx_r1.name(), \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(4);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(15, _c82, ctx_r1.showSource));
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r1.exampleTabs);
    \u0275\u0275advance(2);
    \u0275\u0275property("url", ctx_r1.selectedTab.path);
  }
}
function DocMetaComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275element(1, "img", 4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275property("title", item_r1);
    \u0275\u0275advance();
    \u0275\u0275property("src", \u0275\u0275interpolate1("https://avatars.githubusercontent.com/", item_r1), \u0275\u0275sanitizeUrl);
  }
}
function DocMetaComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "slice");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(2, 1, ctx_r1.contributors(), 3).length, " ");
  }
}
function DocMetaComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0);
    \u0275\u0275repeaterCreate(1, DocMetaComponent_Conditional_0_For_2_Template, 2, 3, "div", 2, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275pipe(3, "slice");
    \u0275\u0275conditionalCreate(4, DocMetaComponent_Conditional_0_Conditional_4_Template, 3, 4, "div", 3);
    \u0275\u0275pipe(5, "slice");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(\u0275\u0275pipeBind3(3, 1, ctx_r1.contributors(), 0, 3));
    \u0275\u0275advance(3);
    \u0275\u0275conditional(\u0275\u0275pipeBind2(5, 5, ctx_r1.contributors(), 3).length ? 4 : -1);
  }
}
function DocMetaComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "dgTranslate");
    \u0275\u0275pipe(3, "date");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275textInterpolate2(" ", \u0275\u0275pipeBind1(2, 2, "LAST_UPDATED_TIME"), " ", \u0275\u0275pipeBind2(3, 4, ctx_r1.lastUpdatedTime(), "yyyy/MM/dd"), " ");
  }
}
function DocPagesLinksComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "a", 1)(2, "div", 2);
    \u0275\u0275element(3, "dg-icon", 3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div")(5, "div", 4);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "dgTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 5);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(5, _c64, ctx_r0.preRouterLink));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 3, "PRE_PAGE"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ctx_r0.docPages.pre.title, " ");
  }
}
function DocPagesLinksComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "a", 1)(2, "div", 2);
    \u0275\u0275element(3, "dg-icon", 6);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "div")(5, "div", 4);
    \u0275\u0275text(6);
    \u0275\u0275pipe(7, "dgTranslate");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 5);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd()()()();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction1(5, _c64, ctx_r0.nextRouterLink));
    \u0275\u0275advance(5);
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind1(7, 3, "NEXT_PAGE"), " ");
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate1(" ", ctx_r0.docPages.next.title, " ");
  }
}
var _c92 = () => ["./overview"];
var _c102 = () => ["./examples"];
var _c118 = () => ["./api"];
function ComponentViewerComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "dgTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(4, _c92));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 2, "OVERVIEW"));
  }
}
function ComponentViewerComponent_Conditional_0_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 3);
    \u0275\u0275text(1);
    \u0275\u0275pipe(2, "dgTranslate");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(4, _c102));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(2, 2, "EXAMPLES"));
  }
}
function ComponentViewerComponent_Conditional_0_Conditional_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 3);
    \u0275\u0275text(1, "API");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(1, _c118));
  }
}
function ComponentViewerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-doc-header", 1);
    \u0275\u0275elementStart(1, "div", 2);
    \u0275\u0275conditionalCreate(2, ComponentViewerComponent_Conditional_0_Conditional_2_Template, 3, 5, "a", 3);
    \u0275\u0275conditionalCreate(3, ComponentViewerComponent_Conditional_0_Conditional_3_Template, 3, 5, "a", 3);
    \u0275\u0275conditionalCreate(4, ComponentViewerComponent_Conditional_0_Conditional_4_Template, 2, 2, "a", 3);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("title", ctx_r0.docItem().title)("subtitle", ctx_r0.docItem().subtitle);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(ctx_r0.docItem().overview ? 2 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.docItem().examples.length > 0 ? 3 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r0.docItem().api ? 4 : -1);
  }
}
var _c123 = ["toc"];
function DocViewerComponent_Conditional_0_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-component-viewer", 1);
  }
  if (rf & 2) {
    const docItem_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("docItem", docItem_r1);
  }
}
function DocViewerComponent_Conditional_0_Conditional_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-doc-pages-links", 7);
  }
  if (rf & 2) {
    \u0275\u0275property("docPages", ctx);
  }
}
function DocViewerComponent_Conditional_0_Conditional_2_Conditional_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-toc");
  }
}
function DocViewerComponent_Conditional_0_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 4);
    \u0275\u0275element(2, "dg-doc-header", 5)(3, "dg-content-viewer", 6);
    \u0275\u0275pipe(4, "dgAssetsContentPath");
    \u0275\u0275conditionalCreate(5, DocViewerComponent_Conditional_0_Conditional_2_Conditional_5_Template, 1, 1, "dg-doc-pages-links", 7);
    \u0275\u0275pipe(6, "async");
    \u0275\u0275element(7, "dg-doc-meta", 8);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(8, DocViewerComponent_Conditional_0_Conditional_2_Conditional_8_Template, 1, 0, "dg-toc");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    let tmp_6_0;
    const docItem_r1 = \u0275\u0275nextContext();
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275property("title", docItem_r1.title)("subtitle", docItem_r1.subtitle);
    \u0275\u0275advance();
    \u0275\u0275property("url", \u0275\u0275pipeBind1(4, 6, docItem_r1.contentPath));
    \u0275\u0275advance(2);
    \u0275\u0275conditional((tmp_6_0 = \u0275\u0275pipeBind1(6, 8, ctx_r1.docPages$)) ? 5 : -1, tmp_6_0);
    \u0275\u0275advance(2);
    \u0275\u0275property("docItem", docItem_r1);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.hasContentToc() ? 8 : -1);
  }
}
function DocViewerComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, DocViewerComponent_Conditional_0_Conditional_0_Template, 1, 1, "dg-component-viewer", 1);
    \u0275\u0275pipe(1, "dgIsComponentDoc");
    \u0275\u0275conditionalBranchCreate(2, DocViewerComponent_Conditional_0_Conditional_2_Template, 9, 10, "div", 2);
    \u0275\u0275element(3, "div", 3)(4, "dg-footer");
  }
  if (rf & 2) {
    \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 1, ctx) ? 0 : 2);
  }
}
function ComponentOverviewComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-toc", null, 0);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_5_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 6);
  }
  if (rf & 2) {
    const apiDeclaration_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("innerHTML", apiDeclaration_r1.description, \u0275\u0275sanitizeHtml);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_6_For_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 15)(1, "td", 16)(2, "label");
    \u0275\u0275text(3);
    \u0275\u0275pipe(4, "dgPropertyName");
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(5, "td", 17)(6, "label");
    \u0275\u0275text(7);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(8, "td", 18);
    \u0275\u0275text(9);
    \u0275\u0275elementEnd();
    \u0275\u0275element(10, "td", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const property_r2 = ctx.$implicit;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(\u0275\u0275pipeBind1(4, 4, property_r2));
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate(property_r2.type);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", property_r2.default || "-", " ");
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", property_r2.description, \u0275\u0275sanitizeHtml);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_6_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td", 20);
    \u0275\u0275text(2, "None");
    \u0275\u0275elementEnd()();
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_6_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 8);
    \u0275\u0275text(2, "Properties");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "table", 9)(4, "thead")(5, "tr", 10)(6, "th", 11);
    \u0275\u0275text(7, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "th", 12);
    \u0275\u0275text(9, "Type");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "th", 13);
    \u0275\u0275text(11, "Default");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(12, "th", 14);
    \u0275\u0275text(13, "Description");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(14, "tbody");
    \u0275\u0275repeaterCreate(15, ComponentApiComponent_Conditional_0_For_2_Conditional_6_For_16_Template, 11, 6, "tr", 15, _forTrack2);
    \u0275\u0275conditionalCreate(17, ComponentApiComponent_Conditional_0_For_2_Conditional_6_Conditional_17_Template, 3, 0, "tr");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const apiDeclaration_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(15);
    \u0275\u0275repeater(apiDeclaration_r1.properties);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!apiDeclaration_r1.properties || apiDeclaration_r1.properties.length === 0 ? 17 : -1);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_For_1_Conditional_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 29);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(item_r3.description || item_r3.comment);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 30)(1, "span", 28);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275conditionalCreate(3, ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_For_1_Conditional_3_Template, 2, 1, "span", 29);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate2("", item_r3.name, ": ", item_r3.type);
    \u0275\u0275advance();
    \u0275\u0275conditional(item_r3.description || item_r3.comment ? 3 : -1);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275repeaterCreate(0, ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_For_1_Template, 4, 3, "div", 30, _forTrack2);
  }
  if (rf & 2) {
    const method_r4 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275repeater(method_r4.parameters);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 26);
    \u0275\u0275text(1, "None");
    \u0275\u0275elementEnd();
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr", 15)(1, "td", 16)(2, "label");
    \u0275\u0275text(3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(4, "td", 17)(5, "div", 23)(6, "div", 24);
    \u0275\u0275text(7, "Parameters:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "div", 25);
    \u0275\u0275conditionalCreate(9, ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_9_Template, 2, 0)(10, ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Conditional_10_Template, 2, 0, "div", 26);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(11, "div", 23)(12, "div", 24);
    \u0275\u0275text(13, "Return:");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(14, "div", 27)(15, "span", 28);
    \u0275\u0275text(16);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(17, "span", 29);
    \u0275\u0275text(18);
    \u0275\u0275elementEnd()()()();
    \u0275\u0275element(19, "td", 19);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const method_r4 = ctx.$implicit;
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(method_r4.name);
    \u0275\u0275advance(6);
    \u0275\u0275conditional(method_r4.parameters && method_r4.parameters.length ? 9 : 10);
    \u0275\u0275advance(7);
    \u0275\u0275textInterpolate(method_r4.returnValue == null ? null : method_r4.returnValue.type);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(method_r4.returnValue == null ? null : method_r4.returnValue.description);
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", method_r4.description, \u0275\u0275sanitizeHtml);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_Conditional_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "tr")(1, "td", 31);
    \u0275\u0275text(2, "None");
    \u0275\u0275elementEnd()();
  }
}
function ComponentApiComponent_Conditional_0_For_2_Conditional_7_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 7)(1, "div", 8);
    \u0275\u0275text(2, "Methods");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "table", 21)(4, "thead")(5, "tr", 10)(6, "th", 11);
    \u0275\u0275text(7, "Name");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(8, "th", 22);
    \u0275\u0275text(9, "Type");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(10, "th", 14);
    \u0275\u0275text(11, "Description");
    \u0275\u0275elementEnd()()();
    \u0275\u0275elementStart(12, "tbody");
    \u0275\u0275repeaterCreate(13, ComponentApiComponent_Conditional_0_For_2_Conditional_7_For_14_Template, 20, 5, "tr", 15, _forTrack2);
    \u0275\u0275conditionalCreate(15, ComponentApiComponent_Conditional_0_For_2_Conditional_7_Conditional_15_Template, 3, 0, "tr");
    \u0275\u0275elementEnd()()();
  }
  if (rf & 2) {
    const apiDeclaration_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275advance(13);
    \u0275\u0275repeater(apiDeclaration_r1.methods);
    \u0275\u0275advance(2);
    \u0275\u0275conditional(!apiDeclaration_r1.methods || apiDeclaration_r1.methods.length === 0 ? 15 : -1);
  }
}
function ComponentApiComponent_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 4)(1, "h1", 5);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(3, "label");
    \u0275\u0275text(4);
    \u0275\u0275elementEnd()();
    \u0275\u0275conditionalCreate(5, ComponentApiComponent_Conditional_0_For_2_Conditional_5_Template, 1, 1, "div", 6);
    \u0275\u0275conditionalCreate(6, ComponentApiComponent_Conditional_0_For_2_Conditional_6_Template, 18, 1, "div", 7);
    \u0275\u0275conditionalCreate(7, ComponentApiComponent_Conditional_0_For_2_Conditional_7_Template, 16, 1, "div", 7);
  }
  if (rf & 2) {
    const apiDeclaration_r1 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("id", \u0275\u0275interpolate(apiDeclaration_r1.name));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(apiDeclaration_r1.name);
    \u0275\u0275advance();
    \u0275\u0275classMap(\u0275\u0275interpolate1("type-label dg-label ", apiDeclaration_r1.type));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(apiDeclaration_r1.type);
    \u0275\u0275advance();
    \u0275\u0275conditional(apiDeclaration_r1.description ? 5 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(apiDeclaration_r1.properties && apiDeclaration_r1.properties.length ? 6 : -1);
    \u0275\u0275advance();
    \u0275\u0275conditional(apiDeclaration_r1.methods && apiDeclaration_r1.methods.length ? 7 : -1);
  }
}
function ComponentApiComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275repeaterCreate(1, ComponentApiComponent_Conditional_0_For_2_Template, 8, 10, null, null, _forTrack2);
    \u0275\u0275elementEnd();
    \u0275\u0275element(3, "dg-toc", 3, 0);
  }
  if (rf & 2) {
    const ctx_r4 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r4.apiDeclarations());
  }
}
function ComponentApiComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275text(1, "Loading...");
    \u0275\u0275elementEnd();
  }
}
function ComponentExamplesComponent_For_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-example-viewer", 0);
  }
  if (rf & 2) {
    const example_r1 = ctx.$implicit;
    \u0275\u0275property("name", example_r1);
  }
}
var _forTrack3 = ($index, $item) => $item.text;
var _forTrack4 = ($index, $item) => $item.title;
function HomeComponent_Conditional_0_For_8_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 7);
    \u0275\u0275pipe(1, "dgHeroActionClass");
    \u0275\u0275text(2);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r1 = ctx.$implicit;
    \u0275\u0275property("ngClass", \u0275\u0275pipeBind1(1, 3, item_r1))("href", item_r1.link, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", item_r1.text, " ");
  }
}
function HomeComponent_Conditional_0_Conditional_10_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "img", 9);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275property("src", ctx_r1.bannerImgSrc, \u0275\u0275sanitizeUrl);
  }
}
function HomeComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 0)(1, "div", 3)(2, "h1", 4);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(4, "p", 5);
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(6, "div", 6);
    \u0275\u0275repeaterCreate(7, HomeComponent_Conditional_0_For_8_Template, 3, 5, "a", 7, _forTrack3);
    \u0275\u0275elementEnd()();
    \u0275\u0275elementStart(9, "div", 8);
    \u0275\u0275conditionalCreate(10, HomeComponent_Conditional_0_Conditional_10_Template, 1, 1, "img", 9);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275textInterpolate(ctx_r1.global.homeMeta.hero.title);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate(ctx_r1.global.homeMeta.hero.description);
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r1.global.homeMeta.hero.actions);
    \u0275\u0275advance(2);
    \u0275\u0275styleProp("background-color", ctx_r1.global.homeMeta.hero.backgroundColor);
    \u0275\u0275advance();
    \u0275\u0275conditional(ctx_r1.bannerImgSrc ? 10 : -1);
  }
}
function HomeComponent_Conditional_1_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275element(1, "img", 11);
    \u0275\u0275elementStart(2, "div", 12);
    \u0275\u0275text(3);
    \u0275\u0275elementEnd();
    \u0275\u0275element(4, "div", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r3 = ctx.$implicit;
    \u0275\u0275advance();
    \u0275\u0275property("src", item_r3.icon, \u0275\u0275sanitizeUrl);
    \u0275\u0275advance(2);
    \u0275\u0275textInterpolate1(" ", item_r3.title, " ");
    \u0275\u0275advance();
    \u0275\u0275property("innerHTML", item_r3.description, \u0275\u0275sanitizeHtml);
  }
}
function HomeComponent_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 1);
    \u0275\u0275repeaterCreate(1, HomeComponent_Conditional_1_For_2_Template, 5, 3, "div", 10, _forTrack4);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.global.homeMeta.features);
  }
}
function HomeComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2);
    \u0275\u0275element(1, "dg-content-viewer", 14);
    \u0275\u0275pipe(2, "dgAssetsContentPath");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275property("url", \u0275\u0275pipeBind1(2, 1, ctx_r1.global.homeMeta.contentPath));
  }
}
var _c133 = (a0) => ({
  system: a0
});
function ThemesSelectorComponent_Conditional_2_For_3_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "div", 5);
    \u0275\u0275listener("click", function ThemesSelectorComponent_Conditional_2_For_3_Template_div_click_0_listener() {
      const item_r2 = \u0275\u0275restoreView(_r1).$implicit;
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.selectTheme(item_r2.key));
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.$implicit;
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(2, _c117, item_r2.key === ctx_r2.theme));
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", item_r2.name, " ");
  }
}
function ThemesSelectorComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 2)(1, "div", 3);
    \u0275\u0275repeaterCreate(2, ThemesSelectorComponent_Conditional_2_For_3_Template, 2, 4, "div", 4, \u0275\u0275repeaterTrackByIdentity);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275repeater(ctx_r2.themes);
  }
}
function NavbarComponent_For_11_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 11);
    \u0275\u0275text(1);
    \u0275\u0275element(2, "dg-icon", 13);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const channel_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("href", \u0275\u0275interpolate(channel_r1.path), \u0275\u0275sanitizeUrl);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", channel_r1.title, " ");
  }
}
function NavbarComponent_For_11_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 12);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const channel_r1 = \u0275\u0275nextContext().$implicit;
    \u0275\u0275property("routerLink", channel_r1.path);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate(channel_r1.title);
  }
}
function NavbarComponent_For_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, NavbarComponent_For_11_Conditional_0_Template, 3, 3, "a", 11)(1, NavbarComponent_For_11_Conditional_1_Template, 2, 2, "a", 12);
  }
  if (rf & 2) {
    const channel_r1 = ctx.$implicit;
    \u0275\u0275conditional(channel_r1.isExternal ? 0 : 1);
  }
}
function NavbarComponent_Conditional_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-search", 8);
  }
}
function NavbarComponent_Conditional_16_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-locales-selector", 9);
  }
}
function NavbarComponent_Conditional_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-themes-selector", 9);
  }
}
function NavbarComponent_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 10)(1, "button", 14);
    \u0275\u0275element(2, "dg-icon", 15);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275property("href", \u0275\u0275interpolate(ctx_r1.global.config.repoUrl), \u0275\u0275sanitizeUrl);
  }
}
function ActualRootComponent_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-navbar");
  }
}
function ActualRootComponent_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "dg-sidebar", 0);
  }
  if (rf & 2) {
    const ctx_r0 = \u0275\u0275nextContext();
    \u0275\u0275property("menus", ctx_r0.navigationService.navs);
  }
}
var DocgeniBuiltInComponent = class _DocgeniBuiltInComponent {
  get hostElement() {
    return this.elementRef.nativeElement;
  }
  constructor(elementRef) {
    this.elementRef = elementRef;
    this.classes = [];
  }
  setAttribute(qualifiedName, value) {
    this.hostElement.setAttribute(qualifiedName, value);
  }
  updateHostClass(classes) {
    if (this.classes) {
      this.classes.forEach((className) => {
        if (!this.classes.includes(className)) {
          this.removeClass(className);
        }
      });
    }
    const newClasses = [];
    classes.forEach((className) => {
      if (className) {
        newClasses.push(className);
        if (!this.classes.includes(className)) {
          this.addClass(className);
        }
      }
    });
    this.classes = newClasses;
    return this;
  }
  addClass(className) {
    this.hostElement.classList.add(className);
  }
  removeClass(className) {
    this.hostElement.classList.remove(className);
  }
  static {
    this.\u0275fac = function DocgeniBuiltInComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniBuiltInComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _DocgeniBuiltInComponent
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniBuiltInComponent, [{
    type: Directive
  }], () => [{
    type: ElementRef
  }], null);
})();
var DocgeniLabelComponent = class _DocgeniLabelComponent extends DocgeniBuiltInComponent {
  constructor(elementRef) {
    super(elementRef);
    this.type = input("primary", ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    effect(() => {
      if (this.type()) {
        this.updateHostClass([`dg-label-${this.type()}`]);
      }
    });
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function DocgeniLabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniLabelComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocgeniLabelComponent,
      selectors: [["label"]],
      hostAttrs: [1, "dg-label"],
      inputs: {
        type: [1, "type"]
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      ngContentSelectors: _c029,
      decls: 1,
      vars: 0,
      template: function DocgeniLabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniLabelComponent, [{
    type: Component,
    args: [{
      selector: "label",
      host: {
        class: "dg-label"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }], {
    type: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "type",
        required: false
      }]
    }]
  });
})();
var label = {
  selector: "label",
  component: DocgeniLabelComponent
};
var DocgeniAlertComponent = class _DocgeniAlertComponent extends DocgeniBuiltInComponent {
  constructor(elementRef) {
    super(elementRef);
    this.type = input("info", ...ngDevMode ? [{
      debugName: "type"
    }] : []);
    effect(() => {
      if (this.type()) {
        this.updateHostClass([`dg-alert-${this.type()}`]);
      }
    });
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function DocgeniAlertComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniAlertComponent)(\u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocgeniAlertComponent,
      selectors: [["alert"]],
      hostAttrs: [1, "dg-alert"],
      inputs: {
        type: [1, "type"]
      },
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      ngContentSelectors: _c029,
      decls: 1,
      vars: 0,
      template: function DocgeniAlertComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniAlertComponent, [{
    type: Component,
    args: [{
      selector: "alert",
      host: {
        class: "dg-alert"
      },
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }], {
    type: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "type",
        required: false
      }]
    }]
  });
})();
var alert = {
  selector: "alert",
  component: DocgeniAlertComponent
};
var builtInComponents;
function setBuiltInComponents(components) {
  builtInComponents = components || [];
}
function getBuiltInComponents() {
  return builtInComponents;
}
function addBuiltInComponents(components) {
  builtInComponents = builtInComponents ? builtInComponents.concat(components) : components;
}
function loadBuiltInComponents() {
  setBuiltInComponents([label, alert]);
}
var DocgeniBuiltInModule = class _DocgeniBuiltInModule {
  constructor() {
    loadBuiltInComponents();
  }
  static {
    this.\u0275fac = function DocgeniBuiltInModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniBuiltInModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _DocgeniBuiltInModule,
      declarations: [DocgeniLabelComponent, DocgeniAlertComponent],
      imports: [CommonModule]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [CommonModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniBuiltInModule, [{
    type: NgModule,
    args: [{
      declarations: [DocgeniLabelComponent, DocgeniAlertComponent],
      imports: [CommonModule],
      exports: [],
      providers: []
    }]
  }], () => [], null);
})();
var DocgeniTheme;
(function(DocgeniTheme2) {
  DocgeniTheme2["light"] = "light";
  DocgeniTheme2["dark"] = "dark";
  DocgeniTheme2["system"] = "system";
})(DocgeniTheme || (DocgeniTheme = {}));
function languageCompare(language1, language2) {
  return language1.toLocaleLowerCase().replace(/_/g, "-") === language2.toLocaleLowerCase().replace(/_/g, "-");
}
var CONFIG_TOKEN = new InjectionToken("DOC_SITE_CONFIG");
var DEFAULT_CONFIG = {
  title: "Docgeni",
  description: ""
};
var DOCGENI_LOCALE_KEY = "docgeni-locale";
var DOCGENI_MODE_KEY = "docgeni-mode";
var DOCGENI_THEME_KEY = "docgeni-theme";
var GlobalContext = class _GlobalContext {
  get isDefaultLocale() {
    return this.locale === this.config.defaultLocale;
  }
  constructor(config2, http, document2, location2) {
    this.config = config2;
    this.http = http;
    this.document = document2;
    this.location = location2;
    this.theme = signal(DocgeniTheme.light, ...ngDevMode ? [{
      debugName: "theme"
    }] : []);
    this.isDarkTheme = computed(() => {
      return this.theme() === DocgeniTheme.system && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches || this.theme() === DocgeniTheme.dark;
    }, ...ngDevMode ? [{
      debugName: "isDarkTheme"
    }] : []);
    this.setup();
  }
  getLocaleKey() {
    const localeKeyFromUrl = this.getLocalKeyFromUrl();
    if (localeKeyFromUrl) {
      return localeKeyFromUrl;
    } else {
      const cacheLocale = window.localStorage.getItem(DOCGENI_LOCALE_KEY) || window.navigator.language || "";
      const locale2 = (this.config.locales || []).find((locale3) => {
        return languageCompare(locale3.key, cacheLocale);
      });
      if (locale2) {
        return locale2.key;
      } else {
        return this.config.defaultLocale;
      }
    }
  }
  setup() {
    this.setLocale(this.getLocaleKey());
    this.setTheme(this.getTheme());
    const cacheMode = window.localStorage.getItem(DOCGENI_MODE_KEY);
    if (cacheMode && ["lite", "full"].includes(cacheMode)) {
      this.config.mode = cacheMode;
    }
    document.body.classList.add(`dg-mode-${this.config.mode}`, `dg-navbar-theme-${this.config.theme}`);
    if (this.config.repoUrl) {
      const pattern = /https:\/\/github.com\/([^\/]*)\/([^\/]*)/.exec(this.config.repoUrl);
      if (pattern && pattern.length === 3) {
        this.owner = pattern[1];
        this.repo = pattern[2];
      }
    }
  }
  getLocalKeyFromUrl() {
    const localeFromUrl = (this.config.locales || []).find((locale2) => {
      return this.location.path().startsWith(`/${locale2.key}`);
    });
    return localeFromUrl && localeFromUrl.key;
  }
  setLocale(locale2) {
    this.locale = locale2;
    window.localStorage.setItem(DOCGENI_LOCALE_KEY, locale2);
  }
  getTheme() {
    const cacheTheme = window.localStorage.getItem(DOCGENI_THEME_KEY);
    if (cacheTheme && [DocgeniTheme.light, DocgeniTheme.dark, DocgeniTheme.system].includes(cacheTheme)) {
      return cacheTheme;
    } else {
      return DocgeniTheme.light;
    }
  }
  setTheme(theme) {
    this.theme.set(theme);
    window.localStorage.setItem(DOCGENI_THEME_KEY, theme);
    if (this.isDarkTheme()) {
      document.documentElement.setAttribute("theme", DocgeniTheme.dark);
      document.documentElement.style.setProperty("color-scheme", "dark");
    } else {
      document.documentElement.removeAttribute("theme");
      document.documentElement.style.removeProperty("color-scheme");
    }
  }
  getNowTimestamp() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  initialize() {
    return new Promise((resolve, reject) => {
      this.http.get(`assets/content/navigations-${this.locale}.json?t=${this.getNowTimestamp()}`).subscribe({
        next: (response) => {
          this.homeMeta = response.homeMeta;
          this.navs = response.navs;
          this.docItems = this.sortDocItems(this.navs);
          resolve(response);
        },
        error: (error) => {
          reject(error);
        }
      });
    });
  }
  getAssetsContentPath(path) {
    return path.startsWith("/") ? `assets/content${path}` : `assets/content/${path}`;
  }
  sortDocItems(navs) {
    navs = navs.slice();
    const list2 = [];
    while (navs.length) {
      const item = navs.shift();
      if (item) {
        if (item.items) {
          item.items.forEach((child) => {
            child.ancestors = child.ancestors || [];
            child.ancestors.push(...item.ancestors || [], item);
          });
          navs.unshift(...item.items);
        } else if (!item.hidden) {
          list2.push(item);
        }
      }
    }
    return list2;
  }
  static {
    this.\u0275fac = function GlobalContext_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GlobalContext)(\u0275\u0275inject(CONFIG_TOKEN), \u0275\u0275inject(HttpClient), \u0275\u0275inject(DOCUMENT), \u0275\u0275inject(Location));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _GlobalContext,
      factory: _GlobalContext.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GlobalContext, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [CONFIG_TOKEN]
    }]
  }, {
    type: HttpClient
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: Location
  }], null);
})();
var NavigationService = class _NavigationService {
  get channel() {
    return this.channel$.value;
  }
  get docItem() {
    return this.docItem$.value;
  }
  get navs() {
    return this.global.navs;
  }
  get docItems() {
    return this.global.docItems;
  }
  constructor(global) {
    this.global = global;
    this.channel$ = new BehaviorSubject(null);
    this.docItem$ = new BehaviorSubject(null);
    this.docPages$ = new BehaviorSubject(null);
    this.showSidebar = false;
  }
  getChannels() {
    return this.navs;
  }
  getChannel(path) {
    return this.navs.find((nav) => {
      return nav.path === path;
    });
  }
  getDocItemByPath(path) {
    let index2;
    if (this.channel) {
      if (this.channel.lib) {
        index2 = this.docItems.findIndex((docItem) => {
          return docItem.path === path && docItem.channelPath === this.channel.path && !!docItem.importSpecifier;
        });
      } else {
        index2 = this.docItems.findIndex((docItem) => {
          return docItem.path === path && docItem.channelPath === this.channel.path;
        });
      }
    } else {
      index2 = this.docItems.findIndex((docItem) => {
        return docItem.path === path && (this.global.config.mode === "lite" ? true : !docItem.channelPath);
      });
    }
    if (index2 > -1) {
      const preDocItem = index2 ? this.docItems[index2 - 1] : void 0;
      const nextDocItem = this.docItems.length - 1 === index2 ? void 0 : this.docItems[index2 + 1];
      this.docPages$.next({
        pre: preDocItem,
        next: nextDocItem
      });
    }
    return this.docItems[index2];
  }
  selectChannelByPath(path) {
    const channel = this.getChannel(path);
    this.channel$.next(channel);
    return channel;
  }
  clearChannel() {
    this.channel$.next(null);
  }
  selectDocItem(path) {
    const docItem = this.getDocItemByPath(path);
    this.docItem$.next(docItem);
  }
  getChannelFirstDocItem() {
    if (this.channel && this.channel.items) {
      return this.searchFirstDocItem(this.channel.items);
    }
    return null;
  }
  searchFirstDocItem(items = this.navs) {
    let docItem;
    for (const nav of items) {
      if (this.isDocItem(nav)) {
        docItem = nav;
      } else {
        docItem = this.getNavFirstDocItem(nav);
      }
      if (docItem) {
        break;
      }
    }
    return docItem;
  }
  getNavFirstDocItem(nav) {
    let docItem;
    for (const item of nav.items) {
      if (item && this.isCategoryItem(item)) {
        docItem = this.getNavFirstDocItem(item);
      } else {
        docItem = item;
      }
      if (docItem) {
        break;
      }
    }
    return docItem;
  }
  toggleSidebar() {
    this.showSidebar = !this.showSidebar;
  }
  resetShowSidebar() {
    this.showSidebar = false;
  }
  isCategoryItem(category) {
    return category.items;
  }
  isDocItem(item) {
    return !item.items;
  }
  static {
    this.\u0275fac = function NavigationService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NavigationService)(\u0275\u0275inject(GlobalContext));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _NavigationService,
      factory: _NavigationService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavigationService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: GlobalContext
  }], null);
})();
var ChannelResolver = class _ChannelResolver {
  constructor(navigationService) {
    this.navigationService = navigationService;
  }
  resolve(route) {
    const path = route.paramMap.get("channel");
    const channel = this.navigationService.getChannel(path);
    return channel;
  }
  static {
    this.\u0275fac = function ChannelResolver_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChannelResolver)(\u0275\u0275inject(NavigationService));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ChannelResolver,
      factory: _ChannelResolver.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChannelResolver, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: NavigationService
  }], null);
})();
var ExampleLoader = class _ExampleLoader {
  static {
    this.\u0275fac = function ExampleLoader_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExampleLoader)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ExampleLoader,
      factory: _ExampleLoader.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleLoader, [{
    type: Injectable
  }], null, null);
})();
var PageTitleService = class _PageTitleService {
  get title() {
    return this.innerTitle;
  }
  set title(title) {
    this.innerTitle = title;
    if (title !== "") {
      title = `${title} - ${this.globalContext.config.title}`;
    } else {
      title = this.globalContext.config.title;
    }
    this.bodyTitle.setTitle(title);
  }
  constructor(bodyTitle, globalContext) {
    this.bodyTitle = bodyTitle;
    this.globalContext = globalContext;
    this.innerTitle = "";
  }
  static {
    this.\u0275fac = function PageTitleService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PageTitleService)(\u0275\u0275inject(Title), \u0275\u0275inject(GlobalContext));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _PageTitleService,
      factory: _PageTitleService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PageTitleService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Title
  }, {
    type: GlobalContext
  }], null);
})();
var OFFSET$1 = 0;
var TocService = class _TocService {
  get links$() {
    return this.linksSubject$.asObservable();
  }
  get activeLink$() {
    return this.activeLinkSubject$.asObservable();
  }
  constructor(document2, global, viewportScroller) {
    this.document = document2;
    this.viewportScroller = viewportScroller;
    this.linksSubject$ = new BehaviorSubject([]);
    this.activeLinkSubject$ = new BehaviorSubject(null);
    this.destroyed$ = new Subject();
    this.links = toSignal(this.links$);
    if (global.config.mode === "lite") {
      OFFSET$1 = 0;
    }
    this.viewportScroller.setOffset([0, OFFSET$1]);
  }
  reset() {
    this.linksSubject$.next([]);
    this.activeLinkSubject$.next(null);
    this.highestLevel = 0;
    this.destroyed$.next(null);
    this.destroyed$.complete();
  }
  generateToc(docViewerContent, scrollContainer = ".dg-scroll-container") {
    const headers = Array.from(docViewerContent.querySelectorAll("h1, h2, h3, h4, dg-examples"));
    const links = [];
    headers.forEach((header) => {
      if (header.tagName === "DG-EXAMPLES") {
        const allExamples = header.querySelectorAll("example");
        const headerLevel2 = 2;
        allExamples.forEach((example) => {
          links.push({
            name: example.getAttribute("title"),
            type: "h2",
            top: example.getBoundingClientRect().top,
            id: example.getAttribute("name"),
            active: false,
            level: headerLevel2,
            element: example
          });
        });
        return;
      }
      const name = header.innerText.trim().replace(/^TocLink/, "");
      const {
        top
      } = header.getBoundingClientRect();
      const headerLevel = parseInt(header.tagName[1], 10);
      links.push({
        name,
        type: header.tagName.toLowerCase(),
        top,
        id: header.id,
        active: false,
        level: headerLevel,
        element: header
      });
      this.highestLevel = this.highestLevel && headerLevel > this.highestLevel ? this.highestLevel : headerLevel;
    });
    this.initializeScrollContainer(scrollContainer);
    this.linksSubject$.next(links);
  }
  initializeScrollContainer(scrollContainerSelector) {
    this.scrollContainer = scrollContainerSelector ? this.document.querySelectorAll(scrollContainerSelector)[0] : window;
    Promise.resolve().then(() => {
      if (this.scrollContainer) {
        fromEvent(this.scrollContainer, "scroll").pipe(takeUntil(this.destroyed$), debounceTime(10)).subscribe(() => this.onScroll());
      }
      this.onScroll();
    });
  }
  onScroll() {
    const scrollOffset = this.getScrollOffset();
    let activeItem;
    if (scrollOffset <= OFFSET$1 + 1) {
      activeItem = this.links()[0];
    } else {
      const itemOffset = this.links().find((link) => {
        return link.element.offsetTop >= scrollOffset;
      });
      if (itemOffset) {
        activeItem = itemOffset;
      } else {
        activeItem = this.links()[this.links().length - 1];
      }
    }
    this.activeLinkSubject$.next(activeItem || null);
  }
  scrollToAnchor(urlFragment) {
    if (this.scrollContainer) {
      if (this.scrollContainer === this.document.window) {
        this.viewportScroller.scrollToAnchor(urlFragment);
      } else {
        const link = this.links().find((link2) => {
          return link2.id === urlFragment;
        });
        if (link) {
          this.scrollContainer.scrollTop = link.element.offsetTop - 10;
        }
      }
    }
  }
  getScrollOffset() {
    if (this.scrollContainer) {
      if (typeof this.scrollContainer.scrollTop !== "undefined") {
        return this.scrollContainer.scrollTop + OFFSET$1;
      } else if (typeof this.scrollContainer.pageYOffset !== "undefined") {
        return this.scrollContainer.pageYOffset + OFFSET$1;
      }
      return 0;
    } else {
      return 0;
    }
  }
  static {
    this.\u0275fac = function TocService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TocService)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(GlobalContext), \u0275\u0275inject(ViewportScroller));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _TocService,
      factory: _TocService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TocService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: GlobalContext
  }, {
    type: ViewportScroller
  }], null);
})();
var OFFSET = 60;
var TableOfContentsComponent = class _TableOfContentsComponent {
  constructor() {
    this.router = inject(Router);
    this.route = inject(ActivatedRoute);
    this.global = inject(GlobalContext);
    this.locationStrategy = inject(LocationStrategy);
    this.tocService = inject(TocService);
    this.container = input(".dg-scroll-container", ...ngDevMode ? [{
      debugName: "container"
    }] : []);
    this.links = [];
    this.rootUrl = this.locationStrategy.path(false);
    this.hideToc = signal(true, ...ngDevMode ? [{
      debugName: "hideToc"
    }] : []);
    this.destroyed = new Subject();
    this.urlFragment = "";
    if (this.global.config.mode === "lite") {
      OFFSET = 0;
    }
    this.router.events.pipe(takeUntil(this.destroyed)).subscribe((event) => {
      if (event instanceof NavigationEnd) {
        const rootUrl = this.locationStrategy.path(false);
        if (rootUrl !== this.rootUrl) {
          this.rootUrl = rootUrl;
        }
      }
    });
    this.route.fragment.pipe(takeUntil(this.destroyed)).subscribe((fragment) => {
      this.urlFragment = fragment;
      this.tocService.scrollToAnchor(this.urlFragment);
    });
    this.tocService.links$.pipe(takeUntil(this.destroyed)).subscribe((links) => {
      this.hideToc.set(!links || links.length === 0);
      if (!this.hideToc()) {
        this.tocService.scrollToAnchor(this.urlFragment);
      }
    });
    this.tocService.activeLink$.pipe(takeUntil(this.destroyed)).subscribe((activeLink) => {
      this.activeLink = activeLink;
    });
  }
  ngOnInit() {
  }
  ngOnDestroy() {
    this.destroyed.next();
  }
  onLinkClick($event, link) {
  }
  static {
    this.\u0275fac = function TableOfContentsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TableOfContentsComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _TableOfContentsComponent,
      selectors: [["dg-toc"]],
      hostAttrs: [1, "dg-toc"],
      hostVars: 2,
      hostBindings: function TableOfContentsComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-d-none", ctx.hideToc());
        }
      },
      inputs: {
        container: [1, "container"]
      },
      decls: 5,
      vars: 3,
      consts: [[1, "dg-toc-container"], [3, "class"], [1, "dg-link", 3, "click", "href"]],
      template: function TableOfContentsComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275domElementStart(0, "div", 0)(1, "ul");
          \u0275\u0275repeaterCreate(2, TableOfContentsComponent_For_3_Template, 3, 9, "li", 1, _forTrack05);
          \u0275\u0275pipe(4, "async");
          \u0275\u0275domElementEnd()();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275attribute("aria-label", "Table of Contents");
          \u0275\u0275advance();
          \u0275\u0275repeater(\u0275\u0275pipeBind1(4, 1, ctx.tocService.links$));
        }
      },
      dependencies: [AsyncPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TableOfContentsComponent, [{
    type: Component,
    args: [{
      selector: "dg-toc",
      imports: [AsyncPipe],
      host: {
        class: "dg-toc",
        "[class.dg-d-none]": "hideToc()"
      },
      template: `<div class="dg-toc-container">
  <ul [attr.aria-label]="'Table of Contents'">
    @for (link of tocService.links$ | async; track link.id; let i = $index) {
      <li class="dg-level-{{ link.type }}" [attr.data-level]="link.level - tocService.highestLevel + 1">
        <a
          class="dg-link"
          [class.active]="link === activeLink"
          (click)="onLinkClick($event, link)"
          [href]="rootUrl + '#' + link.id"
          [attr.data-level]="link.level - tocService.highestLevel + 1"
        >
          {{ link.name }}
        </a>
      </li>
    }
  </ul>
</div>
`
    }]
  }], () => [], {
    container: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "container",
        required: false
      }]
    }]
  });
})();
var github = `<svg focusable="false" viewBox="0 0 51.8 50.4" xmlns="http://www.w3.org/2000/svg" width="1em" height="1em">
<path
  d="M25.9,0.2C11.8,0.2,0.3,11.7,0.3,25.8c0,11.3,7.3,20.9,17.5,24.3c1.3,0.2,1.7-0.6,1.7-1.2c0-0.6,0-2.6,0-4.8c-7.1,1.5-8.6-3-8.6-3c-1.2-3-2.8-3.7-2.8-3.7c-2.3-1.6,0.2-1.6,0.2-1.6c2.6,0.2,3.9,2.6,3.9,2.6c2.3,3.9,6,2.8,7.5,2.1c0.2-1.7,0.9-2.8,1.6-3.4c-5.7-0.6-11.7-2.8-11.7-12.7c0-2.8,1-5.1,2.6-6.9c-0.3-0.7-1.1-3.3,0.3-6.8c0,0,2.1-0.7,7,2.6c2-0.6,4.2-0.9,6.4-0.9c2.2,0,4.4,0.3,6.4,0.9c4.9-3.3,7-2.6,7-2.6c1.4,3.5,0.5,6.1,0.3,6.8c1.6,1.8,2.6,4.1,2.6,6.9c0,9.8-6,12-11.7,12.6c0.9,0.8,1.7,2.4,1.7,4.7c0,3.4,0,6.2,0,7c0,0.7,0.5,1.5,1.8,1.2c10.2-3.4,17.5-13,17.5-24.3C51.5,11.7,40.1,0.2,25.9,0.2z"
></path>
</svg>`;
var code = `<svg
viewBox="0 0 16 16"
xmlns="http://www.w3.org/2000/svg"
fit=""
height="1em"
width="1em"
preserveAspectRatio="xMidYMid meet"
focusable="false"
>
<g fill-rule="evenodd">
  <path d="M.003 8.306l4.302 4.304.849-.848L.852 7.458z"></path>
  <path d="M0 8.308l.847.85 4.31-4.296-.847-.85zM10.8 4.861l4.309 4.296.848-.85-4.309-4.296z"></path>
  <path d="M10.804 11.762l.849.848 4.302-4.304-.85-.848zM8.526 4L6.1 12.582l1.241.006 2.435-8.565z"></path>
</g>
</svg>`;
var external = `<svg
fit=""
focusable="false"
height="100%"
preserveAspectRatio="xMidYMid meet"
viewBox="0 0 24 24"
width="100%"
xmlns="http://www.w3.org/2000/svg"
>
<path d="M0 0h24v24H0z" fill="none"></path>
<path
  d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"
></path>
</svg>`;
var copy = `<svg
viewBox="0 0 16 16"
xmlns="http://www.w3.org/2000/svg"
fit=""
height="1em"
width="1em"
preserveAspectRatio="xMidYMid meet"
focusable="false"
>
<path
  d="M7.6 8.2V7h4.174v1.2H7.6zm0 3V10h4.174v1.2H7.6zm-4.4-10v10.074H2L2.003 2c0-1.088.895-2 1.997-2h7.585v1.2H3.2zM5 2h9a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V3a1 1 0 0 1 1-1zm.2 1.2v11.6h8.6V3.2H5.2z"
></path>
</svg>`;
var check = `
<svg
  viewBox="0 0 16 16"
  xmlns="http://www.w3.org/2000/svg"
  fit=""
  height="1em"
  width="1em"
  preserveAspectRatio="xMidYMid meet"
  focusable="false"
>
  <path d="M6.012 11.201L1.313 6.832l-.817.879 5.54 5.15 9.304-9.163-.842-.855z"></path>
</svg>`;
var list = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" id="align-justify">
<g id="ageditor/align-justify" stroke-width="1" fill-rule="evenodd">
  <path d="M0 1h16v1.2H0V1zm0 6.4h16v1.2H0V7.4zm0 6.4h16V15H0v-1.2z" id="ag\u5408\u5E76\u5F62\u72B6"></path>
</g>
</svg>`;
var arrowLeft = `<svg width="1em" height="1em" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 55.2 (78181) - https://sketchapp.com -->
    <title>navigation/arrow-left</title>
    <desc>Created with Sketch.</desc>
    <g id="navigation/arrow-left" stroke="none" stroke-width="1"  fill-rule="evenodd">
        <path d="M7.4,4.14955232 L4.4383,7.3151 C4.2123,7.5571 3.8323,7.5691 3.5903,7.3431 C3.3483,7.1161 3.3353,6.7371 3.5623,6.4951 L7.53151194,2.2516372 C7.55538364,2.21814642 7.58305703,2.18659454 7.6145,2.1576 C7.8585,1.9336 8.2375,1.9496 8.4615,2.1946 L12.4315,6.5176 C12.6565,6.7616 12.6395,7.1416 12.3955,7.3656 C12.1515,7.5896 11.7725,7.5736 11.5475,7.3296 L8.6,4.11846621 L8.6,13.2666667 C8.6,13.6712222 8.331,14 8,14 C7.668,14 7.4,13.6712222 7.4,13.2666667 L7.4,4.14955232 Z" id="\u5F62\u72B6\u7ED3\u5408"  transform="translate(7.995013, 7.999832) rotate(-90.000000) translate(-7.995013, -7.999832) "></path>
    </g>
</svg>`;
var arrowRight = `<svg width="1em" height="1em" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 55.2 (78181) - https://sketchapp.com -->
    <title>navigation/arrow-right</title>
    <desc>Created with Sketch.</desc>
    <g id="navigation/arrow-right" stroke="none" stroke-width="1"  fill-rule="evenodd">
        <path d="M7.4,4.14955232 L4.4383,7.3151 C4.2123,7.5571 3.8323,7.5691 3.5903,7.3431 C3.3483,7.1161 3.3353,6.7371 3.5623,6.4951 L7.53151194,2.2516372 C7.55538364,2.21814642 7.58305703,2.18659454 7.6145,2.1576 C7.8585,1.9336 8.2375,1.9496 8.4615,2.1946 L12.4315,6.5176 C12.6565,6.7616 12.6395,7.1416 12.3955,7.3656 C12.1515,7.5896 11.7725,7.5736 11.5475,7.3296 L8.6,4.11846621 L8.6,13.2666667 C8.6,13.6712222 8.331,14 8,14 C7.668,14 7.4,13.6712222 7.4,13.2666667 L7.4,4.14955232 Z" id="\u5F62\u72B6\u7ED3\u5408"  transform="translate(7.995013, 7.999832) rotate(90.000000) translate(-7.995013, -7.999832) "></path>
    </g>
</svg>`;
var angleRight2 = `<svg width="16px" height="16px" viewBox="0 0 16 16" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!-- Generator: Sketch 55.2 (78181) - https://sketchapp.com -->
    <title>navigation/angle-right</title>
    <desc>Created with Sketch.</desc>
    <g id="navigation/angle-right" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <path d="M7.97815,11.49765 L7.9728,11.503 L2.2998,5.831 L3.1298,5 L7.97807731,9.84827731 L12.8255,5 L13.6565,5.831 L7.9835,11.503 L7.97815,11.49765 Z" id="\u5F62\u72B6\u7ED3\u5408" fill="#888888" transform="translate(7.978150, 8.251500) scale(-1, -1) rotate(-270.000000) translate(-7.978150, -8.251500) "></path>
    </g>
</svg>`;
var search = `<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="oonormal/search" stroke-width="1" fill-rule="evenodd"><path d="M6.751 12.303A5.557 5.557 0 0 1 1.2 6.751C1.2 3.691 3.69 1.2 6.751 1.2a5.558 5.558 0 0 1 5.551 5.551 5.557 5.557 0 0 1-5.551 5.552M6.751 0a6.751 6.751 0 1 0 4.309 11.949l3.855 3.855a.6.6 0 1 0 .849-.849l-3.854-3.853A6.751 6.751 0 0 0 6.751 0" id="ooFill-1"></path></g></svg>`;
var empty = `<svg width="148px" height="134px" viewBox="0 0 148 134" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" class="ng-star-inserted"><defs><filter x="0.0%" y="0.0%" width="100.0%" height="100.0%" filterUnits="objectBoundingBox" id="filter-1"><feGaussianBlur stdDeviation="0" in="SourceGraphic"></feGaussianBlur></filter></defs><g id="148x134" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="\u7F16\u7EC4-6" transform="translate(1.000000, 1.000000)"><ellipse id="\u692D\u5706\u5F62" fill="#EDEEF2" opacity="0.3" filter="url(#filter-1)" cx="73.0800017" cy="115.920003" rx="73.0800017" ry="16.8000004"></ellipse><g id="\u7F16\u7EC4-5" transform="translate(15.120000, 0.000000)"><polygon id="\u77E9\u5F62" fill="#E2E4E9" points="19.2789848 49.5600011 99.1200023 48.7200011 117.600003 75.9297673 117.600003 92.313049 0 92.313049 0 75.0356267"></polygon><path d="M23.5200005,0 L94.0800002,0 C97.7913538,2.06413823e-16 100.8,3.00864655 100.8,6.72000015 L100.8,99.1200023 L100.8,99.1200023 L16.8000004,99.1200023 L16.8000004,6.72000015 C16.8000004,3.00864655 19.8086469,1.56994302e-15 23.5200005,0 Z" id="\u77E9\u5F62" fill="#F9FAFB"></path><path d="M30.9200007,12.4400003 L86.6800019,12.4400003 C88.5356787,12.4400003 90.040002,13.9443236 90.040002,15.8000004 L90.040002,42.000001 C90.040002,43.8556778 88.5356787,45.360001 86.6800019,45.360001 L30.9200007,45.360001 C29.0643239,45.360001 27.5600006,43.8556778 27.5600006,42.000001 L27.5600006,15.8000004 C27.5600006,13.9443236 29.0643239,12.4400003 30.9200007,12.4400003 Z" id="\u77E9\u5F62" fill="#E8EAEE"></path><text id="</null>" font-family="PingFangSC-Medium, PingFang SC" font-size="15.1200003" font-weight="400" fill="#BCBECD"><tspan x="33.6000008" y="32.8000004">&lt;/null&gt;</tspan></text><rect id="\u77E9\u5F62" fill="#E8EAEE" x="27.5600006" y="52.0800012" width="61.4800014" height="5.04000011" rx="2.52000006"></rect><rect id="\u77E9\u5F62\u5907\u4EFD" fill="#E8EAEE" x="27.5600006" y="63.8400014" width="61.4800014" height="5.04000011" rx="2.52000006"></rect><path d="M0,75.6000017 L29.280235,75.6000017 C32.0637502,75.6000017 34.3202352,77.8564866 34.3202352,80.6400018 L34.3202352,86.2591426 C34.3202352,89.0426578 36.5767201,91.2991427 39.3602353,91.2991427 L78.4136737,91.2991427 C81.1971889,91.2991427 83.4536738,89.0426578 83.4536738,86.2591426 L83.4536738,80.6400018 C83.4536738,77.8564866 85.7101587,75.6000017 88.4936739,75.6000017 L117.600003,75.6000017 L117.600003,75.6000017 L117.600003,110.880003 C117.600003,115.519195 113.839194,119.280003 109.200002,119.280003 L8.40000019,119.280003 C3.76080819,119.280003 -6.53729019e-15,115.519195 0,110.880003 L0,75.6000017 L0,75.6000017 Z" id="\u77E9\u5F62" fill="#EDEFF2"></path></g></g></g></svg>`;
var stackBlitz = `<svg viewBox="0 0 28 28" aria-hidden="true" class="StackBlitzLogo-module-boltIcon-3IWaX" width="28" height="28"><path d="M12.747 16.273h-7.46L18.925 1.5l-3.671 10.227h7.46L9.075 26.5l3.671-10.227z"></path></svg>`;
var lightTheme = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 48 48" aria-hidden="true" focusable="false"><circle cx="24" cy="24" r="9" fill="currentColor" stroke="none"/><path fill="currentColor" stroke="none" d="M21 5.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-5ZM21 37.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-5ZM42.5 21a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-5a.5.5 0 0 1 .5-.5h5ZM10.5 21a.5.5 0 0 1 .5.5v5a.5.5 0 0 1-.5.5h-5a.5.5 0 0 1-.5-.5v-5a.5.5 0 0 1 .5-.5h5ZM39.203 34.96a.5.5 0 0 1 0 .707l-3.536 3.536a.5.5 0 0 1-.707 0l-3.535-3.536a.5.5 0 0 1 0-.707l3.535-3.535a.5.5 0 0 1 .707 0l3.536 3.535ZM16.575 12.333a.5.5 0 0 1 0 .707l-3.535 3.535a.5.5 0 0 1-.707 0L8.797 13.04a.5.5 0 0 1 0-.707l3.536-3.536a.5.5 0 0 1 .707 0l3.535 3.536ZM13.04 39.203a.5.5 0 0 1-.707 0l-3.536-3.536a.5.5 0 0 1 0-.707l3.536-3.535a.5.5 0 0 1 .707 0l3.536 3.535a.5.5 0 0 1 0 .707l-3.536 3.536ZM35.668 16.575a.5.5 0 0 1-.708 0l-3.535-3.535a.5.5 0 0 1 0-.707l3.535-3.536a.5.5 0 0 1 .708 0l3.535 3.536a.5.5 0 0 1 0 .707l-3.535 3.535Z"/></svg>`;
var darkTheme = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 48 48" aria-hidden="true" focusable="false"><path fill="currentColor" stroke="none" d="M42.108 29.769c.124-.387-.258-.736-.645-.613A17.99 17.99 0 0 1 36 30c-9.941 0-18-8.059-18-18 0-1.904.296-3.74.844-5.463.123-.387-.226-.768-.613-.645C10.558 8.334 5 15.518 5 24c0 10.493 8.507 19 19 19 8.482 0 15.666-5.558 18.108-13.231Z"/></svg>`;
var systemTheme = `<svg fill="none" stroke="currentColor" stroke-width="4" viewBox="0 0 48 48" width="1em" height="1em"><path d="M24 32v8m0 0h-9m9 0h9M7 32h34a1 1 0 0 0 1-1V9a1 1 0 0 0-1-1H7a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1Z"></path></svg>`;
var locale = `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
<path fill-rule="evenodd" clip-rule="evenodd" d="M2 5C2 3.34315 3.34315 2 5 2H7C8.65685 2 10 3.34315 10 5V11H8V8.5H4V11H2V5ZM4 6.5H8V5C8 4.44772 7.55228 4 7 4H5C4.44772 4 4 4.44772 4 5V6.5ZM12 3.5H18C19.6569 3.5 21 4.84315 21 6.5V9H19V6.5C19 5.94772 18.5523 5.5 18 5.5H12V3.5ZM18 11.5V13H22V15H20.9381C20.7182 16.7638 19.9241 18.3492 18.7488 19.5634C19.4441 19.845 20.2041 20 21 20H22V22H21C19.5425 22 18.1765 21.6102 17.0001 20.9297C15.8234 21.6104 14.4572 22 13 22H12V20H13C13.7962 20 14.5562 19.8449 15.2514 19.5633C14.6487 18.9407 14.1463 18.2205 13.7704 17.4291L13.3413 16.5258L15.1478 15.6676L15.5769 16.5709C15.9219 17.2971 16.4081 17.9427 16.9999 18.4723C17.9921 17.5843 18.687 16.371 18.917 15H12V13H16V11.5H18ZM6 13V19C6 19.5523 6.44772 20 7 20H9.5V22H7C5.34315 22 4 20.6569 4 19V13H6Z" fill="currentColor"/>
</svg>`;
var BUILTIN_SVGS = {
  github,
  code,
  external,
  copy,
  check,
  list,
  arrowLeft,
  arrowRight,
  angleRight: angleRight2,
  search,
  empty,
  stackBlitz,
  locale,
  lightTheme,
  darkTheme,
  systemTheme
};
var IconComponent = class _IconComponent {
  set iconName(name) {
    this.setSvg(name);
  }
  constructor(elementRef, domSanitizer) {
    this.elementRef = elementRef;
    this.domSanitizer = domSanitizer;
    this.isIcon = true;
  }
  ngOnInit() {
  }
  ngAfterViewInit() {
  }
  setSvg(name) {
    const svg = BUILTIN_SVGS[name];
    if (svg) {
      this.elementRef.nativeElement.innerHTML = svg;
    } else {
      this.elementRef.nativeElement.innerHTML = "";
    }
  }
  static {
    this.\u0275fac = function IconComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IconComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(DomSanitizer));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _IconComponent,
      selectors: [["dg-icon"]],
      hostVars: 2,
      hostBindings: function IconComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-icon", ctx.isIcon);
        }
      },
      inputs: {
        iconName: "iconName"
      },
      standalone: false,
      ngContentSelectors: _c029,
      decls: 1,
      vars: 0,
      template: function IconComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IconComponent, [{
    type: Component,
    args: [{
      selector: "dg-icon",
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: DomSanitizer
  }], {
    isIcon: [{
      type: HostBinding,
      args: ["class.dg-icon"]
    }],
    iconName: [{
      type: Input
    }]
  });
})();
function colorMetadata(color) {
  let obj;
  if (color.startsWith("#")) {
    obj = hexColorMetadata(color);
  } else if (color.startsWith("rgb")) {
    obj = rgbColorMetadata(color);
  } else {
    throw new Error("unsupported color format " + color);
  }
  return obj;
}
function hexColorMetadata(color) {
  const rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  const hex = color.replace(rgx, (m, r, g, b) => r + r + g + g + b + b);
  const rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return rgb ? {
    r: parseInt(rgb[1], 16),
    g: parseInt(rgb[2], 16),
    b: parseInt(rgb[3], 16)
  } : {};
}
function rgbColorMetadata(color) {
  const result = /rgb\(([0-9]{1,3})\s*[,\s]\s*([0-9]{1,3})\s*[,\s]\s*([0-9]{1,3})\)/i.exec(color);
  return result ? {
    r: parseInt(result[1], 10),
    g: parseInt(result[2], 10),
    b: parseInt(result[3], 10)
  } : {};
}
var LABEL_LIST = ["primary", "danger", "warning", "info"];
var LabelComponent = class _LabelComponent {
  set labelType(value) {
    if (LABEL_LIST.includes(value)) {
      this.classList = ["dg-label", `dg-label-${value}`];
    } else {
      this.classList = ["dg-label"];
      this.renderer.setStyle(this.elementRef.nativeElement, "background-color", this.getBackgroundColor(value));
      this.renderer.setStyle(this.elementRef.nativeElement, "color", value);
    }
  }
  constructor(elementRef, renderer) {
    this.elementRef = elementRef;
    this.renderer = renderer;
  }
  ngOnInit() {
  }
  getBackgroundColor(color) {
    const {
      r,
      g,
      b
    } = colorMetadata(color);
    return `rgba(${r},${g},${b},0.20)`;
  }
  static {
    this.\u0275fac = function LabelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LabelComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(Renderer2));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LabelComponent,
      selectors: [["dg-label"]],
      hostVars: 2,
      hostBindings: function LabelComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classMap(ctx.classList);
        }
      },
      inputs: {
        labelType: "labelType"
      },
      standalone: false,
      ngContentSelectors: _c029,
      decls: 1,
      vars: 0,
      template: function LabelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LabelComponent, [{
    type: Component,
    args: [{
      selector: "dg-label",
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: Renderer2
  }], {
    classList: [{
      type: HostBinding,
      args: [`class`]
    }],
    labelType: [{
      type: Input
    }]
  });
})();
var LocalesSelectorComponent = class _LocalesSelectorComponent {
  constructor(global, navigationService, location2) {
    this.global = global;
    this.navigationService = navigationService;
    this.location = location2;
    this.isDropdownOpen = false;
  }
  ngOnInit() {
    this.locale = this.global.locale;
  }
  openDropdown() {
    this.isDropdownOpen = true;
  }
  closeDropdown() {
    this.isDropdownOpen = false;
  }
  selectLocale(locale2) {
    this.locale = locale2;
    this.isDropdownOpen = false;
    this.localeModelChange();
  }
  localeModelChange() {
    const isDefaultLocale = this.locale === this.global.config.defaultLocale;
    const localKeyFromUrl = this.global.getLocalKeyFromUrl();
    if (isDefaultLocale) {
      this.global.setLocale(this.locale);
    }
    const currentPath = this.location.path();
    if (localKeyFromUrl) {
      this.location.go(currentPath.replace("/" + localKeyFromUrl, isDefaultLocale ? "" : `/${this.locale}`));
    } else {
      this.location.go(isDefaultLocale ? currentPath : `/${this.locale}${currentPath}`);
    }
    location.href = location.href;
  }
  static {
    this.\u0275fac = function LocalesSelectorComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LocalesSelectorComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(NavigationService), \u0275\u0275directiveInject(Location));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LocalesSelectorComponent,
      selectors: [["dg-locales-selector"]],
      hostAttrs: [1, "dg-locales-selector"],
      hostBindings: function LocalesSelectorComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function LocalesSelectorComponent_mouseenter_HostBindingHandler() {
            return ctx.openDropdown();
          })("mouseleave", function LocalesSelectorComponent_mouseleave_HostBindingHandler() {
            return ctx.closeDropdown();
          });
        }
      },
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [["type", "button", 1, "action-icon", 3, "ngClass"], [1, "locales-container"], ["iconName", "locale"], [1, "locales-menu"], [1, "locale", 3, "ngClass"], [1, "locale", 3, "click", "ngClass"]],
      template: function LocalesSelectorComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, LocalesSelectorComponent_Conditional_0_Template, 2, 3, "button", 0);
          \u0275\u0275conditionalCreate(1, LocalesSelectorComponent_Conditional_1_Template, 4, 0, "div", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.global.config.locales && ctx.global.config.locales.length > 1 ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(!!ctx.isDropdownOpen ? 1 : -1);
        }
      },
      dependencies: [NgClass, IconComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LocalesSelectorComponent, [{
    type: Component,
    args: [{
      selector: "dg-locales-selector",
      standalone: false,
      host: {
        class: "dg-locales-selector"
      },
      template: '@if (global.config.locales && global.config.locales.length > 1) {\n  <button type="button" class="action-icon" [ngClass]="{ active: !!isDropdownOpen }">\n    <dg-icon iconName="locale"></dg-icon>\n  </button>\n}\n@if (!!isDropdownOpen) {\n  <div class="locales-container">\n    <div class="locales-menu">\n      @for (item of global.config.locales; track item) {\n        <div class="locale" [ngClass]="{ active: item.key === locale }" (click)="selectLocale(item.key)">\n          {{ item.name }}\n        </div>\n      }\n    </div>\n  </div>\n}\n'
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: NavigationService
  }, {
    type: Location
  }], {
    openDropdown: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    closeDropdown: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var LogoComponent = class _LogoComponent {
  constructor(global, elementRef, viewContainerRef) {
    this.global = global;
    this.elementRef = elementRef;
    this.viewContainerRef = viewContainerRef;
  }
  ngOnInit() {
    this.viewContainerRef.createEmbeddedView(this.logoTemplate);
    const hostElement = this.elementRef.nativeElement;
    hostElement.remove();
  }
  static {
    this.\u0275fac = function LogoComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _LogoComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ViewContainerRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _LogoComponent,
      selectors: [["dg-logo"]],
      viewQuery: function LogoComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c212, 7);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.logoTemplate = _t.first);
        }
      },
      standalone: false,
      decls: 4,
      vars: 0,
      consts: [["logo", ""], ["defaultLogo", ""], ["alt", "Logo", 1, "logo", 3, "src"], ["version", "1.1", "id", "docgeni-logo", "data-name", "docgeni-logo", "xmlns", "http://www.w3.org/2000/svg", 0, "xmlns", "xlink", "http://www.w3.org/1999/xlink", "x", "0px", "y", "0px", "viewBox", "0 0 30 30", 0, "xml", "space", "preserve", 1, "logo", 2, "enable-background", "new 0 0 30 30"], ["type", "text/css"], ["d", "M3.74,3.26h13.54c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-10.59,0.04-10.59,0.04S3.23,11.28,3.74,3.26z", 1, "st0"], ["d", "M6.37,3.26h10.92c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-7.97,0.04-7.97,0.04S5.87,11.28,6.37,3.26z", 1, "st1"], ["d", "M16.04,26.74H2.45L4.88,14.5h6.77l-1.02,5.15h5.4c2.52,0,4.58-2.06,4.58-4.58s-2.06-4.58-4.58-4.58h-1.98\n   v-7.1h1.98c6.44,0,11.68,5.24,11.68,11.68C27.72,21.5,22.48,26.74,16.04,26.74z", 1, "st2"], ["d", "M27.64,13.61c0,0-3.95-0.9-7.06,0.88c0,0-0.31-2.39-2.47-3.55C18.11,10.95,27.32,8.46,27.64,13.61z", 1, "st3"], ["d", "M8.99,3.26h8.68c0,0,3.92,0,7.6,4.66c2.24,2.84,2.38,5.92,2.38,5.92s0.06-2.89-4.48-2.9\n c-7.4-0.02-7.97,0.04-7.97,0.04S8.49,11.28,8.99,3.26z", 1, "st4"]],
      template: function LogoComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275template(0, LogoComponent_ng_template_0_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(2, LogoComponent_ng_template_2_Template, 10, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LogoComponent, [{
    type: Component,
    args: [{
      selector: "dg-logo",
      standalone: false,
      template: '<ng-template #logo>\n  @if (global.config.logoUrl) {\n    <img class="logo" alt="Logo" [src]="global.config.logoUrl" />\n  } @else {\n    <svg\n      version="1.1"\n      class="logo"\n      id="docgeni-logo"\n      data-name="docgeni-logo"\n      xmlns="http://www.w3.org/2000/svg"\n      xmlns:xlink="http://www.w3.org/1999/xlink"\n      x="0px"\n      y="0px"\n      viewBox="0 0 30 30"\n      style="enable-background: new 0 0 30 30"\n      xml:space="preserve"\n    >\n      <style type="text/css">\n        .st0 {\n          fill: #00cc05;\n        }\n        .st1 {\n          fill: #ffda00;\n        }\n        .st2 {\n          fill: #246eff;\n        }\n        .st3 {\n          fill: #004ab5;\n        }\n        .st4 {\n          fill: #ff5050;\n        }\n      </style>\n      <g>\n        <path\n          class="st0"\n          d="M3.74,3.26h13.54c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-10.59,0.04-10.59,0.04S3.23,11.28,3.74,3.26z"\n        />\n        <path\n          class="st1"\n          d="M6.37,3.26h10.92c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-7.97,0.04-7.97,0.04S5.87,11.28,6.37,3.26z"\n        />\n        <g>\n          <path\n            class="st2"\n            d="M16.04,26.74H2.45L4.88,14.5h6.77l-1.02,5.15h5.4c2.52,0,4.58-2.06,4.58-4.58s-2.06-4.58-4.58-4.58h-1.98\n   v-7.1h1.98c6.44,0,11.68,5.24,11.68,11.68C27.72,21.5,22.48,26.74,16.04,26.74z"\n          />\n        </g>\n        <path class="st3" d="M27.64,13.61c0,0-3.95-0.9-7.06,0.88c0,0-0.31-2.39-2.47-3.55C18.11,10.95,27.32,8.46,27.64,13.61z" />\n        <path\n          class="st4"\n          d="M8.99,3.26h8.68c0,0,3.92,0,7.6,4.66c2.24,2.84,2.38,5.92,2.38,5.92s0.06-2.89-4.48-2.9\n c-7.4-0.02-7.97,0.04-7.97,0.04S8.49,11.28,8.99,3.26z"\n        />\n      </g>\n    </svg>\n  }\n</ng-template>\n\n<ng-template #defaultLogo>\n  <svg\n    version="1.1"\n    class="logo"\n    id="docgeni-logo"\n    data-name="docgeni-logo"\n    xmlns="http://www.w3.org/2000/svg"\n    xmlns:xlink="http://www.w3.org/1999/xlink"\n    x="0px"\n    y="0px"\n    viewBox="0 0 30 30"\n    style="enable-background: new 0 0 30 30"\n    xml:space="preserve"\n  >\n    <style type="text/css">\n      .st0 {\n        fill: #00cc05;\n      }\n      .st1 {\n        fill: #ffda00;\n      }\n      .st2 {\n        fill: #246eff;\n      }\n      .st3 {\n        fill: #004ab5;\n      }\n      .st4 {\n        fill: #ff5050;\n      }\n    </style>\n    <g>\n      <path\n        class="st0"\n        d="M3.74,3.26h13.54c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-10.59,0.04-10.59,0.04S3.23,11.28,3.74,3.26z"\n      />\n      <path\n        class="st1"\n        d="M6.37,3.26h10.92c0,0,4.5,0,7.99,4.66c2.33,3.12,2.31,5.42,2.31,5.42s-0.88-2.44-7.04-2.41\n c-7.43,0.04-7.97,0.04-7.97,0.04S5.87,11.28,6.37,3.26z"\n      />\n      <g>\n        <path\n          class="st2"\n          d="M16.04,26.74H2.45L4.88,14.5h6.77l-1.02,5.15h5.4c2.52,0,4.58-2.06,4.58-4.58s-2.06-4.58-4.58-4.58h-1.98\n   v-7.1h1.98c6.44,0,11.68,5.24,11.68,11.68C27.72,21.5,22.48,26.74,16.04,26.74z"\n        />\n      </g>\n      <path class="st3" d="M27.64,13.61c0,0-3.95-0.9-7.06,0.88c0,0-0.31-2.39-2.47-3.55C18.11,10.95,27.32,8.46,27.64,13.61z" />\n      <path\n        class="st4"\n        d="M8.99,3.26h8.68c0,0,3.92,0,7.6,4.66c2.24,2.84,2.38,5.92,2.38,5.92s0.06-2.89-4.48-2.9\n c-7.4-0.02-7.97,0.04-7.97,0.04S8.49,11.28,8.99,3.26z"\n      />\n    </g>\n  </svg>\n</ng-template>\n'
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: ElementRef
  }, {
    type: ViewContainerRef
  }], {
    logoTemplate: [{
      type: ViewChild,
      args: ["logo", {
        static: true
      }]
    }]
  });
})();
var SearchService = class _SearchService {
  get hasAlgolia() {
    return !!(this.global.config.algolia && this.global.config.algolia.apiKey && this.global.config.algolia.indexName);
  }
  constructor(global, document2) {
    this.global = global;
    this.document = document2;
    this.allPages = [];
    this.destroyed$ = new Subject();
    this.result = [];
  }
  initSearch(searchSelector) {
    if (this.hasAlgolia) {
      this.initAlgolia(searchSelector);
    } else {
      this.initInnerSearch(searchSelector);
    }
  }
  initAlgolia(searchSelector) {
    return __async(this, null, function* () {
      const algoliaConfig = this.global.config.algolia;
      const algolia = algoliaConfig?.appId ? {
        appId: algoliaConfig.appId,
        apiKey: algoliaConfig.apiKey,
        indexName: algoliaConfig.indexName
      } : {
        apiKey: algoliaConfig?.apiKey,
        indexName: algoliaConfig?.indexName
      };
      window.global = window;
      window.process = {
        env: {
          DEBUG: void 0
        }
      };
      const {
        default: docsearch
      } = yield import("./npm-GJPEBDB3.js");
      docsearch(__spreadProps(__spreadValues({}, algolia), {
        inputSelector: searchSelector,
        algoliaOptions: {
          hitsPerPage: 5,
          facetFilters: [`lang: ${this.global.locale}`]
        },
        transformData: (hits) => {
          if (location.href.indexOf(this.global.locale) < 0) {
            hits.forEach((hit) => {
              hit.url = hit.url.replace(`${this.global.locale}/`, "");
            });
          }
          return hits;
        }
        // debug: true
      }));
    });
  }
  initInnerSearch(searchSelector) {
    this.generatePages();
    const searchContainer = this.document.querySelector(searchSelector);
    if (searchContainer) {
      fromEvent(searchContainer, "input").pipe(debounceTime(100), map(() => {
        return searchContainer.value;
      }), distinctUntilChanged(), takeUntil(this.destroyed$)).subscribe((value) => {
        this.result = this.searchPages(value);
      });
    } else {
      throw new Error("not find search container");
    }
  }
  generatePages() {
    this.allPages = [];
    this.global.docItems.forEach((docItem) => {
      const path = this.global.config.mode === "full" && docItem.channelPath ? `${docItem.channelPath}/${docItem.path}` : docItem.path;
      const parentPage = {
        title: `${docItem.title} ${docItem.subtitle ? docItem.subtitle : ""}`,
        id: docItem.id,
        path
      };
      this.allPages.push(parentPage);
      (docItem.headings || []).forEach((heading) => {
        this.allPages.push({
          title: heading.name,
          id: heading.id,
          path: `${path}#${heading.id}`,
          parent: parentPage
        });
      });
    });
  }
  searchPages(keywords) {
    const searchText = keywords?.trim().toLowerCase();
    if (searchText) {
      return this.allPages.filter((item) => {
        return item.title.toLowerCase().indexOf(searchText) > -1;
      });
    } else {
      return [];
    }
  }
  trackByFn(index2, item) {
    return item.id || index2;
  }
  static {
    this.\u0275fac = function SearchService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SearchService)(\u0275\u0275inject(GlobalContext), \u0275\u0275inject(DOCUMENT));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _SearchService,
      factory: _SearchService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: void 0,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }], null);
})();
var TRANSLATES = {
  "zh-cn": {
    OVERVIEW: "\u6982\u89C8",
    EXAMPLES: "\u793A\u4F8B",
    HOME: "\u9996\u9875",
    LAST_UPDATED_TIME: "\u6700\u540E\u66F4\u65B0",
    PRE_PAGE: "\u4E0A\u4E00\u7BC7",
    NEXT_PAGE: "\u4E0B\u4E00\u7BC7",
    SEARCH: "\u641C\u7D22"
  },
  "en-us": {
    OVERVIEW: "Overview",
    EXAMPLES: "Examples",
    HOME: "Home",
    LAST_UPDATED_TIME: "Last updated",
    PRE_PAGE: "Previous",
    NEXT_PAGE: "Next",
    SEARCH: "Search"
  }
};
var TranslatePipe = class _TranslatePipe {
  constructor(global) {
    this.global = global;
  }
  transform(key) {
    const langTranslates = TRANSLATES[this.global.locale.toLowerCase()] || TRANSLATES["en-us"];
    return langTranslates[key] ? langTranslates[key] : key;
  }
  static {
    this.\u0275fac = function TranslatePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _TranslatePipe)(\u0275\u0275directiveInject(GlobalContext, 16));
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgTranslate",
      type: _TranslatePipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(TranslatePipe, [{
    type: Pipe,
    args: [{
      name: "dgTranslate",
      standalone: false
    }]
  }], () => [{
    type: GlobalContext
  }], null);
})();
var HighlightPipe = class _HighlightPipe {
  constructor(domSanitizer) {
    this.domSanitizer = domSanitizer;
  }
  highlightTitle(keywords, title) {
    const reg = new RegExp(`(${keywords})`, "gi");
    const chunks = title.split(reg);
    let formatTitle = "";
    chunks.forEach((chunk) => {
      if (chunk) {
        formatTitle = formatTitle + (chunk.toLocaleLowerCase() === keywords ? `<span class="dg-word-highlight">${chunk}</span>` : chunk);
      }
    });
    return formatTitle;
  }
  transform(keywords, title) {
    keywords = (keywords || "").trim().toLocaleLowerCase();
    if (keywords && title) {
      const template = this.highlightTitle(keywords, title);
      return this.domSanitizer.bypassSecurityTrustHtml(template);
    } else {
      return title;
    }
  }
  static {
    this.\u0275fac = function HighlightPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HighlightPipe)(\u0275\u0275directiveInject(DomSanitizer, 16));
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "highlight",
      type: _HighlightPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HighlightPipe, [{
    type: Pipe,
    args: [{
      name: "highlight",
      standalone: false
    }]
  }], () => [{
    type: DomSanitizer
  }], null);
})();
var SearchComponent = class _SearchComponent {
  constructor(searchService, router) {
    this.searchService = searchService;
    this.router = router;
  }
  ngOnInit() {
  }
  ngAfterViewInit() {
    this.searchService.initSearch("#inputSearch");
  }
  focus() {
    this.isFocus = true;
  }
  blur() {
    setTimeout(() => {
      this.isFocus = false;
      this.searchText = "";
      this.hasSearchText = false;
    }, 200);
  }
  change() {
    setTimeout(() => {
      this.hasSearchText = !!this.searchText?.trim();
    }, 200);
  }
  toRoute($event, item) {
    if (!item.path.startsWith("http")) {
      $event.preventDefault();
      this.router.navigateByUrl(item.path);
    }
  }
  static {
    this.\u0275fac = function SearchComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SearchComponent)(\u0275\u0275directiveInject(SearchService), \u0275\u0275directiveInject(Router));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SearchComponent,
      selectors: [["dg-search"]],
      standalone: false,
      decls: 5,
      vars: 5,
      consts: [[1, "dg-search-container"], ["iconName", "search", 1, "search-icon"], ["id", "inputSearch", 1, "search", 3, "ngModelChange", "blur", "focus", "ngModel", "placeholder"], [1, "search-results-container", 3, "is-searching", "result-empty"], [1, "search-results-container"], [1, "search-result", 3, "href"], ["iconName", "empty", 1, "empty-icon"], [1, "search-result", 3, "click", "href"], [3, "innerHtml"]],
      template: function SearchComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275element(1, "dg-icon", 1);
          \u0275\u0275elementStart(2, "input", 2);
          \u0275\u0275pipe(3, "dgTranslate");
          \u0275\u0275twoWayListener("ngModelChange", function SearchComponent_Template_input_ngModelChange_2_listener($event) {
            \u0275\u0275twoWayBindingSet(ctx.searchText, $event) || (ctx.searchText = $event);
            return $event;
          });
          \u0275\u0275listener("ngModelChange", function SearchComponent_Template_input_ngModelChange_2_listener() {
            return ctx.change();
          })("blur", function SearchComponent_Template_input_blur_2_listener() {
            return ctx.blur();
          })("focus", function SearchComponent_Template_input_focus_2_listener() {
            return ctx.focus();
          });
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(4, SearchComponent_Conditional_4_Template, 4, 5, "div", 3);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275twoWayProperty("ngModel", ctx.searchText);
          \u0275\u0275property("placeholder", \u0275\u0275pipeBind1(3, 3, "SEARCH"));
          \u0275\u0275advance(2);
          \u0275\u0275conditional(!ctx.searchService.hasAlgolia ? 4 : -1);
        }
      },
      dependencies: [DefaultValueAccessor, NgControlStatus, NgModel, IconComponent, TranslatePipe, HighlightPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SearchComponent, [{
    type: Component,
    args: [{
      selector: "dg-search",
      standalone: false,
      template: `<div class="dg-search-container">
  <dg-icon iconName="search" class="search-icon"></dg-icon>
  <input
    class="search"
    id="inputSearch"
    [(ngModel)]="searchText"
    (ngModelChange)="change()"
    [placeholder]="'SEARCH' | dgTranslate"
    (blur)="blur()"
    (focus)="focus()"
  />
  @if (!searchService.hasAlgolia) {
    <div
      class="search-results-container"
      [class.is-searching]="hasSearchText && isFocus"
      [class.result-empty]="searchService.result.length === 0"
    >
      @for (item of searchService.result; track searchService.trackByFn($index, item)) {
        <a class="search-result" [href]="item.path" (click)="toRoute($event, item)">
          @if (item.parent) {
            {{ item.parent.title }} &gt;
          }
          <span [innerHtml]="searchText | highlight: item.title"></span>
        </a>
      }
      @if (hasSearchText && searchService.result.length === 0) {
        <dg-icon class="empty-icon" iconName="empty"></dg-icon>
      }
    </div>
  }
</div>
`
    }]
  }], () => [{
    type: SearchService
  }, {
    type: Router
  }], null);
})();
var IsModeLitePipe = class _IsModeLitePipe {
  constructor() {
  }
  transform(mode) {
    return mode === "lite";
  }
  static {
    this.\u0275fac = function IsModeLitePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsModeLitePipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgIsLite",
      type: _IsModeLitePipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsModeLitePipe, [{
    type: Pipe,
    args: [{
      name: "dgIsLite",
      standalone: false
    }]
  }], () => [], null);
})();
var IsModeFullPipe = class _IsModeFullPipe {
  constructor() {
  }
  transform(mode) {
    return mode === "full";
  }
  static {
    this.\u0275fac = function IsModeFullPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsModeFullPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgIsFull",
      type: _IsModeFullPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsModeFullPipe, [{
    type: Pipe,
    args: [{
      name: "dgIsFull",
      standalone: false
    }]
  }], () => [], null);
})();
var SidebarComponent = class _SidebarComponent {
  constructor(global, router, activatedRoute) {
    this.global = global;
    this.router = router;
    this.activatedRoute = activatedRoute;
    this.isSidebar = true;
    this.menuDisplayMap = /* @__PURE__ */ new Map();
    this.initDisplay = true;
  }
  ngOnInit() {
    this.router.events.pipe(filter((item) => item instanceof NavigationEnd)).subscribe(() => {
      this.updateGroupsCollapseStates();
    });
  }
  toggle(menu) {
    if (!menu.items || !menu.items.length) {
      return;
    }
    const status = this.menuDisplayMap.get(menu);
    this.setMenuOpen(menu, !status);
  }
  setMenuOpen(menu, open) {
    this.menuDisplayMap.set(menu, open);
  }
  ngOnChanges() {
    if (this.initDisplay) {
      this.setMenuDisplay(this.menus);
    }
    this.updateGroupsCollapseStates();
  }
  updateGroupsCollapseStates() {
    let ancestors = [];
    for (const menu of this.global.docItems) {
      const urlTree = this.router.createUrlTree(["./" + menu.path], {
        relativeTo: this.activatedRoute
      });
      const result = this.router.isActive(urlTree, !menu.examples);
      if (result) {
        ancestors = menu.ancestors || [];
        break;
      }
    }
    ancestors.forEach((menu) => {
      this.setMenuOpen(menu, true);
    });
  }
  setMenuDisplay(menus) {
    for (const menu of menus) {
      this.menuDisplayMap.set(menu, true);
      if (menu.items && menu.items.length) {
        this.setMenuDisplay(menu.items);
      }
    }
  }
  static {
    this.\u0275fac = function SidebarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _SidebarComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(ActivatedRoute));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SidebarComponent,
      selectors: [["dg-sidebar"]],
      hostVars: 2,
      hostBindings: function SidebarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-sidebar", ctx.isSidebar);
        }
      },
      inputs: {
        menus: "menus"
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 13,
      vars: 9,
      consts: [["navTemplate", ""], ["changeLanguageTemplate", ""], ["routerLinkActive", "routerLinkActive"], [1, "dg-sidebar-header"], [1, "dg-menu"], [1, "menu-item"], [1, "title", 3, "routerLink"], [1, "description"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [4, "ngTemplateOutlet"], [1, "menu-group", 3, "menu-group--open"], [1, "menu-group"], [1, "group-header", 3, "click"], [1, "group-title"], [1, "group-arrow"], [1, "group-body"], [3, "iconName"], ["target", "_blank", 1, "item-content", 3, "href"], ["iconName", "external", 1, "external-icon"], ["routerLinkActive", "active", 1, "menu-item", 3, "routerLinkActiveOptions"], [1, "item-content", 3, "routerLink"], [1, "item-content-title"], [1, "subtitle"], [1, "item-content-label"], [3, "labelType"], [1, "dg-toc-menu"], [1, "action-items"], [1, "action-item"]],
      template: function SidebarComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, SidebarComponent_Conditional_0_Template, 5, 4, "div", 3);
          \u0275\u0275pipe(1, "dgIsLite");
          \u0275\u0275conditionalCreate(2, SidebarComponent_Conditional_2_Template, 1, 0, "dg-search");
          \u0275\u0275pipe(3, "dgIsLite");
          \u0275\u0275elementStart(4, "div", 4);
          \u0275\u0275repeaterCreate(5, SidebarComponent_For_6_Template, 2, 4, "ng-container", 5, \u0275\u0275repeaterTrackByIdentity);
          \u0275\u0275conditionalCreate(7, SidebarComponent_Conditional_7_Template, 1, 1, "ng-container");
          \u0275\u0275pipe(8, "dgIsLite");
          \u0275\u0275template(9, SidebarComponent_ng_template_9_Template, 2, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
          \u0275\u0275elementEnd();
          \u0275\u0275template(11, SidebarComponent_ng_template_11_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        }
        if (rf & 2) {
          \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 3, ctx.global.config.mode) ? 0 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(\u0275\u0275pipeBind1(3, 5, ctx.global.config.mode) ? 2 : -1);
          \u0275\u0275advance(3);
          \u0275\u0275repeater(ctx.menus);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(\u0275\u0275pipeBind1(8, 7, ctx.global.config.mode) ? 7 : -1);
        }
      },
      dependencies: [NgTemplateOutlet, RouterLink, RouterLinkActive, TableOfContentsComponent, IconComponent, LabelComponent, LocalesSelectorComponent, LogoComponent, SearchComponent, IsModeLitePipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SidebarComponent, [{
    type: Component,
    args: [{
      selector: "dg-sidebar",
      standalone: false,
      template: `@if (global.config.mode | dgIsLite) {
  <div class="dg-sidebar-header">
    <dg-logo></dg-logo>
    <a [routerLink]="['/']" class="title">{{ global.config.title }}</a>
    @if (global.config.description) {
      <span class="description">{{ global.config.description }}</span>
    }
  </div>
}
@if (global.config.mode | dgIsLite) {
  <dg-search></dg-search>
}
<div class="dg-menu">
  @for (menu of menus; track menu) {
    <ng-container class="menu-item">
      <ng-container *ngTemplateOutlet="navTemplate; context: { $implicit: menu }"></ng-container>
    </ng-container>
  }
  @if (global.config.mode | dgIsLite) {
    <ng-container *ngTemplateOutlet="changeLanguageTemplate"></ng-container>
  }

  <ng-template let-menu #navTemplate>
    @if (menu.items) {
      @if (menu.items.length > 0) {
        <div class="menu-group" [class.menu-group--open]="menuDisplayMap.get(menu)">
          <div class="group-header" (click)="toggle(menu)">
            @if (menu.title) {
              <div class="group-title">
                {{ menu.title }}
              </div>
            }
            @if (menu.items && menu.items.length) {
              <div class="group-arrow"><dg-icon [iconName]="'angleRight'"></dg-icon></div>
            }
          </div>
          <div class="group-body">
            @for (menu of menu.items; track menu) {
              <ng-container *ngTemplateOutlet="navTemplate; context: { $implicit: menu }"></ng-container>
            }
          </div>
        </div>
      }
    } @else {
      @if (menu.isExternal) {
        <div class="menu-item">
          <a class="item-content" href="{{ menu.path }}" target="_blank">
            <dg-icon class="external-icon" iconName="external"></dg-icon> {{ menu.title }}
          </a>
        </div>
      } @else {
        <div
          class="menu-item"
          #routerLinkActive="routerLinkActive"
          routerLinkActive="active"
          [routerLinkActiveOptions]="{ exact: !menu.examples }"
        >
          <a class="item-content" [routerLink]="['./' + menu.path]">
            <div class="item-content-title">
              {{ menu.title }}
              @if (menu.subtitle) {
                <span class="subtitle">{{ menu.subtitle }}</span>
              }
            </div>
            <div class="item-content-label">
              @if (menu.label) {
                <dg-label [labelType]="menu.label.color">{{ menu.label.text }}</dg-label>
              }
            </div>
          </a>
        </div>
        @if (menu.toc === 'menu' && routerLinkActive.isActive) {
          <dg-toc class="dg-toc-menu"></dg-toc>
        }
      }
    }
  </ng-template>
</div>

<ng-template #changeLanguageTemplate>
  @if (global.config.locales && global.config.locales.length > 1) {
    <div class="action-items">
      <div class="action-item">
        <dg-locales-selector></dg-locales-selector>
      </div>
    </div>
  }
</ng-template>
`
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: Router
  }, {
    type: ActivatedRoute
  }], {
    isSidebar: [{
      type: HostBinding,
      args: [`class.dg-sidebar`]
    }],
    menus: [{
      type: Input
    }]
  });
})();
var ChannelComponent = class _ChannelComponent {
  constructor() {
    this.isLayout = true;
    this.isScrollContainer = true;
    this.exampleComponentType = null;
    this.exampleModuleFactory = null;
    this.route = inject(ActivatedRoute);
    this.navigationService = inject(NavigationService);
    this.global = inject(GlobalContext);
    this.menus = computed(() => {
      return this.navigationService.channel?.items;
    }, ...ngDevMode ? [{
      debugName: "menus"
    }] : []);
  }
  ngOnInit() {
    const path = this.route.snapshot.routeConfig?.path;
    this.navigationService.selectChannelByPath(path);
  }
  ngOnDestroy() {
    this.navigationService.clearChannel();
  }
  static {
    this.\u0275fac = function ChannelComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChannelComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ChannelComponent,
      selectors: [["dg-channel"]],
      hostVars: 4,
      hostBindings: function ChannelComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-layout", ctx.isLayout)("dg-scroll-container", ctx.isScrollContainer);
        }
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[3, "menus"]],
      template: function ChannelComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ChannelComponent_Conditional_0_Template, 2, 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.navigationService.channel ? 0 : -1);
        }
      },
      dependencies: [RouterOutlet, SidebarComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChannelComponent, [{
    type: Component,
    args: [{
      selector: "dg-channel",
      standalone: false,
      template: '@if (navigationService.channel) {\n  <dg-sidebar [menus]="menus()"></dg-sidebar>\n  <router-outlet></router-outlet>\n}\n'
    }]
  }], () => [], {
    isLayout: [{
      type: HostBinding,
      args: [`class.dg-layout`]
    }],
    isScrollContainer: [{
      type: HostBinding,
      args: [`class.dg-scroll-container`]
    }]
  });
})();
var ChannelHomeComponent = class _ChannelHomeComponent {
  constructor(router, navigationService, global, route) {
    this.router = router;
    this.navigationService = navigationService;
    this.global = global;
    this.route = route;
  }
  ngOnInit() {
    const firstDocItem = this.navigationService.getChannelFirstDocItem();
    if (firstDocItem) {
      this.router.navigate(["./" + firstDocItem.path], {
        replaceUrl: true,
        relativeTo: this.route
      });
    }
  }
  static {
    this.\u0275fac = function ChannelHomeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ChannelHomeComponent)(\u0275\u0275directiveInject(Router), \u0275\u0275directiveInject(NavigationService), \u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(ActivatedRoute));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ChannelHomeComponent,
      selectors: [["dg-channel-home"]],
      standalone: false,
      decls: 0,
      vars: 0,
      template: function ChannelHomeComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ChannelHomeComponent, [{
    type: Component,
    args: [{
      selector: "dg-channel-home",
      template: ``,
      standalone: false
    }]
  }], () => [{
    type: Router
  }, {
    type: NavigationService
  }, {
    type: GlobalContext
  }, {
    type: ActivatedRoute
  }], null);
})();
var FooterComponent = class _FooterComponent {
  constructor(global, elementRef) {
    this.global = global;
    this.elementRef = elementRef;
    this.isHide = true;
  }
  ngOnInit() {
    if (this.global.config.footer) {
      this.elementRef.nativeElement.innerHTML = this.global.config.footer;
      this.isHide = false;
    } else {
      this.isHide = true;
    }
  }
  static {
    this.\u0275fac = function FooterComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _FooterComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _FooterComponent,
      selectors: [["dg-footer"]],
      hostAttrs: [1, "dg-footer"],
      hostVars: 2,
      hostBindings: function FooterComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-hidden", ctx.isHide);
        }
      },
      standalone: false,
      ngContentSelectors: _c029,
      decls: 1,
      vars: 0,
      template: function FooterComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(FooterComponent, [{
    type: Component,
    args: [{
      selector: "dg-footer",
      host: {
        class: "dg-footer"
      },
      standalone: false,
      template: "<ng-content></ng-content>\n"
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: ElementRef
  }], {
    isHide: [{
      type: HostBinding,
      args: [`class.dg-hidden`]
    }]
  });
})();
var DocHeaderComponent = class _DocHeaderComponent {
  constructor(navigationService, global) {
    this.navigationService = navigationService;
    this.global = global;
  }
  ngOnInit() {
  }
  toggleSidebar(event) {
    this.navigationService.toggleSidebar();
    event.stopPropagation();
  }
  ngOnDestroy() {
    this.navigationService.resetShowSidebar();
  }
  static {
    this.\u0275fac = function DocHeaderComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocHeaderComponent)(\u0275\u0275directiveInject(NavigationService), \u0275\u0275directiveInject(GlobalContext));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocHeaderComponent,
      selectors: [["dg-doc-header"]],
      inputs: {
        title: "title",
        subtitle: "subtitle"
      },
      standalone: false,
      decls: 7,
      vars: 7,
      consts: [[1, "dg-doc-header"], ["href", "javascript:;", 1, "sidebar-toggler"], [1, "title"], [1, "subtitle"], ["href", "javascript:;", 1, "sidebar-toggler", 3, "click"], ["iconName", "list"]],
      template: function DocHeaderComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "header", 0);
          \u0275\u0275conditionalCreate(1, DocHeaderComponent_Conditional_1_Template, 2, 0, "a", 1);
          \u0275\u0275pipe(2, "dgIsFull");
          \u0275\u0275pipe(3, "dgIsLite");
          \u0275\u0275elementStart(4, "span", 2);
          \u0275\u0275text(5);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(6, DocHeaderComponent_Conditional_6_Template, 2, 1, "span", 3);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275conditional(\u0275\u0275pipeBind1(2, 3, ctx.global.config.mode) && ctx.navigationService.channel || \u0275\u0275pipeBind1(3, 5, ctx.global.config.mode) ? 1 : -1);
          \u0275\u0275advance(4);
          \u0275\u0275textInterpolate(ctx.title);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.subtitle ? 6 : -1);
        }
      },
      dependencies: [IconComponent, IsModeLitePipe, IsModeFullPipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocHeaderComponent, [{
    type: Component,
    args: [{
      selector: "dg-doc-header",
      changeDetection: ChangeDetectionStrategy.OnPush,
      standalone: false,
      template: '<header class="dg-doc-header">\n  @if (((global.config.mode | dgIsFull) && navigationService.channel) || (global.config.mode | dgIsLite)) {\n    <a class="sidebar-toggler" href="javascript:;" (click)="toggleSidebar($event)"><dg-icon iconName="list"></dg-icon></a>\n  }\n\n  <span class="title">{{ title }}</span>\n  @if (subtitle) {\n    <span class="subtitle">{{ subtitle }}</span>\n  }\n</header>\n'
    }]
  }], () => [{
    type: NavigationService
  }, {
    type: GlobalContext
  }], {
    title: [{
      type: Input
    }],
    subtitle: [{
      type: Input
    }]
  });
})();
var ExampleService = class _ExampleService {
  generateEntryFile(module, component) {
    return [this.generateAppModuleTs(module, component), this.generateIndexHtml(), this.generateMainTs(), this.generateAppComponentTs(component.selector)];
  }
  generateAppModuleTs(module, component) {
    return {
      path: `src/app.module.ts`,
      content: `import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { ${module.name} } from './examples.module';
import { AppComponent } from './app.component'
@NgModule({
    declarations: [AppComponent],
    imports: [BrowserModule,${module.name}],
    providers: [],
    bootstrap: [AppComponent]
})
export class AppModule {
    constructor() {}
}
`
    };
  }
  generateMainTs() {
    return {
      path: `src/main.ts`,
      content: `import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';
import { AppModule } from './app.module';
import 'zone.js';
platformBrowserDynamic().bootstrapModule(AppModule);
            `
    };
  }
  generateIndexHtml() {
    return {
      path: `src/index.html`,
      content: `<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <title>Docgeni</title>
    <base href="/" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
  </head>
  <body>
    <app-root></app-root>
  </body>
</html>
`
    };
  }
  generateAppComponentTs(selector) {
    return {
      path: `src/app.component.ts`,
      content: `import { Component } from '@angular/core';
@Component({
  selector: 'app-root',
  template: '<${selector}></${selector}>',
})
export class AppComponent {}`
    };
  }
  static {
    this.\u0275fac = function ExampleService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExampleService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _ExampleService,
      factory: _ExampleService.\u0275fac
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleService, [{
    type: Injectable
  }], null, null);
})();
var StackblitzExampleService = class _StackblitzExampleService extends ExampleService {
  createFormInput(key, value) {
    const input2 = document.createElement("textarea");
    input2.name = key;
    input2.value = value;
    input2.hidden = true;
    return input2;
  }
  open(files, module, component) {
    const form = document.createElement("form");
    form.hidden = true;
    form.target = "_blank";
    form.method = "post";
    form.action = `https://run.stackblitz.com/api/angular/v1`;
    const entryFiles = this.generateEntryFile(module, component);
    const allFiles = [...entryFiles, ...files];
    const filesMap = {};
    allFiles.forEach((item) => {
      filesMap[`files[${item.path}]`] = item.content;
    });
    for (const path in filesMap) {
      if (Object.prototype.hasOwnProperty.call(filesMap, path)) {
        const content = filesMap[path];
        form.appendChild(this.createFormInput(path, content));
      }
    }
    const packageJsonFile = allFiles.find((item) => item.path === "package.json");
    form.appendChild(this.createFormInput(`dependencies`, JSON.stringify(JSON.parse(packageJsonFile.content).dependencies)));
    document.body.appendChild(form);
    form.submit();
    document.body.removeChild(form);
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275StackblitzExampleService_BaseFactory;
      return function StackblitzExampleService_Factory(__ngFactoryType__) {
        return (\u0275StackblitzExampleService_BaseFactory || (\u0275StackblitzExampleService_BaseFactory = \u0275\u0275getInheritedFactory(_StackblitzExampleService)))(__ngFactoryType__ || _StackblitzExampleService);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _StackblitzExampleService,
      factory: _StackblitzExampleService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(StackblitzExampleService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
function coerceBooleanProperty3(value) {
  return value !== null && value !== void 0 && `${value}` !== "false";
}
var ExampleRendererComponent = class _ExampleRendererComponent {
  get enableIvy() {
    return this.exampleLoader.enableIvy;
  }
  constructor(exampleLoader) {
    this.exampleLoader = exampleLoader;
    this.componentType = linkedSignal(() => {
      return this.exampleComponentType();
    }, ...ngDevMode ? [{
      debugName: "componentType"
    }] : []);
    this.exampleModuleFactory = null;
    this.name = input(...ngDevMode ? [void 0, {
      debugName: "name"
    }] : []);
    this.exampleModuleType = input(null, ...ngDevMode ? [{
      debugName: "exampleModuleType"
    }] : []);
    this.exampleComponentType = input(...ngDevMode ? [void 0, {
      debugName: "exampleComponentType"
    }] : []);
    this.exampleLoadSuccess = new EventEmitter();
    effect(() => {
      const name = this.name();
      if (name) {
        this.load(name);
      }
    });
  }
  ngOnInit() {
  }
  load(name) {
    this.exampleLoader.load(name).then((result) => {
      this.exampleModuleFactory = new NgModuleFactory(result.moduleType);
      this.componentType.set(result.componentType);
      this.exampleLoadSuccess.emit(result.example);
    });
  }
  static {
    this.\u0275fac = function ExampleRendererComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExampleRendererComponent)(\u0275\u0275directiveInject(ExampleLoader));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ExampleRendererComponent,
      selectors: [["dg-example-renderer"], ["", "dgExampleRenderer", ""]],
      inputs: {
        name: [1, "name"],
        exampleModuleType: [1, "exampleModuleType"],
        exampleComponentType: [1, "exampleComponentType"]
      },
      outputs: {
        exampleLoadSuccess: "exampleLoadSuccess"
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[3, "ngComponentOutlet"]],
      template: function ExampleRendererComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ExampleRendererComponent_Conditional_0_Template, 1, 1, null, 0);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.componentType() ? 0 : -1);
        }
      },
      dependencies: [NgComponentOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleRendererComponent, [{
    type: Component,
    args: [{
      selector: "dg-example-renderer, [dgExampleRenderer]",
      standalone: false,
      template: '@if (componentType()) {\n  <ng-template [ngComponentOutlet]="componentType()!"></ng-template>\n}\n'
    }]
  }], () => [{
    type: ExampleLoader
  }], {
    name: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "name",
        required: false
      }]
    }],
    exampleModuleType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "exampleModuleType",
        required: false
      }]
    }],
    exampleComponentType: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "exampleComponentType",
        required: false
      }]
    }],
    exampleLoadSuccess: [{
      type: Output
    }]
  });
})();
var ContentRenderer = class _ContentRenderer {
  constructor() {
    this.url = input(...ngDevMode ? [void 0, {
      debugName: "url"
    }] : []);
    this.content = input(...ngDevMode ? [void 0, {
      debugName: "content"
    }] : []);
    this.contentRendered = new EventEmitter();
    this.http = inject(HttpClient);
    effect(() => {
      if (this.url()) {
        this.fetchDocument(this.url());
      }
    });
    effect(() => {
      if (this.content()) {
        this.updateDocument(this.content());
      }
    });
  }
  fetchDocument(url) {
    if (this.documentFetchSubscription) {
      this.documentFetchSubscription.unsubscribe();
    }
    this.documentFetchSubscription = this.http.get(url, {
      responseType: "text"
    }).subscribe((response) => {
      this.updateDocument(response);
    }, (error) => {
      this.showError(url, error);
    });
  }
  destroy() {
    this.documentFetchSubscription.unsubscribe();
  }
  static {
    this.\u0275fac = function ContentRenderer_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ContentRenderer)();
    };
  }
  static {
    this.\u0275dir = /* @__PURE__ */ \u0275\u0275defineDirective({
      type: _ContentRenderer,
      inputs: {
        url: [1, "url"],
        content: [1, "content"]
      },
      outputs: {
        contentRendered: "contentRendered"
      }
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentRenderer, [{
    type: Directive
  }], () => [], {
    url: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "url",
        required: false
      }]
    }],
    content: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "content",
        required: false
      }]
    }],
    contentRendered: [{
      type: Output
    }]
  });
})();
var CopierService = class _CopierService {
  /** Copy the text value to the clipboard. */
  copyText(text) {
    this.createTextareaAndSelect(text);
    const copySuccessful = document.execCommand("copy");
    this.removeFake();
    return copySuccessful;
  }
  /**
   * Creates a hidden textarea element, sets its value from `text` property,
   * and makes a selection on it.
   */
  createTextareaAndSelect(text) {
    this.textarea = document.createElement("textarea");
    this.textarea.style.fontSize = "12pt";
    this.textarea.classList.add("dg-visually-hidden");
    const yPosition = window.pageYOffset || document.documentElement.scrollTop;
    this.textarea.style.top = yPosition + "px";
    this.textarea.setAttribute("readonly", "");
    this.textarea.value = text;
    document.body.appendChild(this.textarea);
    this.textarea.select();
    this.textarea.setSelectionRange(0, this.textarea.value.length);
  }
  /** Remove the text area from the DOM. */
  removeFake() {
    if (this.textarea) {
      document.body.removeChild(this.textarea);
      delete this.textarea;
    }
  }
  static {
    this.\u0275fac = function CopierService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CopierService)();
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _CopierService,
      factory: _CopierService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CopierService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], null, null);
})();
var CopyComponent = class _CopyComponent {
  constructor(copier) {
    this.copier = copier;
    this.icon = "copy";
    this.dgCopy = input("", ...ngDevMode ? [{
      debugName: "dgCopy"
    }] : []);
  }
  ngOnInit() {
  }
  copy($event) {
    this.copier.copyText(this.dgCopy());
    this.icon = "check";
    setTimeout(() => {
      this.icon = "copy";
    }, 2e3);
  }
  static {
    this.\u0275fac = function CopyComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CopyComponent)(\u0275\u0275directiveInject(CopierService));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _CopyComponent,
      selectors: [["dg-copy"], ["", "dgCopy", ""]],
      hostAttrs: [1, "dg-copy"],
      hostBindings: function CopyComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("click", function CopyComponent_click_HostBindingHandler($event) {
            return ctx.copy($event);
          });
        }
      },
      inputs: {
        dgCopy: [1, "dgCopy"]
      },
      standalone: false,
      ngContentSelectors: _c029,
      decls: 2,
      vars: 1,
      consts: [[1, "color-primary", 3, "iconName"]],
      template: function CopyComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275projectionDef();
          \u0275\u0275projection(0);
          \u0275\u0275element(1, "dg-icon", 0);
        }
        if (rf & 2) {
          \u0275\u0275advance();
          \u0275\u0275property("iconName", ctx.icon);
        }
      },
      dependencies: [IconComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CopyComponent, [{
    type: Component,
    args: [{
      selector: "dg-copy,[dgCopy]",
      host: {
        class: "dg-copy"
      },
      standalone: false,
      template: '<ng-content></ng-content>\n<dg-icon class="color-primary" [iconName]="icon"></dg-icon>\n'
    }]
  }], () => [{
    type: CopierService
  }], {
    dgCopy: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "dgCopy",
        required: false
      }]
    }],
    copy: [{
      type: HostListener,
      args: ["click", ["$event"]]
    }]
  });
})();
var SourceCodeComponent = class _SourceCodeComponent extends ContentRenderer {
  constructor() {
    super(...arguments);
    this.codeContent = viewChild("codeContent", __spreadProps(__spreadValues({}, ngDevMode ? {
      debugName: "codeContent"
    } : {}), {
      read: ElementRef
    }));
    this.textContent = computed(() => {
      return this.codeContent()?.nativeElement?.textContent;
    }, ...ngDevMode ? [{
      debugName: "textContent"
    }] : []);
  }
  ngOnInit() {
  }
  updateDocument(content) {
    if (this.codeContent() && this.codeContent()?.nativeElement) {
      this.codeContent().nativeElement.innerHTML = content;
    }
  }
  showError(url, error) {
    console.log(error);
    if (this.textContent() && this.textContent().nativeElement) {
      this.codeContent().nativeElement.innerText = `Failed to load document: ${url}. Error: ${error.statusText}`;
    }
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275SourceCodeComponent_BaseFactory;
      return function SourceCodeComponent_Factory(__ngFactoryType__) {
        return (\u0275SourceCodeComponent_BaseFactory || (\u0275SourceCodeComponent_BaseFactory = \u0275\u0275getInheritedFactory(_SourceCodeComponent)))(__ngFactoryType__ || _SourceCodeComponent);
      };
    })();
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _SourceCodeComponent,
      selectors: [["dg-source-code"], ["", "dgSourceCode", ""]],
      viewQuery: function SourceCodeComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuerySignal(ctx.codeContent, _c73, 5, ElementRef);
        }
        if (rf & 2) {
          \u0275\u0275queryAdvance();
        }
      },
      hostAttrs: [1, "dg-source-code"],
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 3,
      vars: 1,
      consts: [["codeContent", ""], [1, "dg-source-code-content"], ["href", "javascript:;", "title", "Copy", 3, "dgCopy"]],
      template: function SourceCodeComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "div", 1, 0)(2, "a", 2);
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("dgCopy", ctx.textContent());
        }
      },
      dependencies: [CopyComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(SourceCodeComponent, [{
    type: Component,
    args: [{
      selector: "dg-source-code, [dgSourceCode]",
      host: {
        class: "dg-source-code"
      },
      standalone: false,
      template: '<div class="dg-source-code-content" #codeContent></div>\n<a href="javascript:;" title="Copy" [dgCopy]="textContent()"></a>\n'
    }]
  }], null, {
    codeContent: [{
      type: ViewChild,
      args: ["codeContent", __spreadProps(__spreadValues({}, {
        read: ElementRef
      }), {
        isSignal: true
      })]
    }]
  });
})();
var EXAMPLES_HIGHLIGHTED_PATH = `examples-highlighted`;
var nameOrdersMap = {
  HTML: 1,
  TS: 2,
  SCSS: 3,
  CSS: 4
};
var ExampleViewerComponent = class _ExampleViewerComponent {
  get enableIvy() {
    return this.exampleLoader.enableIvy;
  }
  constructor() {
    this._inline = false;
    this.exampleLoader = inject(ExampleLoader);
    this.globalContext = inject(GlobalContext);
    this.http = inject(HttpClient);
    this.stackblitzExampleService = inject(StackblitzExampleService);
    this.name = input.required(...ngDevMode ? [{
      debugName: "name"
    }] : []);
    this.inline = input(false, __spreadProps(__spreadValues({}, ngDevMode ? {
      debugName: "inline"
    } : {}), {
      transform: coerceBooleanProperty3
    }));
    this.example = signal(void 0, ...ngDevMode ? [{
      debugName: "example"
    }] : []);
    this.showSource = false;
    this.exampleTabs = [];
  }
  // Use short name such as TS, HTML, CSS replace exampleName.component.*, we need to transform
  // the file name to match the exampleName.component.* that displays main source files.
  transformFileName(fileName, exampleName) {
    return fileName.startsWith(`${exampleName}.component.`) ? fileName.replace(`${exampleName}.component.`, "").toUpperCase() : fileName;
  }
  ngOnInit() {
    this.exampleLoader.load(this.name()).then((result) => {
      this.exampleModuleType = result.moduleType;
      this.exampleComponentType = result.componentType;
      const example = result.example;
      this.example.set(example);
      const rootDir = this.globalContext.getAssetsContentPath(`${EXAMPLES_HIGHLIGHTED_PATH}/${example.module.importSpecifier}/${example.name}`);
      this.exampleTabs = example.sourceFiles.map((file) => {
        return {
          name: this.transformFileName(file.name, example.name),
          path: `${rootDir}/${file.highlightedPath}`
        };
      }).sort((a, b) => {
        const aOrder = nameOrdersMap[a.name] || Number.MAX_SAFE_INTEGER;
        const bOrder = nameOrdersMap[b.name] || Number.MAX_SAFE_INTEGER;
        return aOrder > bOrder ? 1 : aOrder === bOrder ? 0 : -1;
      });
      this.selectedTab = this.exampleTabs[0];
    });
  }
  selectExampleTab(tab) {
    this.selectedTab = tab;
  }
  toggleSource() {
    this.showSource = !this.showSource;
  }
  openStackBlitz() {
    forkJoin({
      examplesSources: this.http.get(`assets/content/examples-source-bundle/${this.example().module.importSpecifier}/bundle.json`),
      sharedFiles: this.http.get(`assets/stack-blitz/bundle.json`)
    }).subscribe((result) => {
      const {
        examplesSources,
        sharedFiles
      } = result;
      this.stackblitzExampleService.open([...examplesSources.map((item) => {
        return __spreadProps(__spreadValues({}, item), {
          path: `src/${item.path}`
        });
      }), ...sharedFiles], this.example().module, {
        name: this.example().componentName,
        selector: this.example().key
      });
    });
  }
  static {
    this.\u0275fac = function ExampleViewerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExampleViewerComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ExampleViewerComponent,
      selectors: [["dg-example-viewer"]],
      hostAttrs: ["class.dg-example-viewer-inline", "inline()", 1, "dg-example-viewer"],
      hostVars: 1,
      hostBindings: function ExampleViewerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          let tmp_0_0;
          \u0275\u0275attribute("id", (tmp_0_0 = ctx.example()) == null ? null : tmp_0_0.key);
        }
      },
      inputs: {
        name: [1, "name"],
        inline: [1, "inline"]
      },
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [["sourceCode", ""], [1, "dg-example-viewer-wrapper"], [1, "dg-example-viewer-header"], [1, "title"], ["dgExampleRenderer", "", 1, "dg-example-viewer-body", 3, "exampleModuleType", "exampleComponentType"], [1, "dg-example-viewer-actions", 3, "title"], ["title", "Copy source code", "href", "javascript:;", 1, "action-item", 3, "dgCopy"], ["title", "Toggle source code", "href", "javascript:;", 1, "action-item", 3, "click"], ["iconName", "code"], ["title", "Open example in new tab", "target", "_blank", 1, "action-item", 3, "href"], ["iconName", "external"], ["title", "Open example in StackBlitz", "target", "_blank", 1, "action-item", 3, "click"], ["iconName", "stackBlitz"], [1, "dg-example-viewer-sources", 3, "ngClass"], [1, "dg-tab-links"], ["href", "javascript:;", 1, "dg-tab-link", 3, "ngClass"], ["dgSourceCode", "", 3, "url"], ["href", "javascript:;", 1, "dg-tab-link", 3, "click", "ngClass"]],
      template: function ExampleViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ExampleViewerComponent_Conditional_0_Template, 19, 17, "div", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.example() ? 0 : -1);
        }
      },
      dependencies: [NgClass, ExampleRendererComponent, IconComponent, SourceCodeComponent, CopyComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleViewerComponent, [{
    type: Component,
    args: [{
      selector: "dg-example-viewer",
      host: {
        "[attr.id]": "example()?.key",
        class: "dg-example-viewer",
        "class.dg-example-viewer-inline": "inline()"
      },
      standalone: false,
      template: `@if (example()) {
  <div class="dg-example-viewer-wrapper">
    <div class="dg-example-viewer-header">
      <span class="title">{{ example()!.title }}</span>
    </div>
    <div
      class="dg-example-viewer-body"
      [style.background]="example()!.background"
      [class.dg-example-viewer-compact]="example()!.compact"
      [class]="example()!.className"
      dgExampleRenderer
      [exampleModuleType]="exampleModuleType"
      [exampleComponentType]="exampleComponentType"
    ></div>
    <div class="dg-example-viewer-actions" title="{{ example()!.title }}">
      <a class="action-item" title="Copy source code" href="javascript:;" [dgCopy]="sourceCode?.textContent()"></a>
      <a class="action-item" title="Toggle source code" href="javascript:;" (click)="toggleSource()"><dg-icon iconName="code"></dg-icon></a>
      <a class="action-item" title="Open example in new tab" target="_blank" [href]="'~examples/' + name()"
        ><dg-icon iconName="external"></dg-icon
      ></a>
      <a class="action-item" title="Open example in StackBlitz" target="_blank" (click)="openStackBlitz()"
        ><dg-icon iconName="stackBlitz"></dg-icon
      ></a>
    </div>
    <div class="dg-example-viewer-sources" [ngClass]="{ 'dg-sources-show': showSource }">
      <div class="dg-tab-links">
        @for (tab of exampleTabs; track tab.name) {
          <a [ngClass]="{ active: tab === selectedTab }" class="dg-tab-link" href="javascript:;" (click)="selectExampleTab(tab)">{{
            tab.name
          }}</a>
        }
      </div>
      <pre #sourceCode dgSourceCode [url]="selectedTab.path"></pre>
    </div>
  </div>
}
`
    }]
  }], () => [], {
    name: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "name",
        required: true
      }]
    }],
    inline: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "inline",
        required: false
      }]
    }]
  });
})();
var Portal2 = class {
  /** Attach this portal to a host. */
  attach(host) {
    this._attachedHost = host;
    return host.attach(this);
  }
  /** Detach this portal from its host */
  detach() {
    const host = this._attachedHost;
    if (host !== null) {
      this._attachedHost = null;
      host.detach();
    }
  }
  /** Whether this portal is attached to a host. */
  get isAttached() {
    return this._attachedHost !== null;
  }
  /**
   * Sets the PortalOutlet reference without performing `attach()`. This is used directly by
   * the PortalOutlet when it is performing an `attach()` or `detach()`.
   */
  setAttachedHost(host) {
    this._attachedHost = host;
  }
};
var ComponentPortal2 = class extends Portal2 {
  constructor(component, viewContainerRef, injector, componentFactoryResolver) {
    super();
    this.component = component;
    this.viewContainerRef = viewContainerRef;
    this.injector = injector;
    this.componentFactoryResolver = componentFactoryResolver;
  }
};
var DomPortalOutlet2 = class {
  constructor(outletElement, componentFactoryResolver, appRef, defaultInjector, projectableNodes) {
    this.outletElement = outletElement;
    this.componentFactoryResolver = componentFactoryResolver;
    this.appRef = appRef;
    this.defaultInjector = defaultInjector;
    this.projectableNodes = projectableNodes;
  }
  attach(portal, replace = false) {
    const resolver = portal.componentFactoryResolver || this.componentFactoryResolver;
    const componentFactory = resolver.resolveComponentFactory(portal.component);
    let componentRef;
    if (portal.viewContainerRef) {
      componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector, this.projectableNodes);
      this.setDisposeFn(() => {
        componentRef.destroy();
      });
    } else {
      componentRef = componentFactory.create(portal.injector || this.defaultInjector);
      this.appRef.attachView(componentRef.hostView);
      this.setDisposeFn(() => {
        this.appRef.detachView(componentRef.hostView);
        componentRef.destroy();
      });
    }
    if (replace) {
      this.outletElement.replaceWith(this.getComponentRootNode(componentRef));
    } else {
      this.outletElement.appendChild(this.getComponentRootNode(componentRef));
    }
    this.attachedPortal = portal;
    return componentRef;
  }
  hasAttached() {
    return !!this.attachedPortal;
  }
  /** Detaches a previously attached portal. */
  detach() {
    if (this.attachedPortal) {
      this.attachedPortal.setAttachedHost(null);
      this.attachedPortal = null;
    }
    this.invokeDisposeFn();
  }
  /** Permanently dispose of this portal host. */
  dispose() {
    if (this.hasAttached()) {
      this.detach();
    }
    this.invokeDisposeFn();
    this.isDisposed = true;
  }
  /** @docs-private */
  setDisposeFn(fn) {
    this.disposeFn = fn;
  }
  invokeDisposeFn() {
    if (this.disposeFn) {
      this.disposeFn();
      this.disposeFn = null;
    }
  }
  /** Gets the root HTMLElement for an instantiated component. */
  getComponentRootNode(componentRef) {
    return componentRef.hostView.rootNodes[0];
  }
};
var ContentViewerComponent = class _ContentViewerComponent extends ContentRenderer {
  constructor(elementRef, appRef, componentFactoryResolver, injector, viewContainerRef, ngZone, tocService, cdr) {
    super();
    this.elementRef = elementRef;
    this.appRef = appRef;
    this.componentFactoryResolver = componentFactoryResolver;
    this.injector = injector;
    this.viewContainerRef = viewContainerRef;
    this.ngZone = ngZone;
    this.tocService = tocService;
    this.cdr = cdr;
    this.portalHosts = [];
  }
  ngOnInit() {
  }
  updateDocument(content) {
    this.elementRef.nativeElement.innerHTML = content;
    this.loadComponents("example", ExampleViewerComponent);
    getBuiltInComponents().forEach((item) => {
      this.loadComponents(item.selector, item.component, true);
    });
    this.cdr.markForCheck();
    this.ngZone.run(() => {
      setTimeout(() => {
        this.contentRendered.emit(this.elementRef.nativeElement);
        this.updateTableOfContents(this.elementRef.nativeElement);
      });
    });
  }
  updateTableOfContents(docViewerContent) {
    if (docViewerContent) {
      this.tocService.generateToc(docViewerContent);
    }
  }
  loadComponents(selector, componentClass, replace = false) {
    const exampleElements = this.elementRef.nativeElement.querySelectorAll(selector);
    Array.prototype.slice.call(exampleElements).forEach((element) => {
      const portalHost = new DomPortalOutlet2(element, this.componentFactoryResolver, this.appRef, this.injector, [element.childNodes]);
      const examplePortal = new ComponentPortal2(componentClass, this.viewContainerRef);
      const exampleViewerRef = portalHost.attach(examplePortal, replace);
      const compMetadata = reflectComponentType(componentClass);
      const inputsOfKey = compMetadata?.inputs.reduce((result, item) => {
        result[item.templateName] = item;
        return result;
      }, {}) || {};
      for (const attributeKey in element.attributes) {
        if (Object.prototype.hasOwnProperty.call(element.attributes, attributeKey)) {
          const attribute = element.attributes[attributeKey];
          const qualifiedName = attribute.nodeName;
          const setAttributeFn = exampleViewerRef.instance["setAttribute"];
          if (inputsOfKey[attribute.nodeName]) {
            exampleViewerRef.setInput(qualifiedName, element.getAttribute(qualifiedName));
          } else {
            exampleViewerRef.instance[qualifiedName] = element.getAttribute(qualifiedName);
          }
          if (setAttributeFn) {
            setAttributeFn.call(exampleViewerRef.instance, qualifiedName, element.getAttribute(qualifiedName) || "");
          }
        }
      }
      this.portalHosts.push(portalHost);
    });
  }
  /** Show an error that occurred when fetching a document. */
  showError(url, error) {
    console.log(error);
    this.elementRef.nativeElement.innerText = `Failed to load document: ${url}. Error: ${error.statusText}`;
  }
  clearLiveExamples() {
    this.portalHosts.forEach((h) => h.dispose());
    this.portalHosts = [];
  }
  ngOnDestroy() {
    this.clearLiveExamples();
    this.tocService.reset();
    super.destroy();
  }
  static {
    this.\u0275fac = function ContentViewerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ContentViewerComponent)(\u0275\u0275directiveInject(ElementRef), \u0275\u0275directiveInject(ApplicationRef), \u0275\u0275directiveInject(ComponentFactoryResolver$1), \u0275\u0275directiveInject(Injector), \u0275\u0275directiveInject(ViewContainerRef), \u0275\u0275directiveInject(NgZone), \u0275\u0275directiveInject(TocService), \u0275\u0275directiveInject(ChangeDetectorRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ContentViewerComponent,
      selectors: [["dg-content-viewer"]],
      hostAttrs: [1, "dg-doc-content"],
      standalone: false,
      features: [\u0275\u0275InheritDefinitionFeature],
      decls: 1,
      vars: 0,
      template: function ContentViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275text(0, "Loading...");
        }
      },
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ContentViewerComponent, [{
    type: Component,
    args: [{
      selector: "dg-content-viewer",
      template: "Loading...",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "dg-doc-content"
      },
      standalone: false
    }]
  }], () => [{
    type: ElementRef
  }, {
    type: ApplicationRef
  }, {
    type: ComponentFactoryResolver$1
  }, {
    type: Injector
  }, {
    type: ViewContainerRef
  }, {
    type: NgZone
  }, {
    type: TocService
  }, {
    type: ChangeDetectorRef
  }], null);
})();
var DocMetaComponent = class _DocMetaComponent {
  constructor() {
    this.hideDocMeta = signal(false, ...ngDevMode ? [{
      debugName: "hideDocMeta"
    }] : []);
    this.lastUpdatedTime = signal(void 0, ...ngDevMode ? [{
      debugName: "lastUpdatedTime"
    }] : []);
    this.contributors = signal(void 0, ...ngDevMode ? [{
      debugName: "contributors"
    }] : []);
    this.http = inject(HttpClient);
    this.globalContext = inject(GlobalContext);
    this.docItem = input.required(...ngDevMode ? [{
      debugName: "docItem"
    }] : []);
    effect(() => {
      const docItem = this.docItem();
      untracked(() => {
        if (docItem.originPath && this.globalContext.owner && this.globalContext.repo) {
          this.http.get(`https://api.github.com/repos/${this.globalContext.owner}/${this.globalContext.repo}/commits`, {
            params: {
              path: docItem.originPath
            }
          }).pipe(filter((result) => !!result.length)).subscribe((result) => {
            this.contributors.set(Array.from(new Set(result.map((item) => item.author.login))));
            this.lastUpdatedTime.set(new Date(result[0].commit.author.date));
            this.hideDocMeta.set(false);
          });
        } else {
          this.contributors.set(void 0);
          this.lastUpdatedTime.set(void 0);
          this.hideDocMeta.set(true);
        }
      });
    });
  }
  ngOnChanges() {
  }
  static {
    this.\u0275fac = function DocMetaComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocMetaComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocMetaComponent,
      selectors: [["dg-doc-meta"]],
      hostAttrs: [1, "dg-doc-meta"],
      hostVars: 2,
      hostBindings: function DocMetaComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-d-none", ctx.hideDocMeta());
        }
      },
      inputs: {
        docItem: [1, "docItem"]
      },
      standalone: false,
      features: [\u0275\u0275NgOnChangesFeature],
      decls: 2,
      vars: 2,
      consts: [[1, "dg-contributor-avatar-list"], [1, "dg-contribution-last-time"], [1, "dg-contributor-avatar", 3, "title"], [1, "dg-contributor-avatar", "dg-contributor-other"], [3, "src"]],
      template: function DocMetaComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, DocMetaComponent_Conditional_0_Template, 6, 8, "div", 0);
          \u0275\u0275conditionalCreate(1, DocMetaComponent_Conditional_1_Template, 4, 7, "div", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.contributors() ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.lastUpdatedTime() ? 1 : -1);
        }
      },
      dependencies: [SlicePipe, DatePipe, TranslatePipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocMetaComponent, [{
    type: Component,
    args: [{
      selector: "dg-doc-meta",
      host: {
        class: "dg-doc-meta",
        "[class.dg-d-none]": "hideDocMeta()"
      },
      standalone: false,
      template: `@if (contributors()) {
  <div class="dg-contributor-avatar-list">
    @for (item of contributors() | slice: 0 : 3; track item; let i = $index) {
      <div class="dg-contributor-avatar" [title]="item">
        <img src="https://avatars.githubusercontent.com/{{ item }}" />
      </div>
    }
    @if ((contributors()! | slice: 3).length) {
      <div class="dg-contributor-avatar dg-contributor-other">
        {{ (contributors()! | slice: 3).length }}
      </div>
    }
  </div>
}
@if (lastUpdatedTime()) {
  <div class="dg-contribution-last-time">
    {{ 'LAST_UPDATED_TIME' | dgTranslate }}
    {{ lastUpdatedTime() | date: 'yyyy/MM/dd' }}
  </div>
}
`
    }]
  }], () => [], {
    docItem: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "docItem",
        required: true
      }]
    }]
  });
})();
var DocPagesLinksComponent = class _DocPagesLinksComponent {
  constructor(globalContext) {
    this.globalContext = globalContext;
  }
  ngOnInit() {
    if (this.docPages.pre) {
      this.preRouterLink = this.globalContext.config.mode === "lite" ? `/${this.docPages.pre.path}` : `/${this.docPages.pre.channelPath}/${this.docPages.pre.path}`;
    }
    if (this.docPages.next) {
      this.nextRouterLink = this.globalContext.config.mode === "lite" ? `/${this.docPages.next.path}` : `/${this.docPages.next.channelPath}/${this.docPages.next.path}`;
    }
  }
  static {
    this.\u0275fac = function DocPagesLinksComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocPagesLinksComponent)(\u0275\u0275directiveInject(GlobalContext));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocPagesLinksComponent,
      selectors: [["dg-doc-pages-links"]],
      hostAttrs: [1, "dg-pages-link"],
      inputs: {
        docPages: "docPages"
      },
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [[1, "dg-page-link"], [3, "routerLink"], [1, "dg-page-link-icon"], ["iconName", "arrowLeft"], [1, "dg-page-link-label"], [1, "dg-page-link-title"], ["iconName", "arrowRight"]],
      template: function DocPagesLinksComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, DocPagesLinksComponent_Conditional_0_Template, 10, 7, "div", 0);
          \u0275\u0275conditionalCreate(1, DocPagesLinksComponent_Conditional_1_Template, 10, 7, "div", 0);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.docPages.pre && ctx.preRouterLink ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.docPages.next && ctx.nextRouterLink ? 1 : -1);
        }
      },
      dependencies: [RouterLink, IconComponent, TranslatePipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocPagesLinksComponent, [{
    type: Component,
    args: [{
      selector: "dg-doc-pages-links",
      host: {
        class: "dg-pages-link"
      },
      standalone: false,
      template: `@if (docPages.pre && preRouterLink) {
  <div class="dg-page-link">
    <a [routerLink]="[preRouterLink]">
      <div class="dg-page-link-icon">
        <dg-icon iconName="arrowLeft"></dg-icon>
      </div>
      <div>
        <div class="dg-page-link-label">
          {{ 'PRE_PAGE' | dgTranslate }}
        </div>
        <div class="dg-page-link-title">
          {{ docPages.pre.title }}
        </div>
      </div>
    </a>
  </div>
}
@if (docPages.next && nextRouterLink) {
  <div class="dg-page-link">
    <a [routerLink]="[nextRouterLink]">
      <div class="dg-page-link-icon">
        <dg-icon iconName="arrowRight"></dg-icon>
      </div>
      <div>
        <div class="dg-page-link-label">
          {{ 'NEXT_PAGE' | dgTranslate }}
        </div>
        <div class="dg-page-link-title">
          {{ docPages.next.title }}
        </div>
      </div>
    </a>
  </div>
}
`
    }]
  }], () => [{
    type: GlobalContext
  }], {
    docPages: [{
      type: Input
    }]
  });
})();
var ComponentViewerComponent = class _ComponentViewerComponent {
  constructor() {
    this.docItem = input.required(...ngDevMode ? [{
      debugName: "docItem"
    }] : []);
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function ComponentViewerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ComponentViewerComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ComponentViewerComponent,
      selectors: [["dg-component-viewer"]],
      hostAttrs: [1, "dg-component-viewer"],
      inputs: {
        docItem: [1, "docItem"]
      },
      standalone: false,
      decls: 3,
      vars: 2,
      consts: [[3, "docItem"], [3, "title", "subtitle"], [1, "dg-tab-links"], ["routerLinkActive", "active", 1, "dg-tab-link", 3, "routerLink"]],
      template: function ComponentViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ComponentViewerComponent_Conditional_0_Template, 5, 5);
          \u0275\u0275element(1, "router-outlet")(2, "dg-doc-meta", 0);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.docItem() ? 0 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275property("docItem", ctx.docItem());
        }
      },
      dependencies: [RouterOutlet, RouterLink, RouterLinkActive, DocHeaderComponent, DocMetaComponent, TranslatePipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentViewerComponent, [{
    type: Component,
    args: [{
      selector: "dg-component-viewer",
      host: {
        class: "dg-component-viewer"
      },
      standalone: false,
      template: `@if (docItem()) {
  <dg-doc-header [title]="docItem().title!" [subtitle]="docItem().subtitle!"></dg-doc-header>
  <div class="dg-tab-links">
    @if (docItem().overview) {
      <a class="dg-tab-link" [routerLink]="['./overview']" routerLinkActive="active">{{ 'OVERVIEW' | dgTranslate }}</a>
    }
    @if (docItem().examples!.length > 0) {
      <a class="dg-tab-link" [routerLink]="['./examples']" routerLinkActive="active">{{ 'EXAMPLES' | dgTranslate }}</a>
    }
    @if (docItem().api) {
      <a class="dg-tab-link" [routerLink]="['./api']" routerLinkActive="active">API</a>
    }
  </div>
}
<router-outlet></router-outlet>
<dg-doc-meta [docItem]="docItem()"></dg-doc-meta>
`
    }]
  }], () => [], {
    docItem: [{
      type: Input,
      args: [{
        isSignal: true,
        alias: "docItem",
        required: true
      }]
    }]
  });
})();
var ComponentEmptyComponent = class _ComponentEmptyComponent {
  constructor() {
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function ComponentEmptyComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ComponentEmptyComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ComponentEmptyComponent,
      selectors: [["dg-component-empty"]],
      hostAttrs: [1, "dg-component-empty"],
      standalone: false,
      decls: 2,
      vars: 0,
      template: function ComponentEmptyComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "p");
          \u0275\u0275text(1, "Current component has not been documented.");
          \u0275\u0275elementEnd();
        }
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentEmptyComponent, [{
    type: Component,
    args: [{
      selector: "dg-component-empty",
      template: ` <p>Current component has not been documented.</p> `,
      host: {
        class: "dg-component-empty"
      },
      standalone: false
    }]
  }], () => [], null);
})();
var AssetsContentPathPipe = class _AssetsContentPathPipe {
  constructor(globalContext) {
    this.globalContext = globalContext;
  }
  transform(path) {
    return this.globalContext.getAssetsContentPath(path);
  }
  static {
    this.\u0275fac = function AssetsContentPathPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AssetsContentPathPipe)(\u0275\u0275directiveInject(GlobalContext, 16));
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgAssetsContentPath",
      type: _AssetsContentPathPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AssetsContentPathPipe, [{
    type: Pipe,
    args: [{
      name: "dgAssetsContentPath",
      standalone: false
    }]
  }], () => [{
    type: GlobalContext
  }], null);
})();
var IsComponentDocPipe = class _IsComponentDocPipe {
  constructor() {
  }
  transform(docItem) {
    return !!docItem.importSpecifier;
  }
  static {
    this.\u0275fac = function IsComponentDocPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsComponentDocPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgIsComponentDoc",
      type: _IsComponentDocPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsComponentDocPipe, [{
    type: Pipe,
    args: [{
      name: "dgIsComponentDoc",
      standalone: false
    }]
  }], () => [], null);
})();
var DocViewerComponent = class _DocViewerComponent {
  get channel() {
    return this.navigationService.channel;
  }
  constructor() {
    this.route = inject(ActivatedRoute);
    this.router = inject(Router);
    this.navigationService = inject(NavigationService);
    this.pageTitle = inject(PageTitleService);
    this.tocService = inject(TocService);
    this.isSingle = signal(false, ...ngDevMode ? [{
      debugName: "isSingle"
    }] : []);
    this.hasContentToc = signal(false, ...ngDevMode ? [{
      debugName: "hasContentToc"
    }] : []);
    this.exampleComponentType = null;
    this.exampleModuleFactory = null;
    this.docItem$ = this.navigationService.docItem$.asObservable();
    this.docPages$ = this.navigationService.docPages$.asObservable();
    this.destroyed = new Subject();
  }
  ngOnInit() {
    if (this.route.snapshot.data) {
      this.isSingle.set(this.route.snapshot.data["single"]);
    }
    this.route.paramMap.subscribe((params) => {
      const id = params.get("id");
      if (id) {
        this.navigationService.selectDocItem(id);
        this.navigationService.resetShowSidebar();
      } else {
        const path = this.route.snapshot.routeConfig?.path;
        this.navigationService.selectDocItem(path);
      }
      if (this.navigationService.docItem) {
        this.pageTitle.title = "" + this.navigationService.docItem.title;
      } else {
        const firstDoc = this.navigationService.searchFirstDocItem();
        if (firstDoc) {
          this.router.navigate(["./" + firstDoc.path], {
            relativeTo: this.route
          });
        }
      }
    });
    combineLatest([this.navigationService.docItem$, this.tocService.links$]).pipe(takeUntil(this.destroyed)).subscribe((result) => {
      this.hasContentToc.set(result[0].toc === "content" && result[1].length > 0);
    });
  }
  close() {
    if (this.navigationService.showSidebar) {
      this.navigationService.toggleSidebar();
    }
  }
  ngOnDestroy() {
    this.destroyed.next();
    this.destroyed.complete();
  }
  static {
    this.\u0275fac = function DocViewerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocViewerComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocViewerComponent,
      selectors: [["dg-doc-viewer"]],
      viewQuery: function DocViewerComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c123, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tableOfContents = _t.first);
        }
      },
      hostVars: 6,
      hostBindings: function DocViewerComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-doc-viewer", true)("dg-doc-viewer--single", ctx.isSingle())("dg-doc-viewer--toc", ctx.hasContentToc());
        }
      },
      standalone: false,
      decls: 3,
      vars: 3,
      consts: [[1, "dg-doc-viewer-backdrop", 3, "click"], [3, "docItem"], [1, "dg-doc-viewer-inner"], [1, "dg-spring"], [1, "dg-doc-viewer-inner-content"], [3, "title", "subtitle"], [3, "url"], [3, "docPages"], [1, "dg-mt-4", 3, "docItem"]],
      template: function DocViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, DocViewerComponent_Conditional_0_Template, 5, 3);
          \u0275\u0275pipe(1, "async");
          \u0275\u0275elementStart(2, "div", 0);
          \u0275\u0275listener("click", function DocViewerComponent_Template_div_click_2_listener() {
            return ctx.close();
          });
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          let tmp_0_0;
          \u0275\u0275conditional((tmp_0_0 = \u0275\u0275pipeBind1(1, 1, ctx.docItem$)) ? 0 : -1, tmp_0_0);
        }
      },
      dependencies: [FooterComponent, DocHeaderComponent, ContentViewerComponent, DocMetaComponent, DocPagesLinksComponent, TableOfContentsComponent, ComponentViewerComponent, AsyncPipe, AssetsContentPathPipe, IsComponentDocPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocViewerComponent, [{
    type: Component,
    args: [{
      selector: "dg-doc-viewer",
      standalone: false,
      host: {
        "[class.dg-doc-viewer]": "true",
        "[class.dg-doc-viewer--single]": "isSingle()",
        "[class.dg-doc-viewer--toc]": "hasContentToc()"
      },
      template: '@if (docItem$ | async; as docItem) {\n  @if (docItem | dgIsComponentDoc) {\n    <dg-component-viewer [docItem]="docItem"></dg-component-viewer>\n  } @else {\n    <div class="dg-doc-viewer-inner">\n      <div class="dg-doc-viewer-inner-content">\n        <dg-doc-header [title]="docItem.title!" [subtitle]="docItem.subtitle!"></dg-doc-header>\n        <dg-content-viewer [url]="docItem.contentPath! | dgAssetsContentPath"> </dg-content-viewer>\n        @if (docPages$ | async; as docPages) {\n          <dg-doc-pages-links [docPages]="docPages"></dg-doc-pages-links>\n        }\n        <dg-doc-meta class="dg-mt-4" [docItem]="docItem"></dg-doc-meta>\n      </div>\n      @if (hasContentToc()) {\n        <dg-toc></dg-toc>\n      }\n    </div>\n  }\n  <div class="dg-spring"></div>\n  <dg-footer></dg-footer>\n}\n<div class="dg-doc-viewer-backdrop" (click)="close()"></div>\n'
    }]
  }], () => [], {
    tableOfContents: [{
      type: ViewChild,
      args: ["toc"]
    }]
  });
})();
var DocViewerHomeComponent = class _DocViewerHomeComponent {
  constructor(navigationService, route, router) {
    this.destroy$ = new Subject();
    navigationService.docItem$.pipe(takeUntil(this.destroy$)).subscribe((docItem) => {
      if (docItem) {
        let redirectTo = "./empty";
        if (docItem.overview) {
          redirectTo = "./overview";
        } else if (docItem.examples && docItem.examples.length > 0) {
          redirectTo = "./examples";
        } else if (docItem.api) {
          redirectTo = "./api";
        }
        if (redirectTo) {
          router.navigate([redirectTo], {
            relativeTo: route,
            replaceUrl: true
          });
        }
      }
    });
  }
  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
  static {
    this.\u0275fac = function DocViewerHomeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocViewerHomeComponent)(\u0275\u0275directiveInject(NavigationService), \u0275\u0275directiveInject(ActivatedRoute), \u0275\u0275directiveInject(Router));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _DocViewerHomeComponent,
      selectors: [["doc-viewer-home"]],
      standalone: false,
      decls: 0,
      vars: 0,
      template: function DocViewerHomeComponent_Template(rf, ctx) {
      },
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocViewerHomeComponent, [{
    type: Component,
    args: [{
      selector: "doc-viewer-home",
      template: "",
      standalone: false
    }]
  }], () => [{
    type: NavigationService
  }, {
    type: ActivatedRoute
  }, {
    type: Router
  }], null);
})();
var ComponentOverviewComponent = class _ComponentOverviewComponent {
  constructor() {
    this.componentViewer = inject(ComponentViewerComponent);
    this.global = inject(GlobalContext);
  }
  ngOnInit() {
    this.contentUrl = this.global.getAssetsContentPath(`overviews/${this.componentViewer.docItem().importSpecifier}/${this.global.locale}.html`);
  }
  static {
    this.\u0275fac = function ComponentOverviewComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ComponentOverviewComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ComponentOverviewComponent,
      selectors: [["dg-component-overview"]],
      viewQuery: function ComponentOverviewComponent_Query(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275viewQuery(_c123, 5);
        }
        if (rf & 2) {
          let _t;
          \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.tableOfContents = _t.first);
        }
      },
      hostAttrs: [1, "dg-component-overview"],
      standalone: false,
      decls: 2,
      vars: 2,
      consts: [["toc", ""], [1, "dg-doc-viewer-inner-content", 3, "url"]],
      template: function ComponentOverviewComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "dg-content-viewer", 1);
          \u0275\u0275conditionalCreate(1, ComponentOverviewComponent_Conditional_1_Template, 2, 0, "dg-toc");
        }
        if (rf & 2) {
          \u0275\u0275property("url", ctx.contentUrl);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.componentViewer.docItem().toc === "content" ? 1 : -1);
        }
      },
      dependencies: [ContentViewerComponent, TableOfContentsComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentOverviewComponent, [{
    type: Component,
    args: [{
      selector: "dg-component-overview",
      host: {
        class: "dg-component-overview"
      },
      standalone: false,
      template: `<dg-content-viewer class="dg-doc-viewer-inner-content" [url]="contentUrl"> </dg-content-viewer>
@if (componentViewer.docItem().toc === 'content') {
  <dg-toc #toc></dg-toc>
}
`
    }]
  }], () => [], {
    tableOfContents: [{
      type: ViewChild,
      args: ["toc"]
    }]
  });
})();
var IsNgContentChildKindPipe = class _IsNgContentChildKindPipe {
  constructor() {
  }
  transform(kind) {
    return kind === "ContentChild" || kind === "ContentChildren";
  }
  static {
    this.\u0275fac = function IsNgContentChildKindPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _IsNgContentChildKindPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgIsContentChildKind",
      type: _IsNgContentChildKindPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(IsNgContentChildKindPipe, [{
    type: Pipe,
    args: [{
      name: "dgIsContentChildKind",
      standalone: false
    }]
  }], () => [], null);
})();
var PropertyNamePipe = class _PropertyNamePipe {
  constructor() {
  }
  transform(property) {
    const ngContentChildKind = new IsNgContentChildKindPipe();
    const isContentChild = ngContentChildKind.transform(property.kind);
    const name = property.aliasName || property.name;
    if (isContentChild) {
      return `#${name}`;
    } else if (property.kind === "Output") {
      return `(${name})`;
    } else {
      return `${name}`;
    }
  }
  static {
    this.\u0275fac = function PropertyNamePipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _PropertyNamePipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgPropertyName",
      type: _PropertyNamePipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(PropertyNamePipe, [{
    type: Pipe,
    args: [{
      name: "dgPropertyName",
      standalone: false
    }]
  }], () => [], null);
})();
var ComponentApiComponent = class _ComponentApiComponent {
  constructor() {
    this.apiDeclarations = signal(void 0, ...ngDevMode ? [{
      debugName: "apiDeclarations"
    }] : []);
    this.componentViewer = inject(ComponentViewerComponent);
    this.global = inject(GlobalContext);
    this.http = inject(HttpClient);
    this.ngZone = inject(NgZone);
    this.elementRef = inject(ElementRef);
    this.tocService = inject(TocService);
  }
  ngOnInit() {
    const apiUrl = this.global.getAssetsContentPath(`api-docs/${this.componentViewer.docItem().importSpecifier}/${this.global.locale}.json`);
    this.http.get(apiUrl).subscribe({
      next: (data) => {
        this.apiDeclarations.set(data);
        if (this.elementRef.nativeElement) {
          setTimeout(() => {
            this.tocService.generateToc(this.elementRef.nativeElement);
          });
        }
      }
    });
  }
  static {
    this.\u0275fac = function ComponentApiComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ComponentApiComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ComponentApiComponent,
      selectors: [["dg-component-api"]],
      hostAttrs: [1, "dg-component-api"],
      standalone: false,
      features: [\u0275\u0275ProvidersFeature([TocService])],
      decls: 2,
      vars: 1,
      consts: [["toc", ""], [1, "dg-doc-content"], [1, "dg-component-api-content", "dg-doc-content"], [1, "dg-component-api-toc"], [1, "dg-api-header"], [1, "name", 3, "id"], [1, "dg-api-description", 3, "innerHTML"], [1, "dg-section"], [1, "section-title"], [1, "dg-api-property-table"], [1, "dg-api-property-header-row"], [1, "dg-api-property-name-th"], [1, "dg-api-property-type-th"], [1, "dg-api-property-default-th"], [1, "dg-api-property-description-th"], [1, "dg-api-property-row"], [1, "dg-api-property-name-cell"], [1, "dg-api-property-type-cell"], [1, "dg-api-property-default-cell"], [1, "dg-api-property-description-cell", 3, "innerHTML"], ["colspan", "4"], [1, "dg-api-methods-table"], [1, "dg-api-methods-type-th"], [1, "dg-api-method-parameter"], [1, "dg-api-method-parameter-head"], [1, "dg-api-method-parameter-list"], [1, "dg-api-no-method-parameter"], [1, "dg-api-method-return-value"], [1, "dg-api-method-parameter-type"], [1, "dg-api-method-parameter-description"], [1, "dg-api-method-parameter-item"], ["colspan", "3"]],
      template: function ComponentApiComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ComponentApiComponent_Conditional_0_Template, 5, 0)(1, ComponentApiComponent_Conditional_1_Template, 2, 0, "div", 1);
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.apiDeclarations() ? 0 : 1);
        }
      },
      dependencies: [TableOfContentsComponent, PropertyNamePipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentApiComponent, [{
    type: Component,
    args: [{
      selector: "dg-component-api",
      providers: [TocService],
      host: {
        class: "dg-component-api"
      },
      standalone: false,
      template: `<!-- <dg-content-viewer [url]="contentUrl"> </dg-content-viewer> -->
@if (apiDeclarations()) {
  <div class="dg-component-api-content dg-doc-content">
    @for (apiDeclaration of apiDeclarations(); track apiDeclaration.name) {
      <div class="dg-api-header">
        <h1 class="name" id="{{ apiDeclaration.name }}">{{ apiDeclaration.name }}</h1>
        <label class="type-label dg-label {{ apiDeclaration.type }}">{{ apiDeclaration.type }}</label>
      </div>
      @if (apiDeclaration.description) {
        <div class="dg-api-description" [innerHTML]="apiDeclaration.description"></div>
      }
      <!-- <div *ngIf="apiDeclaration.selector">Selector: <code>{{apiDeclaration.selector}}</code></div>
      <div *ngIf="apiDeclaration.exportAs">Exported as: {{apiDeclaration.exportAs}}</div> -->
      @if (apiDeclaration.properties && apiDeclaration.properties.length) {
        <div class="dg-section">
          <div class="section-title">Properties</div>
          <table class="dg-api-property-table">
            <thead>
              <tr class="dg-api-property-header-row">
                <th class="dg-api-property-name-th">Name</th>
                <th class="dg-api-property-type-th">Type</th>
                <th class="dg-api-property-default-th">Default</th>
                <th class="dg-api-property-description-th">Description</th>
              </tr>
            </thead>
            <tbody>
              @for (property of apiDeclaration.properties; track property.name) {
                <tr class="dg-api-property-row">
                  <td class="dg-api-property-name-cell">
                    <label>{{ property | dgPropertyName }}</label>
                  </td>
                  <td class="dg-api-property-type-cell">
                    <label>{{ property.type }}</label>
                  </td>
                  <td class="dg-api-property-default-cell">
                    {{ property.default || '-' }}
                  </td>
                  <td class="dg-api-property-description-cell" [innerHTML]="property.description"></td>
                </tr>
              }
              @if (!apiDeclaration.properties || apiDeclaration.properties.length === 0) {
                <tr>
                  <td colspan="4">None</td>
                </tr>
              }
            </tbody>
          </table>
        </div>
      }
      @if (apiDeclaration.methods && apiDeclaration.methods.length) {
        <div class="dg-section">
          <div class="section-title">Methods</div>
          <table class="dg-api-methods-table">
            <thead>
              <tr class="dg-api-property-header-row">
                <th class="dg-api-property-name-th">Name</th>
                <th class="dg-api-methods-type-th">Type</th>
                <th class="dg-api-property-description-th">Description</th>
              </tr>
            </thead>
            <tbody>
              @for (method of apiDeclaration.methods; track method.name) {
                <tr class="dg-api-property-row">
                  <td class="dg-api-property-name-cell">
                    <label>{{ method.name }}</label>
                  </td>
                  <td class="dg-api-property-type-cell">
                    <div class="dg-api-method-parameter">
                      <div class="dg-api-method-parameter-head">Parameters:</div>
                      <div class="dg-api-method-parameter-list">
                        @if (method.parameters && method.parameters.length) {
                          @for (item of method.parameters; track item.name) {
                            <div class="dg-api-method-parameter-item">
                              <span class="dg-api-method-parameter-type">{{ item.name }}: {{ item.type }}</span>
                              @if (item.description || item.comment) {
                                <span class="dg-api-method-parameter-description">{{ item.description || item.comment }}</span>
                              }
                            </div>
                          }
                        } @else {
                          <div class="dg-api-no-method-parameter">None</div>
                        }
                      </div>
                    </div>
                    <div class="dg-api-method-parameter">
                      <div class="dg-api-method-parameter-head">Return:</div>
                      <div class="dg-api-method-return-value">
                        <span class="dg-api-method-parameter-type">{{ method.returnValue?.type }}</span>
                        <span class="dg-api-method-parameter-description">{{ method.returnValue?.description }}</span>
                      </div>
                    </div>
                  </td>
                  <td class="dg-api-property-description-cell" [innerHTML]="method.description"></td>
                </tr>
              }
              @if (!apiDeclaration.methods || apiDeclaration.methods.length === 0) {
                <tr>
                  <td colspan="3">None</td>
                </tr>
              }
            </tbody>
          </table>
        </div>
      }
    }
  </div>
  <dg-toc #toc class="dg-component-api-toc"></dg-toc>
} @else {
  <div class="dg-doc-content">Loading...</div>
}
`
    }]
  }], () => [], null);
})();
var ComponentExamplesComponent = class _ComponentExamplesComponent {
  get examples() {
    return this.componentViewer.docItem().examples || [];
  }
  constructor() {
    this.componentViewer = inject(ComponentViewerComponent);
    this.navigationService = inject(NavigationService);
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function ComponentExamplesComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ComponentExamplesComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ComponentExamplesComponent,
      selectors: [["dg-component-examples"]],
      hostAttrs: [1, "dg-examples"],
      standalone: false,
      decls: 2,
      vars: 0,
      consts: [[3, "name"]],
      template: function ComponentExamplesComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275repeaterCreate(0, ComponentExamplesComponent_For_1_Template, 1, 1, "dg-example-viewer", 0, \u0275\u0275repeaterTrackByIdentity);
        }
        if (rf & 2) {
          \u0275\u0275repeater(ctx.examples);
        }
      },
      dependencies: [ExampleViewerComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ComponentExamplesComponent, [{
    type: Component,
    args: [{
      selector: "dg-component-examples",
      host: {
        class: "dg-examples"
      },
      standalone: false,
      template: '@for (example of examples; track example) {\n  <dg-example-viewer [name]="example"></dg-example-viewer>\n}\n'
    }]
  }], () => [], null);
})();
var HeroActionClassPipe = class _HeroActionClassPipe {
  constructor() {
  }
  transform(action) {
    return [`dg-btn-${action.btnType || "primary-light"}`, "dg-btn-xlg", `dg-btn-${action.btnShape || "round"}`];
  }
  static {
    this.\u0275fac = function HeroActionClassPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HeroActionClassPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({
      name: "dgHeroActionClass",
      type: _HeroActionClassPipe,
      pure: true,
      standalone: false
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HeroActionClassPipe, [{
    type: Pipe,
    args: [{
      name: "dgHeroActionClass",
      standalone: false
    }]
  }], () => [], null);
})();
var HomeComponent = class _HomeComponent {
  get bannerImgSrc() {
    const banner = this.global.homeMeta.hero.banner;
    if (banner) {
      if (typeof banner === "string") {
        return banner;
      }
      if (Array.isArray(banner)) {
        if (banner.length === 1) {
          return banner[0];
        }
        if (banner.length === 2) {
          if (this.global.isDarkTheme()) {
            return banner[1];
          } else {
            return banner[0];
          }
        }
        return false;
      }
      return false;
    }
    return false;
  }
  constructor() {
    this.global = inject(GlobalContext);
    this.router = inject(Router);
    this.navigationService = inject(NavigationService);
    this.pageTitle = inject(PageTitleService);
    this.hasHome = false;
    if (!this.global.homeMeta) {
      if (this.global.config.mode === "full") {
        const channels = this.navigationService.getChannels();
        if (channels && channels[0].path && !channels[0].isExternal) {
          this.router.navigateByUrl(channels[0].path, {
            replaceUrl: true
          });
        }
      } else {
        const docItem = this.navigationService.searchFirstDocItem();
        if (docItem) {
          this.router.navigateByUrl(docItem.path, {
            replaceUrl: true
          });
        }
      }
      return;
    }
    this.pageTitle.title = new TranslatePipe(this.global).transform("HOME");
    this.hasHome = true;
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function HomeComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _HomeComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _HomeComponent,
      selectors: [["dg-home"]],
      hostAttrs: [1, "dg-home"],
      standalone: false,
      decls: 4,
      vars: 3,
      consts: [[1, "dg-hero"], [1, "dg-features"], [1, "dg-extra-content"], [1, "dg-hero-launch"], [1, "dg-launch-title"], [1, "dg-launch-description"], [1, "dg-launch-actions"], [1, "dg-launch-action", "dg-btn", 3, "ngClass", "href"], [1, "dg-hero-banner"], [3, "src"], [1, "dg-feature"], ["alt", "", 3, "src"], [1, "dg-feature-title"], [1, "dg-feature-description", 3, "innerHTML"], [3, "url"]],
      template: function HomeComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, HomeComponent_Conditional_0_Template, 11, 5, "div", 0);
          \u0275\u0275conditionalCreate(1, HomeComponent_Conditional_1_Template, 3, 0, "div", 1);
          \u0275\u0275conditionalCreate(2, HomeComponent_Conditional_2_Template, 3, 3, "div", 2);
          \u0275\u0275element(3, "dg-footer");
        }
        if (rf & 2) {
          \u0275\u0275conditional(ctx.global.homeMeta.hero ? 0 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.global.homeMeta.features && ctx.global.homeMeta.features.length > 0 ? 1 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.global.homeMeta.contentPath ? 2 : -1);
        }
      },
      dependencies: [NgClass, FooterComponent, ContentViewerComponent, AssetsContentPathPipe, HeroActionClassPipe],
      encapsulation: 2,
      changeDetection: 0
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(HomeComponent, [{
    type: Component,
    args: [{
      selector: "dg-home",
      changeDetection: ChangeDetectionStrategy.OnPush,
      host: {
        class: "dg-home"
      },
      standalone: false,
      template: '@if (global.homeMeta.hero) {\n  <div class="dg-hero">\n    <div class="dg-hero-launch">\n      <h1 class="dg-launch-title">{{ global.homeMeta.hero.title }}</h1>\n      <p class="dg-launch-description">{{ global.homeMeta.hero.description }}</p>\n      <div class="dg-launch-actions">\n        @for (item of global.homeMeta.hero.actions; track item.text) {\n          <a class="dg-launch-action dg-btn" [ngClass]="item | dgHeroActionClass" [href]="item.link">\n            {{ item.text }}\n          </a>\n        }\n      </div>\n    </div>\n    <div class="dg-hero-banner" [style.backgroundColor]="global.homeMeta.hero.backgroundColor">\n      @if (bannerImgSrc) {\n        <img [src]="bannerImgSrc" />\n      }\n    </div>\n  </div>\n}\n\n@if (global.homeMeta.features && global.homeMeta.features.length > 0) {\n  <div class="dg-features">\n    @for (item of global.homeMeta.features; track item.title) {\n      <div class="dg-feature">\n        <img [src]="item.icon" alt="" />\n        <div class="dg-feature-title">\n          {{ item.title }}\n        </div>\n        <div class="dg-feature-description" [innerHTML]="item.description"></div>\n      </div>\n    }\n  </div>\n}\n@if (global.homeMeta.contentPath) {\n  <div class="dg-extra-content">\n    <dg-content-viewer [url]="global.homeMeta.contentPath | dgAssetsContentPath"></dg-content-viewer>\n  </div>\n}\n\n<dg-footer></dg-footer>\n'
    }]
  }], () => [], null);
})();
var ExampleIsolatedViewerComponent = class _ExampleIsolatedViewerComponent {
  constructor() {
    this.name = signal("", ...ngDevMode ? [{
      debugName: "name"
    }] : []);
    this.route = inject(ActivatedRoute);
    this.pageTitle = inject(PageTitleService);
  }
  ngOnInit() {
    this.name.set(this.route.snapshot.paramMap.get("name"));
    this.pageTitle.title = `Example - ${this.name}`;
  }
  static {
    this.\u0275fac = function ExampleIsolatedViewerComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ExampleIsolatedViewerComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ExampleIsolatedViewerComponent,
      selectors: [["dg-example-isolated-viewer"]],
      standalone: false,
      decls: 1,
      vars: 1,
      consts: [[3, "name"]],
      template: function ExampleIsolatedViewerComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "dg-example-renderer", 0);
        }
        if (rf & 2) {
          \u0275\u0275property("name", ctx.name());
        }
      },
      dependencies: [ExampleRendererComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ExampleIsolatedViewerComponent, [{
    type: Component,
    args: [{
      selector: "dg-example-isolated-viewer",
      standalone: false,
      template: '<dg-example-renderer [name]="name()"></dg-example-renderer>\n'
    }]
  }], () => [], null);
})();
var ThemesSelectorComponent = class _ThemesSelectorComponent {
  constructor(global, navigationService) {
    this.global = global;
    this.navigationService = navigationService;
    this.isNavbar = true;
    this.cacheKey = "docgeni-theme";
    this.isDropdownOpen = false;
    this.docgeniTheme = DocgeniTheme;
    this.themesMap = {
      [DocgeniTheme.light]: {
        key: DocgeniTheme.light,
        name: "\u4EAE\u8272\u4E3B\u9898",
        icon: "lightTheme"
      },
      [DocgeniTheme.dark]: {
        key: DocgeniTheme.dark,
        name: "\u6697\u9ED1\u4E3B\u9898",
        icon: "darkTheme"
      },
      [DocgeniTheme.system]: {
        key: DocgeniTheme.system,
        name: "\u8DDF\u968F\u7CFB\u7EDF",
        icon: "systemTheme"
      }
    };
    this.themes = [this.themesMap[DocgeniTheme.light], this.themesMap[DocgeniTheme.dark], this.themesMap[DocgeniTheme.system]];
  }
  openDropdown() {
    this.isDropdownOpen = true;
  }
  closeDropdown() {
    this.isDropdownOpen = false;
  }
  ngOnInit() {
    this.theme = this.global.theme();
  }
  setTheme(theme) {
    this.theme = theme;
    this.global.setTheme(this.theme);
  }
  selectTheme(theme) {
    this.setTheme(theme);
    this.isDropdownOpen = false;
  }
  toggleTheme() {
    if (this.theme === DocgeniTheme.dark) {
      this.setTheme(DocgeniTheme.light);
    } else if (this.theme === DocgeniTheme.light) {
      this.setTheme(DocgeniTheme.dark);
    } else {
    }
  }
  static {
    this.\u0275fac = function ThemesSelectorComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ThemesSelectorComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(NavigationService));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ThemesSelectorComponent,
      selectors: [["dg-themes-selector"]],
      hostVars: 2,
      hostBindings: function ThemesSelectorComponent_HostBindings(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275listener("mouseenter", function ThemesSelectorComponent_mouseenter_HostBindingHandler() {
            return ctx.openDropdown();
          })("mouseleave", function ThemesSelectorComponent_mouseleave_HostBindingHandler() {
            return ctx.closeDropdown();
          });
        }
        if (rf & 2) {
          \u0275\u0275classProp("dg-themes-selector", ctx.isNavbar);
        }
      },
      standalone: false,
      decls: 3,
      vars: 8,
      consts: [["type", "button", 1, "action-icon", 3, "click", "ngClass"], [3, "iconName", "ngClass"], [1, "themes-container"], [1, "themes-menu"], [1, "theme", 3, "ngClass"], [1, "theme", 3, "click", "ngClass"]],
      template: function ThemesSelectorComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "button", 0);
          \u0275\u0275listener("click", function ThemesSelectorComponent_Template_button_click_0_listener() {
            return ctx.toggleTheme();
          });
          \u0275\u0275element(1, "dg-icon", 1);
          \u0275\u0275elementEnd();
          \u0275\u0275conditionalCreate(2, ThemesSelectorComponent_Conditional_2_Template, 4, 0, "div", 2);
        }
        if (rf & 2) {
          \u0275\u0275property("ngClass", \u0275\u0275pureFunction1(4, _c117, !!ctx.isDropdownOpen));
          \u0275\u0275advance();
          \u0275\u0275property("iconName", ctx.themesMap[ctx.theme] == null ? null : ctx.themesMap[ctx.theme].icon)("ngClass", \u0275\u0275pureFunction1(6, _c133, ctx.theme === ctx.docgeniTheme.system));
          \u0275\u0275advance();
          \u0275\u0275conditional(!!ctx.isDropdownOpen ? 2 : -1);
        }
      },
      dependencies: [NgClass, IconComponent],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ThemesSelectorComponent, [{
    type: Component,
    args: [{
      selector: "dg-themes-selector",
      standalone: false,
      template: '<button type="button" class="action-icon" [ngClass]="{ active: !!isDropdownOpen }" (click)="toggleTheme()">\n  <dg-icon [iconName]="themesMap[theme]?.icon!" [ngClass]="{ system: theme === docgeniTheme.system }"></dg-icon>\n</button>\n\n@if (!!isDropdownOpen) {\n  <div class="themes-container">\n    <div class="themes-menu">\n      @for (item of themes; track item) {\n        <div class="theme" [ngClass]="{ active: item.key === theme }" (click)="selectTheme(item.key)">\n          {{ item.name }}\n        </div>\n      }\n    </div>\n  </div>\n}\n'
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: NavigationService
  }], {
    isNavbar: [{
      type: HostBinding,
      args: ["class.dg-themes-selector"]
    }],
    openDropdown: [{
      type: HostListener,
      args: ["mouseenter"]
    }],
    closeDropdown: [{
      type: HostListener,
      args: ["mouseleave"]
    }]
  });
})();
var NavbarComponent = class _NavbarComponent {
  constructor(global, navigationService, elementRef) {
    this.global = global;
    this.navigationService = navigationService;
    this.elementRef = elementRef;
    this.isNavbar = true;
    this.showNav = false;
  }
  ngOnInit() {
    this.channels = this.navigationService.getChannels();
    this.elementRef.nativeElement.classList.add(this.global.config.theme);
  }
  toggleNavbar() {
    this.showNav = !this.showNav;
  }
  static {
    this.\u0275fac = function NavbarComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _NavbarComponent)(\u0275\u0275directiveInject(GlobalContext), \u0275\u0275directiveInject(NavigationService), \u0275\u0275directiveInject(ElementRef));
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _NavbarComponent,
      selectors: [["dg-navbar"]],
      hostVars: 4,
      hostBindings: function NavbarComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-navbar", ctx.isNavbar)("show", ctx.showNav);
        }
      },
      standalone: false,
      decls: 19,
      vars: 9,
      consts: [[1, "navbar-brand"], [1, "title", 3, "routerLink"], [1, "nav", "nav-spacer"], [1, "navbar-toggler", "dg-btn", "dg-btn-primary", 3, "click"], ["iconName", "list"], [1, "nav"], [1, "spacer"], [1, "action-items"], [1, "action-item", "search-container"], [1, "action-icon-item"], ["target", "_blank", 1, "action-icon-item", 3, "href"], ["target", "_blank", 3, "href"], ["routerLinkActive", "active", 3, "routerLink"], ["iconName", "external"], ["type", "button", 1, "action-icon"], ["iconName", "github"]],
      template: function NavbarComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275elementStart(0, "div", 0);
          \u0275\u0275element(1, "dg-logo");
          \u0275\u0275elementStart(2, "a", 1);
          \u0275\u0275text(3);
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(4, "div", 2)(5, "a");
          \u0275\u0275text(6, "\xA0");
          \u0275\u0275elementEnd()();
          \u0275\u0275elementStart(7, "button", 3);
          \u0275\u0275listener("click", function NavbarComponent_Template_button_click_7_listener() {
            return ctx.toggleNavbar();
          });
          \u0275\u0275element(8, "dg-icon", 4);
          \u0275\u0275elementEnd();
          \u0275\u0275elementStart(9, "div", 5);
          \u0275\u0275repeaterCreate(10, NavbarComponent_For_11_Template, 2, 1, null, null, \u0275\u0275repeaterTrackByIdentity);
          \u0275\u0275elementEnd();
          \u0275\u0275element(12, "div", 6);
          \u0275\u0275elementStart(13, "div", 7);
          \u0275\u0275conditionalCreate(14, NavbarComponent_Conditional_14_Template, 1, 0, "dg-search", 8);
          \u0275\u0275pipe(15, "dgIsFull");
          \u0275\u0275conditionalCreate(16, NavbarComponent_Conditional_16_Template, 1, 0, "dg-locales-selector", 9);
          \u0275\u0275conditionalCreate(17, NavbarComponent_Conditional_17_Template, 1, 0, "dg-themes-selector", 9);
          \u0275\u0275conditionalCreate(18, NavbarComponent_Conditional_18_Template, 3, 2, "a", 10);
          \u0275\u0275elementEnd();
        }
        if (rf & 2) {
          \u0275\u0275advance(2);
          \u0275\u0275property("routerLink", \u0275\u0275pureFunction0(8, _c39));
          \u0275\u0275advance();
          \u0275\u0275textInterpolate(ctx.global.config.title);
          \u0275\u0275advance(7);
          \u0275\u0275repeater(ctx.channels);
          \u0275\u0275advance(4);
          \u0275\u0275conditional(\u0275\u0275pipeBind1(15, 6, ctx.global.config.mode) ? 14 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(ctx.global.config.locales && ctx.global.config.locales.length > 1 ? 16 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.global.config.switchTheme ? 17 : -1);
          \u0275\u0275advance();
          \u0275\u0275conditional(ctx.global.config.repoUrl ? 18 : -1);
        }
      },
      dependencies: [RouterLink, RouterLinkActive, IconComponent, LocalesSelectorComponent, ThemesSelectorComponent, LogoComponent, SearchComponent, IsModeFullPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NavbarComponent, [{
    type: Component,
    args: [{
      selector: "dg-navbar",
      standalone: false,
      template: `<div class="navbar-brand">
  <dg-logo></dg-logo>
  <a [routerLink]="['/']" class="title">{{ global.config.title }}</a>
</div>
<div class="nav nav-spacer">
  <a>&nbsp;</a>
</div>

<button class="navbar-toggler dg-btn dg-btn-primary" (click)="toggleNavbar()"><dg-icon iconName="list"></dg-icon></button>
<div class="nav">
  @for (channel of channels; track channel) {
    @if (channel.isExternal) {
      <a href="{{ channel.path }}" target="_blank">{{ channel.title }} <dg-icon iconName="external"></dg-icon> </a>
    } @else {
      <a [routerLink]="channel.path" routerLinkActive="active">{{ channel.title }}</a>
    }
  }
</div>
<div class="spacer"></div>
<div class="action-items">
  @if (global.config.mode | dgIsFull) {
    <dg-search class="action-item search-container"></dg-search>
  }
  @if (global.config.locales && global.config.locales.length > 1) {
    <dg-locales-selector class="action-icon-item"></dg-locales-selector>
  }
  @if (global.config.switchTheme) {
    <dg-themes-selector class="action-icon-item"></dg-themes-selector>
  }
  @if (global.config.repoUrl) {
    <a class="action-icon-item" href="{{ global.config.repoUrl }}" target="_blank">
      <button type="button" class="action-icon">
        <dg-icon iconName="github"></dg-icon>
      </button>
    </a>
  }
</div>
`
    }]
  }], () => [{
    type: GlobalContext
  }, {
    type: NavigationService
  }, {
    type: ElementRef
  }], {
    isNavbar: [{
      type: HostBinding,
      args: ["class.dg-navbar"]
    }],
    showNav: [{
      type: HostBinding,
      args: ["class.show"]
    }]
  });
})();
var ActualRootComponent = class _ActualRootComponent {
  constructor() {
    this.global = inject(GlobalContext);
    this.navigationService = inject(NavigationService);
  }
  static {
    this.\u0275fac = function ActualRootComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _ActualRootComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _ActualRootComponent,
      selectors: [["dg-root-actual"]],
      hostAttrs: [1, "dg-main", "dg-layout"],
      hostVars: 4,
      hostBindings: function ActualRootComponent_HostBindings(rf, ctx) {
        if (rf & 2) {
          \u0275\u0275classProp("dg-scroll-container", ctx.global.config.mode === "lite")("dg-sidebar-show", ctx.navigationService.showSidebar);
        }
      },
      standalone: false,
      decls: 5,
      vars: 6,
      consts: [[3, "menus"]],
      template: function ActualRootComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275conditionalCreate(0, ActualRootComponent_Conditional_0_Template, 1, 0, "dg-navbar");
          \u0275\u0275pipe(1, "dgIsFull");
          \u0275\u0275conditionalCreate(2, ActualRootComponent_Conditional_2_Template, 1, 1, "dg-sidebar", 0);
          \u0275\u0275pipe(3, "dgIsLite");
          \u0275\u0275element(4, "router-outlet");
        }
        if (rf & 2) {
          \u0275\u0275conditional(\u0275\u0275pipeBind1(1, 2, ctx.global.config.mode) ? 0 : -1);
          \u0275\u0275advance(2);
          \u0275\u0275conditional(\u0275\u0275pipeBind1(3, 4, ctx.global.config.mode) ? 2 : -1);
        }
      },
      dependencies: [RouterOutlet, NavbarComponent, SidebarComponent, IsModeLitePipe, IsModeFullPipe],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(ActualRootComponent, [{
    type: Component,
    args: [{
      selector: "dg-root-actual",
      standalone: false,
      host: {
        class: "dg-main dg-layout",
        "[class.dg-scroll-container]": "global.config.mode === 'lite'",
        "[class.dg-sidebar-show]": "navigationService.showSidebar"
      },
      template: '@if (global.config.mode | dgIsFull) {\n  <dg-navbar></dg-navbar>\n}\n@if (global.config.mode | dgIsLite) {\n  <dg-sidebar [menus]="navigationService.navs"></dg-sidebar>\n}\n<router-outlet></router-outlet>\n'
    }]
  }], () => [], null);
})();
var RootComponent = class _RootComponent {
  constructor() {
    this.global = inject(GlobalContext);
    this.navigationService = inject(NavigationService);
  }
  static {
    this.\u0275fac = function RootComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _RootComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({
      type: _RootComponent,
      selectors: [["dg-root"]],
      standalone: false,
      decls: 1,
      vars: 0,
      template: function RootComponent_Template(rf, ctx) {
        if (rf & 1) {
          \u0275\u0275element(0, "router-outlet");
        }
      },
      dependencies: [RouterOutlet],
      encapsulation: 2
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RootComponent, [{
    type: Component,
    args: [{
      selector: "dg-root",
      template: "<router-outlet></router-outlet>",
      standalone: false
    }]
  }], () => [], null);
})();
var componentChildrenRoutes = [{
  path: "",
  component: DocViewerHomeComponent
}, {
  path: "overview",
  component: ComponentOverviewComponent
}, {
  path: "api",
  component: ComponentApiComponent
}, {
  path: "examples",
  component: ComponentExamplesComponent
}, {
  path: "empty",
  component: ComponentEmptyComponent
}, {
  path: "**",
  component: ComponentExamplesComponent
}];
var RouterResetService = class _RouterResetService {
  constructor(router, global) {
    this.router = router;
    this.global = global;
  }
  resetRoutes() {
    const config2 = this.router.config;
    const routes3 = [{
      path: "",
      component: HomeComponent
    }];
    const rootRoutes = [...this.global.config.locales.map((locale2) => {
      return {
        path: locale2.key,
        component: ActualRootComponent,
        children: routes3
      };
    }), {
      path: "",
      component: ActualRootComponent,
      children: routes3
    }, {
      path: "~examples/:name",
      component: ExampleIsolatedViewerComponent
    }];
    const channelPathToRoutes = {};
    const channelPathToHomeRoutes = {};
    let shouldRemoveHome = false;
    if (this.global.config.mode === "full") {
      const rootNavs = this.global.navs.filter((nav) => {
        return !nav.isExternal;
      });
      rootNavs.forEach((nav) => {
        if (nav.items) {
          const route = {
            path: nav.path,
            component: ChannelComponent,
            children: [{
              path: "",
              component: ChannelHomeComponent
            }]
          };
          channelPathToHomeRoutes[nav.path] = route.children[0];
          if (nav.lib) {
            route.children.push({
              path: ":id",
              component: DocViewerComponent,
              children: componentChildrenRoutes
            });
          }
          routes3.push(route);
          channelPathToRoutes[nav.path] = route;
        }
      });
      this.global.docItems.forEach((docItem) => {
        const route = docItem.importSpecifier ? {
          path: docItem.path,
          component: DocViewerComponent,
          children: componentChildrenRoutes
        } : {
          path: docItem.path,
          component: DocViewerComponent
        };
        const channelRoute = channelPathToRoutes[docItem.channelPath];
        if (channelRoute) {
          if (route.path === "" && channelRoute.children.includes(channelPathToHomeRoutes[channelRoute.path])) {
            channelRoute.children.splice(0, 1);
          }
          channelRoute.children.push(route);
        } else if (!docItem.importSpecifier) {
          route.data = {
            single: true
          };
          routes3.push(route);
        }
      });
    } else {
      this.global.docItems.forEach((docItem) => {
        const route = docItem.importSpecifier ? {
          path: docItem.path,
          component: DocViewerComponent,
          children: componentChildrenRoutes
        } : {
          path: docItem.path,
          component: DocViewerComponent
        };
        if (route.path === "") {
          shouldRemoveHome = true;
        }
        routes3.push(route);
      });
      if (shouldRemoveHome) {
        routes3.splice(0, 1);
      }
    }
    this.router.resetConfig([...config2, ...rootRoutes, {
      path: "**",
      redirectTo: ""
    }]);
  }
  static {
    this.\u0275fac = function RouterResetService_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _RouterResetService)(\u0275\u0275inject(Router), \u0275\u0275inject(GlobalContext));
    };
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
      token: _RouterResetService,
      factory: _RouterResetService.\u0275fac,
      providedIn: "root"
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(RouterResetService, [{
    type: Injectable,
    args: [{
      providedIn: "root"
    }]
  }], () => [{
    type: Router
  }, {
    type: GlobalContext
  }], null);
})();
var DOCGENI_INITIALIZER_PROVIDERS = [{
  provide: APP_INITIALIZER,
  useFactory: initializeDocgeniSite,
  deps: [GlobalContext, RouterResetService],
  multi: true
}];
function initializeDocgeniSite(globalContext, routerResetService) {
  return () => {
    return globalContext.initialize().then(() => {
      routerResetService.resetRoutes();
    });
  };
}
var COMPONENTS$1 = [NavbarComponent, FooterComponent, SidebarComponent, ExampleViewerComponent, ExampleRendererComponent, IconComponent, DocHeaderComponent, ContentViewerComponent, SourceCodeComponent, LabelComponent, LocalesSelectorComponent, ThemesSelectorComponent, AssetsContentPathPipe, LogoComponent, CopyComponent, IsComponentDocPipe, IsNgContentChildKindPipe, PropertyNamePipe, TranslatePipe, IsModeLitePipe, IsModeFullPipe, HeroActionClassPipe, DocMetaComponent, DocPagesLinksComponent, SearchComponent, HighlightPipe];
var DocgeniSharedModule = class _DocgeniSharedModule {
  static {
    this.\u0275fac = function DocgeniSharedModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniSharedModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _DocgeniSharedModule,
      declarations: [NavbarComponent, FooterComponent, SidebarComponent, ExampleViewerComponent, ExampleRendererComponent, IconComponent, DocHeaderComponent, ContentViewerComponent, SourceCodeComponent, LabelComponent, LocalesSelectorComponent, ThemesSelectorComponent, AssetsContentPathPipe, LogoComponent, CopyComponent, IsComponentDocPipe, IsNgContentChildKindPipe, PropertyNamePipe, TranslatePipe, IsModeLitePipe, IsModeFullPipe, HeroActionClassPipe, DocMetaComponent, DocPagesLinksComponent, SearchComponent, HighlightPipe],
      imports: [CommonModule, FormsModule, RouterModule, TableOfContentsComponent],
      exports: [CommonModule, FormsModule, RouterModule, NavbarComponent, FooterComponent, SidebarComponent, ExampleViewerComponent, ExampleRendererComponent, IconComponent, DocHeaderComponent, ContentViewerComponent, SourceCodeComponent, LabelComponent, LocalesSelectorComponent, ThemesSelectorComponent, AssetsContentPathPipe, LogoComponent, CopyComponent, IsComponentDocPipe, IsNgContentChildKindPipe, PropertyNamePipe, TranslatePipe, IsModeLitePipe, IsModeFullPipe, HeroActionClassPipe, DocMetaComponent, DocPagesLinksComponent, SearchComponent, HighlightPipe, TableOfContentsComponent]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [provideHttpClient(withInterceptorsFromDi())],
      imports: [CommonModule, FormsModule, RouterModule, CommonModule, FormsModule, RouterModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniSharedModule, [{
    type: NgModule,
    args: [{
      declarations: [...COMPONENTS$1],
      exports: [CommonModule, FormsModule, RouterModule, ...COMPONENTS$1, TableOfContentsComponent],
      imports: [CommonModule, FormsModule, RouterModule, TableOfContentsComponent],
      providers: [provideHttpClient(withInterceptorsFromDi())]
    }]
  }], null, null);
})();
var COMPONENTS2 = [ActualRootComponent, RootComponent, HomeComponent, ChannelComponent, ChannelHomeComponent, DocViewerComponent, DocViewerHomeComponent, ComponentViewerComponent, ComponentOverviewComponent, ComponentApiComponent, ComponentExamplesComponent, ComponentEmptyComponent, ExampleIsolatedViewerComponent];
var DocgeniPagesModule = class _DocgeniPagesModule {
  constructor(appRef) {
    this.appRef = appRef;
  }
  static {
    this.\u0275fac = function DocgeniPagesModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniPagesModule)(\u0275\u0275inject(ApplicationRef));
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _DocgeniPagesModule,
      declarations: [ActualRootComponent, RootComponent, HomeComponent, ChannelComponent, ChannelHomeComponent, DocViewerComponent, DocViewerHomeComponent, ComponentViewerComponent, ComponentOverviewComponent, ComponentApiComponent, ComponentExamplesComponent, ComponentEmptyComponent, ExampleIsolatedViewerComponent],
      imports: [DocgeniSharedModule],
      exports: [ActualRootComponent, RootComponent, HomeComponent, ChannelComponent, ChannelHomeComponent, DocViewerComponent, DocViewerHomeComponent, ComponentViewerComponent, ComponentOverviewComponent, ComponentApiComponent, ComponentExamplesComponent, ComponentEmptyComponent, ExampleIsolatedViewerComponent]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      imports: [DocgeniSharedModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniPagesModule, [{
    type: NgModule,
    args: [{
      declarations: [...COMPONENTS2],
      imports: [DocgeniSharedModule],
      providers: [],
      exports: [...COMPONENTS2]
    }]
  }], () => [{
    type: ApplicationRef
  }], null);
})();
var DocgeniTemplateModule = class _DocgeniTemplateModule {
  constructor() {
  }
  static {
    this.\u0275fac = function DocgeniTemplateModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _DocgeniTemplateModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
      type: _DocgeniTemplateModule,
      imports: [DocgeniSharedModule, DocgeniBuiltInModule, DocgeniPagesModule],
      exports: [DocgeniSharedModule, DocgeniPagesModule, DocgeniBuiltInModule]
    });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
      providers: [{
        provide: CONFIG_TOKEN,
        useValue: DEFAULT_CONFIG
      }, provideHttpClient(withInterceptorsFromDi())],
      imports: [DocgeniSharedModule, DocgeniBuiltInModule, DocgeniPagesModule, DocgeniSharedModule, DocgeniPagesModule, DocgeniBuiltInModule]
    });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(DocgeniTemplateModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      exports: [DocgeniSharedModule, DocgeniPagesModule, DocgeniBuiltInModule],
      imports: [DocgeniSharedModule, DocgeniBuiltInModule, DocgeniPagesModule],
      providers: [{
        provide: CONFIG_TOKEN,
        useValue: DEFAULT_CONFIG
      }, provideHttpClient(withInterceptorsFromDi())]
    }]
  }], () => [], null);
})();
var actualRoutes = [{
  path: "",
  component: HomeComponent
}];
var routes = [...actualRoutes];

// example/src/app/app.component.ts
var AppComponent = class _AppComponent {
  constructor() {
    this.isRoot = true;
    this.title = "example";
  }
  static {
    this.\u0275fac = function AppComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppComponent, selectors: [["example-root"]], hostVars: 2, hostBindings: function AppComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("dg-main", ctx.isRoot);
      }
    }, standalone: false, decls: 2, vars: 0, template: function AppComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275element(0, "dg-navbar")(1, "router-outlet");
      }
    }, dependencies: [RouterOutlet, NavbarComponent], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppComponent, [{
    type: Component,
    args: [{ selector: "example-root", standalone: false, template: "<dg-navbar></dg-navbar>\n<router-outlet></router-outlet>\n" }]
  }], null, { isRoot: [{
    type: HostBinding,
    args: [`class.dg-main`]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppComponent, { className: "AppComponent", filePath: "example/src/app/app.component.ts", lineNumber: 9 });
})();

// example/src/app/helper.ts
function random(min, max) {
  return Math.floor(Math.random() * (max - min)) + min;
}
function randomItems(length, parent, group2) {
  const items = [];
  for (let i = 0; i < length; i++) {
    const start = addDays(/* @__PURE__ */ new Date(), random(-200, 200));
    const end = addDays(start, random(0, 100));
    items.push({
      id: `${parent?.id || group2 || ""}${Math.floor(Math.random() * 1e8)}`,
      title: `${parent?.title || "Task"}-${i}`,
      start: getUnixTime(start),
      end: getUnixTime(end),
      group_id: group2,
      expandable: true
    });
  }
  return items;
}
function randomGroupsAndItems(length) {
  const groups = [];
  let items = [];
  for (let i = 0; i < length; i++) {
    groups.push({
      id: `00000${i}`,
      title: `Group-${i}`
    });
    items = [...items, ...randomItems(6, void 0, groups[i].id)];
  }
  return {
    groups,
    items
  };
}

// example/src/app/pipes/date-format.pipe.ts
var GanttDateFormatPipe = class _GanttDateFormatPipe {
  transform(value, format4) {
    return new GanttDate(value).format(format4);
  }
  static {
    this.\u0275fac = function GanttDateFormatPipe_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _GanttDateFormatPipe)();
    };
  }
  static {
    this.\u0275pipe = /* @__PURE__ */ \u0275\u0275definePipe({ name: "dateFormat", type: _GanttDateFormatPipe, pure: true });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(GanttDateFormatPipe, [{
    type: Pipe,
    args: [{
      name: "dateFormat"
    }]
  }], null, null);
})();

// example/src/app/gantt/gantt.component.ts
var _c030 = ["gantt"];
function AppGanttExampleComponent_ng_template_2_Conditional_18_Template(rf, ctx) {
  if (rf & 1) {
    const _r4 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "\u9690\u85CF\u5047\u671F\uFF1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "thy-switch", 12);
    \u0275\u0275twoWayListener("ngModelChange", function AppGanttExampleComponent_ng_template_2_Conditional_18_Template_thy_switch_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      \u0275\u0275twoWayBindingSet(ctx_r2.isHideHolidayChecked, $event) || (ctx_r2.isHideHolidayChecked = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function AppGanttExampleComponent_ng_template_2_Conditional_18_Template_thy_switch_ngModelChange_2_listener() {
      \u0275\u0275restoreView(_r4);
      const ctx_r2 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r2.holidayChange());
    });
    \u0275\u0275text(3, "\u9690\u85CF\u5047\u671F ");
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext(2);
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.isHideHolidayChecked);
  }
}
function AppGanttExampleComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-button", 11);
    \u0275\u0275listener("click", function AppGanttExampleComponent_ng_template_2_Template_thy_button_click_0_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.scrollToToday());
    });
    \u0275\u0275text(1, "\u4ECA\u5929");
    \u0275\u0275elementEnd();
    \u0275\u0275text(2, " \xA0 \xA0 \xA0 ");
    \u0275\u0275elementStart(3, "thy-button", 11);
    \u0275\u0275listener("click", function AppGanttExampleComponent_ng_template_2_Template_thy_button_click_3_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.refresh());
    });
    \u0275\u0275text(4, "\u5237\u65B0");
    \u0275\u0275elementEnd();
    \u0275\u0275text(5, " \xA0 \xA0 \xA0 ");
    \u0275\u0275elementStart(6, "thy-button", 11);
    \u0275\u0275listener("click", function AppGanttExampleComponent_ng_template_2_Template_thy_button_click_6_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.print("gantt-example"));
    });
    \u0275\u0275text(7, " \u2193 \u5BFC\u51FA\u4E3A\u56FE\u7247 ");
    \u0275\u0275elementEnd();
    \u0275\u0275text(8, " \xA0 \xA0 \xA0 ");
    \u0275\u0275elementStart(9, "span");
    \u0275\u0275text(10, "\u5DE5\u5177\u680F\uFF1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(11, "thy-switch", 12);
    \u0275\u0275twoWayListener("ngModelChange", function AppGanttExampleComponent_ng_template_2_Template_thy_switch_ngModelChange_11_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.isShowToolbarChecked, $event) || (ctx_r2.isShowToolbarChecked = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275elementEnd();
    \u0275\u0275text(12, " \xA0 \xA0 \xA0 ");
    \u0275\u0275elementStart(13, "span");
    \u0275\u0275text(14, "\u57FA\u7EBF\u5BF9\u6BD4\uFF1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(15, "thy-switch", 12);
    \u0275\u0275twoWayListener("ngModelChange", function AppGanttExampleComponent_ng_template_2_Template_thy_switch_ngModelChange_15_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.isBaselineChecked, $event) || (ctx_r2.isBaselineChecked = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function AppGanttExampleComponent_ng_template_2_Template_thy_switch_ngModelChange_15_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.switchChange());
    });
    \u0275\u0275text(16, "\u57FA\u7EBF\u5BF9\u6BD4 ");
    \u0275\u0275elementEnd();
    \u0275\u0275text(17, " \xA0 \xA0 \xA0 ");
    \u0275\u0275conditionalCreate(18, AppGanttExampleComponent_ng_template_2_Conditional_18_Template, 4, 1);
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(11);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.isShowToolbarChecked);
    \u0275\u0275advance(4);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.isBaselineChecked);
    \u0275\u0275advance(3);
    \u0275\u0275conditional(ctx_r2.selectedViewType === "day" ? 18 : -1);
  }
}
function AppGanttExampleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 13);
    \u0275\u0275text(1, "\u67E5\u770B\u6E90\u7801");
    \u0275\u0275elementEnd();
  }
}
function AppGanttExampleComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r5 = ctx.item;
    \u0275\u0275textInterpolate1(" ", item_r5.title, " ");
  }
}
function AppGanttExampleComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "dateFormat");
  }
  if (rf & 2) {
    const item_r6 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r6.start, "yyyy-MM-dd HH:mm"), " ");
  }
}
function AppGanttExampleComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "dateFormat");
  }
  if (rf & 2) {
    const item_r7 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r7.end, "yyyy-MM-dd HH:mm"), " ");
  }
}
function AppGanttExampleComponent_ng_template_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 14);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r8 = ctx.item;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", item_r8.title, " ");
  }
}
var cacheKeys = "GANTT_TABLE_KEYS";
var AppGanttExampleComponent = class _AppGanttExampleComponent {
  constructor() {
    this.printService = inject(GanttPrintService);
    this.thyNotify = inject(ThyNotifyService);
    this.cdr = inject(ChangeDetectorRef);
    this.toolbarOptions = {
      viewTypes: [
        GanttViewType.hour,
        GanttViewType.day,
        GanttViewType.week,
        GanttViewType.month,
        GanttViewType.quarter,
        GanttViewType.year
      ]
    };
    this.viewType = GanttViewType.day;
    this.selectedViewType = GanttViewType.day;
    this.isBaselineChecked = false;
    this.isShowToolbarChecked = true;
    this.loading = false;
    this.isHideHolidayChecked = false;
    this.items = [
      { id: "000000", title: "Task 0", start: 1627729997, end: 1627769997, draggable: false, linkable: false },
      // { id: '000001', title: 'Task 1', start: 1617361997, end: 1625483597, links: ['000003', '000004', '000000'],  },
      { id: "000001", title: "Task 1", start: 1617361997, end: 1625483597, links: ["000003", "000004", "0000029"], draggable: false },
      { id: "000002", title: "Task 2", start: 1617361997, end: 1625483597, progress: 0.5, linkable: false },
      { id: "000003", title: "Task 3 (\u4E0D\u53EF\u62D6\u52A8)", start: 1628507597, end: 1633345997, itemDraggable: false },
      { id: "000004", title: "Task 4", start: 1624705997 },
      { id: "000005", title: "Task 5", start: 1756543568, end: 1756629968, color: "#709dc1" },
      { id: "000006", title: "Task 6", start: 1641121997, end: 1645528397 },
      { id: "000007", title: "Task 7", start: 1639393997, end: 1640862797 },
      { id: "000008", title: "Task 8", end: 1628783999, color: "#709dc1" },
      { id: "000009", title: "Task 9", start: 1639307597, end: 1640344397 },
      { id: "0000010", title: "Task 10", start: 1609067597, end: 1617275597 },
      { id: "0000011", title: "Task 11", start: new Date(1611918797 * 1e3), end: new Date(1611918797 * 1e3) },
      { id: "0000012", title: "Task 12", start: new Date(1627816397 * 1e3), end: new Date(1631358797 * 1e3) },
      { id: "0000013", title: "Task 13", start: new Date(1625051597 * 1e3), end: new Date(1630667597 * 1e3), links: ["0000012"] },
      { id: "0000014", title: "Task 14", start: new Date(162792e4 * 1e3), end: new Date(1629129599 * 1e3) },
      { id: "0000015", title: "Task 15", start: new Date(1633259597 * 1e3), end: new Date(1639480397 * 1e3) },
      { id: "0000016", title: "Task 16", start: new Date(1624965197 * 1e3), end: new Date(1627211597 * 1e3) },
      { id: "0000017", title: "Task 17", start: new Date(1641035597 * 1e3), end: new Date(1649157197 * 1e3) },
      { id: "0000018", title: "Task 18", start: new Date(1637061197 * 1e3), end: new Date(1642677197 * 1e3) },
      { id: "0000019", title: "Task 19", start: new Date(1637925197 * 1e3), end: new Date(1646305997 * 1e3) },
      { id: "0000020", title: "Task 20", start: new Date(1628334797 * 1e3), end: new Date(1629889997 * 1e3) },
      { id: "0000021", title: "Task 21", start: new Date(1622891597 * 1e3), end: new Date(1627643597 * 1e3) },
      { id: "0000022", title: "Task 22", start: new Date(1616238797 * 1e3), end: new Date(1620731597 * 1e3) },
      { id: "0000023", title: "Task 23", start: new Date(1626693197 * 1e3), end: new Date(1630149197 * 1e3) },
      { id: "0000024", title: "Task 24", start: new Date(1626174797 * 1e3), end: new Date(1626952397 * 1e3) },
      { id: "0000025", title: "Task 25", start: new Date(1631013197 * 1e3), end: new Date(1637493197 * 1e3) },
      { id: "0000026", title: "Task 26", start: new Date(1635937997 * 1e3), end: new Date(1643886797 * 1e3) },
      { id: "0000027", title: "Task 27", start: new Date(1637665997 * 1e3), end: new Date(1644059597 * 1e3) },
      { id: "0000028", title: "Task 28", start: new Date(1611400397 * 1e3), end: new Date(1615547597 * 1e3) },
      { id: "0000029", title: "Task 29", start: new Date(1618053197 * 1e3), end: new Date(1619176397 * 1e3) }
    ];
    this.baselineItems = [];
    this.options = {
      viewType: GanttViewType.day
    };
    this.viewOptions = {
      holiday: {
        isHoliday: (date) => date.isWeekend(),
        hideHoliday: false
      }
    };
    this.width = JSON.parse(localStorage.getItem(cacheKeys));
    this.class = true;
    this.dropEnterPredicate = (event) => {
      return true;
    };
  }
  ngOnInit() {
    this.items.forEach((item, index2) => {
      if (index2 % 5 === 0) {
        item.children = randomItems(random(1, 5), item);
      }
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.ganttComponent.scrollToDate(1627729997), 200);
  }
  barClick(event) {
    this.thyNotify.info("Event: barClick", `\u4F60\u70B9\u51FB\u4E86 [${event.item.title}]`);
  }
  lineClick(event) {
    this.thyNotify.info("Event: lineClick", `\u4F60\u70B9\u51FB\u4E86 ${event.source.title} \u5230 ${event.target.title} \u7684\u5173\u8054\u7EBF`);
  }
  dragMoved(event) {
  }
  dragEnded(event) {
    this.thyNotify.info("Event: dragEnded", `\u4FEE\u6539\u4E86 [${event.item.title}] \u7684\u65F6\u95F4`);
    this.items = [...this.items];
  }
  itemClick(event) {
    console.log(`\u70B9\u51FB\u4E86\u6570\u636E\u884C ${event.current.id}`);
  }
  selectedChange(event) {
    event.current && this.ganttComponent.scrollToDate(event.current?.start);
    this.thyNotify.info("Event: selectedChange", `\u5F53\u524D\u9009\u4E2D\u7684 item \u7684 id \u4E3A ${event.selectedValue.map((item) => item.id).join("\u3001")}`);
  }
  linkDragEnded(event) {
    this.items = [...this.items];
    this.thyNotify.info("Event: linkDragEnded", `\u521B\u5EFA\u4E86\u5173\u8054\u5173\u7CFB`);
  }
  print(name) {
    this.printService.print(name);
  }
  scrollToToday() {
    this.ganttComponent.scrollToToday();
  }
  switchChange() {
    if (this.isBaselineChecked) {
      this.baselineItems = [
        { id: "000000", start: 1627728888, end: 1628421197 },
        { id: "000001", start: 1617361997, end: 1625483597 },
        { id: "000002", start: 1610536397, end: 1610622797 },
        { id: "000003", start: 1628507597, end: 1633345997 },
        { id: "000004", start: 1624705997 }
      ];
    } else {
      this.baselineItems = [];
    }
  }
  viewChange(event) {
    this.selectedViewType = event.viewType;
  }
  refresh() {
    this.loading = true;
    of(randomItems(30)).pipe(delay(2e3), finalize(() => {
      this.loading = false;
      this.cdr.markForCheck();
    })).subscribe((res) => {
      this.items = res;
    });
  }
  onDragDropped(event) {
    const sourceItems = event.sourceParent?.children || this.items;
    sourceItems.splice(sourceItems.indexOf(event.source), 1);
    if (event.dropPosition === "inside") {
      event.target.children = [...event.target.children || [], event.source];
    } else {
      const targetItems = event.targetParent?.children || this.items;
      if (event.dropPosition === "before") {
        targetItems.splice(targetItems.indexOf(event.target), 0, event.source);
      } else {
        targetItems.splice(targetItems.indexOf(event.target) + 1, 0, event.source);
      }
    }
    this.items = [...this.items];
  }
  onDragStarted(event) {
    console.log("\u62D6\u62FD\u5F00\u59CB\u4E86", event);
  }
  onDragEnded(event) {
    console.log("\u62D6\u62FD\u7ED3\u675F\u4E86", event);
  }
  resizeChange(width) {
    this.width = width;
    localStorage.setItem(cacheKeys, JSON.stringify(width));
  }
  holidayChange() {
    this.viewOptions = __spreadProps(__spreadValues({}, this.viewOptions), {
      holiday: __spreadProps(__spreadValues({}, this.viewOptions.holiday), {
        hideHoliday: this.isHideHolidayChecked
      })
    });
  }
  static {
    this.\u0275fac = function AppGanttExampleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttExampleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttExampleComponent, selectors: [["app-gantt-example"]], viewQuery: function AppGanttExampleComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c030, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ganttComponent = _t.first);
      }
    }, hostVars: 2, hostBindings: function AppGanttExampleComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-example-component", ctx.class);
      }
    }, features: [\u0275\u0275ProvidersFeature([GanttPrintService])], decls: 21, vars: 17, consts: [["headerContent", ""], ["headerOperation", ""], ["gantt", ""], ["cell", ""], ["bar", ""], [1, "header-with-baseline"], [3, "barClick", "viewChange", "lineClick", "dragMoved", "dragEnded", "selectedChange", "linkDragEnded", "items", "baselineItems", "viewType", "draggable", "linkable", "selectable", "multiple", "viewOptions", "showToolbar", "toolbarOptions", "loading", "virtualScrollEnabled", "quickTimeFocus"], [3, "itemClick", "dragDropped", "dragStarted", "dragEnded", "resizeChange", "draggable", "maxWidth", "dropEnterPredicate"], ["name", "Title", "width", "160px", 3, "showExpandIcon"], ["name", "Start Time", "width", "200px"], ["name", "End Time", "width", "200px"], ["thyType", "primary", "thySize", "sm", 3, "click"], [1, "baseline-switch", 3, "ngModelChange", "ngModel"], ["href", "https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt", "target", "_blank"], [2, "color", "#fff"]], template: function AppGanttExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "thy-layout")(1, "thy-header", 5);
        \u0275\u0275template(2, AppGanttExampleComponent_ng_template_2_Template, 19, 3, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(4, AppGanttExampleComponent_ng_template_4_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(6, "thy-content")(7, "ngx-gantt", 6, 2);
        \u0275\u0275listener("barClick", function AppGanttExampleComponent_Template_ngx_gantt_barClick_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.barClick($event));
        })("viewChange", function AppGanttExampleComponent_Template_ngx_gantt_viewChange_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.viewChange($event));
        })("lineClick", function AppGanttExampleComponent_Template_ngx_gantt_lineClick_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.lineClick($event));
        })("dragMoved", function AppGanttExampleComponent_Template_ngx_gantt_dragMoved_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.dragMoved($event));
        })("dragEnded", function AppGanttExampleComponent_Template_ngx_gantt_dragEnded_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.dragEnded($event));
        })("selectedChange", function AppGanttExampleComponent_Template_ngx_gantt_selectedChange_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.selectedChange($event));
        })("linkDragEnded", function AppGanttExampleComponent_Template_ngx_gantt_linkDragEnded_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.linkDragEnded($event));
        });
        \u0275\u0275elementStart(9, "ngx-gantt-table", 7);
        \u0275\u0275listener("itemClick", function AppGanttExampleComponent_Template_ngx_gantt_table_itemClick_9_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.itemClick($event));
        })("dragDropped", function AppGanttExampleComponent_Template_ngx_gantt_table_dragDropped_9_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragDropped($event));
        })("dragStarted", function AppGanttExampleComponent_Template_ngx_gantt_table_dragStarted_9_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragStarted($event));
        })("dragEnded", function AppGanttExampleComponent_Template_ngx_gantt_table_dragEnded_9_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragEnded($event));
        })("resizeChange", function AppGanttExampleComponent_Template_ngx_gantt_table_resizeChange_9_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.resizeChange($event));
        });
        \u0275\u0275elementStart(10, "ngx-gantt-column", 8);
        \u0275\u0275template(11, AppGanttExampleComponent_ng_template_11_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, "ngx-gantt-column", 9);
        \u0275\u0275template(14, AppGanttExampleComponent_ng_template_14_Template, 2, 4, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(16, "ngx-gantt-column", 10);
        \u0275\u0275template(17, AppGanttExampleComponent_ng_template_17_Template, 2, 4, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()();
        \u0275\u0275template(19, AppGanttExampleComponent_ng_template_19_Template, 2, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275advance(7);
        \u0275\u0275property("items", ctx.items)("baselineItems", ctx.baselineItems)("viewType", ctx.viewType)("draggable", true)("linkable", true)("selectable", true)("multiple", true)("viewOptions", ctx.viewOptions)("showToolbar", ctx.isShowToolbarChecked)("toolbarOptions", ctx.toolbarOptions)("loading", ctx.loading)("virtualScrollEnabled", false)("quickTimeFocus", true);
        \u0275\u0275advance(2);
        \u0275\u0275property("draggable", true)("maxWidth", 800)("dropEnterPredicate", ctx.dropEnterPredicate);
        \u0275\u0275advance();
        \u0275\u0275property("showExpandIcon", true);
      }
    }, dependencies: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThyButton,
      ThySwitch,
      FormsModule,
      NgControlStatus,
      NgModel,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent,
      GanttDateFormatPipe
    ], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttExampleComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-example", providers: [GanttPrintService], imports: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThyButton,
      ThySwitch,
      FormsModule,
      GanttDateFormatPipe,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent
    ], template: `<thy-layout>
  <thy-header class="header-with-baseline">
    <ng-template #headerContent>
      <thy-button thyType="primary" thySize="sm" (click)="scrollToToday()">\u4ECA\u5929</thy-button>
      &nbsp; &nbsp; &nbsp;
      <thy-button thyType="primary" thySize="sm" (click)="refresh()">\u5237\u65B0</thy-button>
      &nbsp; &nbsp; &nbsp;
      <thy-button thyType="primary" thySize="sm" (click)="print('gantt-example')"> \u2193 \u5BFC\u51FA\u4E3A\u56FE\u7247 </thy-button>
      &nbsp; &nbsp; &nbsp;
      <span>\u5DE5\u5177\u680F\uFF1A</span>
      <thy-switch class="baseline-switch" [(ngModel)]="isShowToolbarChecked"> </thy-switch>
      &nbsp; &nbsp; &nbsp;
      <span>\u57FA\u7EBF\u5BF9\u6BD4\uFF1A</span>
      <thy-switch class="baseline-switch" [(ngModel)]="isBaselineChecked" (ngModelChange)="switchChange()">\u57FA\u7EBF\u5BF9\u6BD4 </thy-switch>
      &nbsp; &nbsp; &nbsp;
      @if (selectedViewType === 'day') {
        <span>\u9690\u85CF\u5047\u671F\uFF1A</span>
        <thy-switch class="baseline-switch" [(ngModel)]="isHideHolidayChecked" (ngModelChange)="holidayChange()">\u9690\u85CF\u5047\u671F </thy-switch>
      }
    </ng-template>
    <ng-template #headerOperation>
      <a href="https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt" target="_blank">\u67E5\u770B\u6E90\u7801</a>
    </ng-template>
  </thy-header>
  <thy-content>
    <ngx-gantt
      #gantt
      [items]="items"
      [baselineItems]="baselineItems"
      [viewType]="viewType"
      [draggable]="true"
      [linkable]="true"
      [selectable]="true"
      [multiple]="true"
      [viewOptions]="viewOptions"
      [showToolbar]="isShowToolbarChecked"
      [toolbarOptions]="toolbarOptions"
      [loading]="loading"
      [virtualScrollEnabled]="false"
      (barClick)="barClick($event)"
      (viewChange)="viewChange($event)"
      (lineClick)="lineClick($event)"
      (dragMoved)="dragMoved($event)"
      (dragEnded)="dragEnded($event)"
      (selectedChange)="selectedChange($event)"
      (linkDragEnded)="linkDragEnded($event)"
      [quickTimeFocus]="true"
    >
      <ngx-gantt-table
        [draggable]="true"
        [maxWidth]="800"
        [dropEnterPredicate]="dropEnterPredicate"
        (itemClick)="itemClick($event)"
        (dragDropped)="onDragDropped($event)"
        (dragStarted)="onDragStarted($event)"
        (dragEnded)="onDragEnded($event)"
        (resizeChange)="resizeChange($event)"
      >
        <ngx-gantt-column name="Title" width="160px" [showExpandIcon]="true">
          <ng-template #cell let-item="item"> {{ item.title }} </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="Start Time" width="200px">
          <ng-template #cell let-item="item">
            {{ item.start | dateFormat: 'yyyy-MM-dd HH:mm' }}
          </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="End Time" width="200px">
          <ng-template #cell let-item="item">
            {{ item.end | dateFormat: 'yyyy-MM-dd HH:mm' }}
          </ng-template>
        </ngx-gantt-column>
      </ngx-gantt-table>

      <ng-template #bar let-item="item">
        <span style="color: #fff">&nbsp;&nbsp;{{ item.title }} </span>
      </ng-template>
    </ngx-gantt>
  </thy-content>
</thy-layout>
` }]
  }], () => [], { class: [{
    type: HostBinding,
    args: ["class.gantt-example-component"]
  }], ganttComponent: [{
    type: ViewChild,
    args: ["gantt"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttExampleComponent, { className: "AppGanttExampleComponent", filePath: "example/src/app/gantt/gantt.component.ts", lineNumber: 55 });
})();

// example/src/app/gantt-advanced/component/flat.component.ts
function AppGanttFlatComponent_ng_template_1_For_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 5)(1, "div", 6);
    \u0275\u0275text(2);
    \u0275\u0275elementEnd()();
  }
  if (rf & 2) {
    const group_r1 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275advance();
    \u0275\u0275styleProp("height", (group_r1.mergedItems == null ? null : group_r1.mergedItems.length) * (ctx_r1.styles().rowHeight + 10) - 10, "px");
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", group_r1.title, " ");
  }
}
function AppGanttFlatComponent_ng_template_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 3);
    \u0275\u0275text(1, "\u9879\u76EE");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "div", 4);
    \u0275\u0275repeaterCreate(3, AppGanttFlatComponent_ng_template_1_For_4_Template, 3, 3, "div", 5, \u0275\u0275componentInstance().trackBy, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275advance(3);
    \u0275\u0275repeater(ctx_r1.groups);
  }
}
function AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_For_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r3 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "ngx-gantt-bar", 14);
    \u0275\u0275listener("barClick", function AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_For_2_For_2_Template_ngx_gantt_bar_barClick_0_listener($event) {
      \u0275\u0275restoreView(_r3);
      const ctx_r1 = \u0275\u0275nextContext(5);
      return \u0275\u0275resetView(ctx_r1.barClick.emit($event));
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r4 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(5);
    \u0275\u0275property("item", item_r4)("template", ctx_r1.barTemplate());
  }
}
function AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 12);
    \u0275\u0275repeaterCreate(1, AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_For_2_For_2_Template, 1, 2, "ngx-gantt-bar", 13, \u0275\u0275componentInstance().trackBy, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const items_r5 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(4);
    \u0275\u0275styleProp("height", ctx_r1.styles().rowHeight, "px");
    \u0275\u0275advance();
    \u0275\u0275repeater(items_r5);
  }
}
function AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 10);
    \u0275\u0275repeaterCreate(1, AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_For_2_Template, 3, 2, "div", 11, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r6 = ctx.$implicit;
    const ctx_r1 = \u0275\u0275nextContext(3);
    \u0275\u0275styleProp("height", (group_r6.mergedItems == null ? null : group_r6.mergedItems.length) * (ctx_r1.styles().rowHeight + 10) - 10, "px");
    \u0275\u0275advance();
    \u0275\u0275repeater(group_r6.mergedItems);
  }
}
function AppGanttFlatComponent_ng_template_3_Conditional_0_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 8);
    \u0275\u0275repeaterCreate(1, AppGanttFlatComponent_ng_template_3_Conditional_0_For_2_Template, 3, 2, "div", 9, \u0275\u0275componentInstance().trackBy, true);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext(2);
    \u0275\u0275styleProp("width", ctx_r1.view.width, "px");
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r1.groups);
  }
}
function AppGanttFlatComponent_ng_template_3_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275conditionalCreate(0, AppGanttFlatComponent_ng_template_3_Conditional_0_Template, 3, 2, "div", 7);
  }
  if (rf & 2) {
    const ctx_r1 = \u0275\u0275nextContext();
    \u0275\u0275conditional(ctx_r1.groups && ctx_r1.groups.length > 0 ? 0 : -1);
  }
}
var AppGanttFlatComponent = class _AppGanttFlatComponent extends GanttUpper {
  constructor() {
    super();
    this.mergeIntervalDays = 3;
    this.groups = [];
    this.ganttFlatClass = true;
    effect(() => {
      if (this.isEffectFinished()) {
        outputToObservable(this.dragEnded).pipe(startWith(null), takeUntil(this.unsubscribe$)).subscribe(() => {
          this.buildGroupItems();
        });
      }
    });
  }
  buildGroupMergedItems(items) {
    const mergedItems = [];
    items = items.filter((item) => item.start && item.end).sort((a, b) => a.start.getUnixTime() - b.start.getUnixTime());
    items.forEach((item) => {
      let indexOfMergedItems = -1;
      for (let i = 0; i < mergedItems.length; i++) {
        const subItems = mergedItems[i];
        if (item.start.value > subItems[subItems.length - 1].end.addDays(this.mergeIntervalDays).value) {
          subItems.push(item);
          indexOfMergedItems = i;
          break;
        }
      }
      if (indexOfMergedItems === -1) {
        mergedItems.push([item]);
        indexOfMergedItems = mergedItems.length - 1;
      }
    });
    return mergedItems;
  }
  ngOnInit() {
    super.ngOnInit();
  }
  buildGroupItems() {
    this.groups.forEach((group2) => {
      group2.mergedItems = this.buildGroupMergedItems(group2.items);
      group2.mergedItems = group2.mergedItems.length === 0 ? [[]] : group2.mergedItems;
    });
  }
  static {
    this.\u0275fac = function AppGanttFlatComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttFlatComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttFlatComponent, selectors: [["app-gantt-flat"]], hostVars: 2, hostBindings: function AppGanttFlatComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-flat", ctx.ganttFlatClass);
      }
    }, features: [\u0275\u0275ProvidersFeature([
      {
        provide: GANTT_UPPER_TOKEN,
        useExisting: _AppGanttFlatComponent
      }
    ]), \u0275\u0275InheritDefinitionFeature], decls: 5, vars: 1, consts: [["sideTemplate", ""], ["mainTemplate", ""], [3, "sideWidth"], [1, "gantt-flat-side-header"], [1, "gantt-flat-side-body"], [1, "gantt-group"], [1, "gantt-group-content"], [1, "gantt-main-groups", 3, "width"], [1, "gantt-main-groups"], [1, "gantt-main-group", 3, "height"], [1, "gantt-main-group"], [1, "gantt-flat-items", 3, "height"], [1, "gantt-flat-items"], [3, "item", "template"], [3, "barClick", "item", "template"]], template: function AppGanttFlatComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "ngx-gantt-root", 2);
        \u0275\u0275template(1, AppGanttFlatComponent_ng_template_1_Template, 5, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(3, AppGanttFlatComponent_ng_template_3_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
      }
      if (rf & 2) {
        \u0275\u0275property("sideWidth", 300);
      }
    }, dependencies: [NgxGanttRootComponent, NgxGanttBarComponent], styles: ["\n\n[_nghost-%COMP%]   .gantt-flat-side-header[_ngcontent-%COMP%] {\n  text-align: center;\n  position: sticky;\n  top: 0;\n  background: #fff;\n  height: 44px;\n  line-height: 44px;\n  z-index: 1;\n  border-bottom: 1px solid #eee;\n  box-sizing: border-box;\n}\n[_nghost-%COMP%]   .gantt-group[_ngcontent-%COMP%]   .gantt-group-content[_ngcontent-%COMP%] {\n  border-bottom: 1px solid #eee;\n  display: flex;\n  align-items: center;\n  padding: 15px;\n}\n[_nghost-%COMP%]   .gantt-main-group[_ngcontent-%COMP%] {\n  border-bottom: 1px solid #eee;\n  padding: 15px 0;\n}\n[_nghost-%COMP%]   .gantt-main-group[_ngcontent-%COMP%]   .gantt-flat-items[_ngcontent-%COMP%] {\n  position: relative;\n}\n/*# sourceMappingURL=flat.css.map */"] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttFlatComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-flat", providers: [
      {
        provide: GANTT_UPPER_TOKEN,
        useExisting: AppGanttFlatComponent
      }
    ], imports: [NgxGanttRootComponent, NgxGanttBarComponent], template: '<ngx-gantt-root [sideWidth]="300">\n  <ng-template #sideTemplate>\n    <div class="gantt-flat-side-header">\u9879\u76EE</div>\n    <div class="gantt-flat-side-body">\n      @for (group of groups; track trackBy($index, group)) {\n        <div class="gantt-group">\n          <div class="gantt-group-content" [style.height.px]="group.mergedItems?.length * (styles().rowHeight + 10) - 10">\n            {{ group.title }}\n          </div>\n        </div>\n      }\n    </div>\n  </ng-template>\n  <ng-template #mainTemplate>\n    <!-- groups -->\n    @if (groups && groups.length > 0) {\n      <div class="gantt-main-groups" [style.width.px]="view.width">\n        @for (group of groups; track trackBy($index, group)) {\n          <div class="gantt-main-group" [style.height.px]="group.mergedItems?.length * (styles().rowHeight + 10) - 10">\n            @for (items of group.mergedItems; track $index) {\n              <div class="gantt-flat-items" [style.height.px]="styles().rowHeight">\n                @for (item of items; track trackBy($index, item)) {\n                  <ngx-gantt-bar [item]="item" [template]="barTemplate()" (barClick)="barClick.emit($event)"></ngx-gantt-bar>\n                }\n              </div>\n            }\n          </div>\n        }\n      </div>\n    }\n  </ng-template>\n</ngx-gantt-root>\n', styles: ["/* example/src/app/gantt-advanced/component/flat.scss */\n:host .gantt-flat-side-header {\n  text-align: center;\n  position: sticky;\n  top: 0;\n  background: #fff;\n  height: 44px;\n  line-height: 44px;\n  z-index: 1;\n  border-bottom: 1px solid #eee;\n  box-sizing: border-box;\n}\n:host .gantt-group .gantt-group-content {\n  border-bottom: 1px solid #eee;\n  display: flex;\n  align-items: center;\n  padding: 15px;\n}\n:host .gantt-main-group {\n  border-bottom: 1px solid #eee;\n  padding: 15px 0;\n}\n:host .gantt-main-group .gantt-flat-items {\n  position: relative;\n}\n/*# sourceMappingURL=flat.css.map */\n"] }]
  }], () => [], { ganttFlatClass: [{
    type: HostBinding,
    args: ["class.gantt-flat"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttFlatComponent, { className: "AppGanttFlatComponent", filePath: "example/src/app/gantt-advanced/component/flat.component.ts", lineNumber: 25 });
})();

// example/src/app/gantt-advanced/gantt-advanced.component.ts
function AppGanttAdvancedExampleComponent_ng_template_20_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const group_r1 = ctx.group;
    \u0275\u0275textInterpolate1(" ", group_r1.title, " ");
  }
}
function AppGanttAdvancedExampleComponent_ng_template_22_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r2 = ctx.item;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", item_r2.title);
  }
}
var AppGanttAdvancedExampleComponent = class _AppGanttAdvancedExampleComponent {
  constructor() {
    this.items = [];
    this.groups = [];
    this.options = {
      viewType: GanttViewType.month,
      draggable: true,
      mergeIntervalDays: 3,
      styles: {
        rowHeight: 50
      }
    };
    this.class = true;
  }
  ngOnInit() {
    const { groups, items } = randomGroupsAndItems(10);
    this.groups = groups;
    this.items = items;
  }
  static {
    this.\u0275fac = function AppGanttAdvancedExampleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttAdvancedExampleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttAdvancedExampleComponent, selectors: [["app-gantt-advanced-example"]], hostVars: 2, hostBindings: function AppGanttAdvancedExampleComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-example-component", ctx.class);
      }
    }, decls: 24, vars: 5, consts: [["gantt", ""], ["group", ""], ["bar", ""], [2, "line-height", "30px", "padding", "15px", "display", "flex"], [2, "flex", "1"], [1, "text-primary"], [2, "padding-right", "15px"], ["href", "https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-advanced", "target", "_blank"], [3, "items", "groups", "viewType", "draggable", "styles"], [2, "color", "#fff"]], template: function AppGanttAdvancedExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 3)(1, "div", 4)(2, "span", 5);
        \u0275\u0275text(3, "NgxGantt");
        \u0275\u0275elementEnd();
        \u0275\u0275text(4, " \u5BFC\u51FA\u4E86 ");
        \u0275\u0275elementStart(5, "span", 5);
        \u0275\u0275text(6, "ngx-gantt-root");
        \u0275\u0275elementEnd();
        \u0275\u0275text(7, "\u3001");
        \u0275\u0275elementStart(8, "span", 5);
        \u0275\u0275text(9, "ngx-gantt-bar");
        \u0275\u0275elementEnd();
        \u0275\u0275text(10, " \u7B49\u57FA\u7840\u7EC4\u4EF6\uFF0C\u7ED3\u5408\u8FD9\u4E9B\u57FA\u7840\u7EC4\u4EF6\u4F7F\u7528\u8005\u53EF\u4EE5\u7ED3\u5408\u81EA\u5DF1\u7684\u4E1A\u52A1\u573A\u666F\u6765\u5C01\u88C5\u81EA\u5DF1\u7684 Gantt \u7EC4\u4EF6\u3002 ");
        \u0275\u0275element(11, "br");
        \u0275\u0275text(12, " \u4E0B\u9762\u793A\u4F8B\u5B9E\u73B0\u4E86\u4EFB\u52A1\u5206\u7EC4\u7684\u5C55\u793A\uFF0C\u5E76\u4E14\u5C06\u6BCF\u4E2A\u5206\u7EC4\u4E0B\u4EFB\u52A1\u6309\u65F6\u95F4\u7EF4\u5EA6\u6253\u5E73\u5C55\u793A\u3002 ");
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, "div", 6)(14, "a", 7);
        \u0275\u0275text(15, "\u67E5\u770B\u6E90\u7801");
        \u0275\u0275elementEnd()()();
        \u0275\u0275elementStart(16, "thy-layout")(17, "thy-content")(18, "app-gantt-flat", 8, 0);
        \u0275\u0275template(20, AppGanttAdvancedExampleComponent_ng_template_20_Template, 1, 1, "ng-template", null, 1, \u0275\u0275templateRefExtractor)(22, AppGanttAdvancedExampleComponent_ng_template_22_Template, 2, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275advance(18);
        \u0275\u0275property("items", ctx.items)("groups", ctx.groups)("viewType", ctx.options.viewType)("draggable", ctx.options.draggable)("styles", ctx.options.styles);
      }
    }, dependencies: [ThyLayout, ThyContent, AppGanttFlatComponent], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttAdvancedExampleComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-advanced-example", imports: [ThyLayout, ThyContent, AppGanttFlatComponent], template: '<div style="line-height: 30px; padding: 15px; display: flex;">\n  <div style="flex: 1;">\n    <span class="text-primary">NgxGantt</span> \u5BFC\u51FA\u4E86 <span class="text-primary">ngx-gantt-root</span>\u3001<span class="text-primary"\n      >ngx-gantt-bar</span\n    >\n    \u7B49\u57FA\u7840\u7EC4\u4EF6\uFF0C\u7ED3\u5408\u8FD9\u4E9B\u57FA\u7840\u7EC4\u4EF6\u4F7F\u7528\u8005\u53EF\u4EE5\u7ED3\u5408\u81EA\u5DF1\u7684\u4E1A\u52A1\u573A\u666F\u6765\u5C01\u88C5\u81EA\u5DF1\u7684 Gantt \u7EC4\u4EF6\u3002\n    <br />\n    \u4E0B\u9762\u793A\u4F8B\u5B9E\u73B0\u4E86\u4EFB\u52A1\u5206\u7EC4\u7684\u5C55\u793A\uFF0C\u5E76\u4E14\u5C06\u6BCF\u4E2A\u5206\u7EC4\u4E0B\u4EFB\u52A1\u6309\u65F6\u95F4\u7EF4\u5EA6\u6253\u5E73\u5C55\u793A\u3002\n  </div>\n  <div style="padding-right: 15px;">\n    <a href="https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-advanced" target="_blank">\u67E5\u770B\u6E90\u7801</a>\n  </div>\n</div>\n<thy-layout>\n  <thy-content>\n    <app-gantt-flat\n      #gantt\n      [items]="items"\n      [groups]="groups"\n      [viewType]="options.viewType"\n      [draggable]="options.draggable"\n      [styles]="options.styles"\n    >\n      <ng-template #group let-group="group">\n        {{ group.title }}\n      </ng-template>\n      <ng-template #bar let-item="item">\n        <span style="color: #fff">&nbsp;&nbsp;{{ item.title }}</span>\n      </ng-template>\n    </app-gantt-flat>\n  </thy-content>\n</thy-layout>\n' }]
  }], () => [], { class: [{
    type: HostBinding,
    args: ["class.gantt-example-component"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttAdvancedExampleComponent, { className: "AppGanttAdvancedExampleComponent", filePath: "example/src/app/gantt-advanced/gantt-advanced.component.ts", lineNumber: 12 });
})();

// example/src/app/components/components.component.ts
var AppExampleComponentsComponent = class _AppExampleComponentsComponent {
  constructor() {
    this.menus = [
      {
        id: "basic",
        title: "\u57FA\u672C\u4F7F\u7528",
        subtitle: "Basic",
        path: "basic"
      },
      {
        id: "groups",
        title: "\u5206\u7EC4\u5C55\u793A",
        subtitle: "Groups",
        path: "groups"
      },
      {
        id: "virtual-scroll",
        title: "\u865A\u62DF\u6EDA\u52A8",
        subtitle: "Virtual Scroll",
        path: "virtual-scroll"
      },
      {
        id: "custom-view",
        title: "\u81EA\u5B9A\u4E49\u89C6\u56FE",
        subtitle: "Custom View",
        path: "custom-view"
      },
      {
        id: "advanced",
        title: "\u9AD8\u7EA7\u4F7F\u7528",
        subtitle: "Advanced",
        path: "advanced"
      }
    ];
  }
  ngOnInit() {
  }
  static {
    this.\u0275fac = function AppExampleComponentsComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppExampleComponentsComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppExampleComponentsComponent, selectors: [["app-example-components"]], standalone: false, decls: 4, vars: 1, consts: [[1, "dg-layout", "dg-scroll-container"], [3, "menus"], [1, "gantt-example-content", 2, "margin-left", "300px"]], template: function AppExampleComponentsComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "div", 0);
        \u0275\u0275element(1, "dg-sidebar", 1);
        \u0275\u0275elementStart(2, "div", 2);
        \u0275\u0275element(3, "router-outlet");
        \u0275\u0275elementEnd()();
      }
      if (rf & 2) {
        \u0275\u0275advance();
        \u0275\u0275property("menus", ctx.menus);
      }
    }, dependencies: [RouterOutlet, SidebarComponent], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppExampleComponentsComponent, [{
    type: Component,
    args: [{ selector: "app-example-components", standalone: false, template: '<div class="dg-layout dg-scroll-container">\n  <dg-sidebar [menus]="menus"></dg-sidebar>\n  <div class="gantt-example-content" style="margin-left: 300px">\n    <router-outlet></router-outlet>\n  </div>\n</div>\n' }]
  }], () => [], null);
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppExampleComponentsComponent, { className: "AppExampleComponentsComponent", filePath: "example/src/app/components/components.component.ts", lineNumber: 9 });
})();

// example/src/app/gantt-groups/gantt-groups.component.ts
var _c031 = ["gantt"];
function AppGanttGroupsExampleComponent_ng_template_2_For_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "button", 13);
    \u0275\u0275listener("click", function AppGanttGroupsExampleComponent_ng_template_2_For_2_Template_button_click_0_listener() {
      const view_r3 = \u0275\u0275restoreView(_r2).$implicit;
      const ctx_r3 = \u0275\u0275nextContext(2);
      return \u0275\u0275resetView(ctx_r3.viewType = view_r3.value);
    });
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const view_r3 = ctx.$implicit;
    const ctx_r3 = \u0275\u0275nextContext(2);
    \u0275\u0275classProp("active", view_r3.value === ctx_r3.viewType);
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", view_r3.name, " ");
  }
}
function AppGanttGroupsExampleComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r1 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "thy-button-group", 10);
    \u0275\u0275repeaterCreate(1, AppGanttGroupsExampleComponent_ng_template_2_For_2_Template, 2, 3, "button", 11, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
    \u0275\u0275text(3, " \xA0 \xA0 \xA0 ");
    \u0275\u0275elementStart(4, "thy-button", 12);
    \u0275\u0275listener("click", function AppGanttGroupsExampleComponent_ng_template_2_Template_thy_button_click_4_listener() {
      \u0275\u0275restoreView(_r1);
      const ctx_r3 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r3.expandAllGroups());
    });
    \u0275\u0275text(5);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r3 = \u0275\u0275nextContext();
    \u0275\u0275advance();
    \u0275\u0275repeater(ctx_r3.views);
    \u0275\u0275advance(4);
    \u0275\u0275textInterpolate1(" ", ctx_r3.expanded ? "\u6298\u53E0\u5168\u90E8\u5206\u7EC4" : "\u5C55\u5F00\u5168\u90E8\u5206\u7EC4", " ");
  }
}
function AppGanttGroupsExampleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 14);
    \u0275\u0275text(1, "\u67E5\u770B\u6E90\u7801");
    \u0275\u0275elementEnd();
  }
}
function AppGanttGroupsExampleComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r5 = ctx.item;
    \u0275\u0275textInterpolate1(" ", item_r5.title, " ");
  }
}
function AppGanttGroupsExampleComponent_ng_template_14_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "date");
  }
  if (rf & 2) {
    const item_r6 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r6.start * 1e3, "yyyy-MM-dd"), " ");
  }
}
function AppGanttGroupsExampleComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "date");
  }
  if (rf & 2) {
    const item_r7 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r7.end * 1e3, "yyyy-MM-dd"), " ");
  }
}
function AppGanttGroupsExampleComponent_ng_template_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const group_r8 = ctx.group;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("", group_r8.title, " \u{1F680} ");
  }
}
var AppGanttGroupsExampleComponent = class _AppGanttGroupsExampleComponent {
  constructor() {
    this.views = [
      {
        name: "\u65E5",
        value: GanttViewType.day
      },
      {
        name: "\u5468",
        value: GanttViewType.week
      },
      {
        name: "\u6708",
        value: GanttViewType.month
      },
      {
        name: "\u5B63",
        value: GanttViewType.quarter
      },
      {
        name: "\u5E74",
        value: GanttViewType.year
      }
    ];
    this.viewType = GanttViewType.quarter;
    this.items = [];
    this.groups = [];
    this.expanded = true;
    this.class = true;
    this.childrenResolve = (item) => {
      const children = randomItems(random(1, 5), item);
      return of(children).pipe(delay(1e3));
    };
  }
  ngOnInit() {
    const { groups, items } = randomGroupsAndItems(10);
    this.groups = groups;
    this.items = items;
  }
  expandAllGroups() {
    if (this.expanded) {
      this.expanded = false;
      this.ganttComponent.collapseAll();
    } else {
      this.expanded = true;
      this.ganttComponent.expandAll();
    }
  }
  static {
    this.\u0275fac = function AppGanttGroupsExampleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttGroupsExampleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttGroupsExampleComponent, selectors: [["app-gantt-groups-example"]], viewQuery: function AppGanttGroupsExampleComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c031, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ganttComponent = _t.first);
      }
    }, hostVars: 2, hostBindings: function AppGanttGroupsExampleComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-example-component", ctx.class);
      }
    }, decls: 21, vars: 7, consts: [["headerContent", ""], ["headerOperation", ""], ["gantt", ""], ["cell", ""], ["group", ""], [3, "groups", "items", "viewType", "draggable", "async", "childrenResolve"], [3, "draggable"], ["name", "Title", "width", "180px"], ["name", "Start Time", "width", "140px"], ["name", "End Time", "width", "140px"], ["thySize", "sm", "thyType", "outline-default"], ["thyButton", "", 3, "active"], ["thyType", "primary", "thySize", "sm", 3, "click"], ["thyButton", "", 3, "click"], ["href", "https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-groups", "target", "_blank"], [1, "text-primary"]], template: function AppGanttGroupsExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275elementStart(0, "thy-layout")(1, "thy-header");
        \u0275\u0275template(2, AppGanttGroupsExampleComponent_ng_template_2_Template, 6, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(4, AppGanttGroupsExampleComponent_ng_template_4_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(6, "thy-content")(7, "ngx-gantt", 5, 2)(9, "ngx-gantt-table", 6)(10, "ngx-gantt-column", 7);
        \u0275\u0275template(11, AppGanttGroupsExampleComponent_ng_template_11_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(13, "ngx-gantt-column", 8);
        \u0275\u0275template(14, AppGanttGroupsExampleComponent_ng_template_14_Template, 2, 4, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(16, "ngx-gantt-column", 9);
        \u0275\u0275template(17, AppGanttGroupsExampleComponent_ng_template_17_Template, 2, 4, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()();
        \u0275\u0275template(19, AppGanttGroupsExampleComponent_ng_template_19_Template, 2, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275advance(7);
        \u0275\u0275property("groups", ctx.groups)("items", ctx.items)("viewType", ctx.viewType)("draggable", true)("async", true)("childrenResolve", ctx.childrenResolve);
        \u0275\u0275advance(2);
        \u0275\u0275property("draggable", true);
      }
    }, dependencies: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThyButton,
      ThyButtonGroup,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent,
      DatePipe
    ], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttGroupsExampleComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-groups-example", imports: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThyButton,
      ThyButtonGroup,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent,
      DatePipe
    ], template: `<thy-layout>
  <thy-header>
    <ng-template #headerContent>
      <thy-button-group thySize="sm" thyType="outline-default">
        @for (view of views; track $index) {
          <button thyButton [class.active]="view.value === viewType" (click)="viewType = view.value">
            {{ view.name }}
          </button>
        }
      </thy-button-group>

      &nbsp; &nbsp; &nbsp;
      <thy-button thyType="primary" thySize="sm" (click)="expandAllGroups()">
        {{ expanded ? '\u6298\u53E0\u5168\u90E8\u5206\u7EC4' : '\u5C55\u5F00\u5168\u90E8\u5206\u7EC4' }}
      </thy-button>
    </ng-template>
    <ng-template #headerOperation>
      <a href="https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-groups" target="_blank">\u67E5\u770B\u6E90\u7801</a>
    </ng-template>
  </thy-header>
  <thy-content>
    <ngx-gantt
      #gantt
      [groups]="groups"
      [items]="items"
      [viewType]="viewType"
      [draggable]="true"
      [async]="true"
      [childrenResolve]="childrenResolve"
    >
      <ngx-gantt-table [draggable]="true">
        <ngx-gantt-column name="Title" width="180px">
          <ng-template #cell let-item="item"> {{ item.title }} </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="Start Time" width="140px">
          <ng-template #cell let-item="item">
            {{ item.start * 1000 | date: 'yyyy-MM-dd' }}
          </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="End Time" width="140px">
          <ng-template #cell let-item="item">
            {{ item.end * 1000 | date: 'yyyy-MM-dd' }}
          </ng-template>
        </ngx-gantt-column>
      </ngx-gantt-table>
      <!-- group template -->
      <ng-template #group let-group="group" let-items="items">
        <span class="text-primary">{{ group.title }} \u{1F680} </span>
      </ng-template>
    </ngx-gantt>
  </thy-content>
</thy-layout>
` }]
  }], () => [], { ganttComponent: [{
    type: ViewChild,
    args: ["gantt"]
  }], class: [{
    type: HostBinding,
    args: ["class.gantt-example-component"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttGroupsExampleComponent, { className: "AppGanttGroupsExampleComponent", filePath: "example/src/app/gantt-groups/gantt-groups.component.ts", lineNumber: 24 });
})();

// example/src/app/gantt-custom-view/custom-day-view.ts
var defaultViewOptions = {
  unitWidth: 50,
  start: new GanttDate().startOfMonth().startOfWeek({ weekStartsOn: 1 }),
  end: new GanttDate().endOfMonth().endOfWeek({ weekStartsOn: 1 }),
  loadDuration: {
    amount: 1,
    unit: "month"
  },
  fillDays: 1
};
var GanttViewCustom = class extends GanttView {
  constructor(start, end, options) {
    super(start, end, Object.assign({}, defaultViewOptions, options));
    this.showNowIndicator = true;
    this.viewType = GanttViewType.day;
  }
  rangeStartOf(date) {
    return date.startOfWeek({ weekStartsOn: 1 });
  }
  rangeEndOf(date) {
    return date.endOfWeek({ weekStartsOn: 1 });
  }
  getPeriodWidth() {
    if (!this.options.showWeekend) {
      return this.getUnitWidth() * 5;
    } else {
      return this.getUnitWidth() * 7;
    }
  }
  getDayWidth(date) {
    if (!this.options.showWeekend && date.isWeekend()) {
      return 0;
    }
    return this.unitWidth;
  }
  getPeriodTicks() {
    const days = eachDayOfInterval({ start: this.start.value, end: this.end.value });
    const ticks = [];
    const dayInWeekMap = {
      "1": "\u5468\u4E00",
      "2": "\u5468\u4E8C",
      "3": "\u5468\u4E09",
      "4": "\u5468\u56DB",
      "5": "\u5468\u4E94",
      "6": "\u5468\u516D",
      "0": "\u5468\u65E5"
    };
    const periodWidth = this.getPeriodWidth();
    for (let i = 0; i < days.length; i++) {
      const start = new GanttDate(days[i]);
      const isWeekend3 = start.isWeekend();
      const rectX = i * periodWidth;
      const tick = new GanttViewTick({
        date: start,
        rect: {
          x: rectX,
          width: periodWidth,
          background: isWeekend3 ? "#f5f5f5" : void 0
        },
        label: {
          text: `${dayInWeekMap[start.getDay()]}`,
          y: PERIOD_TICK_TOP,
          x: rectX + periodWidth / 2,
          style: isWeekend3 || start.isToday() ? { color: "#ff9f73" } : void 0
        },
        metadata: {
          isWeekend: isWeekend3,
          isToday: start.isToday()
        }
      });
      ticks.push(tick);
    }
    if (!this.options.showWeekend) {
      return ticks.filter((tick) => !tick.metadata?.isWeekend).map((tick, i) => {
        const unitWidth = this.getUnitWidth();
        const rectX = i * unitWidth;
        return new GanttViewTick({
          date: tick.date,
          rect: __spreadProps(__spreadValues({}, tick.rect), {
            x: rectX,
            width: unitWidth
          }),
          label: __spreadProps(__spreadValues({}, tick.label), {
            x: rectX + unitWidth / 2
          }),
          metadata: tick.metadata
        });
      });
    } else {
      return ticks;
    }
  }
  getUnitTicks() {
    const days = eachDayOfInterval({ start: this.start.value, end: this.end.value });
    const ticks = [];
    const unitWidth = this.getUnitWidth();
    for (let i = 0; i < days.length; i++) {
      const start = new GanttDate(days[i]);
      const isWeekend3 = start.isWeekend();
      const rectX = i * unitWidth;
      const tick = new GanttViewTick({
        date: start,
        rect: {
          x: rectX,
          width: unitWidth,
          background: isWeekend3 ? "#f5f5f5" : void 0
        },
        label: {
          text: `${start.format("MM/d")}`,
          y: UNIT_TICK_TOP,
          x: rectX + unitWidth / 2,
          style: isWeekend3 || start.isToday() ? { color: "#ff9f73" } : void 0
        },
        metadata: {
          isWeekend: isWeekend3,
          isToday: start.isToday()
        }
      });
      ticks.push(tick);
    }
    if (!this.options.showWeekend) {
      return ticks.filter((tick) => !tick.metadata?.isWeekend).map((tick, i) => {
        const rectX = i * unitWidth;
        return new GanttViewTick({
          date: tick.date,
          rect: __spreadProps(__spreadValues({}, tick.rect), {
            x: rectX,
            width: unitWidth
          }),
          label: __spreadProps(__spreadValues({}, tick.label), {
            x: rectX + unitWidth / 2
          }),
          metadata: tick.metadata
        });
      });
    } else {
      return ticks;
    }
  }
};

// example/src/app/gantt-custom-view/gantt.component.ts
var _c032 = ["gantt"];
function AppGanttCustomViewExampleComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    const _r2 = \u0275\u0275getCurrentView();
    \u0275\u0275elementStart(0, "span");
    \u0275\u0275text(1, "\u663E\u793A\u5468\u672B\uFF1A");
    \u0275\u0275elementEnd();
    \u0275\u0275elementStart(2, "thy-switch", 7);
    \u0275\u0275twoWayListener("ngModelChange", function AppGanttCustomViewExampleComponent_ng_template_2_Template_thy_switch_ngModelChange_2_listener($event) {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      \u0275\u0275twoWayBindingSet(ctx_r2.showWeekend, $event) || (ctx_r2.showWeekend = $event);
      return \u0275\u0275resetView($event);
    });
    \u0275\u0275listener("ngModelChange", function AppGanttCustomViewExampleComponent_ng_template_2_Template_thy_switch_ngModelChange_2_listener() {
      \u0275\u0275restoreView(_r2);
      const ctx_r2 = \u0275\u0275nextContext();
      return \u0275\u0275resetView(ctx_r2.weekendChange());
    });
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const ctx_r2 = \u0275\u0275nextContext();
    \u0275\u0275advance(2);
    \u0275\u0275twoWayProperty("ngModel", ctx_r2.showWeekend);
  }
}
function AppGanttCustomViewExampleComponent_ng_template_4_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "a", 8);
    \u0275\u0275text(1, "\u67E5\u770B\u6E90\u7801");
    \u0275\u0275elementEnd();
  }
}
function AppGanttCustomViewExampleComponent_ng_template_11_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r4 = ctx.item;
    \u0275\u0275textInterpolate1(" ", item_r4.title, " ");
  }
}
function AppGanttCustomViewExampleComponent_ng_template_13_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 9);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r5 = ctx.item;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", item_r5.title, " ");
  }
}
var customViewType = "custom";
registerView(customViewType, GanttViewCustom);
var AppGanttCustomViewExampleComponent = class _AppGanttCustomViewExampleComponent {
  constructor() {
    this.thyNotify = inject(ThyNotifyService);
    this.viewType = customViewType;
    this.showWeekend = true;
    this.items = [
      { id: "000000", title: "Task 0", start: 1627729997, end: 1628421197, expandable: true },
      { id: "000001", title: "Task 1", start: 1617361997, end: 1625483597, links: ["000003", "000004", "000000"], expandable: true },
      { id: "000002", title: "Task 2", start: 1610536397, end: 1610622797, laneStyle: { backgroundColor: "rgba(0,255,0,.05)" } },
      { id: "000003", title: "Task 3", start: 1628507597, end: 1633345997, expandable: true },
      { id: "000004", title: "Task 4", start: 1624705997, expandable: true },
      { id: "000005", title: "Task 5", start: 1628075597, end: 1629544397, color: "#709dc1" },
      { id: "000006", title: "Task 6", start: 1641121997, end: 1645528397 },
      { id: "000007", title: "Task 7", start: 1639393997, end: 1640862797, laneStyle: { backgroundColor: "rgba(255,0,0,.05)" } },
      { id: "000008", title: "Task 8", end: 1628783999, color: "#709dc1" },
      { id: "000009", title: "Task 9", start: 1639307597, end: 1640344397 },
      { id: "0000010", title: "Task 10", start: 1609067597, end: 1617275597 },
      { id: "0000011", title: "Task 11", start: 1611918797, end: 1611918797 },
      { id: "0000012", title: "Task 12", start: 1627816397, end: 1631358797 },
      { id: "0000013", title: "Task 13", start: 1625051597, end: 1630667597, links: ["0000012"] },
      { id: "0000014", title: "Task 14", start: 162792e4, end: 1629129599 },
      { id: "0000015", title: "Task 15", start: 1633259597, end: 1639480397 },
      { id: "0000016", title: "Task 16", start: 1624965197, end: 1627211597 },
      { id: "0000017", title: "Task 17", start: 1641035597, end: 1649157197 },
      { id: "0000018", title: "Task 18", start: 1637061197, end: 1642677197 },
      { id: "0000019", title: "Task 19", start: 1637925197, end: 1646305997 },
      { id: "0000020", title: "Task 20", start: 1628334797, end: 1629889997 },
      { id: "0000021", title: "Task 21", start: 1622891597, end: 1627643597 },
      { id: "0000022", title: "Task 22", start: 1616238797, end: 1620731597 },
      { id: "0000023", title: "Task 23", start: 1626693197, end: 1630149197 },
      { id: "0000024", title: "Task 24", start: 1626174797, end: 1626952397 },
      { id: "0000025", title: "Task 25", start: 1631013197, end: 1637493197 },
      { id: "0000026", title: "Task 26", start: 1635937997, end: 1643886797 },
      { id: "0000027", title: "Task 27", start: 1637665997, end: 1644059597 },
      { id: "0000028", title: "Task 28", start: 1611400397, end: 1615547597 },
      { id: "0000029", title: "Task 29", start: 1618053197, end: 1619176397 }
    ];
    this.viewOptions = {
      showWeekend: true
    };
    this.class = true;
    this.childrenResolve = (item) => {
      const children = randomItems(random(1, 5), item);
      return of(children).pipe(delay(1e3));
    };
  }
  ngOnInit() {
  }
  barClick(event) {
    this.thyNotify.info("Event: barClick", `\u4F60\u70B9\u51FB\u4E86 [${event.item.title}]`);
  }
  lineClick(event) {
    this.thyNotify.info("Event: lineClick", `\u4F60\u70B9\u51FB\u4E86 ${event.source.title} \u5230 ${event.target.title} \u7684\u5173\u8054\u7EBF`);
  }
  dragMoved(event) {
  }
  dragEnded(event) {
    this.thyNotify.info("Event: dragEnded", `\u4FEE\u6539\u4E86 [${event.item.title}] \u7684\u65F6\u95F4`);
    this.items = [...this.items];
  }
  selectedChange(event) {
    this.thyNotify.info("Event: selectedChange", `\u5F53\u524D\u9009\u4E2D\u7684 item \u7684 id \u4E3A ${event.selectedValue.map((item) => item.id).join("\u3001")}`);
  }
  linkDragEnded(event) {
    this.items = [...this.items];
    this.thyNotify.info("Event: linkDragEnded", `\u521B\u5EFA\u4E86\u5173\u8054\u5173\u7CFB`);
  }
  weekendChange() {
    console.log(this.showWeekend);
    this.viewOptions = { showWeekend: this.showWeekend };
  }
  static {
    this.\u0275fac = function AppGanttCustomViewExampleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttCustomViewExampleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttCustomViewExampleComponent, selectors: [["app-gantt-custom-view-example"]], viewQuery: function AppGanttCustomViewExampleComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c032, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ganttComponent = _t.first);
      }
    }, hostVars: 2, hostBindings: function AppGanttCustomViewExampleComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-example-component", ctx.class);
      }
    }, decls: 15, vars: 9, consts: [["headerContent", ""], ["headerOperation", ""], ["gantt", ""], ["cell", ""], ["bar", ""], [3, "barClick", "lineClick", "dragMoved", "dragEnded", "selectedChange", "linkDragEnded", "items", "viewType", "async", "childrenResolve", "draggable", "linkable", "selectable", "multiple", "viewOptions"], ["name", "Title", "width", "300px"], [3, "ngModelChange", "ngModel"], ["href", "https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-custom-view", "target", "_blank"], [2, "color", "#fff"]], template: function AppGanttCustomViewExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "thy-layout")(1, "thy-header");
        \u0275\u0275template(2, AppGanttCustomViewExampleComponent_ng_template_2_Template, 3, 1, "ng-template", null, 0, \u0275\u0275templateRefExtractor)(4, AppGanttCustomViewExampleComponent_ng_template_4_Template, 2, 0, "ng-template", null, 1, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(6, "thy-content")(7, "ngx-gantt", 5, 2);
        \u0275\u0275listener("barClick", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_barClick_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.barClick($event));
        })("lineClick", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_lineClick_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.lineClick($event));
        })("dragMoved", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_dragMoved_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.dragMoved($event));
        })("dragEnded", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_dragEnded_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.dragEnded($event));
        })("selectedChange", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_selectedChange_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.selectedChange($event));
        })("linkDragEnded", function AppGanttCustomViewExampleComponent_Template_ngx_gantt_linkDragEnded_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.linkDragEnded($event));
        });
        \u0275\u0275elementStart(9, "ngx-gantt-table")(10, "ngx-gantt-column", 6);
        \u0275\u0275template(11, AppGanttCustomViewExampleComponent_ng_template_11_Template, 1, 1, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()();
        \u0275\u0275template(13, AppGanttCustomViewExampleComponent_ng_template_13_Template, 2, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275advance(7);
        \u0275\u0275property("items", ctx.items)("viewType", ctx.viewType)("async", true)("childrenResolve", ctx.childrenResolve)("draggable", true)("linkable", true)("selectable", true)("multiple", true)("viewOptions", ctx.viewOptions);
      }
    }, dependencies: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThySwitch,
      FormsModule,
      NgControlStatus,
      NgModel,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent
    ], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttCustomViewExampleComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-custom-view-example", imports: [
      ThyLayout,
      ThyContent,
      ThyHeader,
      ThySwitch,
      FormsModule,
      NgxGanttComponent,
      NgxGanttTableComponent,
      NgxGanttTableColumnComponent
    ], template: '<thy-layout>\n  <thy-header>\n    <ng-template #headerContent>\n      <span>\u663E\u793A\u5468\u672B\uFF1A</span>\n      <thy-switch [(ngModel)]="showWeekend" (ngModelChange)="weekendChange()"> </thy-switch>\n    </ng-template>\n    <ng-template #headerOperation>\n      <a href="https://github.com/worktile/ngx-gantt/blob/master/example/src/app/gantt-custom-view" target="_blank">\u67E5\u770B\u6E90\u7801</a>\n    </ng-template>\n  </thy-header>\n  <thy-content>\n    <ngx-gantt\n      #gantt\n      [items]="items"\n      [viewType]="viewType"\n      [async]="true"\n      [childrenResolve]="childrenResolve"\n      [draggable]="true"\n      [linkable]="true"\n      [selectable]="true"\n      [multiple]="true"\n      [viewOptions]="viewOptions"\n      (barClick)="barClick($event)"\n      (lineClick)="lineClick($event)"\n      (dragMoved)="dragMoved($event)"\n      (dragEnded)="dragEnded($event)"\n      (selectedChange)="selectedChange($event)"\n      (linkDragEnded)="linkDragEnded($event)"\n    >\n      <ngx-gantt-table>\n        <ngx-gantt-column name="Title" width="300px">\n          <ng-template #cell let-item="item"> {{ item.title }} </ng-template>\n        </ngx-gantt-column>\n      </ngx-gantt-table>\n\n      <ng-template #bar let-item="item">\n        <span style="color: #fff">&nbsp;&nbsp;{{ item.title }} </span>\n      </ng-template>\n    </ngx-gantt>\n  </thy-content>\n</thy-layout>\n' }]
  }], () => [], { class: [{
    type: HostBinding,
    args: ["class.gantt-example-component"]
  }], ganttComponent: [{
    type: ViewChild,
    args: ["gantt"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttCustomViewExampleComponent, { className: "AppGanttCustomViewExampleComponent", filePath: "example/src/app/gantt-custom-view/gantt.component.ts", lineNumber: 41 });
})();

// example/src/app/gantt-virtual-scroll/gantt.component.ts
var _c033 = ["gantt"];
function AppGanttVirtualScrollExampleComponent_ng_template_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 12);
    \u0275\u0275text(1, "NgxGantt");
    \u0275\u0275elementEnd();
    \u0275\u0275text(2, " \xA0\xA0\u9ED8\u8BA4\u5F00\u542F\u4E86\u865A\u62DF\u6EDA\u52A8\u529F\u80FD\uFF0C\u5982\u9700\u5173\u95ED\u8BE5\u529F\u80FD\u8BBE\u7F6E virtualScrollEnabled \u53C2\u6570\u4E3A false \u5373\u53EF\u3002 ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_9_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
  }
  if (rf & 2) {
    const item_r2 = ctx.item;
    \u0275\u0275textInterpolate1(" ", item_r2.title, " ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_12_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "date");
  }
  if (rf & 2) {
    const item_r3 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r3.start * 1e3, "yyyy-MM-dd"), " ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_15_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275text(0);
    \u0275\u0275pipe(1, "date");
  }
  if (rf & 2) {
    const item_r4 = ctx.item;
    \u0275\u0275textInterpolate1(" ", \u0275\u0275pipeBind2(1, 1, item_r4.end * 1e3, "yyyy-MM-dd"), " ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_17_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 15);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const column_r5 = ctx.$implicit;
    \u0275\u0275styleProp("width", column_r5.columnWidth());
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1(" ", column_r5.name(), " ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_17_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 13);
    \u0275\u0275repeaterCreate(1, AppGanttVirtualScrollExampleComponent_ng_template_17_For_2_Template, 2, 3, "div", 14, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const columns_r6 = ctx.columns;
    \u0275\u0275advance();
    \u0275\u0275repeater(columns_r6);
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_19_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "span", 16);
    \u0275\u0275text(1);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const item_r7 = ctx.item;
    \u0275\u0275advance();
    \u0275\u0275textInterpolate1("\xA0\xA0", item_r7.title, " ");
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Conditional_1_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275element(0, "div", 20);
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Conditional_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 21);
    \u0275\u0275text(1, "0");
    \u0275\u0275elementEnd();
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 19);
    \u0275\u0275conditionalCreate(1, AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Conditional_1_Template, 1, 0, "div", 20)(2, AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Conditional_2_Template, 2, 0, "div", 21);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    const day_r8 = ctx.$implicit;
    \u0275\u0275nextContext(2);
    const gantt_r9 = \u0275\u0275reference(6);
    \u0275\u0275styleProp("left", day_r8.x - (gantt_r9 == null ? null : gantt_r9.view.options.unitWidth) / 2, "px")("width", gantt_r9 == null ? null : gantt_r9.view.options.unitWidth, "px");
    \u0275\u0275advance();
    \u0275\u0275conditional(false ? 1 : 2);
  }
}
function AppGanttVirtualScrollExampleComponent_ng_template_21_Template(rf, ctx) {
  if (rf & 1) {
    \u0275\u0275elementStart(0, "div", 17);
    \u0275\u0275repeaterCreate(1, AppGanttVirtualScrollExampleComponent_ng_template_21_For_2_Template, 3, 5, "div", 18, \u0275\u0275repeaterTrackByIndex);
    \u0275\u0275elementEnd();
  }
  if (rf & 2) {
    \u0275\u0275nextContext();
    const gantt_r9 = \u0275\u0275reference(6);
    \u0275\u0275styleProp("width", gantt_r9 == null ? null : gantt_r9.view.width, "px");
    \u0275\u0275advance();
    \u0275\u0275repeater(gantt_r9 == null ? null : gantt_r9.view.unitTicks);
  }
}
var AppGanttVirtualScrollExampleComponent = class _AppGanttVirtualScrollExampleComponent {
  constructor() {
    this.cdr = inject(ChangeDetectorRef);
    this.items = [];
    this.class = true;
    this.loading = false;
    this.dropEnterPredicate = (event) => {
      return true;
    };
  }
  ngOnInit() {
    this.items.forEach((item, index2) => {
      if (index2 % 5 === 0) {
        item.children = randomItems(random(1, 5), item);
      }
    });
  }
  ngAfterViewInit() {
    setTimeout(() => this.ganttComponent.scrollToDate(1627729997), 200);
  }
  virtualScrolledIndexChange(event) {
    if (event.renderedRange.end + 20 >= event.count) {
      if (!this.loading) {
        const items = randomItems(100);
        this.loading = true;
        of(items).pipe(delay(1e3)).subscribe(() => {
          this.loading = false;
          this.items = [...this.items, ...items];
          this.cdr.detectChanges();
        });
      }
    }
  }
  onDragDropped(event) {
    console.log("\u62D6\u62FD\u6210\u529F\u4E86", event);
    const sourceItems = event.sourceParent?.children || this.items;
    sourceItems.splice(sourceItems.indexOf(event.source), 1);
    if (event.dropPosition === "inside") {
      event.target.children = [...event.target.children || [], event.source];
    } else {
      const targetItems = event.targetParent?.children || this.items;
      if (event.dropPosition === "before") {
        targetItems.splice(targetItems.indexOf(event.target), 0, event.source);
      } else {
        targetItems.splice(targetItems.indexOf(event.target) + 1, 0, event.source);
      }
    }
    this.items = [...this.items];
  }
  onDragStarted(event) {
    console.log("\u62D6\u62FD\u5F00\u59CB\u4E86", event);
  }
  onDragEnded(event) {
    console.log("\u62D6\u62FD\u7ED3\u675F\u4E86", event);
  }
  static {
    this.\u0275fac = function AppGanttVirtualScrollExampleComponent_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppGanttVirtualScrollExampleComponent)();
    };
  }
  static {
    this.\u0275cmp = /* @__PURE__ */ \u0275\u0275defineComponent({ type: _AppGanttVirtualScrollExampleComponent, selectors: [["app-gantt-virtual-scroll-example"]], viewQuery: function AppGanttVirtualScrollExampleComponent_Query(rf, ctx) {
      if (rf & 1) {
        \u0275\u0275viewQuery(_c033, 5);
      }
      if (rf & 2) {
        let _t;
        \u0275\u0275queryRefresh(_t = \u0275\u0275loadQuery()) && (ctx.ganttComponent = _t.first);
      }
    }, hostVars: 2, hostBindings: function AppGanttVirtualScrollExampleComponent_HostBindings(rf, ctx) {
      if (rf & 2) {
        \u0275\u0275classProp("gantt-example-component", ctx.class);
      }
    }, features: [\u0275\u0275ProvidersFeature([GanttPrintService])], decls: 23, vars: 9, consts: [["headerContent", ""], ["gantt", ""], ["cell", ""], ["tableFooter", ""], ["bar", ""], ["footer", ""], [1, "header-with-baseline"], [3, "virtualScrolledIndexChange", "items", "virtualScrollEnabled", "loading", "quickTimeFocus"], [3, "dragDropped", "dragStarted", "dragEnded", "draggable", "dropEnterPredicate"], ["name", "Title", "width", "180px"], ["name", "Start Time", 3, "width"], ["name", "End Time"], [1, "text-primary"], [1, "table-footer"], [1, "gantt-table-column", 3, "width"], [1, "gantt-table-column"], [2, "color", "#fff"], [1, "footer-container"], [1, "footer-item", 3, "left", "width"], [1, "footer-item"], [1, "stat", "stat-fill"], [1, "stat", "stat-empty"]], template: function AppGanttVirtualScrollExampleComponent_Template(rf, ctx) {
      if (rf & 1) {
        const _r1 = \u0275\u0275getCurrentView();
        \u0275\u0275elementStart(0, "thy-layout")(1, "thy-header", 6);
        \u0275\u0275template(2, AppGanttVirtualScrollExampleComponent_ng_template_2_Template, 3, 0, "ng-template", null, 0, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(4, "thy-content")(5, "ngx-gantt", 7, 1);
        \u0275\u0275listener("virtualScrolledIndexChange", function AppGanttVirtualScrollExampleComponent_Template_ngx_gantt_virtualScrolledIndexChange_5_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.virtualScrolledIndexChange($event));
        });
        \u0275\u0275elementStart(7, "ngx-gantt-table", 8);
        \u0275\u0275listener("dragDropped", function AppGanttVirtualScrollExampleComponent_Template_ngx_gantt_table_dragDropped_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragDropped($event));
        })("dragStarted", function AppGanttVirtualScrollExampleComponent_Template_ngx_gantt_table_dragStarted_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragStarted($event));
        })("dragEnded", function AppGanttVirtualScrollExampleComponent_Template_ngx_gantt_table_dragEnded_7_listener($event) {
          \u0275\u0275restoreView(_r1);
          return \u0275\u0275resetView(ctx.onDragEnded($event));
        });
        \u0275\u0275elementStart(8, "ngx-gantt-column", 9);
        \u0275\u0275template(9, AppGanttVirtualScrollExampleComponent_ng_template_9_Template, 1, 1, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(11, "ngx-gantt-column", 10);
        \u0275\u0275template(12, AppGanttVirtualScrollExampleComponent_ng_template_12_Template, 2, 4, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275elementStart(14, "ngx-gantt-column", 11);
        \u0275\u0275template(15, AppGanttVirtualScrollExampleComponent_ng_template_15_Template, 2, 4, "ng-template", null, 2, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275template(17, AppGanttVirtualScrollExampleComponent_ng_template_17_Template, 3, 0, "ng-template", null, 3, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd();
        \u0275\u0275template(19, AppGanttVirtualScrollExampleComponent_ng_template_19_Template, 2, 1, "ng-template", null, 4, \u0275\u0275templateRefExtractor)(21, AppGanttVirtualScrollExampleComponent_ng_template_21_Template, 3, 2, "ng-template", null, 5, \u0275\u0275templateRefExtractor);
        \u0275\u0275elementEnd()()();
      }
      if (rf & 2) {
        \u0275\u0275advance(5);
        \u0275\u0275property("items", ctx.items)("virtualScrollEnabled", true)("loading", ctx.loading)("quickTimeFocus", true);
        \u0275\u0275advance(2);
        \u0275\u0275property("draggable", true)("dropEnterPredicate", ctx.dropEnterPredicate);
        \u0275\u0275advance(4);
        \u0275\u0275classProp("start-time", true);
        \u0275\u0275property("width", 140);
      }
    }, dependencies: [ThyLayout, ThyContent, ThyHeader, NgxGanttComponent, NgxGanttTableComponent, NgxGanttTableColumnComponent, DatePipe], encapsulation: 2 });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppGanttVirtualScrollExampleComponent, [{
    type: Component,
    args: [{ selector: "app-gantt-virtual-scroll-example", providers: [GanttPrintService], imports: [ThyLayout, ThyContent, ThyHeader, NgxGanttComponent, NgxGanttTableComponent, NgxGanttTableColumnComponent, DatePipe], template: `<thy-layout>
  <thy-header class="header-with-baseline">
    <ng-template #headerContent>
      <span class="text-primary">NgxGantt</span>
      &nbsp;&nbsp;\u9ED8\u8BA4\u5F00\u542F\u4E86\u865A\u62DF\u6EDA\u52A8\u529F\u80FD\uFF0C\u5982\u9700\u5173\u95ED\u8BE5\u529F\u80FD\u8BBE\u7F6E virtualScrollEnabled \u53C2\u6570\u4E3A false \u5373\u53EF\u3002
    </ng-template>
  </thy-header>
  <thy-content>
    <ngx-gantt
      #gantt
      [items]="items"
      [virtualScrollEnabled]="true"
      (virtualScrolledIndexChange)="virtualScrolledIndexChange($event)"
      [loading]="loading"
      [quickTimeFocus]="true"
    >
      <ngx-gantt-table
        [draggable]="true"
        [dropEnterPredicate]="dropEnterPredicate"
        (dragDropped)="onDragDropped($event)"
        (dragStarted)="onDragStarted($event)"
        (dragEnded)="onDragEnded($event)"
      >
        <ngx-gantt-column name="Title" width="180px">
          <ng-template #cell let-item="item"> {{ item.title }} </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="Start Time" [class.start-time]="true" [width]="140">
          <ng-template #cell let-item="item">
            {{ item.start * 1000 | date: 'yyyy-MM-dd' }}
          </ng-template>
        </ngx-gantt-column>
        <ngx-gantt-column name="End Time">
          <ng-template #cell let-item="item">
            {{ item.end * 1000 | date: 'yyyy-MM-dd' }}
          </ng-template>
        </ngx-gantt-column>

        <ng-template #tableFooter let-columns="columns">
          <div class="table-footer">
            @for (column of columns; track $index) {
              <div class="gantt-table-column" [style.width]="column.columnWidth()">
                {{ column.name() }}
              </div>
            }
          </div>
        </ng-template>
      </ngx-gantt-table>

      <ng-template #bar let-item="item">
        <span style="color: #fff">&nbsp;&nbsp;{{ item.title }} </span>
      </ng-template>

      <ng-template #footer>
        <div class="footer-container" [style.width.px]="gantt?.view.width">
          @for (day of gantt?.view.unitTicks; track $index) {
            <div
              class="footer-item"
              [style.left.px]="day.x - gantt?.view.options.unitWidth / 2"
              [style.width.px]="gantt?.view.options.unitWidth"
            >
              @if (false) {
                <div class="stat stat-fill"></div>
              } @else {
                <div class="stat stat-empty">0</div>
              }
            </div>
          }
        </div>
      </ng-template>
    </ngx-gantt>
  </thy-content>
</thy-layout>
` }]
  }], () => [], { class: [{
    type: HostBinding,
    args: ["class.gantt-example-component"]
  }], ganttComponent: [{
    type: ViewChild,
    args: ["gantt"]
  }] });
})();
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && \u0275setClassDebugInfo(AppGanttVirtualScrollExampleComponent, { className: "AppGanttVirtualScrollExampleComponent", filePath: "example/src/app/gantt-virtual-scroll/gantt.component.ts", lineNumber: 25 });
})();

// example/src/app/app-routing.module.ts
var routes2 = [
  {
    path: "components",
    component: AppExampleComponentsComponent,
    children: [
      { path: "", redirectTo: "basic", pathMatch: "full" },
      { path: "basic", component: AppGanttExampleComponent },
      { path: "groups", component: AppGanttGroupsExampleComponent },
      { path: "virtual-scroll", component: AppGanttVirtualScrollExampleComponent },
      { path: "custom-view", component: AppGanttCustomViewExampleComponent },
      { path: "advanced", component: AppGanttAdvancedExampleComponent }
    ]
  }
];
var AppRoutingModule = class _AppRoutingModule {
  static {
    this.\u0275fac = function AppRoutingModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppRoutingModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AppRoutingModule });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [RouterModule.forRoot(routes2, {
      useHash: false,
      enableTracing: false,
      onSameUrlNavigation: "reload"
    }), RouterModule] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppRoutingModule, [{
    type: NgModule,
    args: [{
      imports: [
        RouterModule.forRoot(routes2, {
          useHash: false,
          enableTracing: false,
          onSameUrlNavigation: "reload"
        })
      ],
      exports: [RouterModule]
    }]
  }], null, null);
})();

// example/src/app/content/config.ts
var config = {
  "title": "NgxGantt",
  "description": "",
  "mode": "full",
  "theme": "default",
  "baseHref": "/ngx-gantt/v21/",
  "locales": [
    {
      "key": "zh-cn",
      "name": "\u4E2D\u6587"
    },
    {
      "key": "en-us",
      "name": "English"
    }
  ],
  "defaultLocale": "zh-cn",
  "switchTheme": false,
  "logoUrl": "assets/imgs/logo.png",
  "repoUrl": "https://github.com/worktile/ngx-gantt"
};

// example/src/app/content/component-examples.ts
var EXAMPLE_COMPONENTS = {};

// example/src/app/content/example-loader.ts
var LibExampleLoader = class _LibExampleLoader extends ExampleLoader {
  constructor() {
    super(...arguments);
    this.enableIvy = true;
  }
  load(exampleKey) {
    const example = EXAMPLE_COMPONENTS[exampleKey];
    return new Promise((resolve) => {
      this[example.module.importSpecifier]().then((result) => {
        resolve({
          moduleType: result.EXAMPLES_MODULE,
          componentType: result.EXAMPLE_COMPONENTS[exampleKey],
          example
        });
      });
    });
  }
  static {
    this.\u0275fac = /* @__PURE__ */ (() => {
      let \u0275LibExampleLoader_BaseFactory;
      return function LibExampleLoader_Factory(__ngFactoryType__) {
        return (\u0275LibExampleLoader_BaseFactory || (\u0275LibExampleLoader_BaseFactory = \u0275\u0275getInheritedFactory(_LibExampleLoader)))(__ngFactoryType__ || _LibExampleLoader);
      };
    })();
  }
  static {
    this.\u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({ token: _LibExampleLoader, factory: _LibExampleLoader.\u0275fac });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(LibExampleLoader, [{
    type: Injectable
  }], null, null);
})();
var LIB_EXAMPLE_LOADER_PROVIDER = {
  provide: ExampleLoader,
  useClass: LibExampleLoader
};

// example/src/app/content/components/custom/index.ts
var CustomComponentsModule = class _CustomComponentsModule {
  constructor() {
    addBuiltInComponents([]);
  }
  static {
    this.\u0275fac = function CustomComponentsModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _CustomComponentsModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _CustomComponentsModule });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ imports: [CommonModule] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(CustomComponentsModule, [{
    type: NgModule,
    args: [{
      declarations: [],
      providers: [],
      imports: [CommonModule],
      exports: []
    }]
  }], () => [], null);
})();

// example/src/app/content/index.ts
var DOCGENI_SITE_PROVIDERS = [
  ...DOCGENI_INITIALIZER_PROVIDERS,
  LIB_EXAMPLE_LOADER_PROVIDER,
  {
    provide: CONFIG_TOKEN,
    useValue: config
  }
];

// node_modules/@angular/animations/fesm2022/_util-chunk.mjs
var LINE_START = "\n - ";
function invalidTimingValue(exp) {
  return new RuntimeError(3e3, ngDevMode && `The provided timing value "${exp}" is invalid.`);
}
function negativeStepValue() {
  return new RuntimeError(3100, ngDevMode && "Duration values below 0 are not allowed for this animation step.");
}
function negativeDelayValue() {
  return new RuntimeError(3101, ngDevMode && "Delay values below 0 are not allowed for this animation step.");
}
function invalidStyleParams(varName) {
  return new RuntimeError(3001, ngDevMode && `Unable to resolve the local animation param ${varName} in the given list of values`);
}
function invalidParamValue(varName) {
  return new RuntimeError(3003, ngDevMode && `Please provide a value for the animation param ${varName}`);
}
function invalidNodeType(nodeType) {
  return new RuntimeError(3004, ngDevMode && `Unable to resolve animation metadata node #${nodeType}`);
}
function invalidCssUnitValue(userProvidedProperty, value) {
  return new RuntimeError(3005, ngDevMode && `Please provide a CSS unit value for ${userProvidedProperty}:${value}`);
}
function invalidTrigger() {
  return new RuntimeError(3006, ngDevMode && "animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))");
}
function invalidDefinition() {
  return new RuntimeError(3007, ngDevMode && "only state() and transition() definitions can sit inside of a trigger()");
}
function invalidState(metadataName, missingSubs) {
  return new RuntimeError(3008, ngDevMode && `state("${metadataName}", ...) must define default values for all the following style substitutions: ${missingSubs.join(", ")}`);
}
function invalidStyleValue(value) {
  return new RuntimeError(3002, ngDevMode && `The provided style string value ${value} is not allowed.`);
}
function invalidParallelAnimation(prop, firstStart, firstEnd, secondStart, secondEnd) {
  return new RuntimeError(3010, ngDevMode && `The CSS property "${prop}" that exists between the times of "${firstStart}ms" and "${firstEnd}ms" is also being animated in a parallel animation between the times of "${secondStart}ms" and "${secondEnd}ms"`);
}
function invalidKeyframes() {
  return new RuntimeError(3011, ngDevMode && `keyframes() must be placed inside of a call to animate()`);
}
function invalidOffset() {
  return new RuntimeError(3012, ngDevMode && `Please ensure that all keyframe offsets are between 0 and 1`);
}
function keyframeOffsetsOutOfOrder() {
  return new RuntimeError(3200, ngDevMode && `Please ensure that all keyframe offsets are in order`);
}
function keyframesMissingOffsets() {
  return new RuntimeError(3202, ngDevMode && `Not all style() steps within the declared keyframes() contain offsets`);
}
function invalidStagger() {
  return new RuntimeError(3013, ngDevMode && `stagger() can only be used inside of query()`);
}
function invalidQuery(selector) {
  return new RuntimeError(3014, ngDevMode && `\`query("${selector}")\` returned zero elements. (Use \`query("${selector}", { optional: true })\` if you wish to allow this.)`);
}
function invalidExpression(expr) {
  return new RuntimeError(3015, ngDevMode && `The provided transition expression "${expr}" is not supported`);
}
function invalidTransitionAlias(alias) {
  return new RuntimeError(3016, ngDevMode && `The transition alias value "${alias}" is not supported`);
}
function triggerBuildFailed(name, errors) {
  return new RuntimeError(3404, ngDevMode && `The animation trigger "${name}" has failed to build due to the following errors:
 - ${errors.map((err) => err.message).join("\n - ")}`);
}
function animationFailed(errors) {
  return new RuntimeError(3502, ngDevMode && `Unable to animate due to the following errors:${LINE_START}${errors.map((err) => err.message).join(LINE_START)}`);
}
function registerFailed(errors) {
  return new RuntimeError(3503, ngDevMode && `Unable to build the animation due to the following errors: ${errors.map((err) => err.message).join("\n")}`);
}
function missingOrDestroyedAnimation() {
  return new RuntimeError(3300, ngDevMode && "The requested animation doesn't exist or has already been destroyed");
}
function createAnimationFailed(errors) {
  return new RuntimeError(3504, ngDevMode && `Unable to create the animation due to the following errors:${errors.map((err) => err.message).join("\n")}`);
}
function missingPlayer(id) {
  return new RuntimeError(3301, ngDevMode && `Unable to find the timeline player referenced by ${id}`);
}
function missingTrigger(phase, name) {
  return new RuntimeError(3302, ngDevMode && `Unable to listen on the animation trigger event "${phase}" because the animation trigger "${name}" doesn't exist!`);
}
function missingEvent(name) {
  return new RuntimeError(3303, ngDevMode && `Unable to listen on the animation trigger "${name}" because the provided event is undefined!`);
}
function unsupportedTriggerEvent(phase, name) {
  return new RuntimeError(3400, ngDevMode && `The provided animation trigger event "${phase}" for the animation trigger "${name}" is not supported!`);
}
function unregisteredTrigger(name) {
  return new RuntimeError(3401, ngDevMode && `The provided animation trigger "${name}" has not been registered!`);
}
function triggerTransitionsFailed(errors) {
  return new RuntimeError(3402, ngDevMode && `Unable to process animations due to the following failed trigger transitions
 ${errors.map((err) => err.message).join("\n")}`);
}
function transitionFailed(name, errors) {
  return new RuntimeError(3505, ngDevMode && `@${name} has failed due to:
 ${errors.map((err) => err.message).join("\n- ")}`);
}
var ANIMATABLE_PROP_SET = /* @__PURE__ */ new Set(["-moz-outline-radius", "-moz-outline-radius-bottomleft", "-moz-outline-radius-bottomright", "-moz-outline-radius-topleft", "-moz-outline-radius-topright", "-ms-grid-columns", "-ms-grid-rows", "-webkit-line-clamp", "-webkit-text-fill-color", "-webkit-text-stroke", "-webkit-text-stroke-color", "accent-color", "all", "backdrop-filter", "background", "background-color", "background-position", "background-size", "block-size", "border", "border-block-end", "border-block-end-color", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-width", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image-outset", "border-image-slice", "border-image-width", "border-inline-end", "border-inline-end-color", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-width", "border-left", "border-left-color", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-width", "border-start-end-radius", "border-start-start-radius", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-width", "border-width", "bottom", "box-shadow", "caret-color", "clip", "clip-path", "color", "column-count", "column-gap", "column-rule", "column-rule-color", "column-rule-width", "column-width", "columns", "filter", "flex", "flex-basis", "flex-grow", "flex-shrink", "font", "font-size", "font-size-adjust", "font-stretch", "font-variation-settings", "font-weight", "gap", "grid-column-gap", "grid-gap", "grid-row-gap", "grid-template-columns", "grid-template-rows", "height", "inline-size", "input-security", "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "left", "letter-spacing", "line-clamp", "line-height", "margin", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "mask", "mask-border", "mask-position", "mask-size", "max-block-size", "max-height", "max-inline-size", "max-lines", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "outline", "outline-color", "outline-offset", "outline-width", "padding", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "perspective", "perspective-origin", "right", "rotate", "row-gap", "scale", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-coordinate", "scroll-snap-destination", "scrollbar-color", "shape-image-threshold", "shape-margin", "shape-outside", "tab-size", "text-decoration", "text-decoration-color", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-indent", "text-shadow", "text-underline-offset", "top", "transform", "transform-origin", "translate", "vertical-align", "visibility", "width", "word-spacing", "z-index", "zoom"]);
function optimizeGroupPlayer(players) {
  switch (players.length) {
    case 0:
      return new NoopAnimationPlayer();
    case 1:
      return players[0];
    default:
      return new AnimationGroupPlayer(players);
  }
}
function normalizeKeyframes$1(normalizer, keyframes2, preStyles = /* @__PURE__ */ new Map(), postStyles = /* @__PURE__ */ new Map()) {
  const errors = [];
  const normalizedKeyframes = [];
  let previousOffset = -1;
  let previousKeyframe = null;
  keyframes2.forEach((kf) => {
    const offset = kf.get("offset");
    const isSameOffset = offset == previousOffset;
    const normalizedKeyframe = isSameOffset && previousKeyframe || /* @__PURE__ */ new Map();
    kf.forEach((val, prop) => {
      let normalizedProp = prop;
      let normalizedValue = val;
      if (prop !== "offset") {
        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);
        switch (normalizedValue) {
          case \u0275PRE_STYLE:
            normalizedValue = preStyles.get(prop);
            break;
          case AUTO_STYLE:
            normalizedValue = postStyles.get(prop);
            break;
          default:
            normalizedValue = normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);
            break;
        }
      }
      normalizedKeyframe.set(normalizedProp, normalizedValue);
    });
    if (!isSameOffset) {
      normalizedKeyframes.push(normalizedKeyframe);
    }
    previousKeyframe = normalizedKeyframe;
    previousOffset = offset;
  });
  if (errors.length) {
    throw animationFailed(errors);
  }
  return normalizedKeyframes;
}
function listenOnPlayer(player, eventName, event, callback) {
  switch (eventName) {
    case "start":
      player.onStart(() => callback(event && copyAnimationEvent(event, "start", player)));
      break;
    case "done":
      player.onDone(() => callback(event && copyAnimationEvent(event, "done", player)));
      break;
    case "destroy":
      player.onDestroy(() => callback(event && copyAnimationEvent(event, "destroy", player)));
      break;
  }
}
function copyAnimationEvent(e, phaseName, player) {
  const totalTime = player.totalTime;
  const disabled = player.disabled ? true : false;
  const event = makeAnimationEvent(e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName, totalTime == void 0 ? e.totalTime : totalTime, disabled);
  const data = e["_data"];
  if (data != null) {
    event["_data"] = data;
  }
  return event;
}
function makeAnimationEvent(element, triggerName, fromState, toState, phaseName = "", totalTime = 0, disabled) {
  return {
    element,
    triggerName,
    fromState,
    toState,
    phaseName,
    totalTime,
    disabled: !!disabled
  };
}
function getOrSetDefaultValue(map2, key, defaultValue) {
  let value = map2.get(key);
  if (!value) {
    map2.set(key, value = defaultValue);
  }
  return value;
}
function parseTimelineCommand(command) {
  const separatorPos = command.indexOf(":");
  const id = command.substring(1, separatorPos);
  const action = command.slice(separatorPos + 1);
  return [id, action];
}
var documentElement = /* @__PURE__ */ (() => typeof document === "undefined" ? null : document.documentElement)();
function getParentElement(element) {
  const parent = element.parentNode || element.host || null;
  if (parent === documentElement) {
    return null;
  }
  return parent;
}
function containsVendorPrefix(prop) {
  return prop.substring(1, 6) == "ebkit";
}
var _CACHED_BODY = null;
var _IS_WEBKIT = false;
function validateStyleProperty(prop) {
  if (!_CACHED_BODY) {
    _CACHED_BODY = getBodyNode() || {};
    _IS_WEBKIT = _CACHED_BODY.style ? "WebkitAppearance" in _CACHED_BODY.style : false;
  }
  let result = true;
  if (_CACHED_BODY.style && !containsVendorPrefix(prop)) {
    result = prop in _CACHED_BODY.style;
    if (!result && _IS_WEBKIT) {
      const camelProp = "Webkit" + prop.charAt(0).toUpperCase() + prop.slice(1);
      result = camelProp in _CACHED_BODY.style;
    }
  }
  return result;
}
function validateWebAnimatableStyleProperty(prop) {
  return ANIMATABLE_PROP_SET.has(prop);
}
function getBodyNode() {
  if (typeof document != "undefined") {
    return document.body;
  }
  return null;
}
function containsElement(elm1, elm2) {
  while (elm2) {
    if (elm2 === elm1) {
      return true;
    }
    elm2 = getParentElement(elm2);
  }
  return false;
}
function invokeQuery(element, selector, multi) {
  if (multi) {
    return Array.from(element.querySelectorAll(selector));
  }
  const elem = element.querySelector(selector);
  return elem ? [elem] : [];
}
var ONE_SECOND = 1e3;
var SUBSTITUTION_EXPR_START = "{{";
var SUBSTITUTION_EXPR_END = "}}";
var ENTER_CLASSNAME = "ng-enter";
var LEAVE_CLASSNAME = "ng-leave";
var NG_TRIGGER_CLASSNAME = "ng-trigger";
var NG_TRIGGER_SELECTOR = ".ng-trigger";
var NG_ANIMATING_CLASSNAME = "ng-animating";
var NG_ANIMATING_SELECTOR = ".ng-animating";
function resolveTimingValue(value) {
  if (typeof value == "number") return value;
  const matches = value.match(/^(-?[\.\d]+)(m?s)/);
  if (!matches || matches.length < 2) return 0;
  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
}
function _convertTimeValueToMS(value, unit) {
  switch (unit) {
    case "s":
      return value * ONE_SECOND;
    default:
      return value;
  }
}
function resolveTiming(timings, errors, allowNegativeValues) {
  return timings.hasOwnProperty("duration") ? timings : parseTimeExpression(timings, errors, allowNegativeValues);
}
var PARSE_TIME_EXPRESSION_REGEX = /^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i;
function parseTimeExpression(exp, errors, allowNegativeValues) {
  let duration;
  let delay2 = 0;
  let easing = "";
  if (typeof exp === "string") {
    const matches = exp.match(PARSE_TIME_EXPRESSION_REGEX);
    if (matches === null) {
      errors.push(invalidTimingValue(exp));
      return {
        duration: 0,
        delay: 0,
        easing: ""
      };
    }
    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);
    const delayMatch = matches[3];
    if (delayMatch != null) {
      delay2 = _convertTimeValueToMS(parseFloat(delayMatch), matches[4]);
    }
    const easingVal = matches[5];
    if (easingVal) {
      easing = easingVal;
    }
  } else {
    duration = exp;
  }
  if (!allowNegativeValues) {
    let containsErrors = false;
    let startIndex = errors.length;
    if (duration < 0) {
      errors.push(negativeStepValue());
      containsErrors = true;
    }
    if (delay2 < 0) {
      errors.push(negativeDelayValue());
      containsErrors = true;
    }
    if (containsErrors) {
      errors.splice(startIndex, 0, invalidTimingValue(exp));
    }
  }
  return {
    duration,
    delay: delay2,
    easing
  };
}
function normalizeKeyframes(keyframes2) {
  if (!keyframes2.length) {
    return [];
  }
  if (keyframes2[0] instanceof Map) {
    return keyframes2;
  }
  return keyframes2.map((kf) => new Map(Object.entries(kf)));
}
function setStyles(element, styles, formerStyles) {
  styles.forEach((val, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    if (formerStyles && !formerStyles.has(prop)) {
      formerStyles.set(prop, element.style[camelProp]);
    }
    element.style[camelProp] = val;
  });
}
function eraseStyles(element, styles) {
  styles.forEach((_, prop) => {
    const camelProp = dashCaseToCamelCase(prop);
    element.style[camelProp] = "";
  });
}
function normalizeAnimationEntry(steps) {
  if (Array.isArray(steps)) {
    if (steps.length == 1) return steps[0];
    return sequence(steps);
  }
  return steps;
}
function validateStyleParams(value, options, errors) {
  const params = options.params || {};
  const matches = extractStyleParams(value);
  if (matches.length) {
    matches.forEach((varName) => {
      if (!params.hasOwnProperty(varName)) {
        errors.push(invalidStyleParams(varName));
      }
    });
  }
}
var PARAM_REGEX = /* @__PURE__ */ new RegExp(`${SUBSTITUTION_EXPR_START}\\s*(.+?)\\s*${SUBSTITUTION_EXPR_END}`, "g");
function extractStyleParams(value) {
  let params = [];
  if (typeof value === "string") {
    let match5;
    while (match5 = PARAM_REGEX.exec(value)) {
      params.push(match5[1]);
    }
    PARAM_REGEX.lastIndex = 0;
  }
  return params;
}
function interpolateParams(value, params, errors) {
  const original = `${value}`;
  const str = original.replace(PARAM_REGEX, (_, varName) => {
    let localVal = params[varName];
    if (localVal == null) {
      errors.push(invalidParamValue(varName));
      localVal = "";
    }
    return localVal.toString();
  });
  return str == original ? value : str;
}
var DASH_CASE_REGEXP = /-+([a-z0-9])/g;
function dashCaseToCamelCase(input2) {
  return input2.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());
}
function camelCaseToDashCase(input2) {
  return input2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function allowPreviousPlayerStylesMerge(duration, delay2) {
  return duration === 0 || delay2 === 0;
}
function balancePreviousStylesIntoKeyframes(element, keyframes2, previousStyles) {
  if (previousStyles.size && keyframes2.length) {
    let startingKeyframe = keyframes2[0];
    let missingStyleProps = [];
    previousStyles.forEach((val, prop) => {
      if (!startingKeyframe.has(prop)) {
        missingStyleProps.push(prop);
      }
      startingKeyframe.set(prop, val);
    });
    if (missingStyleProps.length) {
      for (let i = 1; i < keyframes2.length; i++) {
        let kf = keyframes2[i];
        missingStyleProps.forEach((prop) => kf.set(prop, computeStyle(element, prop)));
      }
    }
  }
  return keyframes2;
}
function visitDslNode(visitor, node, context) {
  switch (node.type) {
    case AnimationMetadataType.Trigger:
      return visitor.visitTrigger(node, context);
    case AnimationMetadataType.State:
      return visitor.visitState(node, context);
    case AnimationMetadataType.Transition:
      return visitor.visitTransition(node, context);
    case AnimationMetadataType.Sequence:
      return visitor.visitSequence(node, context);
    case AnimationMetadataType.Group:
      return visitor.visitGroup(node, context);
    case AnimationMetadataType.Animate:
      return visitor.visitAnimate(node, context);
    case AnimationMetadataType.Keyframes:
      return visitor.visitKeyframes(node, context);
    case AnimationMetadataType.Style:
      return visitor.visitStyle(node, context);
    case AnimationMetadataType.Reference:
      return visitor.visitReference(node, context);
    case AnimationMetadataType.AnimateChild:
      return visitor.visitAnimateChild(node, context);
    case AnimationMetadataType.AnimateRef:
      return visitor.visitAnimateRef(node, context);
    case AnimationMetadataType.Query:
      return visitor.visitQuery(node, context);
    case AnimationMetadataType.Stagger:
      return visitor.visitStagger(node, context);
    default:
      throw invalidNodeType(node.type);
  }
}
function computeStyle(element, prop) {
  return window.getComputedStyle(element)[prop];
}

// node_modules/@angular/animations/fesm2022/browser.mjs
var NoopAnimationDriver = class _NoopAnimationDriver {
  validateStyleProperty(prop) {
    return validateStyleProperty(prop);
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  getParentElement(element) {
    return getParentElement(element);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return defaultValue || "";
  }
  animate(element, keyframes2, duration, delay2, easing, previousPlayers = [], scrubberAccessRequested) {
    return new NoopAnimationPlayer(duration, delay2);
  }
  static \u0275fac = function NoopAnimationDriver_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationDriver)();
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _NoopAnimationDriver,
    factory: _NoopAnimationDriver.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationDriver, [{
    type: Injectable
  }], null, null);
})();
var AnimationDriver = class {
  static NOOP = new NoopAnimationDriver();
};
var AnimationStyleNormalizer = class {
};
var DIMENSIONAL_PROP_SET = /* @__PURE__ */ new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]);
var WebAnimationsStyleNormalizer = class extends AnimationStyleNormalizer {
  normalizePropertyName(propertyName, errors) {
    return dashCaseToCamelCase(propertyName);
  }
  normalizeStyleValue(userProvidedProperty, normalizedProperty, value, errors) {
    let unit = "";
    const strVal = value.toString().trim();
    if (DIMENSIONAL_PROP_SET.has(normalizedProperty) && value !== 0 && value !== "0") {
      if (typeof value === "number") {
        unit = "px";
      } else {
        const valAndSuffixMatch = value.match(/^[+-]?[\d\.]+([a-z]*)$/);
        if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {
          errors.push(invalidCssUnitValue(userProvidedProperty, value));
        }
      }
    }
    return strVal + unit;
  }
};
function createListOfWarnings(warnings) {
  const LINE_START2 = "\n - ";
  return `${LINE_START2}${warnings.filter(Boolean).map((warning) => warning).join(LINE_START2)}`;
}
function warnTriggerBuild(name, warnings) {
  console.warn(`The animation trigger "${name}" has built with the following warnings:${createListOfWarnings(warnings)}`);
}
function warnRegister(warnings) {
  console.warn(`Animation built with the following warnings:${createListOfWarnings(warnings)}`);
}
function pushUnrecognizedPropertiesWarning(warnings, props) {
  if (props.length) {
    warnings.push(`The following provided properties are not recognized: ${props.join(", ")}`);
  }
}
var ANY_STATE = "*";
function parseTransitionExpr(transitionValue, errors) {
  const expressions = [];
  if (typeof transitionValue == "string") {
    transitionValue.split(/\s*,\s*/).forEach((str) => parseInnerTransitionStr(str, expressions, errors));
  } else {
    expressions.push(transitionValue);
  }
  return expressions;
}
function parseInnerTransitionStr(eventStr, expressions, errors) {
  if (eventStr[0] == ":") {
    const result = parseAnimationAlias(eventStr, errors);
    if (typeof result == "function") {
      expressions.push(result);
      return;
    }
    eventStr = result;
  }
  const match5 = eventStr.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/);
  if (match5 == null || match5.length < 4) {
    errors.push(invalidExpression(eventStr));
    return expressions;
  }
  const fromState = match5[1];
  const separator = match5[2];
  const toState = match5[3];
  expressions.push(makeLambdaFromStates(fromState, toState));
  const isFullAnyStateExpr = fromState == ANY_STATE && toState == ANY_STATE;
  if (separator[0] == "<" && !isFullAnyStateExpr) {
    expressions.push(makeLambdaFromStates(toState, fromState));
  }
  return;
}
function parseAnimationAlias(alias, errors) {
  switch (alias) {
    case ":enter":
      return "void => *";
    case ":leave":
      return "* => void";
    case ":increment":
      return (fromState, toState) => parseFloat(toState) > parseFloat(fromState);
    case ":decrement":
      return (fromState, toState) => parseFloat(toState) < parseFloat(fromState);
    default:
      errors.push(invalidTransitionAlias(alias));
      return "* => *";
  }
}
var TRUE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["true", "1"]);
var FALSE_BOOLEAN_VALUES = /* @__PURE__ */ new Set(["false", "0"]);
function makeLambdaFromStates(lhs, rhs) {
  const LHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(lhs) || FALSE_BOOLEAN_VALUES.has(lhs);
  const RHS_MATCH_BOOLEAN = TRUE_BOOLEAN_VALUES.has(rhs) || FALSE_BOOLEAN_VALUES.has(rhs);
  return (fromState, toState) => {
    let lhsMatch = lhs == ANY_STATE || lhs == fromState;
    let rhsMatch = rhs == ANY_STATE || rhs == toState;
    if (!lhsMatch && LHS_MATCH_BOOLEAN && typeof fromState === "boolean") {
      lhsMatch = fromState ? TRUE_BOOLEAN_VALUES.has(lhs) : FALSE_BOOLEAN_VALUES.has(lhs);
    }
    if (!rhsMatch && RHS_MATCH_BOOLEAN && typeof toState === "boolean") {
      rhsMatch = toState ? TRUE_BOOLEAN_VALUES.has(rhs) : FALSE_BOOLEAN_VALUES.has(rhs);
    }
    return lhsMatch && rhsMatch;
  };
}
var SELF_TOKEN = ":self";
var SELF_TOKEN_REGEX = /* @__PURE__ */ new RegExp(`s*${SELF_TOKEN}s*,?`, "g");
function buildAnimationAst(driver, metadata, errors, warnings) {
  return new AnimationAstBuilderVisitor(driver).build(metadata, errors, warnings);
}
var ROOT_SELECTOR = "";
var AnimationAstBuilderVisitor = class {
  _driver;
  constructor(_driver) {
    this._driver = _driver;
  }
  build(metadata, errors, warnings) {
    const context = new AnimationAstBuilderContext(errors);
    this._resetContextStyleTimingState(context);
    const ast = visitDslNode(this, normalizeAnimationEntry(metadata), context);
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      if (context.unsupportedCSSPropertiesFound.size) {
        pushUnrecognizedPropertiesWarning(warnings, [...context.unsupportedCSSPropertiesFound.keys()]);
      }
    }
    return ast;
  }
  _resetContextStyleTimingState(context) {
    context.currentQuerySelector = ROOT_SELECTOR;
    context.collectedStyles = /* @__PURE__ */ new Map();
    context.collectedStyles.set(ROOT_SELECTOR, /* @__PURE__ */ new Map());
    context.currentTime = 0;
  }
  visitTrigger(metadata, context) {
    let queryCount = context.queryCount = 0;
    let depCount = context.depCount = 0;
    const states = [];
    const transitions = [];
    if (metadata.name.charAt(0) == "@") {
      context.errors.push(invalidTrigger());
    }
    metadata.definitions.forEach((def) => {
      this._resetContextStyleTimingState(context);
      if (def.type == AnimationMetadataType.State) {
        const stateDef = def;
        const name = stateDef.name;
        name.toString().split(/\s*,\s*/).forEach((n) => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context));
        });
        stateDef.name = name;
      } else if (def.type == AnimationMetadataType.Transition) {
        const transition2 = this.visitTransition(def, context);
        queryCount += transition2.queryCount;
        depCount += transition2.depCount;
        transitions.push(transition2);
      } else {
        context.errors.push(invalidDefinition());
      }
    });
    return {
      type: AnimationMetadataType.Trigger,
      name: metadata.name,
      states,
      transitions,
      queryCount,
      depCount,
      options: null
    };
  }
  visitState(metadata, context) {
    const styleAst = this.visitStyle(metadata.styles, context);
    const astParams = metadata.options && metadata.options.params || null;
    if (styleAst.containsDynamicStyles) {
      const missingSubs = /* @__PURE__ */ new Set();
      const params = astParams || {};
      styleAst.styles.forEach((style2) => {
        if (style2 instanceof Map) {
          style2.forEach((value) => {
            extractStyleParams(value).forEach((sub) => {
              if (!params.hasOwnProperty(sub)) {
                missingSubs.add(sub);
              }
            });
          });
        }
      });
      if (missingSubs.size) {
        context.errors.push(invalidState(metadata.name, [...missingSubs.values()]));
      }
    }
    return {
      type: AnimationMetadataType.State,
      name: metadata.name,
      style: styleAst,
      options: astParams ? {
        params: astParams
      } : null
    };
  }
  visitTransition(metadata, context) {
    context.queryCount = 0;
    context.depCount = 0;
    const animation2 = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    const matchers = parseTransitionExpr(metadata.expr, context.errors);
    return {
      type: AnimationMetadataType.Transition,
      matchers,
      animation: animation2,
      queryCount: context.queryCount,
      depCount: context.depCount,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitSequence(metadata, context) {
    return {
      type: AnimationMetadataType.Sequence,
      steps: metadata.steps.map((s) => visitDslNode(this, s, context)),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitGroup(metadata, context) {
    const currentTime = context.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map((step) => {
      context.currentTime = currentTime;
      const innerAst = visitDslNode(this, step, context);
      furthestTime = Math.max(furthestTime, context.currentTime);
      return innerAst;
    });
    context.currentTime = furthestTime;
    return {
      type: AnimationMetadataType.Group,
      steps,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimate(metadata, context) {
    const timingAst = constructTimingAst(metadata.timings, context.errors);
    context.currentAnimateTimings = timingAst;
    let styleAst;
    let styleMetadata = metadata.styles ? metadata.styles : style({});
    if (styleMetadata.type == AnimationMetadataType.Keyframes) {
      styleAst = this.visitKeyframes(styleMetadata, context);
    } else {
      let styleMetadata2 = metadata.styles;
      let isEmpty2 = false;
      if (!styleMetadata2) {
        isEmpty2 = true;
        const newStyleData = {};
        if (timingAst.easing) {
          newStyleData["easing"] = timingAst.easing;
        }
        styleMetadata2 = style(newStyleData);
      }
      context.currentTime += timingAst.duration + timingAst.delay;
      const _styleAst = this.visitStyle(styleMetadata2, context);
      _styleAst.isEmptyStep = isEmpty2;
      styleAst = _styleAst;
    }
    context.currentAnimateTimings = null;
    return {
      type: AnimationMetadataType.Animate,
      timings: timingAst,
      style: styleAst,
      options: null
    };
  }
  visitStyle(metadata, context) {
    const ast = this._makeStyleAst(metadata, context);
    this._validateStyleAst(ast, context);
    return ast;
  }
  _makeStyleAst(metadata, context) {
    const styles = [];
    const metadataStyles = Array.isArray(metadata.styles) ? metadata.styles : [metadata.styles];
    for (let styleTuple of metadataStyles) {
      if (typeof styleTuple === "string") {
        if (styleTuple === AUTO_STYLE) {
          styles.push(styleTuple);
        } else {
          context.errors.push(invalidStyleValue(styleTuple));
        }
      } else {
        styles.push(new Map(Object.entries(styleTuple)));
      }
    }
    let containsDynamicStyles = false;
    let collectedEasing = null;
    styles.forEach((styleData) => {
      if (styleData instanceof Map) {
        if (styleData.has("easing")) {
          collectedEasing = styleData.get("easing");
          styleData.delete("easing");
        }
        if (!containsDynamicStyles) {
          for (let value of styleData.values()) {
            if (value.toString().indexOf(SUBSTITUTION_EXPR_START) >= 0) {
              containsDynamicStyles = true;
              break;
            }
          }
        }
      }
    });
    return {
      type: AnimationMetadataType.Style,
      styles,
      easing: collectedEasing,
      offset: metadata.offset,
      containsDynamicStyles,
      options: null
    };
  }
  _validateStyleAst(ast, context) {
    const timings = context.currentAnimateTimings;
    let endTime = context.currentTime;
    let startTime = context.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }
    ast.styles.forEach((tuple) => {
      if (typeof tuple === "string") return;
      tuple.forEach((value, prop) => {
        if (typeof ngDevMode === "undefined" || ngDevMode) {
          if (!this._driver.validateStyleProperty(prop)) {
            tuple.delete(prop);
            context.unsupportedCSSPropertiesFound.add(prop);
            return;
          }
        }
        const collectedStyles = context.collectedStyles.get(context.currentQuerySelector);
        const collectedEntry = collectedStyles.get(prop);
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime && endTime <= collectedEntry.endTime) {
            context.errors.push(invalidParallelAnimation(prop, collectedEntry.startTime, collectedEntry.endTime, startTime, endTime));
            updateCollectedStyle = false;
          }
          startTime = collectedEntry.startTime;
        }
        if (updateCollectedStyle) {
          collectedStyles.set(prop, {
            startTime,
            endTime
          });
        }
        if (context.options) {
          validateStyleParams(value, context.options, context.errors);
        }
      });
    });
  }
  visitKeyframes(metadata, context) {
    const ast = {
      type: AnimationMetadataType.Keyframes,
      styles: [],
      options: null
    };
    if (!context.currentAnimateTimings) {
      context.errors.push(invalidKeyframes());
      return ast;
    }
    const MAX_KEYFRAME_OFFSET = 1;
    let totalKeyframesWithOffsets = 0;
    const offsets = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset = 0;
    const keyframes2 = metadata.steps.map((styles) => {
      const style2 = this._makeStyleAst(styles, context);
      let offsetVal = style2.offset != null ? style2.offset : consumeOffset(style2.styles);
      let offset = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset = style2.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
      previousOffset = offset;
      offsets.push(offset);
      return style2;
    });
    if (keyframesOutOfRange) {
      context.errors.push(invalidOffset());
    }
    if (offsetsOutOfOrder) {
      context.errors.push(keyframeOffsetsOutOfOrder());
    }
    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context.errors.push(keyframesMissingOffsets());
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }
    const limit = length - 1;
    const currentTime = context.currentTime;
    const currentAnimateTimings = context.currentAnimateTimings;
    const animateDuration = currentAnimateTimings.duration;
    keyframes2.forEach((kf, i) => {
      const offset = generatedOffset > 0 ? i == limit ? 1 : generatedOffset * i : offsets[i];
      const durationUpToThisFrame = offset * animateDuration;
      context.currentTime = currentTime + currentAnimateTimings.delay + durationUpToThisFrame;
      currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context);
      kf.offset = offset;
      ast.styles.push(kf);
    });
    return ast;
  }
  visitReference(metadata, context) {
    return {
      type: AnimationMetadataType.Reference,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateChild(metadata, context) {
    context.depCount++;
    return {
      type: AnimationMetadataType.AnimateChild,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitAnimateRef(metadata, context) {
    return {
      type: AnimationMetadataType.AnimateRef,
      animation: this.visitReference(metadata.animation, context),
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitQuery(metadata, context) {
    const parentSelector = context.currentQuerySelector;
    const options = metadata.options || {};
    context.queryCount++;
    context.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context.currentQuerySelector = parentSelector.length ? parentSelector + " " + selector : selector;
    getOrSetDefaultValue(context.collectedStyles, context.currentQuerySelector, /* @__PURE__ */ new Map());
    const animation2 = visitDslNode(this, normalizeAnimationEntry(metadata.animation), context);
    context.currentQuery = null;
    context.currentQuerySelector = parentSelector;
    return {
      type: AnimationMetadataType.Query,
      selector,
      limit: options.limit || 0,
      optional: !!options.optional,
      includeSelf,
      animation: animation2,
      originalSelector: metadata.selector,
      options: normalizeAnimationOptions(metadata.options)
    };
  }
  visitStagger(metadata, context) {
    if (!context.currentQuery) {
      context.errors.push(invalidStagger());
    }
    const timings = metadata.timings === "full" ? {
      duration: 0,
      delay: 0,
      easing: "full"
    } : resolveTiming(metadata.timings, context.errors, true);
    return {
      type: AnimationMetadataType.Stagger,
      animation: visitDslNode(this, normalizeAnimationEntry(metadata.animation), context),
      timings,
      options: null
    };
  }
};
function normalizeSelector(selector) {
  const hasAmpersand = selector.split(/\s*,\s*/).find((token) => token == SELF_TOKEN) ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(SELF_TOKEN_REGEX, "");
  }
  selector = selector.replace(/@\*/g, NG_TRIGGER_SELECTOR).replace(/@\w+/g, (match5) => NG_TRIGGER_SELECTOR + "-" + match5.slice(1)).replace(/:animating/g, NG_ANIMATING_SELECTOR);
  return [selector, hasAmpersand];
}
function normalizeParams(obj) {
  return obj ? __spreadValues({}, obj) : null;
}
var AnimationAstBuilderContext = class {
  errors;
  queryCount = 0;
  depCount = 0;
  currentTransition = null;
  currentQuery = null;
  currentQuerySelector = null;
  currentAnimateTimings = null;
  currentTime = 0;
  collectedStyles = /* @__PURE__ */ new Map();
  options = null;
  unsupportedCSSPropertiesFound = /* @__PURE__ */ new Set();
  constructor(errors) {
    this.errors = errors;
  }
};
function consumeOffset(styles) {
  if (typeof styles == "string") return null;
  let offset = null;
  if (Array.isArray(styles)) {
    styles.forEach((styleTuple) => {
      if (styleTuple instanceof Map && styleTuple.has("offset")) {
        const obj = styleTuple;
        offset = parseFloat(obj.get("offset"));
        obj.delete("offset");
      }
    });
  } else if (styles instanceof Map && styles.has("offset")) {
    const obj = styles;
    offset = parseFloat(obj.get("offset"));
    obj.delete("offset");
  }
  return offset;
}
function constructTimingAst(value, errors) {
  if (value.hasOwnProperty("duration")) {
    return value;
  }
  if (typeof value == "number") {
    const duration = resolveTiming(value, errors).duration;
    return makeTimingAst(duration, 0, "");
  }
  const strValue = value;
  const isDynamic = strValue.split(/\s+/).some((v) => v.charAt(0) == "{" && v.charAt(1) == "{");
  if (isDynamic) {
    const ast = makeTimingAst(0, 0, "");
    ast.dynamic = true;
    ast.strValue = strValue;
    return ast;
  }
  const timings = resolveTiming(strValue, errors);
  return makeTimingAst(timings.duration, timings.delay, timings.easing);
}
function normalizeAnimationOptions(options) {
  if (options) {
    options = __spreadValues({}, options);
    if (options["params"]) {
      options["params"] = normalizeParams(options["params"]);
    }
  } else {
    options = {};
  }
  return options;
}
function makeTimingAst(duration, delay2, easing) {
  return {
    duration,
    delay: delay2,
    easing
  };
}
function createTimelineInstruction(element, keyframes2, preStyleProps, postStyleProps, duration, delay2, easing = null, subTimeline = false) {
  return {
    type: 1,
    element,
    keyframes: keyframes2,
    preStyleProps,
    postStyleProps,
    duration,
    delay: delay2,
    totalTime: duration + delay2,
    easing,
    subTimeline
  };
}
var ElementInstructionMap = class {
  _map = /* @__PURE__ */ new Map();
  get(element) {
    return this._map.get(element) || [];
  }
  append(element, instructions) {
    let existingInstructions = this._map.get(element);
    if (!existingInstructions) {
      this._map.set(element, existingInstructions = []);
    }
    existingInstructions.push(...instructions);
  }
  has(element) {
    return this._map.has(element);
  }
  clear() {
    this._map.clear();
  }
};
var ONE_FRAME_IN_MILLISECONDS = 1;
var ENTER_TOKEN = ":enter";
var ENTER_TOKEN_REGEX = /* @__PURE__ */ new RegExp(ENTER_TOKEN, "g");
var LEAVE_TOKEN = ":leave";
var LEAVE_TOKEN_REGEX = /* @__PURE__ */ new RegExp(LEAVE_TOKEN, "g");
function buildAnimationTimelines(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles = /* @__PURE__ */ new Map(), finalStyles = /* @__PURE__ */ new Map(), options, subInstructions, errors = []) {
  return new AnimationTimelineBuilderVisitor().buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors);
}
var AnimationTimelineBuilderVisitor = class {
  buildKeyframes(driver, rootElement, ast, enterClassName, leaveClassName, startingStyles, finalStyles, options, subInstructions, errors = []) {
    subInstructions = subInstructions || new ElementInstructionMap();
    const context = new AnimationTimelineContext(driver, rootElement, subInstructions, enterClassName, leaveClassName, errors, []);
    context.options = options;
    const delay2 = options.delay ? resolveTimingValue(options.delay) : 0;
    context.currentTimeline.delayNextStep(delay2);
    context.currentTimeline.setStyles([startingStyles], null, context.errors, options);
    visitDslNode(this, ast, context);
    const timelines = context.timelines.filter((timeline) => timeline.containsAnimation());
    if (timelines.length && finalStyles.size) {
      let lastRootTimeline;
      for (let i = timelines.length - 1; i >= 0; i--) {
        const timeline = timelines[i];
        if (timeline.element === rootElement) {
          lastRootTimeline = timeline;
          break;
        }
      }
      if (lastRootTimeline && !lastRootTimeline.allowOnlyTimelineStyles()) {
        lastRootTimeline.setStyles([finalStyles], null, context.errors, options);
      }
    }
    return timelines.length ? timelines.map((timeline) => timeline.buildKeyframes()) : [createTimelineInstruction(rootElement, [], [], [], 0, delay2, "", false)];
  }
  visitTrigger(ast, context) {
  }
  visitState(ast, context) {
  }
  visitTransition(ast, context) {
  }
  visitAnimateChild(ast, context) {
    const elementInstructions = context.subInstructions.get(context.element);
    if (elementInstructions) {
      const innerContext = context.createSubContext(ast.options);
      const startTime = context.currentTimeline.currentTime;
      const endTime = this._visitSubInstructions(elementInstructions, innerContext, innerContext.options);
      if (startTime != endTime) {
        context.transformIntoNewTimeline(endTime);
      }
    }
    context.previousNode = ast;
  }
  visitAnimateRef(ast, context) {
    const innerContext = context.createSubContext(ast.options);
    innerContext.transformIntoNewTimeline();
    this._applyAnimationRefDelays([ast.options, ast.animation.options], context, innerContext);
    this.visitReference(ast.animation, innerContext);
    context.transformIntoNewTimeline(innerContext.currentTimeline.currentTime);
    context.previousNode = ast;
  }
  _applyAnimationRefDelays(animationsRefsOptions, context, innerContext) {
    for (const animationRefOptions of animationsRefsOptions) {
      const animationDelay = animationRefOptions?.delay;
      if (animationDelay) {
        const animationDelayValue = typeof animationDelay === "number" ? animationDelay : resolveTimingValue(interpolateParams(animationDelay, animationRefOptions?.params ?? {}, context.errors));
        innerContext.delayNextStep(animationDelayValue);
      }
    }
  }
  _visitSubInstructions(instructions, context, options) {
    const startTime = context.currentTimeline.currentTime;
    let furthestTime = startTime;
    const duration = options.duration != null ? resolveTimingValue(options.duration) : null;
    const delay2 = options.delay != null ? resolveTimingValue(options.delay) : null;
    if (duration !== 0) {
      instructions.forEach((instruction) => {
        const instructionTimings = context.appendInstructionToTimeline(instruction, duration, delay2);
        furthestTime = Math.max(furthestTime, instructionTimings.duration + instructionTimings.delay);
      });
    }
    return furthestTime;
  }
  visitReference(ast, context) {
    context.updateOptions(ast.options, true);
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
  }
  visitSequence(ast, context) {
    const subContextCount = context.subContextCount;
    let ctx = context;
    const options = ast.options;
    if (options && (options.params || options.delay)) {
      ctx = context.createSubContext(options);
      ctx.transformIntoNewTimeline();
      if (options.delay != null) {
        if (ctx.previousNode.type == AnimationMetadataType.Style) {
          ctx.currentTimeline.snapshotCurrentStyles();
          ctx.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
        }
        const delay2 = resolveTimingValue(options.delay);
        ctx.delayNextStep(delay2);
      }
    }
    if (ast.steps.length) {
      ast.steps.forEach((s) => visitDslNode(this, s, ctx));
      ctx.currentTimeline.applyStylesToKeyframe();
      if (ctx.subContextCount > subContextCount) {
        ctx.transformIntoNewTimeline();
      }
    }
    context.previousNode = ast;
  }
  visitGroup(ast, context) {
    const innerTimelines = [];
    let furthestTime = context.currentTimeline.currentTime;
    const delay2 = ast.options && ast.options.delay ? resolveTimingValue(ast.options.delay) : 0;
    ast.steps.forEach((s) => {
      const innerContext = context.createSubContext(ast.options);
      if (delay2) {
        innerContext.delayNextStep(delay2);
      }
      visitDslNode(this, s, innerContext);
      furthestTime = Math.max(furthestTime, innerContext.currentTimeline.currentTime);
      innerTimelines.push(innerContext.currentTimeline);
    });
    innerTimelines.forEach((timeline) => context.currentTimeline.mergeTimelineCollectedStyles(timeline));
    context.transformIntoNewTimeline(furthestTime);
    context.previousNode = ast;
  }
  _visitTiming(ast, context) {
    if (ast.dynamic) {
      const strValue = ast.strValue;
      const timingValue = context.params ? interpolateParams(strValue, context.params, context.errors) : strValue;
      return resolveTiming(timingValue, context.errors);
    } else {
      return {
        duration: ast.duration,
        delay: ast.delay,
        easing: ast.easing
      };
    }
  }
  visitAnimate(ast, context) {
    const timings = context.currentAnimateTimings = this._visitTiming(ast.timings, context);
    const timeline = context.currentTimeline;
    if (timings.delay) {
      context.incrementTime(timings.delay);
      timeline.snapshotCurrentStyles();
    }
    const style2 = ast.style;
    if (style2.type == AnimationMetadataType.Keyframes) {
      this.visitKeyframes(style2, context);
    } else {
      context.incrementTime(timings.duration);
      this.visitStyle(style2, context);
      timeline.applyStylesToKeyframe();
    }
    context.currentAnimateTimings = null;
    context.previousNode = ast;
  }
  visitStyle(ast, context) {
    const timeline = context.currentTimeline;
    const timings = context.currentAnimateTimings;
    if (!timings && timeline.hasCurrentStyleProperties()) {
      timeline.forwardFrame();
    }
    const easing = timings && timings.easing || ast.easing;
    if (ast.isEmptyStep) {
      timeline.applyEmptyStep(easing);
    } else {
      timeline.setStyles(ast.styles, easing, context.errors, context.options);
    }
    context.previousNode = ast;
  }
  visitKeyframes(ast, context) {
    const currentAnimateTimings = context.currentAnimateTimings;
    const startTime = context.currentTimeline.duration;
    const duration = currentAnimateTimings.duration;
    const innerContext = context.createSubContext();
    const innerTimeline = innerContext.currentTimeline;
    innerTimeline.easing = currentAnimateTimings.easing;
    ast.styles.forEach((step) => {
      const offset = step.offset || 0;
      innerTimeline.forwardTime(offset * duration);
      innerTimeline.setStyles(step.styles, step.easing, context.errors, context.options);
      innerTimeline.applyStylesToKeyframe();
    });
    context.currentTimeline.mergeTimelineCollectedStyles(innerTimeline);
    context.transformIntoNewTimeline(startTime + duration);
    context.previousNode = ast;
  }
  visitQuery(ast, context) {
    const startTime = context.currentTimeline.currentTime;
    const options = ast.options || {};
    const delay2 = options.delay ? resolveTimingValue(options.delay) : 0;
    if (delay2 && (context.previousNode.type === AnimationMetadataType.Style || startTime == 0 && context.currentTimeline.hasCurrentStyleProperties())) {
      context.currentTimeline.snapshotCurrentStyles();
      context.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    }
    let furthestTime = startTime;
    const elms = context.invokeQuery(ast.selector, ast.originalSelector, ast.limit, ast.includeSelf, options.optional ? true : false, context.errors);
    context.currentQueryTotal = elms.length;
    let sameElementTimeline = null;
    elms.forEach((element, i) => {
      context.currentQueryIndex = i;
      const innerContext = context.createSubContext(ast.options, element);
      if (delay2) {
        innerContext.delayNextStep(delay2);
      }
      if (element === context.element) {
        sameElementTimeline = innerContext.currentTimeline;
      }
      visitDslNode(this, ast.animation, innerContext);
      innerContext.currentTimeline.applyStylesToKeyframe();
      const endTime = innerContext.currentTimeline.currentTime;
      furthestTime = Math.max(furthestTime, endTime);
    });
    context.currentQueryIndex = 0;
    context.currentQueryTotal = 0;
    context.transformIntoNewTimeline(furthestTime);
    if (sameElementTimeline) {
      context.currentTimeline.mergeTimelineCollectedStyles(sameElementTimeline);
      context.currentTimeline.snapshotCurrentStyles();
    }
    context.previousNode = ast;
  }
  visitStagger(ast, context) {
    const parentContext = context.parentContext;
    const tl = context.currentTimeline;
    const timings = ast.timings;
    const duration = Math.abs(timings.duration);
    const maxTime = duration * (context.currentQueryTotal - 1);
    let delay2 = duration * context.currentQueryIndex;
    let staggerTransformer = timings.duration < 0 ? "reverse" : timings.easing;
    switch (staggerTransformer) {
      case "reverse":
        delay2 = maxTime - delay2;
        break;
      case "full":
        delay2 = parentContext.currentStaggerTime;
        break;
    }
    const timeline = context.currentTimeline;
    if (delay2) {
      timeline.delayNextStep(delay2);
    }
    const startingTime = timeline.currentTime;
    visitDslNode(this, ast.animation, context);
    context.previousNode = ast;
    parentContext.currentStaggerTime = tl.currentTime - startingTime + (tl.startTime - parentContext.currentTimeline.startTime);
  }
};
var DEFAULT_NOOP_PREVIOUS_NODE = {};
var AnimationTimelineContext = class _AnimationTimelineContext {
  _driver;
  element;
  subInstructions;
  _enterClassName;
  _leaveClassName;
  errors;
  timelines;
  parentContext = null;
  currentTimeline;
  currentAnimateTimings = null;
  previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
  subContextCount = 0;
  options = {};
  currentQueryIndex = 0;
  currentQueryTotal = 0;
  currentStaggerTime = 0;
  constructor(_driver, element, subInstructions, _enterClassName, _leaveClassName, errors, timelines, initialTimeline) {
    this._driver = _driver;
    this.element = element;
    this.subInstructions = subInstructions;
    this._enterClassName = _enterClassName;
    this._leaveClassName = _leaveClassName;
    this.errors = errors;
    this.timelines = timelines;
    this.currentTimeline = initialTimeline || new TimelineBuilder(this._driver, element, 0);
    timelines.push(this.currentTimeline);
  }
  get params() {
    return this.options.params;
  }
  updateOptions(options, skipIfExists) {
    if (!options) return;
    const newOptions = options;
    let optionsToUpdate = this.options;
    if (newOptions.duration != null) {
      optionsToUpdate.duration = resolveTimingValue(newOptions.duration);
    }
    if (newOptions.delay != null) {
      optionsToUpdate.delay = resolveTimingValue(newOptions.delay);
    }
    const newParams = newOptions.params;
    if (newParams) {
      let paramsToUpdate = optionsToUpdate.params;
      if (!paramsToUpdate) {
        paramsToUpdate = this.options.params = {};
      }
      Object.keys(newParams).forEach((name) => {
        if (!skipIfExists || !paramsToUpdate.hasOwnProperty(name)) {
          paramsToUpdate[name] = interpolateParams(newParams[name], paramsToUpdate, this.errors);
        }
      });
    }
  }
  _copyOptions() {
    const options = {};
    if (this.options) {
      const oldParams = this.options.params;
      if (oldParams) {
        const params = options["params"] = {};
        Object.keys(oldParams).forEach((name) => {
          params[name] = oldParams[name];
        });
      }
    }
    return options;
  }
  createSubContext(options = null, element, newTime) {
    const target = element || this.element;
    const context = new _AnimationTimelineContext(this._driver, target, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(target, newTime || 0));
    context.previousNode = this.previousNode;
    context.currentAnimateTimings = this.currentAnimateTimings;
    context.options = this._copyOptions();
    context.updateOptions(options);
    context.currentQueryIndex = this.currentQueryIndex;
    context.currentQueryTotal = this.currentQueryTotal;
    context.parentContext = this;
    this.subContextCount++;
    return context;
  }
  transformIntoNewTimeline(newTime) {
    this.previousNode = DEFAULT_NOOP_PREVIOUS_NODE;
    this.currentTimeline = this.currentTimeline.fork(this.element, newTime);
    this.timelines.push(this.currentTimeline);
    return this.currentTimeline;
  }
  appendInstructionToTimeline(instruction, duration, delay2) {
    const updatedTimings = {
      duration: duration != null ? duration : instruction.duration,
      delay: this.currentTimeline.currentTime + (delay2 != null ? delay2 : 0) + instruction.delay,
      easing: ""
    };
    const builder = new SubTimelineBuilder(this._driver, instruction.element, instruction.keyframes, instruction.preStyleProps, instruction.postStyleProps, updatedTimings, instruction.stretchStartingKeyframe);
    this.timelines.push(builder);
    return updatedTimings;
  }
  incrementTime(time) {
    this.currentTimeline.forwardTime(this.currentTimeline.duration + time);
  }
  delayNextStep(delay2) {
    if (delay2 > 0) {
      this.currentTimeline.delayNextStep(delay2);
    }
  }
  invokeQuery(selector, originalSelector, limit, includeSelf, optional, errors) {
    let results = [];
    if (includeSelf) {
      results.push(this.element);
    }
    if (selector.length > 0) {
      selector = selector.replace(ENTER_TOKEN_REGEX, "." + this._enterClassName);
      selector = selector.replace(LEAVE_TOKEN_REGEX, "." + this._leaveClassName);
      const multi = limit != 1;
      let elements = this._driver.query(this.element, selector, multi);
      if (limit !== 0) {
        elements = limit < 0 ? elements.slice(elements.length + limit, elements.length) : elements.slice(0, limit);
      }
      results.push(...elements);
    }
    if (!optional && results.length == 0) {
      errors.push(invalidQuery(originalSelector));
    }
    return results;
  }
};
var TimelineBuilder = class _TimelineBuilder {
  _driver;
  element;
  startTime;
  _elementTimelineStylesLookup;
  duration = 0;
  easing = null;
  _previousKeyframe = /* @__PURE__ */ new Map();
  _currentKeyframe = /* @__PURE__ */ new Map();
  _keyframes = /* @__PURE__ */ new Map();
  _styleSummary = /* @__PURE__ */ new Map();
  _localTimelineStyles = /* @__PURE__ */ new Map();
  _globalTimelineStyles;
  _pendingStyles = /* @__PURE__ */ new Map();
  _backFill = /* @__PURE__ */ new Map();
  _currentEmptyStepKeyframe = null;
  constructor(_driver, element, startTime, _elementTimelineStylesLookup) {
    this._driver = _driver;
    this.element = element;
    this.startTime = startTime;
    this._elementTimelineStylesLookup = _elementTimelineStylesLookup;
    if (!this._elementTimelineStylesLookup) {
      this._elementTimelineStylesLookup = /* @__PURE__ */ new Map();
    }
    this._globalTimelineStyles = this._elementTimelineStylesLookup.get(element);
    if (!this._globalTimelineStyles) {
      this._globalTimelineStyles = this._localTimelineStyles;
      this._elementTimelineStylesLookup.set(element, this._localTimelineStyles);
    }
    this._loadKeyframe();
  }
  containsAnimation() {
    switch (this._keyframes.size) {
      case 0:
        return false;
      case 1:
        return this.hasCurrentStyleProperties();
      default:
        return true;
    }
  }
  hasCurrentStyleProperties() {
    return this._currentKeyframe.size > 0;
  }
  get currentTime() {
    return this.startTime + this.duration;
  }
  delayNextStep(delay2) {
    const hasPreStyleStep = this._keyframes.size === 1 && this._pendingStyles.size;
    if (this.duration || hasPreStyleStep) {
      this.forwardTime(this.currentTime + delay2);
      if (hasPreStyleStep) {
        this.snapshotCurrentStyles();
      }
    } else {
      this.startTime += delay2;
    }
  }
  fork(element, currentTime) {
    this.applyStylesToKeyframe();
    return new _TimelineBuilder(this._driver, element, currentTime || this.currentTime, this._elementTimelineStylesLookup);
  }
  _loadKeyframe() {
    if (this._currentKeyframe) {
      this._previousKeyframe = this._currentKeyframe;
    }
    this._currentKeyframe = this._keyframes.get(this.duration);
    if (!this._currentKeyframe) {
      this._currentKeyframe = /* @__PURE__ */ new Map();
      this._keyframes.set(this.duration, this._currentKeyframe);
    }
  }
  forwardFrame() {
    this.duration += ONE_FRAME_IN_MILLISECONDS;
    this._loadKeyframe();
  }
  forwardTime(time) {
    this.applyStylesToKeyframe();
    this.duration = time;
    this._loadKeyframe();
  }
  _updateStyle(prop, value) {
    this._localTimelineStyles.set(prop, value);
    this._globalTimelineStyles.set(prop, value);
    this._styleSummary.set(prop, {
      time: this.currentTime,
      value
    });
  }
  allowOnlyTimelineStyles() {
    return this._currentEmptyStepKeyframe !== this._currentKeyframe;
  }
  applyEmptyStep(easing) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    for (let [prop, value] of this._globalTimelineStyles) {
      this._backFill.set(prop, value || AUTO_STYLE);
      this._currentKeyframe.set(prop, AUTO_STYLE);
    }
    this._currentEmptyStepKeyframe = this._currentKeyframe;
  }
  setStyles(input2, easing, errors, options) {
    if (easing) {
      this._previousKeyframe.set("easing", easing);
    }
    const params = options && options.params || {};
    const styles = flattenStyles(input2, this._globalTimelineStyles);
    for (let [prop, value] of styles) {
      const val = interpolateParams(value, params, errors);
      this._pendingStyles.set(prop, val);
      if (!this._localTimelineStyles.has(prop)) {
        this._backFill.set(prop, this._globalTimelineStyles.get(prop) ?? AUTO_STYLE);
      }
      this._updateStyle(prop, val);
    }
  }
  applyStylesToKeyframe() {
    if (this._pendingStyles.size == 0) return;
    this._pendingStyles.forEach((val, prop) => {
      this._currentKeyframe.set(prop, val);
    });
    this._pendingStyles.clear();
    this._localTimelineStyles.forEach((val, prop) => {
      if (!this._currentKeyframe.has(prop)) {
        this._currentKeyframe.set(prop, val);
      }
    });
  }
  snapshotCurrentStyles() {
    for (let [prop, val] of this._localTimelineStyles) {
      this._pendingStyles.set(prop, val);
      this._updateStyle(prop, val);
    }
  }
  getFinalKeyframe() {
    return this._keyframes.get(this.duration);
  }
  get properties() {
    const properties = [];
    for (let prop in this._currentKeyframe) {
      properties.push(prop);
    }
    return properties;
  }
  mergeTimelineCollectedStyles(timeline) {
    timeline._styleSummary.forEach((details1, prop) => {
      const details0 = this._styleSummary.get(prop);
      if (!details0 || details1.time > details0.time) {
        this._updateStyle(prop, details1.value);
      }
    });
  }
  buildKeyframes() {
    this.applyStylesToKeyframe();
    const preStyleProps = /* @__PURE__ */ new Set();
    const postStyleProps = /* @__PURE__ */ new Set();
    const isEmpty2 = this._keyframes.size === 1 && this.duration === 0;
    let finalKeyframes = [];
    this._keyframes.forEach((keyframe, time) => {
      const finalKeyframe = new Map([...this._backFill, ...keyframe]);
      finalKeyframe.forEach((value, prop) => {
        if (value === \u0275PRE_STYLE) {
          preStyleProps.add(prop);
        } else if (value === AUTO_STYLE) {
          postStyleProps.add(prop);
        }
      });
      if (!isEmpty2) {
        finalKeyframe.set("offset", time / this.duration);
      }
      finalKeyframes.push(finalKeyframe);
    });
    const preProps = [...preStyleProps.values()];
    const postProps = [...postStyleProps.values()];
    if (isEmpty2) {
      const kf0 = finalKeyframes[0];
      const kf1 = new Map(kf0);
      kf0.set("offset", 0);
      kf1.set("offset", 1);
      finalKeyframes = [kf0, kf1];
    }
    return createTimelineInstruction(this.element, finalKeyframes, preProps, postProps, this.duration, this.startTime, this.easing, false);
  }
};
var SubTimelineBuilder = class extends TimelineBuilder {
  keyframes;
  preStyleProps;
  postStyleProps;
  _stretchStartingKeyframe;
  timings;
  constructor(driver, element, keyframes2, preStyleProps, postStyleProps, timings, _stretchStartingKeyframe = false) {
    super(driver, element, timings.delay);
    this.keyframes = keyframes2;
    this.preStyleProps = preStyleProps;
    this.postStyleProps = postStyleProps;
    this._stretchStartingKeyframe = _stretchStartingKeyframe;
    this.timings = {
      duration: timings.duration,
      delay: timings.delay,
      easing: timings.easing
    };
  }
  containsAnimation() {
    return this.keyframes.length > 1;
  }
  buildKeyframes() {
    let keyframes2 = this.keyframes;
    let {
      delay: delay2,
      duration,
      easing
    } = this.timings;
    if (this._stretchStartingKeyframe && delay2) {
      const newKeyframes = [];
      const totalTime = duration + delay2;
      const startingGap = delay2 / totalTime;
      const newFirstKeyframe = new Map(keyframes2[0]);
      newFirstKeyframe.set("offset", 0);
      newKeyframes.push(newFirstKeyframe);
      const oldFirstKeyframe = new Map(keyframes2[0]);
      oldFirstKeyframe.set("offset", roundOffset(startingGap));
      newKeyframes.push(oldFirstKeyframe);
      const limit = keyframes2.length - 1;
      for (let i = 1; i <= limit; i++) {
        let kf = new Map(keyframes2[i]);
        const oldOffset = kf.get("offset");
        const timeAtKeyframe = delay2 + oldOffset * duration;
        kf.set("offset", roundOffset(timeAtKeyframe / totalTime));
        newKeyframes.push(kf);
      }
      duration = totalTime;
      delay2 = 0;
      easing = "";
      keyframes2 = newKeyframes;
    }
    return createTimelineInstruction(this.element, keyframes2, this.preStyleProps, this.postStyleProps, duration, delay2, easing, true);
  }
};
function roundOffset(offset, decimalPoints = 3) {
  const mult = Math.pow(10, decimalPoints - 1);
  return Math.round(offset * mult) / mult;
}
function flattenStyles(input2, allStyles) {
  const styles = /* @__PURE__ */ new Map();
  let allProperties;
  input2.forEach((token) => {
    if (token === "*") {
      allProperties ??= allStyles.keys();
      for (let prop of allProperties) {
        styles.set(prop, AUTO_STYLE);
      }
    } else {
      for (let [prop, val] of token) {
        styles.set(prop, val);
      }
    }
  });
  return styles;
}
function createTransitionInstruction(element, triggerName, fromState, toState, isRemovalTransition, fromStyles, toStyles, timelines, queriedElements, preStyleProps, postStyleProps, totalTime, errors) {
  return {
    type: 0,
    element,
    triggerName,
    isRemovalTransition,
    fromState,
    fromStyles,
    toState,
    toStyles,
    timelines,
    queriedElements,
    preStyleProps,
    postStyleProps,
    totalTime,
    errors
  };
}
var EMPTY_OBJECT = {};
var AnimationTransitionFactory = class {
  _triggerName;
  ast;
  _stateStyles;
  constructor(_triggerName, ast, _stateStyles) {
    this._triggerName = _triggerName;
    this.ast = ast;
    this._stateStyles = _stateStyles;
  }
  match(currentState, nextState, element, params) {
    return oneOrMoreTransitionsMatch(this.ast.matchers, currentState, nextState, element, params);
  }
  buildStyles(stateName, params, errors) {
    let styler = this._stateStyles.get("*");
    if (stateName !== void 0) {
      styler = this._stateStyles.get(stateName?.toString()) || styler;
    }
    return styler ? styler.buildStyles(params, errors) : /* @__PURE__ */ new Map();
  }
  build(driver, element, currentState, nextState, enterClassName, leaveClassName, currentOptions, nextOptions, subInstructions, skipAstBuild) {
    const errors = [];
    const transitionAnimationParams = this.ast.options && this.ast.options.params || EMPTY_OBJECT;
    const currentAnimationParams = currentOptions && currentOptions.params || EMPTY_OBJECT;
    const currentStateStyles = this.buildStyles(currentState, currentAnimationParams, errors);
    const nextAnimationParams = nextOptions && nextOptions.params || EMPTY_OBJECT;
    const nextStateStyles = this.buildStyles(nextState, nextAnimationParams, errors);
    const queriedElements = /* @__PURE__ */ new Set();
    const preStyleMap = /* @__PURE__ */ new Map();
    const postStyleMap = /* @__PURE__ */ new Map();
    const isRemoval = nextState === "void";
    const animationOptions = {
      params: applyParamDefaults(nextAnimationParams, transitionAnimationParams),
      delay: this.ast.options?.delay
    };
    const timelines = skipAstBuild ? [] : buildAnimationTimelines(driver, element, this.ast.animation, enterClassName, leaveClassName, currentStateStyles, nextStateStyles, animationOptions, subInstructions, errors);
    let totalTime = 0;
    timelines.forEach((tl) => {
      totalTime = Math.max(tl.duration + tl.delay, totalTime);
    });
    if (errors.length) {
      return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, [], [], preStyleMap, postStyleMap, totalTime, errors);
    }
    timelines.forEach((tl) => {
      const elm = tl.element;
      const preProps = getOrSetDefaultValue(preStyleMap, elm, /* @__PURE__ */ new Set());
      tl.preStyleProps.forEach((prop) => preProps.add(prop));
      const postProps = getOrSetDefaultValue(postStyleMap, elm, /* @__PURE__ */ new Set());
      tl.postStyleProps.forEach((prop) => postProps.add(prop));
      if (elm !== element) {
        queriedElements.add(elm);
      }
    });
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      checkNonAnimatableInTimelines(timelines, this._triggerName, driver);
    }
    return createTransitionInstruction(element, this._triggerName, currentState, nextState, isRemoval, currentStateStyles, nextStateStyles, timelines, [...queriedElements.values()], preStyleMap, postStyleMap, totalTime);
  }
};
function checkNonAnimatableInTimelines(timelines, triggerName, driver) {
  if (!driver.validateAnimatableStyleProperty) {
    return;
  }
  const allowedNonAnimatableProps = /* @__PURE__ */ new Set(["easing"]);
  const invalidNonAnimatableProps = /* @__PURE__ */ new Set();
  timelines.forEach(({
    keyframes: keyframes2
  }) => {
    const nonAnimatablePropsInitialValues = /* @__PURE__ */ new Map();
    keyframes2.forEach((keyframe) => {
      const entriesToCheck = Array.from(keyframe.entries()).filter(([prop]) => !allowedNonAnimatableProps.has(prop));
      for (const [prop, value] of entriesToCheck) {
        if (!driver.validateAnimatableStyleProperty(prop)) {
          if (nonAnimatablePropsInitialValues.has(prop) && !invalidNonAnimatableProps.has(prop)) {
            const propInitialValue = nonAnimatablePropsInitialValues.get(prop);
            if (propInitialValue !== value) {
              invalidNonAnimatableProps.add(prop);
            }
          } else {
            nonAnimatablePropsInitialValues.set(prop, value);
          }
        }
      }
    });
  });
  if (invalidNonAnimatableProps.size > 0) {
    console.warn(`Warning: The animation trigger "${triggerName}" is attempting to animate the following not animatable properties: ` + Array.from(invalidNonAnimatableProps).join(", ") + "\n(to check the list of all animatable properties visit https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)");
  }
}
function oneOrMoreTransitionsMatch(matchFns, currentState, nextState, element, params) {
  return matchFns.some((fn) => fn(currentState, nextState, element, params));
}
function applyParamDefaults(userParams, defaults) {
  const result = __spreadValues({}, defaults);
  Object.entries(userParams).forEach(([key, value]) => {
    if (value != null) {
      result[key] = value;
    }
  });
  return result;
}
var AnimationStateStyles = class {
  styles;
  defaultParams;
  normalizer;
  constructor(styles, defaultParams, normalizer) {
    this.styles = styles;
    this.defaultParams = defaultParams;
    this.normalizer = normalizer;
  }
  buildStyles(params, errors) {
    const finalStyles = /* @__PURE__ */ new Map();
    const combinedParams = applyParamDefaults(params, this.defaultParams);
    this.styles.styles.forEach((value) => {
      if (typeof value !== "string") {
        value.forEach((val, prop) => {
          if (val) {
            val = interpolateParams(val, combinedParams, errors);
          }
          const normalizedProp = this.normalizer.normalizePropertyName(prop, errors);
          val = this.normalizer.normalizeStyleValue(prop, normalizedProp, val, errors);
          finalStyles.set(prop, val);
        });
      }
    });
    return finalStyles;
  }
};
function buildTrigger(name, ast, normalizer) {
  return new AnimationTrigger(name, ast, normalizer);
}
var AnimationTrigger = class {
  name;
  ast;
  _normalizer;
  transitionFactories = [];
  fallbackTransition;
  states = /* @__PURE__ */ new Map();
  constructor(name, ast, _normalizer) {
    this.name = name;
    this.ast = ast;
    this._normalizer = _normalizer;
    ast.states.forEach((ast2) => {
      const defaultParams = ast2.options && ast2.options.params || {};
      this.states.set(ast2.name, new AnimationStateStyles(ast2.style, defaultParams, _normalizer));
    });
    balanceProperties(this.states, "true", "1");
    balanceProperties(this.states, "false", "0");
    ast.transitions.forEach((ast2) => {
      this.transitionFactories.push(new AnimationTransitionFactory(name, ast2, this.states));
    });
    this.fallbackTransition = createFallbackTransition(name, this.states);
  }
  get containsQueries() {
    return this.ast.queryCount > 0;
  }
  matchTransition(currentState, nextState, element, params) {
    const entry = this.transitionFactories.find((f) => f.match(currentState, nextState, element, params));
    return entry || null;
  }
  matchStyles(currentState, params, errors) {
    return this.fallbackTransition.buildStyles(currentState, params, errors);
  }
};
function createFallbackTransition(triggerName, states, normalizer) {
  const matchers = [(fromState, toState) => true];
  const animation2 = {
    type: AnimationMetadataType.Sequence,
    steps: [],
    options: null
  };
  const transition2 = {
    type: AnimationMetadataType.Transition,
    animation: animation2,
    matchers,
    options: null,
    queryCount: 0,
    depCount: 0
  };
  return new AnimationTransitionFactory(triggerName, transition2, states);
}
function balanceProperties(stateMap, key1, key2) {
  if (stateMap.has(key1)) {
    if (!stateMap.has(key2)) {
      stateMap.set(key2, stateMap.get(key1));
    }
  } else if (stateMap.has(key2)) {
    stateMap.set(key1, stateMap.get(key2));
  }
}
var EMPTY_INSTRUCTION_MAP = /* @__PURE__ */ new ElementInstructionMap();
var TimelineAnimationEngine = class {
  bodyNode;
  _driver;
  _normalizer;
  _animations = /* @__PURE__ */ new Map();
  _playersById = /* @__PURE__ */ new Map();
  players = [];
  constructor(bodyNode, _driver, _normalizer) {
    this.bodyNode = bodyNode;
    this._driver = _driver;
    this._normalizer = _normalizer;
  }
  register(id, metadata) {
    const errors = [];
    const warnings = [];
    const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
    if (errors.length) {
      throw registerFailed(errors);
    } else {
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (warnings.length) {
          warnRegister(warnings);
        }
      }
      this._animations.set(id, ast);
    }
  }
  _buildPlayer(i, preStyles, postStyles) {
    const element = i.element;
    const keyframes2 = normalizeKeyframes$1(this._normalizer, i.keyframes, preStyles, postStyles);
    return this._driver.animate(element, keyframes2, i.duration, i.delay, i.easing, [], true);
  }
  create(id, element, options = {}) {
    const errors = [];
    const ast = this._animations.get(id);
    let instructions;
    const autoStylesMap = /* @__PURE__ */ new Map();
    if (ast) {
      instructions = buildAnimationTimelines(this._driver, element, ast, ENTER_CLASSNAME, LEAVE_CLASSNAME, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), options, EMPTY_INSTRUCTION_MAP, errors);
      instructions.forEach((inst) => {
        const styles = getOrSetDefaultValue(autoStylesMap, inst.element, /* @__PURE__ */ new Map());
        inst.postStyleProps.forEach((prop) => styles.set(prop, null));
      });
    } else {
      errors.push(missingOrDestroyedAnimation());
      instructions = [];
    }
    if (errors.length) {
      throw createAnimationFailed(errors);
    }
    autoStylesMap.forEach((styles, element2) => {
      styles.forEach((_, prop) => {
        styles.set(prop, this._driver.computeStyle(element2, prop, AUTO_STYLE));
      });
    });
    const players = instructions.map((i) => {
      const styles = autoStylesMap.get(i.element);
      return this._buildPlayer(i, /* @__PURE__ */ new Map(), styles);
    });
    const player = optimizeGroupPlayer(players);
    this._playersById.set(id, player);
    player.onDestroy(() => this.destroy(id));
    this.players.push(player);
    return player;
  }
  destroy(id) {
    const player = this._getPlayer(id);
    player.destroy();
    this._playersById.delete(id);
    const index2 = this.players.indexOf(player);
    if (index2 >= 0) {
      this.players.splice(index2, 1);
    }
  }
  _getPlayer(id) {
    const player = this._playersById.get(id);
    if (!player) {
      throw missingPlayer(id);
    }
    return player;
  }
  listen(id, element, eventName, callback) {
    const baseEvent = makeAnimationEvent(element, "", "", "");
    listenOnPlayer(this._getPlayer(id), eventName, baseEvent, callback);
    return () => {
    };
  }
  command(id, element, command, args) {
    if (command == "register") {
      this.register(id, args[0]);
      return;
    }
    if (command == "create") {
      const options = args[0] || {};
      this.create(id, element, options);
      return;
    }
    const player = this._getPlayer(id);
    switch (command) {
      case "play":
        player.play();
        break;
      case "pause":
        player.pause();
        break;
      case "reset":
        player.reset();
        break;
      case "restart":
        player.restart();
        break;
      case "finish":
        player.finish();
        break;
      case "init":
        player.init();
        break;
      case "setPosition":
        player.setPosition(parseFloat(args[0]));
        break;
      case "destroy":
        this.destroy(id);
        break;
    }
  }
};
var QUEUED_CLASSNAME = "ng-animate-queued";
var QUEUED_SELECTOR = ".ng-animate-queued";
var DISABLED_CLASSNAME = "ng-animate-disabled";
var DISABLED_SELECTOR = ".ng-animate-disabled";
var STAR_CLASSNAME = "ng-star-inserted";
var STAR_SELECTOR = ".ng-star-inserted";
var EMPTY_PLAYER_ARRAY = [];
var NULL_REMOVAL_STATE = {
  namespaceId: "",
  setForRemoval: false,
  setForMove: false,
  hasAnimation: false,
  removedBeforeQueried: false
};
var NULL_REMOVED_QUERIED_STATE = {
  namespaceId: "",
  setForMove: false,
  setForRemoval: false,
  hasAnimation: false,
  removedBeforeQueried: true
};
var REMOVAL_FLAG = "__ng_removed";
var StateValue = class {
  namespaceId;
  value;
  options;
  get params() {
    return this.options.params;
  }
  constructor(input2, namespaceId = "") {
    this.namespaceId = namespaceId;
    const isObj = input2 && input2.hasOwnProperty("value");
    const value = isObj ? input2["value"] : input2;
    this.value = normalizeTriggerValue(value);
    if (isObj) {
      const _a = input2, {
        value: value2
      } = _a, options = __objRest(_a, [
        "value"
      ]);
      this.options = options;
    } else {
      this.options = {};
    }
    if (!this.options.params) {
      this.options.params = {};
    }
  }
  absorbOptions(options) {
    const newParams = options.params;
    if (newParams) {
      const oldParams = this.options.params;
      Object.keys(newParams).forEach((prop) => {
        if (oldParams[prop] == null) {
          oldParams[prop] = newParams[prop];
        }
      });
    }
  }
};
var VOID_VALUE = "void";
var DEFAULT_STATE_VALUE = /* @__PURE__ */ new StateValue(VOID_VALUE);
var AnimationTransitionNamespace = class {
  id;
  hostElement;
  _engine;
  players = [];
  _triggers = /* @__PURE__ */ new Map();
  _queue = [];
  _elementListeners = /* @__PURE__ */ new Map();
  _hostClassName;
  constructor(id, hostElement, _engine) {
    this.id = id;
    this.hostElement = hostElement;
    this._engine = _engine;
    this._hostClassName = "ng-tns-" + id;
    addClass(hostElement, this._hostClassName);
  }
  listen(element, name, phase, callback) {
    if (!this._triggers.has(name)) {
      throw missingTrigger(phase, name);
    }
    if (phase == null || phase.length == 0) {
      throw missingEvent(name);
    }
    if (!isTriggerEventValid(phase)) {
      throw unsupportedTriggerEvent(phase, name);
    }
    const listeners = getOrSetDefaultValue(this._elementListeners, element, []);
    const data = {
      name,
      phase,
      callback
    };
    listeners.push(data);
    const triggersWithStates = getOrSetDefaultValue(this._engine.statesByElement, element, /* @__PURE__ */ new Map());
    if (!triggersWithStates.has(name)) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + name);
      triggersWithStates.set(name, DEFAULT_STATE_VALUE);
    }
    return () => {
      this._engine.afterFlush(() => {
        const index2 = listeners.indexOf(data);
        if (index2 >= 0) {
          listeners.splice(index2, 1);
        }
        if (!this._triggers.has(name)) {
          triggersWithStates.delete(name);
        }
      });
    };
  }
  register(name, ast) {
    if (this._triggers.has(name)) {
      return false;
    } else {
      this._triggers.set(name, ast);
      return true;
    }
  }
  _getTrigger(name) {
    const trigger2 = this._triggers.get(name);
    if (!trigger2) {
      throw unregisteredTrigger(name);
    }
    return trigger2;
  }
  trigger(element, triggerName, value, defaultToFallback = true) {
    const trigger2 = this._getTrigger(triggerName);
    const player = new TransitionAnimationPlayer(this.id, triggerName, element);
    let triggersWithStates = this._engine.statesByElement.get(element);
    if (!triggersWithStates) {
      addClass(element, NG_TRIGGER_CLASSNAME);
      addClass(element, NG_TRIGGER_CLASSNAME + "-" + triggerName);
      this._engine.statesByElement.set(element, triggersWithStates = /* @__PURE__ */ new Map());
    }
    let fromState = triggersWithStates.get(triggerName);
    const toState = new StateValue(value, this.id);
    const isObj = value && value.hasOwnProperty("value");
    if (!isObj && fromState) {
      toState.absorbOptions(fromState.options);
    }
    triggersWithStates.set(triggerName, toState);
    if (!fromState) {
      fromState = DEFAULT_STATE_VALUE;
    }
    const isRemoval = toState.value === VOID_VALUE;
    if (!isRemoval && fromState.value === toState.value) {
      if (!objEquals(fromState.params, toState.params)) {
        const errors = [];
        const fromStyles = trigger2.matchStyles(fromState.value, fromState.params, errors);
        const toStyles = trigger2.matchStyles(toState.value, toState.params, errors);
        if (errors.length) {
          this._engine.reportError(errors);
        } else {
          this._engine.afterFlush(() => {
            eraseStyles(element, fromStyles);
            setStyles(element, toStyles);
          });
        }
      }
      return;
    }
    const playersOnElement = getOrSetDefaultValue(this._engine.playersByElement, element, []);
    playersOnElement.forEach((player2) => {
      if (player2.namespaceId == this.id && player2.triggerName == triggerName && player2.queued) {
        player2.destroy();
      }
    });
    let transition2 = trigger2.matchTransition(fromState.value, toState.value, element, toState.params);
    let isFallbackTransition = false;
    if (!transition2) {
      if (!defaultToFallback) return;
      transition2 = trigger2.fallbackTransition;
      isFallbackTransition = true;
    }
    this._engine.totalQueuedPlayers++;
    this._queue.push({
      element,
      triggerName,
      transition: transition2,
      fromState,
      toState,
      player,
      isFallbackTransition
    });
    if (!isFallbackTransition) {
      addClass(element, QUEUED_CLASSNAME);
      player.onStart(() => {
        removeClass(element, QUEUED_CLASSNAME);
      });
    }
    player.onDone(() => {
      let index2 = this.players.indexOf(player);
      if (index2 >= 0) {
        this.players.splice(index2, 1);
      }
      const players = this._engine.playersByElement.get(element);
      if (players) {
        let index3 = players.indexOf(player);
        if (index3 >= 0) {
          players.splice(index3, 1);
        }
      }
    });
    this.players.push(player);
    playersOnElement.push(player);
    return player;
  }
  deregister(name) {
    this._triggers.delete(name);
    this._engine.statesByElement.forEach((stateMap) => stateMap.delete(name));
    this._elementListeners.forEach((listeners, element) => {
      this._elementListeners.set(element, listeners.filter((entry) => {
        return entry.name != name;
      }));
    });
  }
  clearElementCache(element) {
    this._engine.statesByElement.delete(element);
    this._elementListeners.delete(element);
    const elementPlayers = this._engine.playersByElement.get(element);
    if (elementPlayers) {
      elementPlayers.forEach((player) => player.destroy());
      this._engine.playersByElement.delete(element);
    }
  }
  _signalRemovalForInnerTriggers(rootElement, context) {
    const elements = this._engine.driver.query(rootElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((elm) => {
      if (elm[REMOVAL_FLAG]) return;
      const namespaces = this._engine.fetchNamespacesByElement(elm);
      if (namespaces.size) {
        namespaces.forEach((ns) => ns.triggerLeaveAnimation(elm, context, false, true));
      } else {
        this.clearElementCache(elm);
      }
    });
    this._engine.afterFlushAnimationsDone(() => elements.forEach((elm) => this.clearElementCache(elm)));
  }
  triggerLeaveAnimation(element, context, destroyAfterComplete, defaultToFallback) {
    const triggerStates = this._engine.statesByElement.get(element);
    const previousTriggersValues = /* @__PURE__ */ new Map();
    if (triggerStates) {
      const players = [];
      triggerStates.forEach((state2, triggerName) => {
        previousTriggersValues.set(triggerName, state2.value);
        if (this._triggers.has(triggerName)) {
          const player = this.trigger(element, triggerName, VOID_VALUE, defaultToFallback);
          if (player) {
            players.push(player);
          }
        }
      });
      if (players.length) {
        this._engine.markElementAsRemoved(this.id, element, true, context, previousTriggersValues);
        if (destroyAfterComplete) {
          optimizeGroupPlayer(players).onDone(() => this._engine.processLeaveNode(element));
        }
        return true;
      }
    }
    return false;
  }
  prepareLeaveAnimationListeners(element) {
    const listeners = this._elementListeners.get(element);
    const elementStates = this._engine.statesByElement.get(element);
    if (listeners && elementStates) {
      const visitedTriggers = /* @__PURE__ */ new Set();
      listeners.forEach((listener) => {
        const triggerName = listener.name;
        if (visitedTriggers.has(triggerName)) return;
        visitedTriggers.add(triggerName);
        const trigger2 = this._triggers.get(triggerName);
        const transition2 = trigger2.fallbackTransition;
        const fromState = elementStates.get(triggerName) || DEFAULT_STATE_VALUE;
        const toState = new StateValue(VOID_VALUE);
        const player = new TransitionAnimationPlayer(this.id, triggerName, element);
        this._engine.totalQueuedPlayers++;
        this._queue.push({
          element,
          triggerName,
          transition: transition2,
          fromState,
          toState,
          player,
          isFallbackTransition: true
        });
      });
    }
  }
  removeNode(element, context) {
    const engine = this._engine;
    if (element.childElementCount) {
      this._signalRemovalForInnerTriggers(element, context);
    }
    if (this.triggerLeaveAnimation(element, context, true)) return;
    let containsPotentialParentTransition = false;
    if (engine.totalAnimations) {
      const currentPlayers = engine.players.length ? engine.playersByQueriedElement.get(element) : [];
      if (currentPlayers && currentPlayers.length) {
        containsPotentialParentTransition = true;
      } else {
        let parent = element;
        while (parent = parent.parentNode) {
          const triggers = engine.statesByElement.get(parent);
          if (triggers) {
            containsPotentialParentTransition = true;
            break;
          }
        }
      }
    }
    this.prepareLeaveAnimationListeners(element);
    if (containsPotentialParentTransition) {
      engine.markElementAsRemoved(this.id, element, false, context);
    } else {
      const removalFlag = element[REMOVAL_FLAG];
      if (!removalFlag || removalFlag === NULL_REMOVAL_STATE) {
        engine.afterFlush(() => this.clearElementCache(element));
        engine.destroyInnerAnimations(element);
        engine._onRemovalComplete(element, context);
      }
    }
  }
  insertNode(element, parent) {
    addClass(element, this._hostClassName);
  }
  drainQueuedTransitions(microtaskId) {
    const instructions = [];
    this._queue.forEach((entry) => {
      const player = entry.player;
      if (player.destroyed) return;
      const element = entry.element;
      const listeners = this._elementListeners.get(element);
      if (listeners) {
        listeners.forEach((listener) => {
          if (listener.name == entry.triggerName) {
            const baseEvent = makeAnimationEvent(element, entry.triggerName, entry.fromState.value, entry.toState.value);
            baseEvent["_data"] = microtaskId;
            listenOnPlayer(entry.player, listener.phase, baseEvent, listener.callback);
          }
        });
      }
      if (player.markedForDestroy) {
        this._engine.afterFlush(() => {
          player.destroy();
        });
      } else {
        instructions.push(entry);
      }
    });
    this._queue = [];
    return instructions.sort((a, b) => {
      const d0 = a.transition.ast.depCount;
      const d1 = b.transition.ast.depCount;
      if (d0 == 0 || d1 == 0) {
        return d0 - d1;
      }
      return this._engine.driver.containsElement(a.element, b.element) ? 1 : -1;
    });
  }
  destroy(context) {
    this.players.forEach((p) => p.destroy());
    this._signalRemovalForInnerTriggers(this.hostElement, context);
  }
};
var TransitionAnimationEngine = class {
  bodyNode;
  driver;
  _normalizer;
  players = [];
  newHostElements = /* @__PURE__ */ new Map();
  playersByElement = /* @__PURE__ */ new Map();
  playersByQueriedElement = /* @__PURE__ */ new Map();
  statesByElement = /* @__PURE__ */ new Map();
  disabledNodes = /* @__PURE__ */ new Set();
  totalAnimations = 0;
  totalQueuedPlayers = 0;
  _namespaceLookup = {};
  _namespaceList = [];
  _flushFns = [];
  _whenQuietFns = [];
  namespacesByHostElement = /* @__PURE__ */ new Map();
  collectedEnterElements = [];
  collectedLeaveElements = [];
  onRemovalComplete = (element, context) => {
  };
  _onRemovalComplete(element, context) {
    this.onRemovalComplete(element, context);
  }
  constructor(bodyNode, driver, _normalizer) {
    this.bodyNode = bodyNode;
    this.driver = driver;
    this._normalizer = _normalizer;
  }
  get queuedPlayers() {
    const players = [];
    this._namespaceList.forEach((ns) => {
      ns.players.forEach((player) => {
        if (player.queued) {
          players.push(player);
        }
      });
    });
    return players;
  }
  createNamespace(namespaceId, hostElement) {
    const ns = new AnimationTransitionNamespace(namespaceId, hostElement, this);
    if (this.bodyNode && this.driver.containsElement(this.bodyNode, hostElement)) {
      this._balanceNamespaceList(ns, hostElement);
    } else {
      this.newHostElements.set(hostElement, ns);
      this.collectEnterElement(hostElement);
    }
    return this._namespaceLookup[namespaceId] = ns;
  }
  _balanceNamespaceList(ns, hostElement) {
    const namespaceList = this._namespaceList;
    const namespacesByHostElement = this.namespacesByHostElement;
    const limit = namespaceList.length - 1;
    if (limit >= 0) {
      let found = false;
      let ancestor = this.driver.getParentElement(hostElement);
      while (ancestor) {
        const ancestorNs = namespacesByHostElement.get(ancestor);
        if (ancestorNs) {
          const index2 = namespaceList.indexOf(ancestorNs);
          namespaceList.splice(index2 + 1, 0, ns);
          found = true;
          break;
        }
        ancestor = this.driver.getParentElement(ancestor);
      }
      if (!found) {
        namespaceList.unshift(ns);
      }
    } else {
      namespaceList.push(ns);
    }
    namespacesByHostElement.set(hostElement, ns);
    return ns;
  }
  register(namespaceId, hostElement) {
    let ns = this._namespaceLookup[namespaceId];
    if (!ns) {
      ns = this.createNamespace(namespaceId, hostElement);
    }
    return ns;
  }
  registerTrigger(namespaceId, name, trigger2) {
    let ns = this._namespaceLookup[namespaceId];
    if (ns && ns.register(name, trigger2)) {
      this.totalAnimations++;
    }
  }
  destroy(namespaceId, context) {
    if (!namespaceId) return;
    this.afterFlush(() => {
    });
    this.afterFlushAnimationsDone(() => {
      const ns = this._fetchNamespace(namespaceId);
      this.namespacesByHostElement.delete(ns.hostElement);
      const index2 = this._namespaceList.indexOf(ns);
      if (index2 >= 0) {
        this._namespaceList.splice(index2, 1);
      }
      ns.destroy(context);
      delete this._namespaceLookup[namespaceId];
    });
  }
  _fetchNamespace(id) {
    return this._namespaceLookup[id];
  }
  fetchNamespacesByElement(element) {
    const namespaces = /* @__PURE__ */ new Set();
    const elementStates = this.statesByElement.get(element);
    if (elementStates) {
      for (let stateValue of elementStates.values()) {
        if (stateValue.namespaceId) {
          const ns = this._fetchNamespace(stateValue.namespaceId);
          if (ns) {
            namespaces.add(ns);
          }
        }
      }
    }
    return namespaces;
  }
  trigger(namespaceId, element, name, value) {
    if (isElementNode(element)) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.trigger(element, name, value);
        return true;
      }
    }
    return false;
  }
  insertNode(namespaceId, element, parent, insertBefore) {
    if (!isElementNode(element)) return;
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      details.setForRemoval = false;
      details.setForMove = true;
      const index2 = this.collectedLeaveElements.indexOf(element);
      if (index2 >= 0) {
        this.collectedLeaveElements.splice(index2, 1);
      }
    }
    if (namespaceId) {
      const ns = this._fetchNamespace(namespaceId);
      if (ns) {
        ns.insertNode(element, parent);
      }
    }
    if (insertBefore) {
      this.collectEnterElement(element);
    }
  }
  collectEnterElement(element) {
    this.collectedEnterElements.push(element);
  }
  markElementAsDisabled(element, value) {
    if (value) {
      if (!this.disabledNodes.has(element)) {
        this.disabledNodes.add(element);
        addClass(element, DISABLED_CLASSNAME);
      }
    } else if (this.disabledNodes.has(element)) {
      this.disabledNodes.delete(element);
      removeClass(element, DISABLED_CLASSNAME);
    }
  }
  removeNode(namespaceId, element, context) {
    if (isElementNode(element)) {
      const ns = namespaceId ? this._fetchNamespace(namespaceId) : null;
      if (ns) {
        ns.removeNode(element, context);
      } else {
        this.markElementAsRemoved(namespaceId, element, false, context);
      }
      const hostNS = this.namespacesByHostElement.get(element);
      if (hostNS && hostNS.id !== namespaceId) {
        hostNS.removeNode(element, context);
      }
    } else {
      this._onRemovalComplete(element, context);
    }
  }
  markElementAsRemoved(namespaceId, element, hasAnimation, context, previousTriggersValues) {
    this.collectedLeaveElements.push(element);
    element[REMOVAL_FLAG] = {
      namespaceId,
      setForRemoval: context,
      hasAnimation,
      removedBeforeQueried: false,
      previousTriggersValues
    };
  }
  listen(namespaceId, element, name, phase, callback) {
    if (isElementNode(element)) {
      return this._fetchNamespace(namespaceId).listen(element, name, phase, callback);
    }
    return () => {
    };
  }
  _buildInstruction(entry, subTimelines, enterClassName, leaveClassName, skipBuildAst) {
    return entry.transition.build(this.driver, entry.element, entry.fromState.value, entry.toState.value, enterClassName, leaveClassName, entry.fromState.options, entry.toState.options, subTimelines, skipBuildAst);
  }
  destroyInnerAnimations(containerElement) {
    let elements = this.driver.query(containerElement, NG_TRIGGER_SELECTOR, true);
    elements.forEach((element) => this.destroyActiveAnimationsForElement(element));
    if (this.playersByQueriedElement.size == 0) return;
    elements = this.driver.query(containerElement, NG_ANIMATING_SELECTOR, true);
    elements.forEach((element) => this.finishActiveQueriedAnimationOnElement(element));
  }
  destroyActiveAnimationsForElement(element) {
    const players = this.playersByElement.get(element);
    if (players) {
      players.forEach((player) => {
        if (player.queued) {
          player.markedForDestroy = true;
        } else {
          player.destroy();
        }
      });
    }
  }
  finishActiveQueriedAnimationOnElement(element) {
    const players = this.playersByQueriedElement.get(element);
    if (players) {
      players.forEach((player) => player.finish());
    }
  }
  whenRenderingDone() {
    return new Promise((resolve) => {
      if (this.players.length) {
        return optimizeGroupPlayer(this.players).onDone(() => resolve());
      } else {
        resolve();
      }
    });
  }
  processLeaveNode(element) {
    const details = element[REMOVAL_FLAG];
    if (details && details.setForRemoval) {
      element[REMOVAL_FLAG] = NULL_REMOVAL_STATE;
      if (details.namespaceId) {
        this.destroyInnerAnimations(element);
        const ns = this._fetchNamespace(details.namespaceId);
        if (ns) {
          ns.clearElementCache(element);
        }
      }
      this._onRemovalComplete(element, details.setForRemoval);
    }
    if (element.classList?.contains(DISABLED_CLASSNAME)) {
      this.markElementAsDisabled(element, false);
    }
    this.driver.query(element, DISABLED_SELECTOR, true).forEach((node) => {
      this.markElementAsDisabled(node, false);
    });
  }
  flush(microtaskId = -1) {
    let players = [];
    if (this.newHostElements.size) {
      this.newHostElements.forEach((ns, element) => this._balanceNamespaceList(ns, element));
      this.newHostElements.clear();
    }
    if (this.totalAnimations && this.collectedEnterElements.length) {
      for (let i = 0; i < this.collectedEnterElements.length; i++) {
        const elm = this.collectedEnterElements[i];
        addClass(elm, STAR_CLASSNAME);
      }
    }
    if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) {
      const cleanupFns = [];
      try {
        players = this._flushAnimations(cleanupFns, microtaskId);
      } finally {
        for (let i = 0; i < cleanupFns.length; i++) {
          cleanupFns[i]();
        }
      }
    } else {
      for (let i = 0; i < this.collectedLeaveElements.length; i++) {
        const element = this.collectedLeaveElements[i];
        this.processLeaveNode(element);
      }
    }
    this.totalQueuedPlayers = 0;
    this.collectedEnterElements.length = 0;
    this.collectedLeaveElements.length = 0;
    this._flushFns.forEach((fn) => fn());
    this._flushFns = [];
    if (this._whenQuietFns.length) {
      const quietFns = this._whenQuietFns;
      this._whenQuietFns = [];
      if (players.length) {
        optimizeGroupPlayer(players).onDone(() => {
          quietFns.forEach((fn) => fn());
        });
      } else {
        quietFns.forEach((fn) => fn());
      }
    }
  }
  reportError(errors) {
    throw triggerTransitionsFailed(errors);
  }
  _flushAnimations(cleanupFns, microtaskId) {
    const subTimelines = new ElementInstructionMap();
    const skippedPlayers = [];
    const skippedPlayersMap = /* @__PURE__ */ new Map();
    const queuedInstructions = [];
    const queriedElements = /* @__PURE__ */ new Map();
    const allPreStyleElements = /* @__PURE__ */ new Map();
    const allPostStyleElements = /* @__PURE__ */ new Map();
    const disabledElementsSet = /* @__PURE__ */ new Set();
    this.disabledNodes.forEach((node) => {
      disabledElementsSet.add(node);
      const nodesThatAreDisabled = this.driver.query(node, QUEUED_SELECTOR, true);
      for (let i2 = 0; i2 < nodesThatAreDisabled.length; i2++) {
        disabledElementsSet.add(nodesThatAreDisabled[i2]);
      }
    });
    const bodyNode = this.bodyNode;
    const allTriggerElements = Array.from(this.statesByElement.keys());
    const enterNodeMap = buildRootMap(allTriggerElements, this.collectedEnterElements);
    const enterNodeMapIds = /* @__PURE__ */ new Map();
    let i = 0;
    enterNodeMap.forEach((nodes, root) => {
      const className = ENTER_CLASSNAME + i++;
      enterNodeMapIds.set(root, className);
      nodes.forEach((node) => addClass(node, className));
    });
    const allLeaveNodes = [];
    const mergedLeaveNodes = /* @__PURE__ */ new Set();
    const leaveNodesWithoutAnimations = /* @__PURE__ */ new Set();
    for (let i2 = 0; i2 < this.collectedLeaveElements.length; i2++) {
      const element = this.collectedLeaveElements[i2];
      const details = element[REMOVAL_FLAG];
      if (details && details.setForRemoval) {
        allLeaveNodes.push(element);
        mergedLeaveNodes.add(element);
        if (details.hasAnimation) {
          this.driver.query(element, STAR_SELECTOR, true).forEach((elm) => mergedLeaveNodes.add(elm));
        } else {
          leaveNodesWithoutAnimations.add(element);
        }
      }
    }
    const leaveNodeMapIds = /* @__PURE__ */ new Map();
    const leaveNodeMap = buildRootMap(allTriggerElements, Array.from(mergedLeaveNodes));
    leaveNodeMap.forEach((nodes, root) => {
      const className = LEAVE_CLASSNAME + i++;
      leaveNodeMapIds.set(root, className);
      nodes.forEach((node) => addClass(node, className));
    });
    cleanupFns.push(() => {
      enterNodeMap.forEach((nodes, root) => {
        const className = enterNodeMapIds.get(root);
        nodes.forEach((node) => removeClass(node, className));
      });
      leaveNodeMap.forEach((nodes, root) => {
        const className = leaveNodeMapIds.get(root);
        nodes.forEach((node) => removeClass(node, className));
      });
      allLeaveNodes.forEach((element) => {
        this.processLeaveNode(element);
      });
    });
    const allPlayers = [];
    const erroneousTransitions = [];
    for (let i2 = this._namespaceList.length - 1; i2 >= 0; i2--) {
      const ns = this._namespaceList[i2];
      ns.drainQueuedTransitions(microtaskId).forEach((entry) => {
        const player = entry.player;
        const element = entry.element;
        allPlayers.push(player);
        if (this.collectedEnterElements.length) {
          const details = element[REMOVAL_FLAG];
          if (details && details.setForMove) {
            if (details.previousTriggersValues && details.previousTriggersValues.has(entry.triggerName)) {
              const previousValue = details.previousTriggersValues.get(entry.triggerName);
              const triggersWithStates = this.statesByElement.get(entry.element);
              if (triggersWithStates && triggersWithStates.has(entry.triggerName)) {
                const state2 = triggersWithStates.get(entry.triggerName);
                state2.value = previousValue;
                triggersWithStates.set(entry.triggerName, state2);
              }
            }
            player.destroy();
            return;
          }
        }
        const nodeIsOrphaned = !bodyNode || !this.driver.containsElement(bodyNode, element);
        const leaveClassName = leaveNodeMapIds.get(element);
        const enterClassName = enterNodeMapIds.get(element);
        const instruction = this._buildInstruction(entry, subTimelines, enterClassName, leaveClassName, nodeIsOrphaned);
        if (instruction.errors && instruction.errors.length) {
          erroneousTransitions.push(instruction);
          return;
        }
        if (nodeIsOrphaned) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        if (entry.isFallbackTransition) {
          player.onStart(() => eraseStyles(element, instruction.fromStyles));
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          skippedPlayers.push(player);
          return;
        }
        const timelines = [];
        instruction.timelines.forEach((tl) => {
          tl.stretchStartingKeyframe = true;
          if (!this.disabledNodes.has(tl.element)) {
            timelines.push(tl);
          }
        });
        instruction.timelines = timelines;
        subTimelines.append(element, instruction.timelines);
        const tuple = {
          instruction,
          player,
          element
        };
        queuedInstructions.push(tuple);
        instruction.queriedElements.forEach((element2) => getOrSetDefaultValue(queriedElements, element2, []).push(player));
        instruction.preStyleProps.forEach((stringMap, element2) => {
          if (stringMap.size) {
            let setVal = allPreStyleElements.get(element2);
            if (!setVal) {
              allPreStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
            }
            stringMap.forEach((_, prop) => setVal.add(prop));
          }
        });
        instruction.postStyleProps.forEach((stringMap, element2) => {
          let setVal = allPostStyleElements.get(element2);
          if (!setVal) {
            allPostStyleElements.set(element2, setVal = /* @__PURE__ */ new Set());
          }
          stringMap.forEach((_, prop) => setVal.add(prop));
        });
      });
    }
    if (erroneousTransitions.length) {
      const errors = [];
      erroneousTransitions.forEach((instruction) => {
        errors.push(transitionFailed(instruction.triggerName, instruction.errors));
      });
      allPlayers.forEach((player) => player.destroy());
      this.reportError(errors);
    }
    const allPreviousPlayersMap = /* @__PURE__ */ new Map();
    const animationElementMap = /* @__PURE__ */ new Map();
    queuedInstructions.forEach((entry) => {
      const element = entry.element;
      if (subTimelines.has(element)) {
        animationElementMap.set(element, element);
        this._beforeAnimationBuild(entry.player.namespaceId, entry.instruction, allPreviousPlayersMap);
      }
    });
    skippedPlayers.forEach((player) => {
      const element = player.element;
      const previousPlayers = this._getPreviousPlayers(element, false, player.namespaceId, player.triggerName, null);
      previousPlayers.forEach((prevPlayer) => {
        getOrSetDefaultValue(allPreviousPlayersMap, element, []).push(prevPlayer);
        prevPlayer.destroy();
      });
    });
    const replaceNodes = allLeaveNodes.filter((node) => {
      return replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements);
    });
    const postStylesMap = /* @__PURE__ */ new Map();
    const allLeaveQueriedNodes = cloakAndComputeStyles(postStylesMap, this.driver, leaveNodesWithoutAnimations, allPostStyleElements, AUTO_STYLE);
    allLeaveQueriedNodes.forEach((node) => {
      if (replacePostStylesAsPre(node, allPreStyleElements, allPostStyleElements)) {
        replaceNodes.push(node);
      }
    });
    const preStylesMap = /* @__PURE__ */ new Map();
    enterNodeMap.forEach((nodes, root) => {
      cloakAndComputeStyles(preStylesMap, this.driver, new Set(nodes), allPreStyleElements, \u0275PRE_STYLE);
    });
    replaceNodes.forEach((node) => {
      const post = postStylesMap.get(node);
      const pre = preStylesMap.get(node);
      postStylesMap.set(node, new Map([...post?.entries() ?? [], ...pre?.entries() ?? []]));
    });
    const rootPlayers = [];
    const subPlayers = [];
    const NO_PARENT_ANIMATION_ELEMENT_DETECTED = {};
    queuedInstructions.forEach((entry) => {
      const {
        element,
        player,
        instruction
      } = entry;
      if (subTimelines.has(element)) {
        if (disabledElementsSet.has(element)) {
          player.onDestroy(() => setStyles(element, instruction.toStyles));
          player.disabled = true;
          player.overrideTotalTime(instruction.totalTime);
          skippedPlayers.push(player);
          return;
        }
        let parentWithAnimation = NO_PARENT_ANIMATION_ELEMENT_DETECTED;
        if (animationElementMap.size > 1) {
          let elm = element;
          const parentsToAdd = [];
          while (elm = elm.parentNode) {
            const detectedParent = animationElementMap.get(elm);
            if (detectedParent) {
              parentWithAnimation = detectedParent;
              break;
            }
            parentsToAdd.push(elm);
          }
          parentsToAdd.forEach((parent) => animationElementMap.set(parent, parentWithAnimation));
        }
        const innerPlayer = this._buildAnimation(player.namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap);
        player.setRealPlayer(innerPlayer);
        if (parentWithAnimation === NO_PARENT_ANIMATION_ELEMENT_DETECTED) {
          rootPlayers.push(player);
        } else {
          const parentPlayers = this.playersByElement.get(parentWithAnimation);
          if (parentPlayers && parentPlayers.length) {
            player.parentPlayer = optimizeGroupPlayer(parentPlayers);
          }
          skippedPlayers.push(player);
        }
      } else {
        eraseStyles(element, instruction.fromStyles);
        player.onDestroy(() => setStyles(element, instruction.toStyles));
        subPlayers.push(player);
        if (disabledElementsSet.has(element)) {
          skippedPlayers.push(player);
        }
      }
    });
    subPlayers.forEach((player) => {
      const playersForElement = skippedPlayersMap.get(player.element);
      if (playersForElement && playersForElement.length) {
        const innerPlayer = optimizeGroupPlayer(playersForElement);
        player.setRealPlayer(innerPlayer);
      }
    });
    skippedPlayers.forEach((player) => {
      if (player.parentPlayer) {
        player.syncPlayerEvents(player.parentPlayer);
      } else {
        player.destroy();
      }
    });
    for (let i2 = 0; i2 < allLeaveNodes.length; i2++) {
      const element = allLeaveNodes[i2];
      const details = element[REMOVAL_FLAG];
      removeClass(element, LEAVE_CLASSNAME);
      if (details && details.hasAnimation) continue;
      let players = [];
      if (queriedElements.size) {
        let queriedPlayerResults = queriedElements.get(element);
        if (queriedPlayerResults && queriedPlayerResults.length) {
          players.push(...queriedPlayerResults);
        }
        let queriedInnerElements = this.driver.query(element, NG_ANIMATING_SELECTOR, true);
        for (let j = 0; j < queriedInnerElements.length; j++) {
          let queriedPlayers = queriedElements.get(queriedInnerElements[j]);
          if (queriedPlayers && queriedPlayers.length) {
            players.push(...queriedPlayers);
          }
        }
      }
      const activePlayers = players.filter((p) => !p.destroyed);
      if (activePlayers.length) {
        removeNodesAfterAnimationDone(this, element, activePlayers);
      } else {
        this.processLeaveNode(element);
      }
    }
    allLeaveNodes.length = 0;
    rootPlayers.forEach((player) => {
      this.players.push(player);
      player.onDone(() => {
        player.destroy();
        const index2 = this.players.indexOf(player);
        this.players.splice(index2, 1);
      });
      player.play();
    });
    return rootPlayers;
  }
  afterFlush(callback) {
    this._flushFns.push(callback);
  }
  afterFlushAnimationsDone(callback) {
    this._whenQuietFns.push(callback);
  }
  _getPreviousPlayers(element, isQueriedElement, namespaceId, triggerName, toStateValue) {
    let players = [];
    if (isQueriedElement) {
      const queriedElementPlayers = this.playersByQueriedElement.get(element);
      if (queriedElementPlayers) {
        players = queriedElementPlayers;
      }
    } else {
      const elementPlayers = this.playersByElement.get(element);
      if (elementPlayers) {
        const isRemovalAnimation = !toStateValue || toStateValue == VOID_VALUE;
        elementPlayers.forEach((player) => {
          if (player.queued) return;
          if (!isRemovalAnimation && player.triggerName != triggerName) return;
          players.push(player);
        });
      }
    }
    if (namespaceId || triggerName) {
      players = players.filter((player) => {
        if (namespaceId && namespaceId != player.namespaceId) return false;
        if (triggerName && triggerName != player.triggerName) return false;
        return true;
      });
    }
    return players;
  }
  _beforeAnimationBuild(namespaceId, instruction, allPreviousPlayersMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const targetNameSpaceId = instruction.isRemovalTransition ? void 0 : namespaceId;
    const targetTriggerName = instruction.isRemovalTransition ? void 0 : triggerName;
    for (const timelineInstruction of instruction.timelines) {
      const element = timelineInstruction.element;
      const isQueriedElement = element !== rootElement;
      const players = getOrSetDefaultValue(allPreviousPlayersMap, element, []);
      const previousPlayers = this._getPreviousPlayers(element, isQueriedElement, targetNameSpaceId, targetTriggerName, instruction.toState);
      previousPlayers.forEach((player) => {
        const realPlayer = player.getRealPlayer();
        if (realPlayer.beforeDestroy) {
          realPlayer.beforeDestroy();
        }
        player.destroy();
        players.push(player);
      });
    }
    eraseStyles(rootElement, instruction.fromStyles);
  }
  _buildAnimation(namespaceId, instruction, allPreviousPlayersMap, skippedPlayersMap, preStylesMap, postStylesMap) {
    const triggerName = instruction.triggerName;
    const rootElement = instruction.element;
    const allQueriedPlayers = [];
    const allConsumedElements = /* @__PURE__ */ new Set();
    const allSubElements = /* @__PURE__ */ new Set();
    const allNewPlayers = instruction.timelines.map((timelineInstruction) => {
      const element = timelineInstruction.element;
      allConsumedElements.add(element);
      const details = element[REMOVAL_FLAG];
      if (details && details.removedBeforeQueried) return new NoopAnimationPlayer(timelineInstruction.duration, timelineInstruction.delay);
      const isQueriedElement = element !== rootElement;
      const previousPlayers = flattenGroupPlayers((allPreviousPlayersMap.get(element) || EMPTY_PLAYER_ARRAY).map((p) => p.getRealPlayer())).filter((p) => {
        const pp = p;
        return pp.element ? pp.element === element : false;
      });
      const preStyles = preStylesMap.get(element);
      const postStyles = postStylesMap.get(element);
      const keyframes2 = normalizeKeyframes$1(this._normalizer, timelineInstruction.keyframes, preStyles, postStyles);
      const player2 = this._buildPlayer(timelineInstruction, keyframes2, previousPlayers);
      if (timelineInstruction.subTimeline && skippedPlayersMap) {
        allSubElements.add(element);
      }
      if (isQueriedElement) {
        const wrappedPlayer = new TransitionAnimationPlayer(namespaceId, triggerName, element);
        wrappedPlayer.setRealPlayer(player2);
        allQueriedPlayers.push(wrappedPlayer);
      }
      return player2;
    });
    allQueriedPlayers.forEach((player2) => {
      getOrSetDefaultValue(this.playersByQueriedElement, player2.element, []).push(player2);
      player2.onDone(() => deleteOrUnsetInMap(this.playersByQueriedElement, player2.element, player2));
    });
    allConsumedElements.forEach((element) => addClass(element, NG_ANIMATING_CLASSNAME));
    const player = optimizeGroupPlayer(allNewPlayers);
    player.onDestroy(() => {
      allConsumedElements.forEach((element) => removeClass(element, NG_ANIMATING_CLASSNAME));
      setStyles(rootElement, instruction.toStyles);
    });
    allSubElements.forEach((element) => {
      getOrSetDefaultValue(skippedPlayersMap, element, []).push(player);
    });
    return player;
  }
  _buildPlayer(instruction, keyframes2, previousPlayers) {
    if (keyframes2.length > 0) {
      return this.driver.animate(instruction.element, keyframes2, instruction.duration, instruction.delay, instruction.easing, previousPlayers);
    }
    return new NoopAnimationPlayer(instruction.duration, instruction.delay);
  }
};
var TransitionAnimationPlayer = class {
  namespaceId;
  triggerName;
  element;
  _player = new NoopAnimationPlayer();
  _containsRealPlayer = false;
  _queuedCallbacks = /* @__PURE__ */ new Map();
  destroyed = false;
  parentPlayer = null;
  markedForDestroy = false;
  disabled = false;
  queued = true;
  totalTime = 0;
  constructor(namespaceId, triggerName, element) {
    this.namespaceId = namespaceId;
    this.triggerName = triggerName;
    this.element = element;
  }
  setRealPlayer(player) {
    if (this._containsRealPlayer) return;
    this._player = player;
    this._queuedCallbacks.forEach((callbacks, phase) => {
      callbacks.forEach((callback) => listenOnPlayer(player, phase, void 0, callback));
    });
    this._queuedCallbacks.clear();
    this._containsRealPlayer = true;
    this.overrideTotalTime(player.totalTime);
    this.queued = false;
  }
  getRealPlayer() {
    return this._player;
  }
  overrideTotalTime(totalTime) {
    this.totalTime = totalTime;
  }
  syncPlayerEvents(player) {
    const p = this._player;
    if (p.triggerCallback) {
      player.onStart(() => p.triggerCallback("start"));
    }
    player.onDone(() => this.finish());
    player.onDestroy(() => this.destroy());
  }
  _queueEvent(name, callback) {
    getOrSetDefaultValue(this._queuedCallbacks, name, []).push(callback);
  }
  onDone(fn) {
    if (this.queued) {
      this._queueEvent("done", fn);
    }
    this._player.onDone(fn);
  }
  onStart(fn) {
    if (this.queued) {
      this._queueEvent("start", fn);
    }
    this._player.onStart(fn);
  }
  onDestroy(fn) {
    if (this.queued) {
      this._queueEvent("destroy", fn);
    }
    this._player.onDestroy(fn);
  }
  init() {
    this._player.init();
  }
  hasStarted() {
    return this.queued ? false : this._player.hasStarted();
  }
  play() {
    !this.queued && this._player.play();
  }
  pause() {
    !this.queued && this._player.pause();
  }
  restart() {
    !this.queued && this._player.restart();
  }
  finish() {
    this._player.finish();
  }
  destroy() {
    this.destroyed = true;
    this._player.destroy();
  }
  reset() {
    !this.queued && this._player.reset();
  }
  setPosition(p) {
    if (!this.queued) {
      this._player.setPosition(p);
    }
  }
  getPosition() {
    return this.queued ? 0 : this._player.getPosition();
  }
  triggerCallback(phaseName) {
    const p = this._player;
    if (p.triggerCallback) {
      p.triggerCallback(phaseName);
    }
  }
};
function deleteOrUnsetInMap(map2, key, value) {
  let currentValues = map2.get(key);
  if (currentValues) {
    if (currentValues.length) {
      const index2 = currentValues.indexOf(value);
      currentValues.splice(index2, 1);
    }
    if (currentValues.length == 0) {
      map2.delete(key);
    }
  }
  return currentValues;
}
function normalizeTriggerValue(value) {
  return value != null ? value : null;
}
function isElementNode(node) {
  return node && node["nodeType"] === 1;
}
function isTriggerEventValid(eventName) {
  return eventName == "start" || eventName == "done";
}
function cloakElement(element, value) {
  const oldValue = element.style.display;
  element.style.display = value != null ? value : "none";
  return oldValue;
}
function cloakAndComputeStyles(valuesMap, driver, elements, elementPropsMap, defaultStyle) {
  const cloakVals = [];
  elements.forEach((element) => cloakVals.push(cloakElement(element)));
  const failedElements = [];
  elementPropsMap.forEach((props, element) => {
    const styles = /* @__PURE__ */ new Map();
    props.forEach((prop) => {
      const value = driver.computeStyle(element, prop, defaultStyle);
      styles.set(prop, value);
      if (!value || value.length == 0) {
        element[REMOVAL_FLAG] = NULL_REMOVED_QUERIED_STATE;
        failedElements.push(element);
      }
    });
    valuesMap.set(element, styles);
  });
  let i = 0;
  elements.forEach((element) => cloakElement(element, cloakVals[i++]));
  return failedElements;
}
function buildRootMap(roots, nodes) {
  const rootMap = /* @__PURE__ */ new Map();
  roots.forEach((root) => rootMap.set(root, []));
  if (nodes.length == 0) return rootMap;
  const NULL_NODE = 1;
  const nodeSet = new Set(nodes);
  const localRootMap = /* @__PURE__ */ new Map();
  function getRoot(node) {
    if (!node) return NULL_NODE;
    let root = localRootMap.get(node);
    if (root) return root;
    const parent = node.parentNode;
    if (rootMap.has(parent)) {
      root = parent;
    } else if (nodeSet.has(parent)) {
      root = NULL_NODE;
    } else {
      root = getRoot(parent);
    }
    localRootMap.set(node, root);
    return root;
  }
  nodes.forEach((node) => {
    const root = getRoot(node);
    if (root !== NULL_NODE) {
      rootMap.get(root).push(node);
    }
  });
  return rootMap;
}
function addClass(element, className) {
  element.classList?.add(className);
}
function removeClass(element, className) {
  element.classList?.remove(className);
}
function removeNodesAfterAnimationDone(engine, element, players) {
  optimizeGroupPlayer(players).onDone(() => engine.processLeaveNode(element));
}
function flattenGroupPlayers(players) {
  const finalPlayers = [];
  _flattenGroupPlayersRecur(players, finalPlayers);
  return finalPlayers;
}
function _flattenGroupPlayersRecur(players, finalPlayers) {
  for (let i = 0; i < players.length; i++) {
    const player = players[i];
    if (player instanceof AnimationGroupPlayer) {
      _flattenGroupPlayersRecur(player.players, finalPlayers);
    } else {
      finalPlayers.push(player);
    }
  }
}
function objEquals(a, b) {
  const k1 = Object.keys(a);
  const k2 = Object.keys(b);
  if (k1.length != k2.length) return false;
  for (let i = 0; i < k1.length; i++) {
    const prop = k1[i];
    if (!b.hasOwnProperty(prop) || a[prop] !== b[prop]) return false;
  }
  return true;
}
function replacePostStylesAsPre(element, allPreStyleElements, allPostStyleElements) {
  const postEntry = allPostStyleElements.get(element);
  if (!postEntry) return false;
  let preEntry = allPreStyleElements.get(element);
  if (preEntry) {
    postEntry.forEach((data) => preEntry.add(data));
  } else {
    allPreStyleElements.set(element, postEntry);
  }
  allPostStyleElements.delete(element);
  return true;
}
var AnimationEngine = class {
  _driver;
  _normalizer;
  _transitionEngine;
  _timelineEngine;
  _triggerCache = {};
  onRemovalComplete = (element, context) => {
  };
  constructor(doc, _driver, _normalizer) {
    this._driver = _driver;
    this._normalizer = _normalizer;
    this._transitionEngine = new TransitionAnimationEngine(doc.body, _driver, _normalizer);
    this._timelineEngine = new TimelineAnimationEngine(doc.body, _driver, _normalizer);
    this._transitionEngine.onRemovalComplete = (element, context) => this.onRemovalComplete(element, context);
  }
  registerTrigger(componentId, namespaceId, hostElement, name, metadata) {
    const cacheKey = componentId + "-" + name;
    let trigger2 = this._triggerCache[cacheKey];
    if (!trigger2) {
      const errors = [];
      const warnings = [];
      const ast = buildAnimationAst(this._driver, metadata, errors, warnings);
      if (errors.length) {
        throw triggerBuildFailed(name, errors);
      }
      if (typeof ngDevMode === "undefined" || ngDevMode) {
        if (warnings.length) {
          warnTriggerBuild(name, warnings);
        }
      }
      trigger2 = buildTrigger(name, ast, this._normalizer);
      this._triggerCache[cacheKey] = trigger2;
    }
    this._transitionEngine.registerTrigger(namespaceId, name, trigger2);
  }
  register(namespaceId, hostElement) {
    this._transitionEngine.register(namespaceId, hostElement);
  }
  destroy(namespaceId, context) {
    this._transitionEngine.destroy(namespaceId, context);
  }
  onInsert(namespaceId, element, parent, insertBefore) {
    this._transitionEngine.insertNode(namespaceId, element, parent, insertBefore);
  }
  onRemove(namespaceId, element, context) {
    this._transitionEngine.removeNode(namespaceId, element, context);
  }
  disableAnimations(element, disable) {
    this._transitionEngine.markElementAsDisabled(element, disable);
  }
  process(namespaceId, element, property, value) {
    if (property.charAt(0) == "@") {
      const [id, action] = parseTimelineCommand(property);
      const args = value;
      this._timelineEngine.command(id, element, action, args);
    } else {
      this._transitionEngine.trigger(namespaceId, element, property, value);
    }
  }
  listen(namespaceId, element, eventName, eventPhase, callback) {
    if (eventName.charAt(0) == "@") {
      const [id, action] = parseTimelineCommand(eventName);
      return this._timelineEngine.listen(id, element, action, callback);
    }
    return this._transitionEngine.listen(namespaceId, element, eventName, eventPhase, callback);
  }
  flush(microtaskId = -1) {
    this._transitionEngine.flush(microtaskId);
  }
  get players() {
    return [...this._transitionEngine.players, ...this._timelineEngine.players];
  }
  whenRenderingDone() {
    return this._transitionEngine.whenRenderingDone();
  }
  afterFlushAnimationsDone(cb) {
    this._transitionEngine.afterFlushAnimationsDone(cb);
  }
};
function packageNonAnimatableStyles(element, styles) {
  let startStyles = null;
  let endStyles = null;
  if (Array.isArray(styles) && styles.length) {
    startStyles = filterNonAnimatableStyles(styles[0]);
    if (styles.length > 1) {
      endStyles = filterNonAnimatableStyles(styles[styles.length - 1]);
    }
  } else if (styles instanceof Map) {
    startStyles = filterNonAnimatableStyles(styles);
  }
  return startStyles || endStyles ? new SpecialCasedStyles(element, startStyles, endStyles) : null;
}
var SpecialCasedStyles = class _SpecialCasedStyles {
  _element;
  _startStyles;
  _endStyles;
  static initialStylesByElement = /* @__PURE__ */ new WeakMap();
  _state = 0;
  _initialStyles;
  constructor(_element, _startStyles, _endStyles) {
    this._element = _element;
    this._startStyles = _startStyles;
    this._endStyles = _endStyles;
    let initialStyles = _SpecialCasedStyles.initialStylesByElement.get(_element);
    if (!initialStyles) {
      _SpecialCasedStyles.initialStylesByElement.set(_element, initialStyles = /* @__PURE__ */ new Map());
    }
    this._initialStyles = initialStyles;
  }
  start() {
    if (this._state < 1) {
      if (this._startStyles) {
        setStyles(this._element, this._startStyles, this._initialStyles);
      }
      this._state = 1;
    }
  }
  finish() {
    this.start();
    if (this._state < 2) {
      setStyles(this._element, this._initialStyles);
      if (this._endStyles) {
        setStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      this._state = 1;
    }
  }
  destroy() {
    this.finish();
    if (this._state < 3) {
      _SpecialCasedStyles.initialStylesByElement.delete(this._element);
      if (this._startStyles) {
        eraseStyles(this._element, this._startStyles);
        this._endStyles = null;
      }
      if (this._endStyles) {
        eraseStyles(this._element, this._endStyles);
        this._endStyles = null;
      }
      setStyles(this._element, this._initialStyles);
      this._state = 3;
    }
  }
};
function filterNonAnimatableStyles(styles) {
  let result = null;
  styles.forEach((val, prop) => {
    if (isNonAnimatableStyle(prop)) {
      result = result || /* @__PURE__ */ new Map();
      result.set(prop, val);
    }
  });
  return result;
}
function isNonAnimatableStyle(prop) {
  return prop === "display" || prop === "position";
}
var WebAnimationsPlayer = class {
  element;
  keyframes;
  options;
  _specialStyles;
  _onDoneFns = [];
  _onStartFns = [];
  _onDestroyFns = [];
  _duration;
  _delay;
  _initialized = false;
  _finished = false;
  _started = false;
  _destroyed = false;
  _finalKeyframe;
  _originalOnDoneFns = [];
  _originalOnStartFns = [];
  domPlayer = null;
  time = 0;
  parentPlayer = null;
  currentSnapshot = /* @__PURE__ */ new Map();
  constructor(element, keyframes2, options, _specialStyles) {
    this.element = element;
    this.keyframes = keyframes2;
    this.options = options;
    this._specialStyles = _specialStyles;
    this._duration = options["duration"];
    this._delay = options["delay"] || 0;
    this.time = this._duration + this._delay;
  }
  _onFinish() {
    if (!this._finished) {
      this._finished = true;
      this._onDoneFns.forEach((fn) => fn());
      this._onDoneFns = [];
    }
  }
  init() {
    if (!this._buildPlayer()) {
      return;
    }
    this._preparePlayerBeforeStart();
  }
  _buildPlayer() {
    if (this._initialized) return this.domPlayer;
    this._initialized = true;
    const keyframes2 = this.keyframes;
    const animation2 = this._triggerWebAnimation(this.element, keyframes2, this.options);
    if (!animation2) {
      this._onFinish();
      return null;
    }
    this.domPlayer = animation2;
    this._finalKeyframe = keyframes2.length ? keyframes2[keyframes2.length - 1] : /* @__PURE__ */ new Map();
    const onFinish = () => this._onFinish();
    animation2.addEventListener("finish", onFinish);
    this.onDestroy(() => {
      animation2.removeEventListener("finish", onFinish);
    });
    return animation2;
  }
  _preparePlayerBeforeStart() {
    if (this._delay) {
      this._resetDomPlayerState();
    } else {
      this.domPlayer?.pause();
    }
  }
  _convertKeyframesToObject(keyframes2) {
    const kfs = [];
    keyframes2.forEach((frame) => {
      kfs.push(Object.fromEntries(frame));
    });
    return kfs;
  }
  _triggerWebAnimation(element, keyframes2, options) {
    const keyframesObject = this._convertKeyframesToObject(keyframes2);
    try {
      return element.animate(keyframesObject, options);
    } catch {
      return null;
    }
  }
  onStart(fn) {
    this._originalOnStartFns.push(fn);
    this._onStartFns.push(fn);
  }
  onDone(fn) {
    this._originalOnDoneFns.push(fn);
    this._onDoneFns.push(fn);
  }
  onDestroy(fn) {
    this._onDestroyFns.push(fn);
  }
  play() {
    const player = this._buildPlayer();
    if (!player) {
      return;
    }
    if (!this.hasStarted()) {
      this._onStartFns.forEach((fn) => fn());
      this._onStartFns = [];
      this._started = true;
      if (this._specialStyles) {
        this._specialStyles.start();
      }
    }
    player.play();
  }
  pause() {
    this.init();
    this.domPlayer?.pause();
  }
  finish() {
    this.init();
    if (!this.domPlayer) return;
    if (this._specialStyles) {
      this._specialStyles.finish();
    }
    this._onFinish();
    this.domPlayer.finish();
  }
  reset() {
    this._resetDomPlayerState();
    this._destroyed = false;
    this._finished = false;
    this._started = false;
    this._onStartFns = this._originalOnStartFns;
    this._onDoneFns = this._originalOnDoneFns;
  }
  _resetDomPlayerState() {
    this.domPlayer?.cancel();
  }
  restart() {
    this.reset();
    this.play();
  }
  hasStarted() {
    return this._started;
  }
  destroy() {
    if (!this._destroyed) {
      this._destroyed = true;
      this._resetDomPlayerState();
      this._onFinish();
      if (this._specialStyles) {
        this._specialStyles.destroy();
      }
      this._onDestroyFns.forEach((fn) => fn());
      this._onDestroyFns = [];
    }
  }
  setPosition(p) {
    if (!this.domPlayer) {
      this.init();
    }
    if (this.domPlayer) {
      this.domPlayer.currentTime = p * this.time;
    }
  }
  getPosition() {
    if (!this.domPlayer) {
      return this._initialized ? 1 : 0;
    }
    return +(this.domPlayer.currentTime ?? 0) / this.time;
  }
  get totalTime() {
    return this._delay + this._duration;
  }
  beforeDestroy() {
    const styles = /* @__PURE__ */ new Map();
    if (this.hasStarted()) {
      const finalKeyframe = this._finalKeyframe;
      finalKeyframe.forEach((val, prop) => {
        if (prop !== "offset") {
          styles.set(prop, this._finished ? val : computeStyle(this.element, prop));
        }
      });
    }
    this.currentSnapshot = styles;
  }
  triggerCallback(phaseName) {
    const methods = phaseName === "start" ? this._onStartFns : this._onDoneFns;
    methods.forEach((fn) => fn());
    methods.length = 0;
  }
};
var WebAnimationsDriver = class {
  validateStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      return validateStyleProperty(prop);
    }
    return true;
  }
  validateAnimatableStyleProperty(prop) {
    if (typeof ngDevMode === "undefined" || ngDevMode) {
      const cssProp = camelCaseToDashCase(prop);
      return validateWebAnimatableStyleProperty(cssProp);
    }
    return true;
  }
  containsElement(elm1, elm2) {
    return containsElement(elm1, elm2);
  }
  getParentElement(element) {
    return getParentElement(element);
  }
  query(element, selector, multi) {
    return invokeQuery(element, selector, multi);
  }
  computeStyle(element, prop, defaultValue) {
    return computeStyle(element, prop);
  }
  animate(element, keyframes2, duration, delay2, easing, previousPlayers = []) {
    const fill = delay2 == 0 ? "both" : "forwards";
    const playerOptions = {
      duration,
      delay: delay2,
      fill
    };
    if (easing) {
      playerOptions["easing"] = easing;
    }
    const previousStyles = /* @__PURE__ */ new Map();
    const previousWebAnimationPlayers = previousPlayers.filter((player) => player instanceof WebAnimationsPlayer);
    if (allowPreviousPlayerStylesMerge(duration, delay2)) {
      previousWebAnimationPlayers.forEach((player) => {
        player.currentSnapshot.forEach((val, prop) => previousStyles.set(prop, val));
      });
    }
    let _keyframes = normalizeKeyframes(keyframes2).map((styles) => new Map(styles));
    _keyframes = balancePreviousStylesIntoKeyframes(element, _keyframes, previousStyles);
    const specialStyles = packageNonAnimatableStyles(element, _keyframes);
    return new WebAnimationsPlayer(element, _keyframes, playerOptions, specialStyles);
  }
};
var ANIMATION_PREFIX = "@";
var DISABLE_ANIMATIONS_FLAG = "@.disabled";
var BaseAnimationRenderer = class {
  namespaceId;
  delegate;
  engine;
  _onDestroy;
  \u0275type = 0;
  constructor(namespaceId, delegate, engine, _onDestroy) {
    this.namespaceId = namespaceId;
    this.delegate = delegate;
    this.engine = engine;
    this._onDestroy = _onDestroy;
  }
  get data() {
    return this.delegate.data;
  }
  destroyNode(node) {
    this.delegate.destroyNode?.(node);
  }
  destroy() {
    this.engine.destroy(this.namespaceId, this.delegate);
    this.engine.afterFlushAnimationsDone(() => {
      queueMicrotask(() => {
        this.delegate.destroy();
      });
    });
    this._onDestroy?.();
  }
  createElement(name, namespace) {
    return this.delegate.createElement(name, namespace);
  }
  createComment(value) {
    return this.delegate.createComment(value);
  }
  createText(value) {
    return this.delegate.createText(value);
  }
  appendChild(parent, newChild) {
    this.delegate.appendChild(parent, newChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, false);
  }
  insertBefore(parent, newChild, refChild, isMove = true) {
    this.delegate.insertBefore(parent, newChild, refChild);
    this.engine.onInsert(this.namespaceId, newChild, parent, isMove);
  }
  removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval) {
    if (requireSynchronousElementRemoval) {
      this.delegate.removeChild(parent, oldChild, isHostElement, requireSynchronousElementRemoval);
      return;
    }
    if (this.parentNode(oldChild)) {
      this.engine.onRemove(this.namespaceId, oldChild, this.delegate);
    }
  }
  selectRootElement(selectorOrNode, preserveContent) {
    return this.delegate.selectRootElement(selectorOrNode, preserveContent);
  }
  parentNode(node) {
    return this.delegate.parentNode(node);
  }
  nextSibling(node) {
    return this.delegate.nextSibling(node);
  }
  setAttribute(el, name, value, namespace) {
    this.delegate.setAttribute(el, name, value, namespace);
  }
  removeAttribute(el, name, namespace) {
    this.delegate.removeAttribute(el, name, namespace);
  }
  addClass(el, name) {
    this.delegate.addClass(el, name);
  }
  removeClass(el, name) {
    this.delegate.removeClass(el, name);
  }
  setStyle(el, style2, value, flags) {
    this.delegate.setStyle(el, style2, value, flags);
  }
  removeStyle(el, style2, flags) {
    this.delegate.removeStyle(el, style2, flags);
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {
      this.disableAnimations(el, !!value);
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  setValue(node, value) {
    this.delegate.setValue(node, value);
  }
  listen(target, eventName, callback, options) {
    return this.delegate.listen(target, eventName, callback, options);
  }
  disableAnimations(element, value) {
    this.engine.disableAnimations(element, value);
  }
};
var AnimationRenderer = class extends BaseAnimationRenderer {
  factory;
  constructor(factory, namespaceId, delegate, engine, onDestroy) {
    super(namespaceId, delegate, engine, onDestroy);
    this.factory = factory;
    this.namespaceId = namespaceId;
  }
  setProperty(el, name, value) {
    if (name.charAt(0) == ANIMATION_PREFIX) {
      if (name.charAt(1) == "." && name == DISABLE_ANIMATIONS_FLAG) {
        value = value === void 0 ? true : !!value;
        this.disableAnimations(el, value);
      } else {
        this.engine.process(this.namespaceId, el, name.slice(1), value);
      }
    } else {
      this.delegate.setProperty(el, name, value);
    }
  }
  listen(target, eventName, callback, options) {
    if (eventName.charAt(0) == ANIMATION_PREFIX) {
      const element = resolveElementFromTarget(target);
      let name = eventName.slice(1);
      let phase = "";
      if (name.charAt(0) != ANIMATION_PREFIX) {
        [name, phase] = parseTriggerCallbackName(name);
      }
      return this.engine.listen(this.namespaceId, element, name, phase, (event) => {
        const countId = event["_data"] || -1;
        this.factory.scheduleListenerCallback(countId, callback, event);
      });
    }
    return this.delegate.listen(target, eventName, callback, options);
  }
};
function resolveElementFromTarget(target) {
  switch (target) {
    case "body":
      return document.body;
    case "document":
      return document;
    case "window":
      return window;
    default:
      return target;
  }
}
function parseTriggerCallbackName(triggerName) {
  const dotIndex = triggerName.indexOf(".");
  const trigger2 = triggerName.substring(0, dotIndex);
  const phase = triggerName.slice(dotIndex + 1);
  return [trigger2, phase];
}
var AnimationRendererFactory = class {
  delegate;
  engine;
  _zone;
  _currentId = 0;
  _microtaskId = 1;
  _animationCallbacksBuffer = [];
  _rendererCache = /* @__PURE__ */ new Map();
  _cdRecurDepth = 0;
  constructor(delegate, engine, _zone) {
    this.delegate = delegate;
    this.engine = engine;
    this._zone = _zone;
    engine.onRemovalComplete = (element, delegate2) => {
      delegate2?.removeChild(null, element);
    };
  }
  createRenderer(hostElement, type) {
    const EMPTY_NAMESPACE_ID = "";
    const delegate = this.delegate.createRenderer(hostElement, type);
    if (!hostElement || !type?.data?.["animation"]) {
      const cache = this._rendererCache;
      let renderer = cache.get(delegate);
      if (!renderer) {
        const onRendererDestroy = () => cache.delete(delegate);
        renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine, onRendererDestroy);
        cache.set(delegate, renderer);
      }
      return renderer;
    }
    const componentId = type.id;
    const namespaceId = type.id + "-" + this._currentId;
    this._currentId++;
    this.engine.register(namespaceId, hostElement);
    const registerTrigger = (trigger2) => {
      if (Array.isArray(trigger2)) {
        trigger2.forEach(registerTrigger);
      } else {
        this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger2.name, trigger2);
      }
    };
    const animationTriggers = type.data["animation"];
    animationTriggers.forEach(registerTrigger);
    return new AnimationRenderer(this, namespaceId, delegate, this.engine);
  }
  begin() {
    this._cdRecurDepth++;
    if (this.delegate.begin) {
      this.delegate.begin();
    }
  }
  _scheduleCountTask() {
    queueMicrotask(() => {
      this._microtaskId++;
    });
  }
  scheduleListenerCallback(count, fn, data) {
    if (count >= 0 && count < this._microtaskId) {
      this._zone.run(() => fn(data));
      return;
    }
    const animationCallbacksBuffer = this._animationCallbacksBuffer;
    if (animationCallbacksBuffer.length == 0) {
      queueMicrotask(() => {
        this._zone.run(() => {
          animationCallbacksBuffer.forEach((tuple) => {
            const [fn2, data2] = tuple;
            fn2(data2);
          });
          this._animationCallbacksBuffer = [];
        });
      });
    }
    animationCallbacksBuffer.push([fn, data]);
  }
  end() {
    this._cdRecurDepth--;
    if (this._cdRecurDepth == 0) {
      this._zone.runOutsideAngular(() => {
        this._scheduleCountTask();
        this.engine.flush(this._microtaskId);
      });
    }
    if (this.delegate.end) {
      this.delegate.end();
    }
  }
  whenRenderingDone() {
    return this.engine.whenRenderingDone();
  }
  componentReplaced(componentId) {
    this.engine.flush();
    this.delegate.componentReplaced?.(componentId);
  }
};

// node_modules/@angular/platform-browser/fesm2022/animations.mjs
var InjectableAnimationEngine = class _InjectableAnimationEngine extends AnimationEngine {
  constructor(doc, driver, normalizer) {
    super(doc, driver, normalizer);
  }
  ngOnDestroy() {
    this.flush();
  }
  static \u0275fac = function InjectableAnimationEngine_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _InjectableAnimationEngine)(\u0275\u0275inject(DOCUMENT), \u0275\u0275inject(AnimationDriver), \u0275\u0275inject(AnimationStyleNormalizer));
  };
  static \u0275prov = /* @__PURE__ */ \u0275\u0275defineInjectable({
    token: _InjectableAnimationEngine,
    factory: _InjectableAnimationEngine.\u0275fac
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(InjectableAnimationEngine, [{
    type: Injectable
  }], () => [{
    type: Document,
    decorators: [{
      type: Inject,
      args: [DOCUMENT]
    }]
  }, {
    type: AnimationDriver
  }, {
    type: AnimationStyleNormalizer
  }], null);
})();
function instantiateDefaultStyleNormalizer() {
  return new WebAnimationsStyleNormalizer();
}
function instantiateRendererFactory() {
  return new AnimationRendererFactory(inject(DomRendererFactory2), inject(AnimationEngine), inject(NgZone));
}
var SHARED_ANIMATION_PROVIDERS = [{
  provide: AnimationStyleNormalizer,
  useFactory: instantiateDefaultStyleNormalizer
}, {
  provide: AnimationEngine,
  useClass: InjectableAnimationEngine
}, {
  provide: RendererFactory2,
  useFactory: instantiateRendererFactory
}];
var BROWSER_NOOP_ANIMATIONS_PROVIDERS = [{
  provide: AnimationDriver,
  useClass: NoopAnimationDriver
}, {
  provide: ANIMATION_MODULE_TYPE,
  useValue: "NoopAnimations"
}, ...SHARED_ANIMATION_PROVIDERS];
var BROWSER_ANIMATIONS_PROVIDERS = [{
  provide: AnimationDriver,
  useFactory: () => false ? new NoopAnimationDriver() : new WebAnimationsDriver()
}, {
  provide: ANIMATION_MODULE_TYPE,
  useFactory: () => false ? "NoopAnimations" : "BrowserAnimations"
}, ...SHARED_ANIMATION_PROVIDERS];
var BrowserAnimationsModule = class _BrowserAnimationsModule {
  static withConfig(config2) {
    return {
      ngModule: _BrowserAnimationsModule,
      providers: config2.disableAnimations ? BROWSER_NOOP_ANIMATIONS_PROVIDERS : BROWSER_ANIMATIONS_PROVIDERS
    };
  }
  static \u0275fac = function BrowserAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _BrowserAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _BrowserAnimationsModule,
    exports: [BrowserModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(BrowserAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();
var NoopAnimationsModule = class _NoopAnimationsModule {
  static \u0275fac = function NoopAnimationsModule_Factory(__ngFactoryType__) {
    return new (__ngFactoryType__ || _NoopAnimationsModule)();
  };
  static \u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({
    type: _NoopAnimationsModule,
    exports: [BrowserModule]
  });
  static \u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({
    providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,
    imports: [BrowserModule]
  });
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(NoopAnimationsModule, [{
    type: NgModule,
    args: [{
      exports: [BrowserModule],
      providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS
    }]
  }], null, null);
})();

// example/src/app/content/example-modules.ts
var EXAMPLE_MODULES = [];

// example/src/app/app.module.ts
var AppModule = class _AppModule {
  constructor() {
    setPrintErrorWhenIconNotFound(false);
  }
  static {
    this.\u0275fac = function AppModule_Factory(__ngFactoryType__) {
      return new (__ngFactoryType__ || _AppModule)();
    };
  }
  static {
    this.\u0275mod = /* @__PURE__ */ \u0275\u0275defineNgModule({ type: _AppModule, bootstrap: [AppComponent] });
  }
  static {
    this.\u0275inj = /* @__PURE__ */ \u0275\u0275defineInjector({ providers: [
      ...DOCGENI_SITE_PROVIDERS,
      {
        provide: GANTT_GLOBAL_CONFIG,
        useFactory: () => {
          const docgeniGlobalContext = inject(GlobalContext);
          return {
            locale: docgeniGlobalContext.locale === "en-us" ? GanttI18nLocale.enUs : GanttI18nLocale.zhHans
          };
        }
      },
      provideZonelessChangeDetection()
    ], imports: [
      BrowserModule,
      BrowserAnimationsModule,
      CommonModule,
      DocgeniTemplateModule,
      NgxGanttModule,
      AppRoutingModule,
      RouterModule.forRoot([]),
      ThyButtonModule,
      ThyNavModule,
      ThyLayoutModule,
      ThyCheckboxModule,
      ThyNotifyModule,
      ThySwitchModule,
      ThyDatePickerModule,
      EXAMPLE_MODULES
    ] });
  }
};
(() => {
  (typeof ngDevMode === "undefined" || ngDevMode) && setClassMetadata(AppModule, [{
    type: NgModule,
    args: [{
      declarations: [AppComponent, AppExampleComponentsComponent],
      imports: [
        BrowserModule,
        BrowserAnimationsModule,
        CommonModule,
        DocgeniTemplateModule,
        NgxGanttModule,
        AppRoutingModule,
        RouterModule.forRoot([]),
        ThyButtonModule,
        ThyNavModule,
        ThyLayoutModule,
        ThyCheckboxModule,
        ThyNotifyModule,
        ThySwitchModule,
        ThyDatePickerModule,
        ...EXAMPLE_MODULES
      ],
      providers: [
        ...DOCGENI_SITE_PROVIDERS,
        {
          provide: GANTT_GLOBAL_CONFIG,
          useFactory: () => {
            const docgeniGlobalContext = inject(GlobalContext);
            return {
              locale: docgeniGlobalContext.locale === "en-us" ? GanttI18nLocale.enUs : GanttI18nLocale.zhHans
            };
          }
        },
        provideZonelessChangeDetection()
      ],
      bootstrap: [AppComponent]
    }]
  }], () => [], null);
})();

// example/src/environments/environment.ts
var environment = {
  production: false
};

// example/src/main.ts
if (environment.production) {
  enableProdMode();
}
platformBrowser().bootstrapModule(AppModule).catch((err) => console.error(err));
/*! Bundled license information:

@angular/forms/fesm2022/forms.mjs:
@angular/common/fesm2022/_module-chunk.mjs:
@angular/common/fesm2022/http.mjs:
@angular/platform-browser/fesm2022/_dom_renderer-chunk.mjs:
@angular/platform-browser/fesm2022/_browser-chunk.mjs:
@angular/platform-browser/fesm2022/platform-browser.mjs:
@angular/core/fesm2022/rxjs-interop.mjs:
@angular/animations/fesm2022/_private_export-chunk.mjs:
@angular/animations/fesm2022/animations.mjs:
@angular/router/fesm2022/_router-chunk.mjs:
@angular/router/fesm2022/_router_module-chunk.mjs:
@angular/router/fesm2022/router.mjs:
@angular/animations/fesm2022/_util-chunk.mjs:
@angular/animations/fesm2022/browser.mjs:
@angular/platform-browser/fesm2022/animations.mjs:
  (**
   * @license Angular v21.0.6
   * (c) 2010-2025 Google LLC. https://angular.dev/
   * License: MIT
   *)

@tethys/cdk/fesm2022/tethys-cdk-event.mjs:
ngx-tethys/fesm2022/ngx-tethys-shared.mjs:
ngx-tethys/fesm2022/ngx-tethys-shared.mjs:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.io/license
   *)

@angular/common/locales/zh-Hans.js:
  (**
   * @license
   * Copyright Google LLC All Rights Reserved.
   *
   * Use of this source code is governed by an MIT-style license that can be
   * found in the LICENSE file at https://angular.dev/license
   *)
*/
//# sourceMappingURL=main.js.map
